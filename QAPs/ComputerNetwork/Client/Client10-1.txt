â˜…How is Quip's web client implemented?Quip's web client is super-fast and has a ton of features, and is one of the most feature-packed single-page apps I've ever seen. I'm curious which technologies/frameworks they used, specifically, if they used a open-source JS framework like Backbone or Angular. Bonus points if you have info on how they managed performance.
Here are some observations from looking at the DOM and requests (WebSocket and POST) through devtools: The current document being edited is contained in a contenteditable <article> node, which contains simple markup for the content, annotated with data- attributes. The behavior (key, mouse, copy/paste events) inside the contenteditable is transformed via js using these data- attributes to give a consistent experience with their design choices. A lot of JS is used to tame the behavior of the contenteditable. For example, copy and paste operations pass through custom handlers to transform html content as it is pasted or copied, since the editor is meant to be restricted to the provided styles. The formatting bar is a couple of elements that are non-contenteditable and get attached to the line that the user selects. Changes to the document are communicated over WebSockets, which provide a persistent connection to the server (listen1.quip.com), cutting down response times. Exchanges over this connection seem to JSON encode the current change and sufficient state information about the editor and the document, so that the same document being edited concurrently can be handled correctly. Collaboration is implemented by locking the line being edited to a single user. This explains the design choice of surrounding the current line by the formatting bar. This is less fine-grained than Google Docs, but easier to implement (see Operational Transformation) and probably also easier to reason about as a user. There is a 20s 'heartbeat' on the websocket connection, but updates are also pushed as they happen (see comments). The format of the updates is not entirely clear, but looks like the server sends html nodes which are inserted into the document at a place determined by the server based on some operational transformation of all the edits happening concurrently. The desktop version loads really quickly because it sends very few requests that block first paint times (3 requests by my count). All subsequent actions keep you on the same page, with js moving around the elements, issuing requests and updating the url in the address bar.