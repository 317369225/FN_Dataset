â˜…How different is a futex from mutex - conceptually and also implementation wise?I got to know that futex (fast userspace mutex) was essentially a user-mode implementation of the mutex. But I couldn't make much sense of it from the man-page results that popped up when I was looking into this. What are the design decisions that encourage using one over the other?
Mutex provide mutual exclusion by having a memory area which can toggle between locked and unlocked atomically. The memory resides in user space but the toggling happens through a system call inside the kernel. The reason why the system call is required (and hence heavy weight) is because: 1. WAKE - The kernel has to schedule the next thread in the wait queue 2. WAIT - All accesses to the lock are guarded and queued through a single point of synchronization - the kernel. Futex isn't the same as mutex. It provides a wait queue technique accessible in the user space. Pthread Mutex in the latest Linux distributions are implemented through Futex logic. From Rusty Russell's (author of Futex) interview on some website: JA: Is it possible to summarize the 3MB paper and roughly explain what a futex is, and its advantages over a mutex? Rusty Russell: OK, a futex ("Fast Userspace Mutex") isn't a mutex at all. It was in a (much) earlier implemetation, but now it's just a waitqueue primitive accessible to user space. FUTEX_WAKE says "wake anyone waiting on this address", and FUTEX_WAIT says "when I read ADDR, it contained VALUE: if it still contains that value when you look at it, sleep until someone calls FUTEX_WAKE on this address". It's used as follows. Two processes (or threads) share some memory, and agree to use a part of it as a lock. 1 means unlocked, 0 means locked, < 0 means locked and someone is waiting. To grab the lock, you do an (architecture-specific) atomic decrement operation: if it hits 0, then it was 1, and you've got the lock. Otherwise you wait for a while. When you want to release the lock, you set it to 1 again. This is really fast if there's no contention on the lock: not a system call in sight. Before futexes, the "wait a while" was usually implemented "try three times and then call yield()". The problem with yield is that it has no clear semantics: the kernel has *no* idea what you are waiting for, so it has to guess when to wake you up. In a word, "yield()" is always a hack. With futexes, you say "this address was -1 when I finished with it, sleep on it": the kernel atomically checks the value and either puts you to sleep or returns EAGAIN, and you try again. When you release a lock, if it's 0, you can simply increment it back to 1, otherwise, you set it to 1 and call FUTEX_WAKE, because you know someone is waiting. You can read some example code here, and of course in the current glibc sources.