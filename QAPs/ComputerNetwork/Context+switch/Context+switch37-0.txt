★What does busy waiting mean?
First, let's define waiting. Waiting is the act of suspending the current thread of execution until some future event. That event might be the availability of a contested resource, the passage of time, or the release of a lock. There are two basic ways to wait: busy waiting and sleeping. Systems implement busy waiting by simply spinning in a tight loop, constantly checking if the event in question has occurred. For example, if we're waiting for 5 seconds to elapse, we might do something like this: 1
2
3
 const int until = get_time() + 5;  // 5 seconds from now while (until > get_time())         ; The upside to this approach is that it is simple and, if we aren't waiting long, it might actually be a performance win, since we avoid the overhead of context switching to another thread of execution. The downside is obvious: We're wasting CPU cycles accomplishing nothing of value. Busy waiting is best understood compared to its alternative, sleeping. Sleeping is implemented as a more complicated dance: You build a list of threads wishing to wait, called a wait queue. You put yourself on the wait queue. You ask the kernel to wake up a process from the list whenever the event in question happens. For example, you might ask the kernel to wake you up when a specific mutex becomes available. You then yield to the kernel, allowing it to schedule something else instead of you. The benefits of sleeping over busy looping is that the kernel can run something useful instead for the duration of the wait. The downside is the overhead: Managing the list, putting yourself to sleep, and context switching into a new process (plus back into yourself later). If the wait is very short, it might make sense to busy wait.