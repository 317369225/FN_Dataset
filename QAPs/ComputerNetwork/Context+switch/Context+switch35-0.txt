★Why do 32-bit Linux kernels only recognize 3GB of RAM?The question is that 2³² = 4GB but systems only recognize 3GB.
First, we should note that 32-bit kernels generally recognize 4GB of RAM, not 3GB. But they often expose <4GB of user address space to each process. For example, a 32-bit Linux kernel supports 4GB of RAM but each process can only see 3GB. So let's restate the question: Why do 32-bit kernels expose <4GB of user address space to each process? The answer is that most kernels map both user- and kernel-space into a flat address space, so that while the sum total is 4GB, the amount allocated to each is <4GB. For example, with Linux on x86-32, user-space is given the lower 3GB of the 32-bit address space, while the kernel is mapped into the upper 1GB of address space. In Windows, the split is 50/50: 2GB for user-space and 2GB for kernel-space. Why map both the user process and kernel into virtual memory at the same time? Why not map in the user process when in user-space and map the kernel when in kernel-space? One reason: Performance. Swapping the virtual address space incurs a nontrivial cost. Worse, depending on the system, various caches must be flushed. For example, on x86, the TLB, which caches virtual to physical address translations, must be flushed whenever the virtual mappings change. On systems with virtually-tagged caches, such as older ARM architectures, the entirety of the data and instruction cache must be flushed whenever you context switch! Cache performance is everything on modern systems, so avoiding such flushes is of paramount importance. Consequently, by mapping both the kernel and user address spaces into memory at the same time, context switching into the kernel becomes relatively cheap, particularly on systems such as Linux where entry into the kernel is otherwise lightweight. On system call and interrupt-heavy workloads, this makes a very large and tangible difference, as the address space need not be swapped out and caches need not be flushed on every system call or interrupt. Not all systems employ this approach. 32-bit Solaris, for example, maps user-space and kernel-space into distinct 4GB address spaces. This has the pro that user-space gets an extra gigabyte--useful for large database processes--but the con that context switching into the kernel is comparatively more expensive. This compounds Solaris's already slow system call overhead and is a large reason why even early on, Linux beat Solaris in most microbenchmarks.