â˜…Is this a context switch?
I think your friend is just nitpicking on that particular definition of context switching. You are right and your friend is wrong. Upon termination of process P1, the do_exit function is called (found in /kernel/exit.c) which does a couple of things. Among the things it does is cleaning up after the process AND updating the task_struct structure to reflect P1's new state as TASK_DEAD. This means that the state is indeed saved. I don't know whether the registers and instruction pointer are still saved, but they probably are, because P1's task_struct structure is not removed from the system just yet for a number of reasons. Cleaning up after a process and removing its process descriptor are two separate operations. One of the reasons for this is that it allows the parent to obtain information about its dead child. The kernel removes the process descriptor only after the parent is done with it or after the kernel is signaled by the parent that it does not care. Kind of tragic if you think about it. Unless the scheduler is specifically designed to distinguish between new and old processes and handle them differently, the scheduler does not care what kind of process it is - as long as the process in the Ready state, the context switch is handled the same way. Maybe you could ask your friend what his reasoning is behind this. If your friend still insists that it is not a context switch, then he needs to answer this question: "If it is not a context switch but is doing the exact things a context switch would, what is it?"