â˜…When do you need a DSL?
With DSL do you also include EDSLs? Assuming you do where do you draw the line that makes your code an EDSL? In a loose sense you are almost always designing a DSL. When you tackle a problem you start coding data structures, functions and procedures that represent your problem domain data, computations and algorithms. Then you use the programming language capabilities to combine and compose these building blocks together. In fact you generally do modularly separating specific parts/components of your problem and/or layering your code according to different abstraction levels. In most languages you actually have concepts like packages/modules. Not to mention libraries and frameworks (either existing or that you create anew). In a loose sense you have an EDSL. The vocabulary of your language is the public interface of your module in the form of identifiers (type, data, function and procedure names). The semantic is in the code that implement those modules. The syntax you use to combine the different elements is, as with all EDSLs, the one of your host language. If you are using a lisp like language you can move up a layer of abstraction and use macros. These languages have a peculiar syntax: in one sense they have nearly no syntax at all (everything is an s-expression), in another sense the syntax is in the order of elements of a list and the nesting of lists. It's not for nothing that in some of them the macros are called syntax trasformers. You are still somewhat tied to the underlying assumption that the basic syntax is just that of an s-expression, but in the other sense you are now defining your own syntax to manipulate the vocabulary of the language (and the syntax now can also be seen as part of the vocabulary). In some languages you can do something similar without the use of macros, just exploiting the characteristics of the programming language. Ruby is quite famous for this, especially since Rails which is built with this philosophy: Rails provide an EDSL (actually more than one) in the form of a DSL for web server development embedded into Ruby. For better guarantees about your language and more control of the correctness of the programs you can use a strongly typed functional language like Haskell. You now have the full abstraction power of functors and monads and the flexibility of reasoning at the level of an interpreter for an EDSL. You also automatically get both type checking and type inference for your EDSL for free. You actually can do more: if you design your language using the correct techniques you can use partial evaluation of an application of the interpreter to the program you write in your EDSL to effectively compile your language down to the host language. If you use a total language with inductive types and dependent types you can in fact also formally reason both about your EDSL and about the programs written with it, proving properties like correctness or whatever you consider important. In some cases you can also get the compiler to autogenerate code (think autocomplete, but more powerful: you write the type of the function and the compiler may be able to write the whole function for you or at least some parts of it). Going beyond that you need to actually code a parser (possibly a lexer and a parser) and either translate your source to an EDSL or to code in some other existing language. Racket is a nice lispy language to experiment with this sort of things. In fact powerful facilities to designing languages is the most important characteristic that distinguish Racket from other Schemes. So, when do you need a DSL? In a loose sense nearly always. In a stricter sense whenever you are working in a domain with a specific vocabulary and abstractions in which you are going to solve multiple problems over time. In the full sense whenever not only you but also many other people, some of which may be non programmers, will have to code multiple solutions over a long period of time. Exactly when the lines are crossed, however, depends on how easy it is to implement an EDSL. If you are working with a lispy language you arguably develop proper EDSL in almost all of your problems. It's so easy to write a macro (and to use it) that it makes sense to do it even if it's not in the domain you are working with but in an "implementation detail" domain: you use the macros to help you write the functions you'd normally do anyway.