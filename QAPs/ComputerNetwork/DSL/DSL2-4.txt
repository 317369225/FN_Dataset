★When do you need a DSL?
A very comprehensive idea of DSL can be found on wikipedia Domain-specific language . I am no authority on DSL but let's look at it from fundamental principles. Computers (general purpose, microprocessors, microcontrollers, DSP[Digital Signal Processing] chips etc) (as of today) understand just a sequence of 0s and 1s Electronic devices with custom functionality and algorithms are still designed hard-wired (that is literally sequencing 0 and 1 flow based on input) - examples include but not limited DSP chips, Graphic rendering (triangles, shadows etc), Security algorithms etc. In case of programmable computers (general purpose -(PC, Mac, server etc), microprocessors, microcontroller) - there was wide usage and adoption for customized task and people realized it's too laborious to implement boiler-plate code sequences literally in 0s and 1s and ASM (assembly language) and variants were born - abstracting out mundane repetitive code sequence into convenient aliases - which can be translated into actual code sequence by a compiler. With further adoption and usage of new ASM language, more complex code could be written - which soon turned out to contain repetitive patterns of code block - which people found can be got rid of by further abstraction and better compiler/interpreter. Thus even better and abstracted 'higher level' languages were born - FORTRAN, COBOL, BASIC etc.  These languages were designed [in simple terms abstracted out ASM code sequences] to be suitable and easy for the domain they were meant to be used. COBOL was syntaxed and designed to be good for business applications, FORTRAN for scientific computation, BASIC for general programming. With time - and wide usage and adaption - even higher level languages like C/ C++ / Prolog / Smalltalk etc were invented to abstract out languages even more for ease of programming. You see - how the trend goes on ? While the general programming languages like Perl / Python/ Java/ C++ / Scala have gather much larger attention and adaption - DSL still finds its place. SQL,  HTML, LaTeX, Verilog, VHDL, MATLAB etc all abstract out things at a level which just serves a widely used and popular application domain. IMO - the criteria to switch to/invent a DSL instead of a primary language is - "Repetitive code patterns used by large number of programmers in a related application area"  -- How do we determine this 'large' ? - I have no clear idea. Engineers move a lot across companies and code patterns get shared too (over internet, through engineer movements and most importantly because of similarity in problems getting solved / application area). At some point, somebody does realise this is happening and decides to abstract out for easing out their life.  I think these kind of pseudo languages get invented at companies - bigger the team , higher the probability. I have seen in-house scripting / programming languages and birth new languages as well In fact many of developers in a sizable team working for a considerable amount of time in same application area do invent their own shortcuts and abstractions to eliminate repetitive codes. At some point, these inventors / groups/ teams/ companies decide to give out these new abstracted languages out to the world for a greater good - (of themselves and of the world). That's how a DSL lanugage is born. Now let's look at your questions.  When do we decide to use a DSL language ?: If you are going to work predominantly on a problem in a particular domain which already has a very well customized implementation of a language and/or is well supported with libraries and user base. Examples: Erlang, Clojure, Scala, Go all have very well designed abstraction for problems involving parallelism and concurrency - through message passing. SQL is very well designed for Relational Database query and manipulation Verilog/VHDL are well designed for implementing logic blocks (logic blocks are massively parallel with sequential sections and "cannot"  be reasonably coded in a pure sequential language like C++/C - underneath verilog compiler does generate a C/C++ exectutable but all that dirty work is abstracted out and became a language). HTML/XML are designed for easy human readable document creation and sharing. Even after all these implementations - if you really feel none of the DSL provide you easy abstractions and/or desired performance for your problem, you get down to implementing your own [library] based on "lower/general language" (C++ / Java / other general programming languages) and at some point you end up with a library but in practice you had just abstracted out repetitive code patterns. Now there is a something called premature optimization.  Unless you have enough metrics that a particular DSL cannot meet the performance/abstraction level requirments of your problem - do not try to reinvent the wheel. Most of the time you would do fine with a good DSL. If you can't benchmark early then - Start off with a seemingly suitable DSL - evalauate and recode in another language if need  be. Most likely you won't need to. Your other question : Is this language dependent ?:  No. DSL like name says is Domain Specific Language -- it doesn't matter which language it is implemented in. What matters is how willing and comfortable you and your team is when using a particular DSL. For example : Erlang, Scala, Clojure and Go all offer very good message passing based concurrency models. Erlang - is purely functional with syntax lot like Haskell Scala - is mix of functional and object oriented and is fully compatible with Java Clojure - looks and is based on Lisp Go - very similar to C/C++ Now if my application requires predominant use of message passing based concurrency - and me and my team is comfortable with Java - I /We will start off with Scala (it might be less performant than Erlang or other languages - but unless I have concrete benchmark that my application will be affected by the performance limitation - I would not really try to ponder way too much and spend my and team's time over learning other language) If it is just me trying to learn a new language - I would really learn a language I don't know and experiment out, see results and switch to another one if need be. Python, Clojure, Scala - all are general programming languages but offer different set of unique features. Choose what suits your application domain.