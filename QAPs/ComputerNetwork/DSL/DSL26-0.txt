★What are some important domain-specific language (DSL) design issues?
A domain specific language (DSL) needs to speak the ubiquitous language of the domain without compromising on the basic principles of API design. It's not true that a DSL is targeted only for business users or non-programmers. At the end of the day a DSL models an API for the domain. Some of the issues that we often encounter while designing a DSL are : an urge to design an English like language with similar verbosity that often results in basic inefficiency in modelling. I have seen DSLs that read like English using lots of fillers that are basically empty abstractions. They contribute to the inefficiency of the underlying model. a DSL needs to have a solid underlying model in whatever language it's being implemented. The model needs to be extensible and the end user language should be a veneer of linguistic abstraction on top of the underlying domain model. It's also true that the same model can have more than one DSL implemented on top of it targeted towards different sets of users. a DSL should be implemented using the idioms that the host language offers. e.g. when implementing a DSL in Haskell, the type system is your friend. Use the power of the type system to make it statically safe and the inferencing capabilities of it to make it succinct for the user. Use the point-free programming techniques to make the DSL lean and only resort to quasi-quoting using Template Haskell as the last resort. On the other hand when you implement a DSL in a Lisp like language, use the power of compile time meta-programming using macros to implement your sublanguage on top of Lisp. When using a hybrid language like Scala, use the power of objects as well as lambdas to make the DSL extensible and modular. a big issue with DSL design is how you handle and manage exceptions. If you design an embedded DSL, embedded within a host language (also called internal DSL), the host language offers you the native built in exception management techniques, which you can reuse in your DSL. Still you need to make the exceptions domain friendly and present it to the user in a language comprehensible to him. Things are different when you design an external DSL, where you are responsible for building the parser and the grammar of the language. You need to devise your own techniques to manage exceptions, which is often quite complicated. another issue that comes up frequently in DSL design is tool integration. There are quite a few workbenches that offer seamless integration and management of DSLs. But most of them are proprietary in that the user is locked into their environment. Eclipse XText, Language Development Made Easy!,  is one of the very flexible frameworks that offers the capabilities of implementing and managing the lifecycle of DSLs that you develop ground up. composition of multiple DSLs is another issue that needs to be addressed when you have a large system that is composed of more than one DSL. Usually DSLs are designed stand alone and are quite difficult to compose. But many languages offer abstractions using which you can write DSLs that you can later compose together and form larger DSLs. Quite some time back I discussed this issue with Scala as the implemnetation language in a blog post DSL Composition techniques in Scala. Lastly a disclaimer : I have written a book named Manning: DSLs in Action where I discuss all of the above points with respect to designing DSLs in languages like Java, Groovy, Ruby, Scala and Clojure.