★Do people still write and compile programs from the command line instead of an IDE? Why or why not?I'm currently in an introductory C course and we've started learning how to compile and debug using tools such as gcc, gdb and valgrind. Is this approach still relevant in a practical context, or is using an IDE more common in the real world? I noticed that professional programmers still use no-frills word processors such as Notepad and Vim. Sorry for the noob question.
I am probably the most schizophrenic person you'll run into when it comes to IDEs.  I love them.  I hate them.  I'm *creating* one -- albeit for creating games on the NES, Nesicide [a niche market, for sure]. At work, I use a Cygwin environment with GNU tools.  I use a Linux box for Linux projects, or a VM running Ubuntu.  In that, I use GNU tools. Our RTOS SDK used to come just with that, and I loved it.  Nothing beats the freedom of being able to do everything you want to do from your own command line.  It's like flying a plane by moving the ailerons, elevators, and rudders by hand.  It can be daunting, but you can make anything you want, however you want. Now they're moving to OpenArbor.  I have used Eclipse and I'm not too impressed.  It's too...pluggy.  Everything can be plugged everywhere, moved everywhere, sent to the background, whatever.  There's too many ways to do things but it's all visual.  The thought process is entirely different.  I am avoiding having to upgrade for as long as possible.  But of course, support will eventually ask why I'm not using OpenArbor, where all I'd have to do to solve my problem is click some "Refactor" button. So at work, I largely hate IDEs.  At home, however, I spend my nights pondering how best to improve my NES IDE, how to make it easier for people to get started in NES homebrew game development.  I worry about the ease of use - hit "Compile", hit "Run".  Providing template projects and a project wizard to get newbies started with as much baggage pre-packed as possible. Different audiences?  Perhaps.  Different end goals?  Perhaps.  I don't see myself ever enjoying having to use OpenArbor.  But anything can change.