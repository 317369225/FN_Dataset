★OPERATING SYSTEMS: What are logical and physical address spaces?
I assume the question is: "What is physical address space and logical address space?" So, my answer is based on the above assumption. Let say your system has 2 GB of physical memory (RAM) divided into words of size 8 bytes(on a 64 bit machine). So every word is assigned an address. This actual address is called physical address. At this stage let me tell you we are blind to those physical addresses. Now, let us suppose we have written a C program: 1
2
3
4
5
6
7
8
9
 #include <stdio.h> #include <stdlib.h> int main(int argc, char argv[]) { printf("location of code  : %p\n", (void) main); printf("location of heap  : %p\n", (void) malloc(1)); int x = 3; printf("location of stack : %p\n", (void) &x); return x; } When run on a 64-bit Mac OS X machine, we get the following output: location of code  : 0x1095afe50 location of heap  : 0x1096008c0 location of stack : 0x7fff691aea64 The hexadecimal values displayed are virtual addresses. Any address you can see as a programmer of a user-level program is a virtual address. It’s only the OS, through its tricky techniques of virtualizing memory, that knows where in the physical memory of the machine these instructions and data values lie. So never forget: if you print out an address in a program, it’s a virtual one, an illusion of how things are laid out in memory; only the OS (and the hardware) knows the real truth. The next question that may arise is: "Why are the physical addresses abstracted to user programs?" To make switching between processes faster. If the entire process resides on physical memory, switching processes may take time as entire process need to be pushed to disk during switching and new process needs to be loaded, which may become very slow if processes are large. Hence there came a need for virtual memory leading to abstraction of physical memory addresses. Note: Some people believe that Virtual Memory was required to run large processes which require memory greater than physical memory available. This isn't true. Virtual memory was required for faster context switches especially in modern OS where switching occurs very frequently. We may say that is an added advantage of virtual memory. The next thought that may come to mind is: "So how are things managed?" The image above is an example of logical address space for process A. This space belongs only to process A. There may be a similar logical address space for process B invisible to A. So, process A thinks that it owns entire physical memory. In reality, it owns only a small part of it. It is the duty of OS to map the logical addresses of different processes to actual physical addresses and avoid bumping of one process into another. This is called Memory Management Responsibility of OS. The above image shows three processes A, B, C sharing the physical address space without bumping into one another. Now, if we look again at the logical address space we see that, "Every process thinks that it has been loaded at memory address 0KB. But actually process A, B and C are loaded at 320KB, 192KB and 128KB respectively. And this mapping is managed by the operating system." I guess it would help you. For your exercise, you may find answer to this question: "We have a system with 4 GB of physical memory. Out of this, 2GB is used by the system processes and you have two applications to run each of which require 25 MB of physical memory. Do we still need virtual memory? What would be your answer if both applications require 1 KB of memory?"    Embed Quote