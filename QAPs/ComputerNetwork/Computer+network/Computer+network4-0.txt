â˜…What is the most important computer networking protocol?
IPv4 (and IP in general), without hesitation. See, networking is based on a layered architecture. The layers, in practice, would be: The application layer (HTTP, POP, etc.) The transport layer (TCP, UDP) - also known as layer 4 The network layer (IP) - also known as layer 3 The link layer (Ethernet, 802.11a/b/g/n) - also known as layer 2 But here's the thing: there is only one protocol for the network layer, which means everything has to go through it. You generally have some choice for the transport layer (at least between TCP and UDP, you can create your own protocol in principle), and for the other layers, pretty much anything goes. This fact is generally called the "hourglass model", as can be easily seen here (the top row are specific applications and not protocol per se, the bottom row is the physical layer, which I didn't mention because it is generally handled by "hardware people" and not "network people"): It is clear from that image that IP is the center of attention. Basically everything above it can be application-specific, while everything under it isn't influenced by and does not influence the rest of the Internet, so you can just do whatever. IPv4 is so important that so far we have made relatively little progress in switching to IPv6, even though it corrects a terrible flaw of IPv4, namely the relatively small number of addresses it provides. In fact, IPv6 was proposed in 1996, and as of 2013 the vast majority of us are still using IPv4. Actually, it's been so hard for us to switch to IPv6 that lots and lots of time, money, and energy has been spent on tricks to make IPv4 survive just a little bit longer (NAT, CIDR...), rather than on actually making the switch. The next most important protocol would be TCP. The vast majority of flows on the Internet today are TCP flows. This turns out to have interesting consequences. Remember when I said that you could create your own transport layer protocol and use it easily? Well, this is somewhat true, but not fully. See, although TCP and UDP are supposed to be "end-to-end" protocols, meaning that intermediary nodes are not supposed to look at them, in practice, many intermediary nodes do look at them. There are several reasons for this, one is that you might go through a proxy or a firewall that needs to analyze your traffic, and if they don't recognize your packets, there's actually a chance they might just drop them all. Another is that NATs (which, if you remember, were created to fix issues with IPv4) actually assume that you are using TCP or UDP. That's right, NATs actually break the layering system in a way that actually makes it much harder to create new layer 4 protocols (unless you make them look like TCP or UDP that is). Another issue with TCP is that if you create a new transport layer protocol that does congestion control (like TCP), you are supposed to worry about something called "TCP friendliness". TCP friendliness is the idea that flows using your new protocol should not "beat" TCP flows. Said another way, if your new protocol flow is competing with a TCP flow for network resources, it should converge to a situation where both flows use the same amount of resources[1]. This is an issue because it means that some techniques which achieve significantly better congestion control than TCP cannot be used at all on the actual Internet. That still leaves room for improvement over TCP, but it does limit the range of these improvements. What that means in any case, is that you have to take TCP into account even when you are doing something that is seemingly unrelated to it, which is why it would be the second most important protocol on the Internet. There you have it. If I had to choose a third it would be BGP or maybe Ethernet, but I already cheated by giving two answers, so I won't go any further than this. [1] UPDATE: this is actually incorrect. Your new protocol is allowed to be faster (i.e. use more resources) than TCP. However, if you are sharing a path with other TCP flows, the other flows should have the same amount of access to resources as if you were another TCP flow. As it turns out that doesn't mean you can't be faster than TCP because TCP doesn't use 100% of a path's capacity, even when going at full speed, but it does seriously limit what you can do.