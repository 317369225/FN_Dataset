What are the best websites, online resources, books, etc. to prepare for the ACM ICPC?
Getting Started with the Sport of Programming This document is to guide those people who want to get started or have just started with competitive programming. Originally,  this document was prepared during the summers of 2014 to help the  freshers of Indian Institute of Technology, Kanpur. So, we thought it  might be useful to others as well. Prerequisite : Basics of any programming language. We will follow C/C++. Note : Please note that this blog is not meant to explain concepts in  details. The Aim of this blog is to guide you about which topics you  should read and practice in a systematic way. However, in many places  short explanations have been included for their relevance. Relevant  problems are given after each topic. Proper sources are given from where  these concepts can be studied. Where sources are not mentioned, that  means these are very very popular and you can get to know about them  just by a single google search. Move forward and enjoy it ! All the following things are from our experience and not something written on stone. You will need to show motivation. Languages that should be used C/C++/JAVA (your choice) We will focus on C++, JAVA is slow (one big advantage of JAVA is Big Integers, we will see later) C++  is like superset of C with some additional tools. So, basically if you  have knowledge of C, you are ready to code in C++ as well.  Otherwise go  back and learn how to write codes in C/C++ Sometimes knowledge of PYTHON is helpful when you really need big integers. PARTICIPATE PARTICIPATE PARTICIPATE (the only mantra) SPOJ: Its  a problem Archive (recommended for all beginners Start with problems having maximum submissions. Solve first few  problems (may be 20). Build some confidence. Then start following some  good coders (check their initial submissions). Then start solving  problems topic wise Never  get stuck for too long in the initial period. Google out your doubts  and try to sort them out or you can discuss with someone (ONLY IN THE  BEGINNING). Before getting into live contests like codeforces or codechef, make sure that you have solved about 50-70 problems on SPOJ. CODECHEF: Do all the three contests every month. Do participate in CodeChef LunchTime for sure. Even  if you are unable to solve a problem do always look at the editorials  and then code it and get it accepted (this is the way you will learn). And  even if you are able to do it, do look at the codes of some good  coders. See how they have implemented. Again you will learn. Same point apply to TopCoder and Codeforces as well. Codeforces: 4 to 5 short contests of 2 hour in a month (Do them once you develop some confidence). TopCoder: Once you have proper experience and you can write codes very fast. Online Programming Contests: You  write codes and submit them online . The judge runs your code and  checks the output of your program for several inputs and gives the  result based on your program’s outputs.You must follow exact I/O  formats. For example, do not print statements like : “please enter a  number”, etc :P Each Problem has constraints: Properly analyse the constraints  before you start coding. Time Limit in seconds (gives you an insight of what is the order of solution it expects) -> order analysis(discussed later). The  constraints on input ( very imp ): Most of the time you can correctly  guess the order of the solution by analysing the input constraints and  time limit . Memory Limit ( You need not bother unless you are using insanely large amount of memory). Types of errors you may encounter apart from wrong answer : Run Time Error (Most Encountered) Segmentation fault ( accessing an illegal memory address) You declared array of smaller size than required or you are trying to access negative indices . Declaration of an array of HUGE HUGE(more than 10^8 ints) size -_- . Dividing by Zero / Taking modulo with zero :O . USE gdb ( will learn in coming lectures ) Compilation Error You need to learn how to code in C++. USE GNU G++ compiler or IDEONE(be careful to make codes private). Time Limit Exceed (TLE) You program failed to generate all output within given time limit. Input Files are not randomly generated , they are made such that wrong code does not pass. Always think of worst cases before you start coding .Always try to avoid TLE. Sometimes  a little optimizations are required and sometimes you really need a  totally new and efficient algorithm (this you will learn with time). So whenever you are in doubt that your code will pass or not .Most of the time it won’t pass . Again do proper order analysis of your solution . Sometimes  when you are stuck . Check  the running time of other accepted codes to  take an insight like what Order of solution other people are writing /  what amount of memory they are using. 4 MB ~ array of size 10^6 . Or 2-d array of size 10^3*10^3 Standard Memory limits are of Order of 256MB Order analysis : Order  of a program is a function dependent on the algorithm you code. We wont  go in theoretical details just think Order of program as the total  number of steps that program will take to generate output generally a  function based on input like O(n^2) O(n) O(log n) . Suppose you write a program to add N numbers .See the following code.     int cur,sum=0; for(int i=0;i<n;++i) {     scanf(“%d”,&curr);     sum = sum+curr; }     Total number of computations = n*(1+1+1+1) n times checking i n times i++ n times scanf n times + operating So total of 4*N. We remove the constant and call it O(N) This is the simplest I can explain.You will get further understanding with practice and learning. You must know running time of these algorithms (MUST) Binary Search -> ? Merge / Quick sort -> ? Searching an element in sorted/unsorted array -> ? HCF / LCM / Factorization / Prime CHeck ? We all know the computation power of a processor is also limited. Assume 1 sec ~ 10^8 operations per second . (for spoj old server it is 4*10^6). Keep this in mind while solving any problem. If your program takes O(n^2) steps and problems has T test cases . Then total order is T*N^2. For T < 100 and N < 1000 . It will pass . But for T < 1000 and N < 1000 it wont . Neither for T < 10 and N < 10000  INT OVERFLOW : Sum three numbers. Constraints : 0 < a,b,c < 10^9  int main() {     int a , b,c;     scanf(“%d %d %d”,&a,&b,&c);     int ans = a + b + c;     printf(“%d”,ans);     return 0; } This  program won't give correct output for all cases as 3*10^9 cannot be  stored in INTS you need long long int or unsigned int (4*10^9). what if 0 Comparing Doubles : int main() { float a ; scanf(“%f”,&a); if(a == 10 ) printf(“YES”); return 0; } float / double don’t have infinite precision . BEWARE ( 6/15 digit precision for them respectively) Try the following problem. SPOJ.com - Problem GAMES Standard Template Library (STL): In your code sometimes you need some Data Structures(DS)  and some functions which are used quite frequently. They already have  lots of standard functions and data structures implemented within itself  which we can use directly. Data Structures  ( To be discussed in later lectures ) Vectors Stack Queue Priority Queue Set Map Functions Sort Reverse GCD Swap next_permutation binary_search (left + right) max, min pow, powl memset  Now imagine writing codes using these inbuilt functions and data structures . It would be much more simpler now. What headers/libraries should you include ? Basically  the above functions / DS are in different libraries. So in some cases  you may need to include many headers . But you can include everything  using just one header.         #include <bits/stdc++.h> Try the following problem : Ups and Downs   Which of the above inbuilt function did you use ? What if you need to sort an Array of structure ? You can either make a struct and write compare function for it.(Read more at www.cplusplus.com)Or you can use an vector of pair. Read This: Algorithm Tutorials Now you are ready to start competitive programming . You can continue reading this doc or get started on your own . Good luck :) First,  you must learn the basic and well known algorithms . Not only the  algorithm but you must also understand why that works , proof , code it  and analyze it . To know what basic algorithms you must know you can  read : What is needed to become good algorithmist like top rankers in Topcoder/Spoj/GCJ? What are the 10 algorithms one must know in order to solve most algorithm problems? What are the 10 must-know algorithms and data structures for a software engineer? Also read these answers on how to start competitive programming and get good at it. For an ACM beginner, how should I start? Can I crack the ACM-ICPC in 1.5 years if I have to start from scratch? What was Anudeep Nekkanti's Competitive Programming strategy to become 35th in Global ranking, in just 6-7 months? TopCoder has very nice tutorials on some topics, read them here . You can also read this book topic wise to understand an algorithm in a deeper way http://ldc.usb.ve/~xiomara/ci2525/ALG_3rd.pdf. To get good at writing fast codes and improving your implementation, you can follow this: My personal advice is to start practicing on TopCoder . Start with Div2 250 master it then start with Div2 500 master it then  move to Div1 250 .Also read the editorials of problem you solve and the  codes of fastest submissions to learn how to implement codes in simple  and elegant way.Meanwhile keep learning algorithms and keep practicing  them on SPOJ or CodeChef or Codeforces . And do read the tutorials,  after a time you will realize that the tricks and methods to solve are  repeating themselves . We learn from practice only . If you read same  thing 5 times in different tutorials then it will not be stored in your  short term memory only right . Below are few topics to start with and problems related to those topic. They are very basic stuffs and you can learn all you need to know by just googling them out. “When i will get some time I will try to update and give more details about the topics a newbie should cover.” Try to do all the problems stated below if you are a beginner. PRIMES Prime Check ( O(log n) also possible read about miller-rabbin ) Factorization Number of factors Sum of factors Generating Primes using sieve of eratosthenes Bounds on number of primes till N Euler’s totient function Practice Problems : SPOJ.com - Problem NDIV Problem - 431B - Codeforces SPOJ.com - Problem GAMES SPOJ.com - Problem GCJ101BB SPOJ.com - Problem GCJ1C09A SPOJ.com - Problem MAIN72 SPOJ.com - Problem WINDVANE SPOJ.com - Problem NDIV SPOJ.com - Problem PTIME SPOJ.com - Problem NDIVPHI SPOJ.com - Problem NOSQ SPOJ.com - Problem AFS Witua and Math SPOJ.com - Problem CUBEFR Try as many as you can. Other things that you can read meanwhile Euler Totient function and Euler's theorem [[ READ ]] Modulo function and its properties Miller-Rabin Algorithm            [[ READ ]] Extended Euclid's Algorithm        [[ READ ]] Keep exploring STL Prove running time of HCF is O(log n) Try sorting of structures Practice few problems on several Online Judges Try to do + - * operations on large numbers(<1000 digits) using char array (for learning implementation) Number of factors and sum of factors in sqrt(n) time ,Number of primes till N Basic Number Theory Modulo operations and Inverse modulo How to compute a ^ b % p in O(log b), where p is prime Find Nth fibonacci number modulo p [Read Matrix exponential] n! % p  ( what if we have lots of test cases ) ETF ( calculation / calculation using sieve ) Euler theorem , Fermat’s little theorem , Wilson theorem            [[ READ ]] nCr % p (inverse modulo) ( read about extended euclid algorithm) (p-1)! % p  for prime p, Use of fermat theorem in Miller-Rabin ( Probabilistic ) ( Miller-Rabin SPRP bases records ) 64  Choose 32 < 10^19 we can precompute till herein a 2 dimentional  array [Learn use of the recursive relation : (n+1)Cr = nCr + nC(r-1)] Number of ways to traverse in 2D matrix[Catalan Number] ( what if some places are blocked ? Hint : DP) a^b % c . Given Hcf(a,c) = 1 .And  what if Hcf(a,c) ! = 1.  [[ READ Chineese Remainder Theorem, not used much in competition]] Matrix Exponentiation solving linear recurrence using matrix exponentiation(like fibonacci) Practice problems: http://www.spoj.com/problems/DCEPC11B Field Trip SPOJ.com - Problem FIBOSUM SPOJ.com - Problem POWPOW SPOJ.com - Problem POWPOW2 [[ CRT ]] Go through these tutorials (The listed problems might be tough but do read the tutorial) Algorithm Tutorials Algorithm Tutorials Algorithm Tutorials Algorithm TutorialsPower of BITS Numbers are stored as binary bits in the memory so bits manipulation are alway faster. Bitwise 'or' operator    : | Bitwise 'and' operator : & Bitwise 'xor' operator  : ^ Bitwise 'left shift'         : << Bitwise 'right shift'       : >> Memset and its uses using function : sizeof() Bitmask and use of Bitmask in Dynamic Programming [[subset DP]] Some cool Tricks n = n * 2 :: n = n << 1 n = n /2  :: n = n >> 1 checking if n is power of 2 (1,2,4,8…) ::checking !(n & (n-1)) if x is max power of 2 dividing n, then x = (n & -n) Total number of bits which are set in n = __builtin_popcount(n) setting xth bit of n  :: n |= (1<<x) checking if xth bit of n is set :: checking if  n&(1<<x) is non zero Problem  : You are given N numbers and a numbers S. Check if there exist some  subset of the given numbers which sums equal to S .What if you are asked  to compute the number of such subsets ? Practice problems: SPOJ.com - Problem SPCO Problem - 114B - Codeforces More will be added later Read this for further knowledge Algorithm Tutorials Binary  Search Try this : Problem - 431D - Codeforces Understand  the concept of binary search. Both left_binary_search and  right_binary_search. Try to implement it on your own. Look at others  implementation. sample implementation : int l = 0, r = 10000,  key_val = SOME_VALUE, m; while (r - l > 1) { m = (l+r) >> 1; int val = some_non_decreasing_function(m); if(val < key_val) l = m; else r = m; } if  (some_non_decreasing_function(l) == key_val ) return l; else return r; // this can be modified in a variety of ways, as required in the problem Practice Problems: SPOJ.com - Problem AGGRCOW Problem - 431D - Codeforces [[Learn’t something new ?]] SPOJ.com - Problem PIE SPOJ.com - Problem TETRA SPOJ.com - Problem KOPC12A The Beauty of Standard Template Library of C++ Vectors in one dimension and two dimension http://www.codechef.com/MAY14/problems/CHEFBM solve : Compilers and parsers Now use stacks to taste its beauty and solve the following problem too. Problem - 344D - Codeforces Queue SPOJ.com - Problem DONALDO  Priority Queue Problem - I - Codeforces [[First try without using Priority queue]] Set SPOJ.com - Problem FACEFRND [[First try without using set ]] What if I tell you that apart from scanning the input this problem can be done in 2 lines ? Interesting ? Think! Map Tourist Translations Problem - C - Codeforces            Some Practice Problems Before you proceed further SPOJ.com - Problem DCEPC11B http://www.spoj.com/problems/AGGRCOW/ http://www.codechef.com/problems/CHEFBM Just Some Permutations 3 SPOJ.com - Problem KOPC12A (recommended) Witua and Math/ (recommended) Problem - 431D - Codeforces (recommended) http://www.spoj.com/problems/SPCO/ SPOJ.com - Problem FIBOSUM http://www.spoj.com/problems/POWPOW/ (recommended) The Number Of Solutions SPOJ.com - Problem IOPC_14F http://www.spoj.com/problems/NDIVPHI/ (recommended) http://www.spoj.com/problems/AU12/ (easy) http://www.spoj.com/problems/ETF/ (easy) Problem - 114B - Codeforces (easy) SPOJ.com - Problem HISTOGRA [[Hint : use stacks]] SPOJ.com - Problem HOMO SPOJ.com - Problem NGM2   GRAPHS Try the following problems : Prime Path Prayatna PR Any Ideas ? Def : Think graphs as a relation between node , related nodes are connected via edge. How to store a graph ? ( space complexity ) Adjacency Matrix ( useful in dense graph) Adjacency List (useful in sparse graph) O(min(deg(v),deg(u))) You must know the following terminologies regarding Graphs : Neighbours Node Edge Degree of vertices Directed Graph Connected Graph Undirected Graph Connected components Articulation Points Articulation Bridges Tree [[ connected graph with N nodes and N-1 edges]] Leaves Children Parent Ancestor Rooted Tree Binary Tree K-ary Tree Cycle in graph Path Walk Directed Acyclic Graph [[ DAG ]] Topological Sorting (Not very important, in my opinion) Bipartite Graph ( Tree is an example of Bipartite Graph . Interesting Isn’t it.) Breadth First Search/Traversal (BFS) [[ very important, master it as soon as possible]] Application : Shortest path in unweighted graphs Depth First Search/Traversal (DFS) [[very very important, master it as soon as possible]] Infinitely many applications, just kidding :P (But Its true, Indeed !) Now try the problems given at the beginning ! Practice Problems : Page on codechef.com SPOJ.com - Problem PRATA SPOJ.com - Problem ONEZERO SPOJ.com - Problem PPATH SPOJ.com - Problem PARADOX SPOJ.com - Problem HERDING SPOJ.com - Problem PT07Z SPOJ.com - Problem NICEBTRE SPOJ.com - Problem CERC07K SPOJ.com - Problem BUGLIFE SPOJ.com - Problem COMCB SPOJ.com - Problem NAKANJ Call me, Maybe A Relation on Numbers http://www.codechef.com/IOPC2013/problems/IOPC13C Problem : You are given a Graph. Find the number of connected components in the Graph. Hint : DFS or BFS. Problem : You are given a grid with few cells blocked and others open. You are given a cell , call is source, and another cell , call it dest. You can move from some cell u to some another cell v if cell v is open and it is adjacent to cell u. You have to find the shortest path from source to dest.  Hint : Try to think the grid as a Graph and apply some shortest path algorithm. Which one ? You think ! Problem : You are given a Tree. You need to find two vertices u and v such that distance between them maximum. Hint : Try to do it in O(1) number of DFS or BFS ! GREEDY ALGORITHMS Greedy  Algorithms are one of the most intuitive algorithms. Whenever we see a  problem we first try to apply some greedy strategy to get the answer(we  humans are greedy, aren’t we :P ? ). Read this tutorial for further insight or you can directly attempt the problems  most of the greedy approaches are quite simple and easy to  understand/formulate.But many times the proving part might be difficult.  But you should always try to prove your greedy approach because most  the times it happens that you later realise that you solution does not  give the optimal answer. Algorithm Tutorials They  are generally used in optimization problems and there exists an optimal  substructure to the problem and solutions are generally O(n log n)  (sorting) or O(n) (single pass). Problems List: SPOJ.com - Problem BAISED SPOJ.com - Problem BALIFE SPOJ.com - Problem GCJ101BB Bon Appetit Knapsack Problem Little Elephant and Music SPOJ.com - Problem ARRANGE SPOJ.com - Problem FASHION Q)A thief breaks into a shop and finds there are N items weight of ith item is Wi and cost of ith item is Ci and thief has a bag of which can carry at most W units of weight. Obviously thief wants to have maximum profit . What strategy he should choose if : Case  1: If he is allowed to take fractional part of items (like assume item  to be a bag of rice and you can take whatever fraction of rice you  want). [Hint :: greedy]) Case  2:If he cannot break the items in fractional parts. Will now greedy  work ? Try to make some test cases for which greedy will fail. Most of time when greedy fails its the problem can be solved by Dynamic Programming(DP).   DYNAMIC PROGRAMMING [[ DP ]] In my view this is one the most important topic in competitive programming. The problems are simple and easy to  code but hard to master. Practice as many DP problems as much possible. You must go through this topcoder tutorial and you must try to solve all the problems listed below in this doc. ( These are basic problems and some with few variations that we feel one should know. You must practice other DP problems too) Problems list: SPOJ.com - Problem COINS Read about Maximum Sum Subarray [I dint find exact question on any online judge as its very very basic] Dessert Wizard Makx Sum Q)Finding NCR [Using above discussed recursion in math section and DP] Problem 18 - Project Euler Q)Given  a matrix filled with numbers.You are initially at upper left corner ,  you have to reach to the lower right Page on corner.in each step you can either  go right or down.When ever you go to a cell you points increase by value  of that cell.What is the maximim possible points you can gain? Little Elephant and Mouses SPOJ.com - Problem MAXWOODS SPOJ.com - Problem EDIST SPOJ.com - Problem ADFRUITS SPOJ.com - Problem IOIPALIN Polo the Penguin and the Test Maxim and Progressions Little Elephant and Balloons Pizza Delivery Chefs new Pet For further advanced topics you can follow topcoder tutorials. This also might be helpful introduction to competitive programming - Stanford. Copied from : http://sportprogramming.blogspot... 