How do I do this question?
Thanks for A2A. I got 12th position in this SRM, so I am in some state to discuss my solution. This is how I approached the question. Forget everything. Now what you need to do is insert exactly K edges of zero weight between the two layers such that the distance between the farthest nodes in the resulting graph is minimum. Once you are clear with the above statement, we can now move  to constructing the algorithm. Let us divide the question in two parts : Getting the correct arrangement of K edges. Getting the distance between the farthest nodes in the graph.The 2nd part can be done easily using Floyd-Warshall algorithm (this is because constraints are very less). The 1st part can be done using an adhoc technique. The observation is that the maximum number of edges that you need to insert (i.e K) is 10 between a maximum of 10 pairs of nodes. That indicates that you can try every arrangement of K edges between the two layers. So the final algorithm can be written down as : Iterate over all the possible combinations of K edges. Get the distance between the farthest nodes. Update the answer with this distance if it is smaller than your present answer. Now comes the coding part. First of all, you need to create the graph, I used matrix representation because I was going to use Floyd-Warshall. So, create a graph using a matrix. For iterating through all the possibilities, we can use bit-masking. This technique is very nicely explained here : Tutorial for bitwise operations (goto Generating all Subsets part) In brief, we are going to generate all binary numbers and then take those positions on which the bit is set. i.e, if I have 4 nodes in each layer (corresponding nodes form a pair) and K=2, then to generate all the possibilities, I can do this: 1100 : insert edge between 1st pair and between 2nd pair 1010 : insert edge between 1st pair and between 3rd pair 1001 : insert edge between 1st pair and between 4th pair 0110 : insert edge between 2nd pair and between 3rd pair 0101 : insert edge between 2nd pair and between 4th pair 0011 : insert edge between 3rd pair and between 4th pair ignore binaries like 1110, 0111, 0001, 0010 , simply because the number of set bits is not equal to K while we have to choose exactly K pairs. To achieve this, here is a pseudo-code in c++ : int h=pow(2,nodes); //total number of combinations possible for(int u=0, u<h; u++) //iterate through all combinations {       //If this arrangement contains '1's not equal to K, ignore       if(__builtin_popcount(u)!=K)               continue;       //iterate through all the node-pairs and check if this has to be              // connected according to this arrangement        for(j=0; j<nodes; j++)        {               if(u&(1<<j))  //if j-th bit is set in u, connect j-th pair               {                    mat[j][limit+1+j]=0;  //connecting means making weight 0                    mat[limit+1+j][j]=0;  //for edge between the corresponding                                                             //nodes               }          }         /*                    Insert floyd-warshall         */ } Now we have to get the distance between the farthest nodes in this newly constructed graph. The code is expanded to make the process more clear..     int limit=a.size();     //size of the given vector     int mat_size=(limit+1)*2; //number of rows/cols in the matrix     int nodes=(limit+1);  //number of nodes in one layer     int ans=INT_MAX, u;     int h=pow(2,nodes); //total number of combinations possible     for(u=0; u<h; u++)  //iterate through all combinations     {       //If this arrangement contains '1's not equal to K, ignore       if(__builtin_popcount(u)!=K)               continue;             //make a copy of the matrix that you have       for(i=0; i<mat_size; i++)             for(j=0; j<mat_size; j++)                  dist[i][j]=mat[i][j];            //iterate through all the node-pairs and check if this has to be                         //connected according to this arrangement       for(j=0; j<nodes; j++)       {         if(u&(1<<j))  //if j-th bit is set in u, connect j-th pair         {             dist[j][limit+1+j]=0;  //connecting means making weight 0             dist[limit+1+j][j]=0;         }       }                //Use Floyd-Warshall       for(i=0;i<mat_size;i++)         for(j=0;j<mat_size;j++)           for(k=0;k<mat_size;k++)             dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);                //Search for the maximum distance in this matrix       int curr=0;       for(i=0; i<mat_size;i++)         for(j=0; j<mat_size;j++)           if(i!=j)             curr=max(curr,dist[i][j]);                //update the answer with the minimum value       ans=min(ans,curr);     } If you are still not clear with the solution, you should try reading about Floyd-Warshall algorithm and bit-masking. for complete code ([C++] BridgeBuildingDiv2_pakhandi - Pastebin.com) Hope it helps :) 