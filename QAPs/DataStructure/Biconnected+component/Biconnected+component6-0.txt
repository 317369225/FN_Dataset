When should we use BFS instead of DFS, and vice versa?Can you give some examples?
At the early stage of learning graph algorithm/competitive programming, I faced this problem as well. Hopefully this answer could explain things well with simple examples: In general, usually, you would want to: use BFS - when you want to find the shortest path from a certain source node to a certain destination. (Or more generally, the smallest number of steps to reach the end state from a given initial state.) use DFS - when you want to exhaust all possibilities, and check which one is the best/count the number of all possible ways. use either BFS or DFS - when you just want to check connectedness between two nodes on a given graph. (Or more generally, whether you could reach a given state to another.) So, some actual simple examples: BFS examples: To determine the smallest number of steps for a knight to reach from a grid to another, you could build a graph using the 8 x 8 cells as nodes, and then add edges between these cells (e.g., there would be an edge between (1, 2) and (2, 4)), and then run a BFS from the start position. Determine the smallest number of steps to reach the destination in a maze in this form (S: start, E: end, . : free cells, #: obstacle): ####### #.#E..# #.#.#.# #...#.# #S#...# ####### DFS examples: Compute the shortest path to visit each city exactly once on a weighted graph. [Note: There is a cleverer Dynamic Programming (DP) solution with an exponential number of states.] The N-Queue problem (if you do competitive programming). [Note: Poly-time constructive solution exists.] BFS/DFS examples: Check if you could reach a node from another on a given graph. On MSPaint (initial version), fill color on a *.bmp image file when you click on a pixel. (Graph Connectedness) Given a graph, from a given node, determine if you can travel to all other nodes without adding extra edges. Sachin Malhotra is correct that BFS and DFS have other more advanced applications, including but not limited to (listing a few I could think of right now, based on my competitive programming experience): DFS - advanced applications: Cycle detection Strongly connected component / Biconnected component Eulerian pathAnd more. Finally, (no offense, really) I would suggest the OP to learn more about these basic things first by solving some simpler/more basic problems, and if you do competitive programming, might be good to first solve a few simpler problems, and once you are confident explore other more interesting areas of graph theory problems. 