Is there a linear time algorithm that checks if an edge in a directed graph is a bridge (cut-edge)?As Tarjan's algorithm seems to be for undirected graphs, I am wondering whether there is some way I could modify Tarjan's algorithm to work for a directed graph, or is there any other linear time algorithm ?
Tarjan's algorithm is not strictly for either directed or undirected graphs, so it can be used to find bridges or cut points in either. The algorithms for finding strongly connected components (SCC) in a directed graph and biconnected components (BCC) in an undirected graph are very similar, to the extent that they can both be called Tarjan's algorithm. Tarjan's run in linear time, and is usually preferred over Kosaraju's due to performance and its extensibility. The version of Tarjan's for SCCs requires a stack and tracks nodes, whereas the version for BCCs requires maintaining a parent and tracks edges. Both use the same idea of a lowpoint and track visited nodes. This is a diff of the two implementations: 9a10,11 > typedef pair<int, int> pii; > 15,16c17 < bool instk[maxn]; < stack<int> stk; --- > stack<pii> stk; 18c19 < void dfs(int a) { --- > void dfs(int a, int p) { 21,22d21 < instk[a] = true; < stk.push(a); 26c25,34 < dfs(b); --- > stk.push(pii(a, b)); > dfs(b, a); > if (lowp[b] >= ind[a]) { > pii t; > do { > t = stk.top(); stk.pop(); > cout << t.first + 1 << ',' << t.second + 1 << ' '; > } while (t != pii(a, b)); > cout << '\n'; > } 28c36,37 < } else if (instk[b]) { --- > } else if (ind[b] < ind[a] && b != p) { > stk.push(pii(a, b)); 32,40d40 < if (lowp[a] == ind[a]) { < int t; < do { < t = stk.top(); stk.pop(); < instk[t] = false; < cout << t << ' '; < } while (t != a); < cout << '\n'; < } 50a51 > adj[b].push_back(a); 54c55 < if (ind[i] == -1) dfs(i); --- > if (ind[i] == -1) dfs(i, -1); 