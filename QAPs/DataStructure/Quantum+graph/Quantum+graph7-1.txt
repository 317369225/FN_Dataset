On a quantum computer, how does the full stack required to calculate 1+1 look like?
Quantum computers wouldn't have any advantage for solving that kind of problem, so I doubt anyone has tried to work out the algorithm. There are some "simple" problems for which quantum computers beat classical algorithms and that have been implemented in experiments, e.g. Grover's search algorithm. This is a search problem in which a classical computer needs to perform O(N) lookups on a database to reach an answer, whereas a quantum algorithm needs O(N^1/2) lookups and O(log(N)) storage. Grover's algorithm Quantum algorithms are useful when solutions are "simple to verify, but difficult to guess". e.g. if you asked a quantum algorithm to factor 45783623, it might first tell you "6359 * 6569" which you would check and find is wrong, and then it might tell you "6917 * 6619" which you can verify is correct. The quantum computer presents a "guess" answer which you check using classical logic / hardware. You repeat the quantum algorithm until the guess turns out to be correct. The properties of good quantum algorithms mean that you need to make far fewer runs of the quantum algorithm until the correct guess is presented, compared to the number of steps needed to solve the same problem by brute force on a classical computer. For using a quantum computer to give any advantage, the problem must be "hard" to solve classically, but "simple" to tell whether a particular guess is correct or not. We already know how to solve 1+1 efficiently with classical computers, pen and paper, etc. so it's not a suitable problem to implement with quantum computation 