Can a quantum computer be modeled on a standard computer?
Hadayat is correct that all standard models of quantum computing (quantum turing machines, quantum circuit models, adiabatic quantum computing, etc.) can be modelled on a standard computer.  Technically speaking, we say that quantum and classcal computers have the same computability properties, i.e. the set of computable functions and the set of decidable languages is the same on both types of computer. Where quantum and classical computers differ is in their computational complexity, i.e. the rates at which the time and memory requirements of an algorithm scale with the size of the problem instance.  As Hadayat notes, if you try to simulate a quantum computer on a classical computer in a naive way, by simply tracking the coefficients of the state vector at each step in the computation, then this would require exponentially large time and memory resources.  However, we can actually do a bit better than that, getting away with only polynomial memory resources, but still requiring exponential time. Technically speaking, the class of problems that is tractable on a quantum computer is called BQP (Bounded Quantum Polynomial -- see Complexity Zoo:B for more details).  We know that BQP is contained in PSPACE, which is the class of problems that a classical computer can solve with polynomial memory resources.  There is a simple proof of this result in the book of Nielsen and Chuang Quantum Computation and Quantum Information: 10th Anniversary Edition: Michael A. Nielsen, Isaac L. Chuang: 9781107002173: Amazon.com: Books.  The basic insight behind the result is that your classical simulation does not have to track the quantum state step by step as a quantum computer would.  We can work backwards from the end of the computation as well as forwards from the beginning at the same time, backtracking in such a way as to consume less memory.  The construction is essentially a discrete time analog of the Feynman path integral approach to quantum theory. We can actually do a little better than the PSPACE result, and complexity classes in which BQP is known to be contained are listed in Complexity Zoo:B, although the meaning of most of them is a bit more obscure than that of PSPACE.  Nevertheless, for all known containments we think that the containing class still requires exponential time resources.  We can't actually prove this at present, since it is notoriously hard to prove that any problem must have exponential complexity, even on a classical computer (see the P vs NP problem). So far, I have described the situation for standard models of quantum computing, All of these models share the property that they produce a classical output at the end of the computation, e.g. the output may be a bit telling you the answer to a yes/know question such as whether the input is a prime number.  However, we could also consider an expanded class of quantum models in which the output of the quantum computation is actually a quantum state.  A classical computer cannot simulate such models for the simple reason that it does not produce quantum states.  Although we are primarily interested in using computers to solve classical problems, i.e. you want an output that tells you the answer to some question at the end of the day, it is useful to consider these expanded models as subroutines within a computation.  For example, we know that some problems, such as graph isomorphism, could be solved efficiently on a quantum computer if we could find an efficient way of preparing a certain class of quantum states.  Complicated quantum states may also be needed for other applications of quantum information, e.g. in quantum error correction or for a quantum cryptography protocol.  Studying the complexity of preparing quantum states is therefore an interesting question.  Hence, there is a sense in which classical computers cannot simulate quantum ones, although this is a little bit of a cheat because you could argue that we should only be comparing the complexity of the overall classical problem rather than looking at quantum subroutines. 