How is a quantum computer programmed?
I don't work too much with the more popular gate/circuit model for quantum computing, but it essentially is a series of gates or operations on a set of qubits. These unitary gates are represented by matrices which correspond to rotations in a vector space of [math]2^n[/math] dimensionality, where [math]n[/math] is your number of qubits. For example, you can apply an [math]X[/math]-gate, which is simply the Pauli-x spin matrix [math]\sigma_x = \begin{bmatrix}0 & 1 \\\\ 1 & 0 \end{bmatrix}[/math] for [math]n[/math] qubits to one qubit [math]|\psi\rangle = a|0\rangle + b|1\rangle[/math], where [math]|0\rangle = \begin{bmatrix}1 \\\\ 0 \end{bmatrix}[/math] [math]|1\rangle = \begin{bmatrix}0 \\\\ 1 \end{bmatrix}[/math] and [math]a[/math] and [math]b[/math] are coefficients that satisfy [math]|a|^2 + |b|^2 = 1[/math], and it basically just flips the states, i.e. [math]X|\psi\rangle = b|0\rangle + a|1\rangle[/math] (coefficients were swapped). The basic thing you have to remember about these gates is that they must be reversible (which implies some interesting things, all of which I don't fully understand). How you get from these types of gates to higher level operations is sort of an open "question" (or rather, it's open to being implemented in a sensible way), and that layer would be analogous to your assembler layer. I think when we have a better understanding of quantum algorithms and what our quantum architectures will look like when we finally are able to implement scalable quantum circuits, we'll have a better idea of what a useful quantum assembler should look like. I have a hard time imagining that we'd have a sort of analogous quantum C language, but I'm pretty sure I'm just lacking insight here. It's a very interesting problem that at least a few people seem to be working on, though we have to be able to build these things first. It's hard to come up with abstract ideas for how things should be organized with foresight into all possible quantum architectures, so we're kind of stuck waiting on the hardware to guide us. Since you tagged D-Wave in this, I'll talk about that a little too. It's actually a lot easier to understand. The classical analog of what the D-Wave processors solves is called a QUBO (quadratic unconstrained binary optimization problem), and it's basically a special quadratic program. It looks like this: [math]E(x_1, x_2, ..., x_N) = \vec{x}^T Q \vec{x} = \sum\limits_{ij}^N x_i Q_{ij} x_j[/math] where [math]x_i[/math] are your binary decision variables and the values of the [math]Q[/math] matrix (it must be symmetric) can take on any value (think of it like an adjacency matrix). The minimization of [math]E[/math] gets you the optimal solution. Note that there are no constraints. This maps straightforwardly to the Ising spin-glass model Hamiltonian in a transverse field, which looks like: [math]H_{Ising} = -\sum\limits_i^N \alpha_i \sigma_i^z - \sum\limits_{ij}^N \beta_{ij} \sigma_i^z \sigma_j^z + \sum\limits_i \delta_i \sigma_i^x [/math] where [math]\sigma[/math] denotes the corresponding Pauli spin matrix, with the rest of the terms being coefficients (and [math]N[/math] is the number of particles/qubits). This is the Hamiltonian that is used as a model for the D-Wave processor where you have these "flux qubits" (they are SQUIDs--superconducting quantum interference devices--with Josephson junctions) connected by superconducting wires (see this paper and presentation (latter is easier to follow): http://arxiv.org/pdf/1004.1628v2... and http://dwave.files.wordpress.com...). So if you're solving problems on a D-Wave processor, it's analogous to solving the Ising problem, which is the same as solving the QUBO problem (with some transformations). Note that the D-Wave processor has limited connectivity (it takes [math](k-1)^2/2[/math] qubits in their hardware graph to represent a fully connected graph with [math]k[/math] vertices), see the linked paper above for more info on that. Updated 139w ago • View Upvotes • Asked to answer by Jan Christian Meyer