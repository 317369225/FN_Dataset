Can a quantum computer be modeled on a standard computer?
Of course! All you need to do is solve the Schroedinger equation. I haven't written anything for the gate model, but all it is is a quantum state [math]|\Psi\rangle[/math], which is a vector of coefficients that correspond to certain basis states (if you expanded it, [math]|\Psi\rangle = c_0 |\psi_0\rangle + c_1 |\psi_1\rangle + ... + c_{2^n} |\psi_{2^n}\rangle[/math] where [math]n[/math] is the number of qubits and [math]|\psi_k\rangle[/math] is a basis vector (or, in quantum mechanics, one of the eigenvectors of the Hamiltonian)), being evolved by unitary operators (which are just Hermitian matrices). For a 1-qubit case, there is a great visualization called the Bloch sphere: So the coefficients tell you how likely it is that you are in the corresponding eigenstate (in this case, it's either the zero or one state, or up and down). Then you apply the operator to this state. An operator is like a function or mapping from one vector space to another. The matrix must always be square so that you're guaranteed to map from a [math]2^n[/math] vector space to another vector space of the same size (think about what happens to the state vector if the matrix were not square.. it won't stay the same length, which doesn't make physical sense). So in quantum computing, all you're doing is applying these unitary operators (could be laser pulses, say) on your state. For the one qubit case, all that happens is that the state vector rotates on that Bloch sphere above. In mathematical terms, it's simple matrix-vector multiplication. If you want to model more of the physics, you'll have to start thinking about other stuff like information loss from noise or decoherence or something. I don't know exactly how to make those calculations, but you can probably find it in this book: Quantum Computation and Quantum Information: 10th Anniversary Edition: Michael A. Nielsen, Isaac L. Chuang: 9781107002173: Amazon.com: Books. Or if you want to think more about it, you can start from the Schroedinger equation and then think about how to model all these other effects separately with quantum mechanics, and then figure out how to put it all together. There is a lot of code out there, so surely someone has done it already. Another interesting thing is that there are people working on building more abstract languages for logic-gate quantum computing. Another thing you can do is model the adiabatic optimization paradigm for quantum computing. This is where you simply solve the time-dependent Schroedinger equation: [math] i\hbar\frac{\partial \Psi}{\partial t} = \hat{H} \Psi[/math] Your Hamiltonian starts in one form (typical case is a transverse magnetic field in the [math]\sigma_x[/math] spin state) and anneals to another (typical case is the [math]\sigma_z[/math] spin state). You also have coefficients for this and.. well, it gets complicated. If you're interested, see my other answers on adiabatic quantum computing here: Hadayat Seddiqi's answer to How does quantum computing work? and Hadayat Seddiqi's answer to How does adiabatic quantum computation work in layman's terms? Anyway, that involves just modeling the above equation. In fact, that's been part of my research recently and I actually have some code that models it completely (written in Python). If you're curious about how exactly the equation is solved, look at the solver.py file. Here's the link: https://github.com/hadsed/AdiaQC Some things to note though. Of course we have to make approximations to solve the time-dependent equation. This means that two parameters matter a lot: your total annealing time and your timestep. Another thing to consider is that [math]2^n[/math] is exponential. With [math]n = 16[/math], you're looking at a number around 65,000, and 16 qubits is nothing. Doing a bit of hand-wavey arithmetic, a simulation for [math]n = 42[/math] will take up all the memory of the Titan (the world's fastest supercomputer at this time, housed at Oak Ridge National Lab). And remember, you're also storing the Hamiltonian, which is [math]2^n \times 2^n[/math]. And you have to do an eigendecomposition at each timestep to see your energy spectrum (which is how you will analyze your annealing schedule). So you're looking at a lot of problems when simulating these things. Hope I covered enough, let me know if you have more questions and I will try to answer. 