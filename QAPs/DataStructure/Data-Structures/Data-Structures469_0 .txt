Can Codeforces 431C - k-tree be solved by recusion?Codeforces 431C - k-treeIts a Dynamic Programming Problem and Recursion with memoization is the easiest way to solve that problem. Things to Note : way to reach a weighted path with an edge of weight atleast d. You have a continuous set of edges upto K at every node. required weight N format of memo dp[current weight][First_Condition_Truth] First_Condition_Truth : zero for false first condition and vice versa. Function(Current_Weight_Of_Path , First_Condition_Truth ) Base Case : You have taken at least one edge of weight d or greater and have reached desired weight , set dp[Current_Weight_Of_Path][ First_Condition_Truth ] equal to 1 and return. Else :store sum of function after Taking every edge from 1 to k till the addition to weight is less than the required weight (N) , and if the edge taken is greater than equal to d set First_Condition_Truth to 1 and then recurse. Store and return this sum. ll solve(ll cur_w,ll state){ if(dp[cur_w][state]!=-1) return dp[cur_w][state]; else if(cur_w>n) dp[cur_w][state] = 0; else if(cur_w==n&&state) dp[cur_w][state] = 1; else { ll ret = 0; for(ll i=1;i<=k;i++) if(cur_w+i<=n)ret+=solve(cur_w+i,state || ((i>=d)?1:0)),ret%=MOD; dp[cur_w][state]=ret; } return dp[cur_w][state]; }  /**** The Start of Recursion and Final result : To be put in Main() **/ for(int i=1;i<=k;i++){ ret+=solve(i,(i>=d)?1:0); ret%=MOD; } 121 Views  View Upvotes  Answer requested by Hoppy Bouasavanh