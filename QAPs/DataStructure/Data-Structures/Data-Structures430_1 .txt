Why do we need an AVL tree in computer science?In a standard Binary Search Tree, the number of elements in the tree you have to examine in order to find, insert, or delete an elements is the number of nodes on the path from the root to the searched-for, inserted, or deleted node. This depends on the shape of the particular tree. For instance, suppose we build an n-element tree by repeated insertion and the elements are inserted in sorted order (perhaps the data was sorted by a previous application). Then the tree degenerates into a linked-list; all the nodes are on a single path. Now a search must examine all n nodes in the worst case and about n/2 nodes on average (assuming all nodes are equally likely to be searched for). This is very bad compared to the lg n value we get when the tree is perfectly balanced. The purpose of the AVL tree is to avoid the poorly shaped trees and ensure that the tree is always well balanced so that we are guaranteed of getting good search, insert, and delete times. Suppose we build a tree (binary or AVL) by repeatedly inserting n distinct items into an initially empty tree. A comparison of the average number of data items we need to examine in order to find a node that is in the tree for the two types of trees follows. (in the following lg n means log base 2 of n). Binary Search Trees best case tree: <= lg n average case (average over all trees assuming that every insertion order is equally likely): (approx) 1.39 lg n worst case tree: (n+1) / 2 AVL Trees best case tree: <= lg n (identical to best case of binary tree) average: ??? worst case tree: 1.44 lg n Notice that the worst case for an AVL tree is only very slightly worse than the average case for a binary search tree (the constant is only about 3.6% higher). Empirically, AVL trees are more efficient than binary search trees. 161 Views