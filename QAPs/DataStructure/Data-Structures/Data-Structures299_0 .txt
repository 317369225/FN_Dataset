When converting an expression from infix to prefix what do you do if the incoming operator has the same precedence as that on top of the stack?Say the expression is a*b*c. One line of thinking is to pop the present operator in the stack and then push the incoming operator into the stack in its place. The other line of thinking is to just push the incoming operator on the stack. Choosing the former gives: *a*bc and latter **abc.Assuming that you are developing a parser… I never encounter this issue because I always ensure that my tokenizer (lexer) is syntax-aware enough to return atomic tokens. For instance, I would never write a lexer that classified all punctuation or even all math operators as the same token type. As the parser calls the lexer, if an addsub_tokentype is encountered, for instance, when the next token is also a an addsub_tokentype, then it is obvious that the next token is a prefix operator. In this way, whenever a token it placed in the stack, a prefix operator is different from an infix operator. In other words, by the time the parser puts it somewhere there is no more ambiguity. And prefix operators are always a high priority with right-associativity so there never is a problem with precedence. Of course, in order to guarantee this behavior, your tokenizer/lexer has to be far more syntax-aware. But this also makes it far easier to handle operator precedence and associativity, and your parser code is much easier to read and maintain. Just my opinion. I hope this helps. 190 Views · View Upvotes · Answer requested by 1 person