How do I solve this problem on binary search?Practice Problem on Binary Search Is there any solution using binary search possible ? Please help me by explaining the idea behind solution instead of the code only.Yes, binary search approach can be applied here. Consider this test case: 9 3 5 2 4 7 So, the resulting array after deletion will be: 1 3 5 6 8 9 Since, 8 is on index 5 (1-indexing), hence answer is 8 The key thing for applying binary search is finding a monotonous function. So, what is that function in this problem. Let’s compare the initial and final indices of the numbers in array. 1:(initial=1,final=1) 3:(initial=3,final=2) 5:(5,3) , 6:(6,4) , 8:(8,5) , 9:(9,6) So, final-initial for each value is: 0 1 2 2 3 3 Voila! we have found our monotonous function, and that is f(x)=index of x in final array-index of x in initial array (domain of f is all the values present in final array) So, how to code this in form of binary search to find the correct answer? take lower bound for binary search to be 1 , and upper bound any value just greater than N(i.e 1e9), Now for each mid value iterate over the array of deleted values and count the values which are less than or equal to the mid value.(say, you store count in variable cnt) Why we are doing this? because we need to find the new index of this mid value. How to find the new index? It’s pretty easy. The new index is mid - cnt . The reason for this is that initially index of value mid was mid, and now after deleting all elements less than or equal to mid value, the index of mid value has decrease by that count. long long int low=1,high=1e9+10,mid,cnt; while(low<high) { mid=(low+high)/2; cnt=0; for(int i=0;i<k;i++) { if(a[i]<=mid)cnt++; } if(mid-cnt>=p)high=mid; else low=mid+1; } if(r<=n)cout<<r<<endl; else cout<<-1<<endl; //idx p is out of final array of size N-k The time complexity will be O(k*lgN) Hope it helps! 495 Views · View Upvotes