Why is the time complexity of Insertion and Deletion in Singly Linked List Big O(1)?Insertion at the head requires you to add the element and update the head pointer. newnode->next = head; head = newnode; Insertion at the tail requires you to keep a pointer to the tail element, add the element at the tail and update the tail pointer. tail->next = newnode; tail = newnode; Deleting the head element requires updating the head and deleting the previously head element. temp = head; head = head->next; delete temp; /* or free(temp); */ All the above are trivial operations and don’t depend upon the number of elements in linked list. Hence, they are O(1) Deleting the tail element would, however, be a O(n) operation because even though you might have a tail pointer, you would still need the penultimate node that would be setup as the new tail node ( by updating the tail pointer and setting the node’s next member to NULL). For this, you need to traverse through the whole linked list. penultimate_el = find_penultimate_el(head); /* this is O(n) operation */ delete tail; /* or free(tail) */ tail = penultimate_el; tail->next = NULL; 241 Views · View Upvotes