Is there an algorithm better than o(n) for the following problem, given a hashset contains integers and a number, find closest num to the given num?n is the number of elements in the hashsetNot really. But sort of. In order to beat [what you might mean by] O(n), we'd have to not look at certain elements. We'd need some ordering property to categorically rule out large sections of the data set, and I don't see any way of doing that on a hash set. However, in truth, the problem just isn't well defined. That possibly suggests a misunderstanding of big O on your part. [EDIT: The problem has now been clarified to state that n is the number of elements in the hash set.] There are two reasonable solutions for this problem: Pull all values from hash set and look for the closest one to X. Round X to an integer (if it's not already) and then check X-1, X+1, X-2, X+2, … The first solution is O(h), where h is the number of elements in your hash set. The second solution is O(abs(X-c)), where c is the closest value to X. When you said O(n), what were you defining n to be? I'm being a little nit picky here, but I've found a ton of people don't quite understand this. N must have a meaning. Many people would describe the second solution as O(n), but it is not the same runtime as the first (which nearly everyone would define as O(n)). They are not directly comparable. The first solution might be preferable on small data sets. But if our data set gets very large (for example, it contains most of the allowable range of ints), we might prefer the second one. 1.9k Views · View Upvotes