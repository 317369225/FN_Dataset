How do STL containers allocate memory? Do they use the new operator?
By "STL" I assume you mean the part of the C++ standard library that is based on the STL proper. This differs from the STL proper in a few ways, but is more widely used than the STL itself and usually just referred to as "STL". The C++ standard library containers are as follows: std::array, std::deque, std::forward_list, std::list, std::vector, std::map, std::multimap, std::set, std::multiset, std::unordered_map, std::unordered_multimap, std::unordered_set, std::unordered_multiset. Among these, std::array is unique because its size is fixed at compile-time. An std::array never needs to perform dynamic memory management for this reason. An std::array<T, N> simply contains an array of N T's somewhere inside it, so whenever you create one, whether on the stack or on the heap, enough memory is automatically set aside to store all the T's. All other containers do need to perform dynamic memory management. A key feature of the STL is its generality. Because dynamic memory management is a detail associated with the data structures used to implement the STL containers, and not a defining characteristic, the STL actually allows you to customize how memory is managed. This is done using the final template argument when instantiating the STL class templates, which always defaults to std::allocator<T>, the "default allocator". This you can see from the standard's synopses. For example: template <class T, class Allocator = allocator<T> > class deque Thus, you specify two types whenever you instantiate the std::deque template: the type of the contained element itself, and the type of the allocator class that will be used to manage memory. You always have to specify the former explicitly, but the latter can be (and is often) omitted. In this case std::allocator<T> is used. But if you do specify it, it lets you customize how memory is managed. When you construct a container, you are given the opportunity to provide the allocator for that container as well. For example, consider the constructor: explicit deque(const Allocator& = Allocator()); When you omit the default argument, it creates an empty deque and value-initializes the container's allocator (whose type is specified as part of the deque's type, as above). But if the allocator type has options that are set by arguments to the allocator's constructor, here you have the opportunity to customize the allocator for this particular instance of the container. Thus: std::deque<int> D; creates a deque that stores ints, which uses the default allocator to manage memory. std::deque<int, MyAlloc> D; creates a deque that stores ints, which uses an object of type MyAlloc to manage memory. Upon construction, D creates a MyAlloc object using the default constructor, which is then used whenever needed. std::deque<int, MyAlloc> D {MyAlloc{my_arg}}; creates a deque that stores ints, which uses an object of type MyAlloc to manage memory. The specific allocator object used to manage memory in D is created by passing my_arg to the MyAlloc constructor. All containers default to using the default allocator, std::allocator. The default allocator uses ::operator new to allocate memory and perform construction, and ::operator delete to perform destruction and deallocate memory. However, the standard says that it is "unspecified" when or how often new and delete are actually called. The above discussion also applies to std::basic_string and its specializations std::string and so on, despite the fact that it is not considered a standard library container. The container adaptors std::stack and std::queue use the allocator of their underlying container (which is std::deque<T, std::allocator<T> > by default). The same goes for std::priority_queue, which uses std::vector<T, std::allocator<T> > by default. So in order to use MyAlloc to manage memory in a stack, you would do: std::stack<int, std::deque<int, MyAlloc> > S; 