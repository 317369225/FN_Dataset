What is the most simple & efficient C++ code for Dijkstra's shortest path algorithm?
Here's my version of Dijkstra. Efficient, Optimized and Blazingly Fast. It's implemented using heaps and adjacency lists (all using built in C++ STL containers which are optimized themselves) which makes it run in [math]O(E*Log(V))[/math] where [math]E[/math] is the number of Edges and [math]V[/math] the number of Vertices in the graph. This is also a great implementation for programming contests (have a look at the same clean, uncommented code you can use for which I have a pasted a link).  In my opinion, this should be the most optimal implementation of Dijkstra's Shortest Path Algorithm I have tried and  documented the code so you'll understand. The code may be slightly obfuscated especially in places when I'm assigning data to variables and then using it in the same step. As i mentioned, I have added a link later for a clean, usable code  as well. However, the original question asked for 'shortest code' as well. So here goes. //Implementation for Dijkstra's SSSP(Single source shortest path) algorithm//This is an optimized algorithm running in O(E*log(V))#include <iostream>#include <queue>#include <vector>#include <climits>using namespace std;#define INF INT_MAX //Infinityconst int sz=10001; //Maximum possible number of vertices. Preallocating space for DataStructures accordinglyvector<pair<int,int> > a[sz]; //Adjacency listint dis[sz]; //Stores shortest distancebool vis[sz]={0}; //Determines whether the node has been visited or notvoid Dijkstra(int source, int n) //Algorithm for SSSP {    for(int i=0;i<sz;i++) //Set initial distances to Infinity        dis[i]=INF;    //Custom Comparator for Determining priority for priority queue (shortest edge comes first)    class prioritize{public: bool operator ()(pair<int, int>&p1 ,pair<int, int>&p2){return p1.second>p2.second;}};    priority_queue<pair<int,int> ,vector<pair<int,int> >, prioritize> pq; //Priority queue to store vertex,weight pairs    pq.push(make_pair(source,dis[source]=0)); //Pushing the source with distance from itself as 0    while(!pq.empty())    {        pair<int, int> curr=pq.top(); //Current vertex. The shortest distance for this has been found        pq.pop();        int cv=curr.first,cw=curr.second; //'cw' the final shortest distance for this vertex        if(vis[cv]) //If the vertex is already visited, no point in exploring adjacent vertices            continue;        vis[cv]=true;         for(int i=0;i<a[cv].size();i++) //Iterating through all adjacent vertices            if(!vis[a[cv][i].first] && a[cv][i].second+cw<dis[a[cv][i].first]) //If this node is not visited and the current parent node distance+distance from there to this node is shorted than the initial distace set to this node, update it                pq.push(make_pair(a[cv][i].first,(dis[a[cv][i].first]=a[cv][i].second+cw))); //Set the new distance and add to priority queue    }}int main() //Driver Function for Dijkstra SSSP{    int n,m,x,y,w;//Number of vertices and edges    //cout<<"Enter number of vertices and edges in the graph\n";    cin>>n>>m;    for(int i=0;i<m;i++) //Building Graph    {        cin>>x>>y>>w; //Vertex1, Vertex2, weight of edge        a[x].push_back(make_pair(y,w));        a[y].push_back(make_pair(x,w));    }    //cout<<"Enter source for Dijkstra's SSSP algorithm\n";    int source;    cin>>source;    Dijkstra(source,n);//SSSP from source (Also passing number of vertices as parameter)    cout<<"Source is: "<<source<<". The shortest distance to every other vertex from here is: \n";    for(int i=1;i<=n;i++)//Printing final shortest distances from source    {        cout<<"Vertex: "<<i<<" , Distance: ";        dis[i]!=INF? cout<<dis[i]<<"\n" : cout<<"-1\n";    }    return 0;} Code in action: http://ideone.com/qkmt31 Further changes that you can make is  incorporate the use of macros and  'typedefs' in C++. This will  significantly reduce your code. For a clean, complete and usable version of the same optimized implementation above along with the macros and stuff: DIJKSTRA_USE.cpp Here are 2 problems you can try. I have also pasted links to the solutions to both of them from my GitHub repository: Problem: SPOJ Problem -EZDIJKST (Easy on the time limit. Good for testing the correctness of your implementation. Even an [math]O(n^2)[/math] solution passes.) Solution: EZDIJKST.cpp     2. Problem: SPOJ Problem -SHPATH (Strict time limit. Only optimized solutions will pass. My code runs in ~0.47 secs. You can try TSHPATH   for  checking your correctness if case you can't get this to pass, which is  the exact same problem with a lenient time limit. It's tolerable enough  to let non optimized solutions pass. ) Solution: SHPATH.cpp Note:If you're attempting these problems on your own, I suggest you understand what is happening from the code above and then use the code from one of the usable links I have posted. You'll have to make tiny changes such as making the graph directed (mentioned in code) and removing the print statements. You can also return from the function once you have found the destination vertex. All of this combined should get you the AC (Accepted) verdict. You can refer to the solution links I have pasted. Updated 8w ago • View Upvotes