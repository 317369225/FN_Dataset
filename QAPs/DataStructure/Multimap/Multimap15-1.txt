Does the following implementation for finding the longest common substring within two strings work?
I think the logic of your algorithm works. Anyway, here is my interpretation of what you described, below in C++ and this works in some simple tests. You just need to be a bit more explicit with the types of container you are using. The type I infer you require is a std::multimap so you can quickly find the integer position of the matched character in the string. Mutlimap is an associative container that supports multiple elements with the same key, since you often get repeated characters at different positions in a string.  std::string max_common_substring( const std::string& a, const std::string& b ){	std::string max("");	//create lookup map	std::multimap< const char, int > map;	for( unsigned int i = 0; i < a.size(); ++i )		map.insert( std::make_pair(a[i], i));	//find substring of b in a	for( unsigned int j = 0; j < b.size(); ++j )	{		std::multimap< const char, int >::const_iterator start, end;		auto pair = std::make_pair( start, end );		pair = map.equal_range( b[j] );		for( std::multimap< const char, int >::const_iterator it = pair.first; it != pair.second; ++it )		{     		//store potential max			std::string temp;			temp.push_back(it->first);			//test the remaining characters			int aindex = it->second;			int bindex = j;			for( unsigned int k=1; k+bindex<b.size() && k+aindex <a.size(); ++k )			{				if( b[bindex+k] == a[aindex+k] )					temp.push_back(a[aindex+k]);				else					break;			}			//store if max found			if( max.size() < temp.size() )				max = temp;		}	}	return max;} 