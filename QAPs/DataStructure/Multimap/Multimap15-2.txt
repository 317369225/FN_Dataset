Does the following implementation for finding the longest common substring within two strings work?
I do not see why you would use a hashmap to do this.  Your algorithm may work but you have not stated what an "element" is - is element an individual character or a substring? Secondly, I assume you want to exclude whitespace from the match.  My initial thought would be you could do this with a simple double for loop - like this: package longestcommonsubstring; /**  *  * @author mdaconta  */ public class LongestCommonSubstring {     /**      * @param args the command line arguments      */     public static void main(String[] args)     {         try         {             if (args.length < 2)             {                 System.out.println("USAGE: java longestcommonsubsting.LongestCommonSubstring <string1> <string2>");                 System.exit(1);             }                     String string1 = args[0];             String string2 = args[1];                         System.out.println("string1 is : " + string1);             System.out.println("string2 is : " + string2);                         StringBuilder currentSubstring = null;             StringBuilder largestSubstring = null;             for (int i=0; i < string1.length(); i++)             {                 char c = string1.charAt(i);                 if (Character.isWhitespace(c))                     continue;                                 for (int j = 0; j < string2.length(); j++)                 {                     // is c in string2?                     char c2 = string2.charAt(j);                                         if (c == c2)                     {                         currentSubstring = new StringBuilder();                         // match                                                int indexString1 = i;                         int indexString2 = j;                                                 char origC = c;                                                 // now see how far they match                         while (c == c2 && !Character.isWhitespace(c) && indexString1 < string1.length()-1 && indexString2 < string2.length()-1)                         {                             currentSubstring.append(c);                             indexString1++; indexString2++;                             c = string1.charAt(indexString1);                             c2 = string2.charAt(indexString2);                         }                         System.out.println("currentSubstring is: " + currentSubstring);                         if (largestSubstring != null)                         {                             if (currentSubstring.length() > largestSubstring.length())                             {                                 largestSubstring = currentSubstring;                                                 System.out.println("largestSubstring is: " + largestSubstring);                             }                         }                         else                                largestSubstring = currentSubstring;                                                                                           // revert                         c = origC;                         j = indexString2;                     }                 }                            }                                    System.out.println("Largest Substring is: " + largestSubstring);                 } catch(Throwable t)         {             t.printStackTrace();         }                    }    } This has not been thoroughly tested and is a brute-force approach; however, it seems simpler than what you were trying.  I always first try to do the simplest thing possible, then determine if I need to optimize it.   Best wishes! 