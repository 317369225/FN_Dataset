What approaches should one follow when solving a problem be it a puzzle, riddle, programming or a real life problem?Also what are the different ways (strategies or methodologies) to attack problems? Please provide an algorithmic approach. If multiple methods or strategies  exists depending on different scenarios then mention them as well. Also it'll be helpful if one can give examples on how to apply it to a problem.
You're asking for an algorithm to solve any problem. That's... that is perhaps the most ambitious question ever asked on Quora. I cannot "provide an algorithmic approach", I'm afraid. I can mention some high-level ideas that are often helpful, but the most fundamental one is also the simplest: If you wish to learn how to solve problems, solve problems. Special cases: if you wish to learn how to tackle programming puzzles, solve lots of programming puzzles. If you wish to learn how to solve math riddles, solve lots of math riddles. If you wish to learn... you get the idea. There are no recipes. You can gain something by reading books (or Quora answers) but that's peanuts relative to what you gain by actual practice. Still, here are a few (well known) ideas to try that are mostly applicable to programming and math puzzles. Many of those are beautifully discussed in a book I highly recommend you read: "How to Solve it" by George Polya. Understand the problem. I can echo a sentiment expressed by many others: it's astonishing how often students ask for help in solving a problem about a concept they don't know the meaning of. - "I have this problem and I need just a hint..." - "Do you know what "absolute value" means?" - "Well, not really..." Do you understand all the terms in the problem? Are you sure? Do they make sense together? Have you seen a similar problem before? This is one of the 1,000,000 things that makes the problem of how to solve problems not quite deterministic. Your personal experience has a huge impact on the approach you are likely to choose, and this is also why it's so important to have an arsenal of problems you've already solved. See if you can think of something similar or analogous you've seen in the past. Try to recast the problem in different terms: is there a graph hiding somewhere? An urn model? Many programming challenges are ultimately about graph coloring, or graph searching, or maximal independent sets. As always, I cannot give you an algorithm for "how to find out if a puzzle is a maximum flow problem". You gain that with experience. Example: Find all solutions to a 3 +b 3 =c 3 +d 3   in integers ranging from 1 to 1000. This is a coding challenge and it's easy to solve naively but the running time would be impractical. Can you do better? Can you recast the problem as one of finding collisions, of throwing balls into bins and observing clashes? What's a good programming paradigm for detecting clashes? Do special cases and smaller cases. Does the problem have some parameter n? Can you solve it for n=1? n=2? Does the problem mention 2012 trees in the forest? If so, can you solve it for 6 trees instead? Like all rules, this one is sometimes meant to be broken or twisted. Questions of probability are sometimes easier to solve if you make one or more parameters larger, taking things to extreme and making them super obvious. Divide and conquer. You're given A. You need to find C. Can you find some good B in the middle that you can see how to get to from A, or how to get from to C? Try various ones. One thing that makes quick problem solvers so quick is that they can mentally scan many candidates for intermediate steps. Example: Given 51 numbers between 1 and 100, show that two of them must be relatively prime. Many people find that tricky but there's an intermediate "B" step here that is obviously true when you have 51 numbers and it obviously implies relative primeness. (If you don't know what "relatively prime" means, go back to the "Understand the Problem" step.) Inside every problem you can't solve hides a smaller problem you can solve. Find it. "Smaller" can be in the sense of the smaller-parameter we discussed, but it can be something else altogether. Can you solve it under the assumption that the numbers are integers? Can you solve it if the probabilities are all uniform? Can you solve it if you drop the 3rd requirement? Can you solve it if the array is initially sorted? I sometimes like to think about this idea as "Inside every problem you can't solve hides a smaller one you still can't solve. Find it." If you keep simplifying a problem and it's still hard, you're making progress: you're on your way to finding its core. At some point you may actually be able to do something about the simpler version, and then it's just a matter of tracing back and improving your solution to handle the harder cases. Generalize. Sometimes problems paradoxically get easier in a larger context. The problem at hand has lots of details and data; is it all really needed? Perhaps I can solve it for any set of ordered objects, regardless of the fact that they happen to be rational numbers with a denominator that's a power of 2? The generalized problem has fewer distractions and fewer potential approaches. Example: Every continuous real-valued function on [0,1] attains a maximum. The interval [0,1] has tons of structure: it is ordered, it has a metric, you can add things, you can multiply things, etc. This richness creates confusion: you may try to solve the problem by looking at the edges, left and right, taking averages, ... Here's an easier problem: Every continuous real-valued function on a compact space attains a maximum. It's way more general and way easier to solve, because in a general compact space you can't do algebra and there's no order and no metric. There's just compactness, a single definition to work with, so you just follow the definition and it's solved. --- There's lots and lots of other heuristics and ideas. Some of the more mathematical ones are in Polya's book. But as I said, reading books and Quora advice will only take you so far. Solve problems. Then solve some more. That's all there is to it. Updated 3 Nov 2012 • View Upvotes