Why is the C++14 "Concepts" feature important?
For historical reasons, C++ has two different kinds of ad-hoc polymorphism that look very different. On the one hand, there are abstract classes with virtual functions, where any concrete classes inheriting from the abstract class can be treated as an instance of the abstract class. On the other hand, there are templates, where a template definition can assume that its type parameters implement various operations. Abstract base class style polymorphism is only resolved at runtime, which makes it slightly more costly, however it is made explicit at compile time and the compiler checks that what you're doing is okay. Template type parameter polymorphism is resolved at compile time, so its very cheap. However, while the compiler won't let you build an executable that tries to call a function that doesn't exist, it checks for this in a pretty dumb way, by simply substituting in the type parameters and then trying to resolve the operators and functions applied to them. Famously, this results in terrible error messages. Concepts have been around as an idea for a long time as way to communicate to developers what kinds of things they can use as type paramters to templates. The designers of the STL semi-formalized the notion of concepts in order to describe things like iterators. But it was not included in the language. The idea in C++14 is to provide a way to say "hey compiler, please make sure these operations exist when my template is intantiated, and produce a nice error message if they don't". Honestly, this whole thing is a bit of a wart on C++ and integrating concepts into the language just puts makeup on it. Haskell type classes and Go's interfaces both manage to integrate runtime and compile time resolution of polymorphic functions into one syntactic construct, instead of having two radically different ones as C++ does. 