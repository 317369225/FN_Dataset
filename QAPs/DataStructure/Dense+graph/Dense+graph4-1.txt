What is the significance of using a priority queue in Dijkstra's algorithm? What difference does it make if we use a normal queue?
I am assuming you have studied Dijkstra's algorithm, and how min-priority queues are implemented, e.g. using a binary min-heap. For descriptions of binary heaps, you can refer a good textbook or search the internet. This PDF (Page on princeton.edu) has good explanations (with graphical illustrations) of how binary heaps (and other more sophisticated variants) work. I found it by Googling. You may find even better references on the internet. In Dijkstra's algorithm, the important step is selecting an unexplored vertex v such that there is an edge (u, v) in the graph, where u is an already explored vertex, and d'(v) = dist(u) + cost(u, v) is minimum. Here, dist(u) is the length of the already found shortest path from the source vertex s to vertex u, and cost(u, v) is the weight of the edge from u to v. If we store the unexplored vertices in a simple array/linked list, we would have to iterate over the whole list each time to find the desired vertex v, with minimum d'(v) (d'(v) = dist(u) + cost(u, v)). If we store the vertices in a priority queue with d'(v) as the key for each vertex, we can get the vertex with minimum d'(v) by using the Extract-Min operation. If we use a binary (min-)heap, the asymptotic complexity of Extract-Min operation will be O(log n). After selecting vertex v, and updating dist(v), we may find that we have a shorter path to another unexplored vertex w through v, i.e. a path with cost d'(w) = dist(v) + cost(v, w), which is less than the cost of the existing path to w. This vertex will be in the priority queue, and its key value will need to be changed to the new value using the Decrease-Key operation, which will decrease the key of a certain element, and bubble it up if necessary to ensure the min-heap property. A binary (min-)heap will support doing Decrease-Key operation with O(log n) complexity. Again, if we had used a simple list, this step would have required us to iterate over the whole list to update the key of a vertex. Also, there are other data structures that can be used to implement a priority queue more efficiently, such as binomial heaps and Fibonacci heaps. But these come at the expense of added complexity. 