Does ACM-ICPC or IOI success correlate with industry success?You might suspect that programming competition winners would be particularly brilliant or at least particularly good programmers, but you might also suspect they would be toy-problem-oriented and do better in academia. Adam D'Angelo and (potentially) some of Team Ksplice are positive examples, but that's not a ton.
I can’t say this reflects the opinions of any arbitrary participant in the contests, though here is what my own personal experience was.   What the ACM contest is like:   The format of the contests consists of a selection of problems that carry the same score for submissions, though the timing for contest submissions plays a huge part in the score. For all practical purposes the only result you get back from a submission is if it worked or not. The level of direct competitive stress you face is very high.   The problems are typically a mix of scheduling, graph theory, simulation, co-ordinate geometry, combinatorics and number theory.   What you need to do well in the contests:   1.    The ability to write code that works correctly the first time around.  If you get an answer wrong, the clock is still ticking, your morale tanks and given the level of competition, odds are you've lost. No silly mistakes allowed. 2.    Work well under stress. 3.    Enjoy more than one area of computer science. You don’t know if the easiest problem on the list is going to be in an area that you don’t know of. 4.    Multitask, while you are cranking on the current problem, a breakthrough on another problem based on a background thinking can make a huge difference. 5.    Above all: Prioritize well.   So much of the competition is a speed race to look at which problems to figure out what you can produce a correct answer for as soon as possible.   While most of the contest has problems that genuinely challenge you and are not mundane, the format typically requires you to read from standard input and write to standard output; as an extension of the rule mentioned above with respect to no mistakes, you need to be lightning fast and precise with respect to the boilerplate parts of your program which involve reading input, storing it in a canonical representation, etc. You can’t be sitting around and debugging scanf bugs.   Things that I got out of preparation for the contests   1.    Get things right the first time around while maintaining speed   This is one of the best things that I learnt from the contests and is highly applicable to working in the industry. 2.    Be a generalist and appreciate different areas of practical computer science. I consider myself someone who truly enjoys different areas of computer science. I still really enjoy reading about implementations which had some novel ideas even if I’m far removed from the domain in question. At one job this has come in handy for a product where one had to understand both network protocols and file systems in detail. At another past job at a mobile infrastructure startup, there was a small part of the product which handled image processing and not many people understood it or wanted to understand it. Sometimes you can see a problem that looks completely different to what you encounter in another domain, but on closer inspection be able to reduce them to the well understood problem in a different domain. 3.    It is better to try really hard and fail than not to try at all. Despite making it to the world final, there was a certain part of it all which did make you feel bitch slapped since we didn’t win anything at the finals. There are those who say there are no losers if you make it to the finals given that very few people make it there, though if you do have that competitive drive that you get into the contests in the first place, there is no way you can internalize anything short of winning the finals as defeat. Relatively speaking, anyone in the later stages of the contest is likely to be near the top of their class with respect to coding abilities, and facing such direct talented competition and hard problems, you must learn to accept some failures.   What it didn't teach me:   1.    Changing the problem statement Creative ways in which you can revise the problem statement. That is a very valid optimization you can do to be far more effective in developing large scale programs. 2.    How to understand vast codebases Cranking out tight loops quickly is one thing, and while it helps, I've come to believe that understanding how code works thoroughly and how pieces fit together is far more important for large programs. 3.    How to build relationships A lot of success in professional life hinges on developing the right relationships with people and being entrepreneurial. With regards to the people who found success in startups primarily acquired that success through being entrepreneurial first and picking the right problem to solve much more so than being good engineers. (That isn’t to speak ill of their engineering skills in any way, merely that they could have had the same engineering skills and not started their startups were they not entrepreneurial). 4.    Communication skills and co-ordination Communication skills are also vital to professional success, particularly if you want to grow into a senior engineer role. There is some communication in the contests where you might want to vet your idea with other team members, but for the most part it isn’t code that you can split up and get different people to implement in parallel. 5.    Getting your hands dirty. Rolling up your sleeves and getting your hands dirty is part and parcel of developing a shipping product vs. an isolated toy.  What I’ve learnt about myself is that while I have no qualms about getting my hand dirty for my work, I for example have no interest to do this in my personal time to proactively seek it out. I still write programs not related to my work in my personal time, but in many ways they are in the spirit of the contest they are typically dense with tight loops and written for the primarily selfish reason of getting a kick of doing something fun vs. actually building a real product. 6.    Developing the right knack about how to write the least amount of code. Being able to crank code out is something you should be prepared to do if needed, but it is counterbalanced by also writing the most leveraged code and developing the right judgment about when you shouldn’t be writing code.   Why it never comes up in real life recruiting:   I’ve thought about this at times, and the best answer I can think of is as follows:   Recognition: Nobody really knows enough about the contests to have a full appreciation for them. Plus, some of the people who participate in the contests are likely to go into academia, and while you can form some sort of professional network with people in your own domains or geographical area, this further partitions the people who understand what the contests are about.   Reach: Say you are taking a hard OS class with 50 other students. Everyone has to endure this, so people gain more widespread recognition for “X engineer in my class is really smart” to a wider set of people. So this can become a far more normalized social circle of people to recruit from.   Hiring processes: I've only interviewed and recruited one other person who made it to the ICPC finals back at Netapp. He was sharp and made it through the interview process with flying colors, though in case hypothetically he hadn’t, how would I have lobbied that we recruit him in terms of trying to override the transparent and meritocratic recruiting process that was in place? Participation:  I also know of other really smart people that did really well in CS classes and professionally, but never got into the contests. Some of these folks were really good at theory but not good at quick on the fly implementation; some of these folks never saw value in them for participating in the contests. Some people didn’t care because programming to them was means to an end and not an end in itself, some people thought it was demoralizing. Evaluation: Finally, it becomes hard to gauge someone’s individual contribution to the team in the contest. For example, while I made it to the regional based on the qualifying arounds on campus, at the regional level, our team captain practically carried our team by scoring the first submission really quickly. I may or may not have scored on the problem, or I might have scored it in such a way that we didn’t win the regional. Then there were the finals where we ranked 28th, which is euphemism to say “one of the 22 teams that didn’t get in a single correct entry”. Did we do something useful or not ? On one hand, the problems were really hard, on the other hand we didn't score a submission. How do I justify that we did or did not do something good there ?   Do the participants like programming?   Finally, I thought to myself that the people who take part in the contests truly like programming because that is the personal appeal, at least to me that was a huge part of the motivation. However, when I take a look at people who were really into programming contests ( including various programming contests in high school ), I’ve found myself to be one of the few people working in the industry as an engineer. Most other people are a 50% split between pursuing MBAs or PhDs.   In summary: Programming contests are a competitive sprint about solving a fixed set of hard problems, though professional success is usually a marathon about what you should solve and the tenacity to follow through on actually solving the problems.   All things being equal someone really physically fit as a sprinter is likely to do far better in a marathon over an average person. However, at the most competitive levels, the best sprinters aren’t automatically the best marathon runners or vice versa. 