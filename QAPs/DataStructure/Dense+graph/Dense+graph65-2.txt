How does a computer program convert different types of data like images or text files into binary data?
I'm going to give you a slightly different answer by focusing first on how computer data is created and stored. Before I get back to it, I'm going to go what will seem to be "off the rails" but then I'll show you how we've been on the rails the whole time... So here goes! This is a light switch: (Crappy Photoshop Attempt Incoming!) In this case, it is in the "Down" position. Thus, the light it controls is "Off". How many states can that light have? Answer: 2 - Off (down switch) and On (up switch) With no light switch, there is only one state possible - that being always on or always off (probably always off) What if we have two switches, two lamps (one on each switch) and the lamps have colored light bulbs in them, lets say the colors are red and green. How many colors can we light up our hypothetical room with? Answer: 4. + = black room +Â  = green room + = red room + = yellow room (green and red light when combined make yellow) By adding only one more switch, we doubled the number of possible outcomes. If we add one more switch, we double it again - because we can have the lights in all 4 previous states but with the new switch in one position, then all 4 previous states again but with the switch in the opposite position and 4 + 4 = 8. Every time we put just one more switch in the series, the possible outcomes double. Now, imagine that instead of "on" and "off" we use a number to represent the state of "on" and "off". And we use "1" for "on" and "0" for "off". Thus, our previous examples mean: (Each number just representing on or off, remember) 0 + 0 = black 0 + 1 = green 1 + 0 = red 1 + 1 = yellow Now, if we end up with a bunch of switches - let's say .... 8 - and each has a different color at a different brightness assigned, how many light possibilities would exist? Remember, each additional switch doubles the number of combinations, so: 1 . . 2 . . 3 . . 4 . . 5 . . 6 . . 7 . . 8 2 . . 4 . . 8 . . 16 . 32 . 64 . 128 . 256 We could have 256 different possible outcomes! With only 8 switches! Well, as it turns out, computers store numbers exactly this way. Each "on" or "off" is represented as a 0 or 1: And here are the first 8 values in order: 0000 0000 0000 0001 0000 0010 0000 0011 0000 0100 0000 0101 0000 0110 0000 0111 (We often write these in 4-switch pairings to make them easier to read) ... etc ... Until 1111 1110 1111 1111 ... Now, those are "on/off" states. They're not numbers, but they have an order to them as represented above - each time you increase, you add a 1 (or "on") to the right edge and if it's already a 1, you find the next 0, make it a 1 and put all 1s you passed over back to 0. (or just stare at the pattern a bit and you should see how it progresses) This order has been agreed upon and in order to stop saying silly stuff like "a four-switch value" programmers decided each switch shall be called a "bit". (Derived from Old English where bit means a single bite - which can sometimes be a bit confusing with a word coming up in short order, but try to think of "bit" as "0 or 1") Programmers are by definition lazy, so they don't like even saying "a 4 bit number" and thus decided that 4 bits are a "nybble" (or "nyble" or "nibble") and 8 bits are a "byte" (you've probably heard of this one!) or sometimes an "octet". There are bigger ones too, but if I introduce them, things will get out of hand really fast... Remember: These are not numbers!!! Instead they're switches that represent some store of data in some way. If we decide that they're storing whole numbers, then we could say: 0000 0000 = 0 0000 0001 = 1 0000 0010 = 2 0000 0011 = 3 Because remember, the have a specific order. But they could also be storing colors directly, using some agreed convention, like maybe: 0000 0000 = black 0000 0001 = red 0000 0010 = green 0000 0011 = yellow You might be thinking "Ah there's where the colors are" - however, it is not so... Very commonly, the values that are stored .. are stored as whole numbers. In a computer monitor, each dot of light is lit up according to (drum roll please!) 256 brightness levels for each of red, green and blue! (Because with light, full red, full green plus full blue makes white!) So, since each dot (called a "pixel" - because programmers are lazy and don't like saying "picture element") is lit up with 256 shades of red, plus 256 shades of blue, plus 256 shades of green, then the most basic way to store this would be: dot 1: red: 128, green: 200, blue 100 dot 2: red: 100, green 20, blue 0 dot 3: red: 80, green 100, blue 255 Now, if you look at this, you might say "Hey, if it's just a bunch of dots in a row, maybe I can skip numbering / naming them!. Then, your picture data becomes: red: 128, green: 200, blue 100 red: 100, green 20, blue 0 red: 80, green 100, blue 255 Now, you look again and say "Hey! If it always goes red, green, blue, red, green, blue, etc, then maybe I can just put the numbers in and know when I read them that I'm reading red, green, blue, red, green, blue, etc!" So then you do this: 128, 200, 100, 100, 20, 0, 80, 100, 255 Then you realize "Hey I'm storing only numbers so I can send just the binary version of each of the numbers to my file!" And you write to the hard disk: 1000 0000 1100 1000 0110 0100 0110 0100 0001 0100 0000 0000 0101 0000 0110 0100 1111 1111 Tada! You've stored a file (more or less) in exactly the way a BMP file is stored. Now, you realize when you read it, that you don't know what width / height the original image was, so you also decide "Before all the pixel data starts, I'm going to store some more information in the front of the file" and that information can contain the image's width and height. It could include anything. Like longitude, latitude of the original camera location when the shot was taken. Or the date and time it was taken. Or a million other pieces of information, which happens in some file formats today. Since a bunch of programmers sat down and agreed as to how that would happen, they created what's called the Exif Standard or "Exchangeable Image Format" But at its core, it's just storing a bunch of "values" that mean "light up the dots according to this brightness ..." So, what about text files? Well, they're stored the same way more or less. Every character you type on a keyboard has a binary sequence associated with it. "A" (capitalized - because it would suck if your saved essays suddenly became all lower case!) is binary 0100 0001 and "B" is 0100 0010 etc. as long as you're saving it in a standard format called "ASCII". Lowercase "a" is 0110 0001 and lowercase "b" is 110 0010 ... etc. This is often the case of why beginner programmers look up ASCII charts and see that "A" is decimal 65 and "a" is decimal 97 and say "that doesn't make any sense - why would they do that?" Let me place their binary forms above and below each other though: 0100 0001 = A 0110 0001 = a ... 0101 1010 = Z 0111 1010 = z Now let me change where the pairing separator is written: 010 00001 = A 011 00001 = a ... 010 11010 = Z 011 11010 = z The first 3 bits mean "010 = Uppercase letter" and "011 = lower case letter" and the last 5 are the letter in question. After all, what is the decimal value of binary 0001 1010? Why it's 26! The same as the number of letters in the alphabet!! (You can use the calculator in "Programmer" mode to convert binary to decimal without having to learn the process manually if you ever want to double check any of these) Thus, to store a text file with only the word "Cat" in it, the most basic way would be to store just this as a data file: 0100 0011 0110 0001 0111 0100 Finally, because of how hard drives work, programmers commonly store a "I'm done" binary to the file that doesn't represent a keyboard character. ASCII actually doesn't have "End of File" in its chart, so most programmers settled on: 0001 1010 And they settled on this because ASCII 0001 1010 means "Substitute" which most programmers said "huh. Useless" - especially in a text file because it has no meaning there. (It's used when communicating between systems to say "I can't show that data") Thus, to store our text file with the data "Cat" we could write a 4-byte file with the following contents: 0100 0011 0110 0001 0111 0100 0001 1010 So, now here's the test - I created a file called Cat.txt and saved it to my hard disk. How does it look in its raw binary format? Test. Success. (Stored in the 3-byte format without a terminating character) 