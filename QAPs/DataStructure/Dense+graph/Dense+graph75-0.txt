What are good parallel implementations of hypergraphs?Which libraries can I use to implement parallel hypergraphs?
I have worked with a high-performance implementation of hypergraphs for a number of years (starting as a graduate student). As you can imagine, it's not as much the data structure itself, but what you are planning to do with it. IMHO, hypergraphs are reasonably easy to implement but there is a number of design decisions that can be made differently depending on the type of hypergraphs you are expecting (sparse vs. dense is just the first level of the decision tree). Parallelism and distributed environments add complexity, but also adds the number of possible high-level optimizations (take a look at the CAP theorem). So, even if you find a solid library supporting hypergraphs, you can probably do better if you have a particular application in mind or know something about typical inputs. Perhaps, much better. Some things to consider --- which access operations do you want to be fast? If you want to support hypergraph traversals, you'd need to find nodes on a hyperedge and hyperedges incident to a node. Supporting this efficiently typically requires redundancy. If you are OK with using double the memory and if you don't plan to modify the hypergraph dynamically (often), then redundancy is a reasonable design decision. Dynamic hypergraphs would be more difficult. Do you need to address individual "pins", i.e., connections between a node and a hyperedge? The answer to this question affects the underlying implementation a lot. Do you want a parallel multicore implementation (of what?) or do you want a distributed-memory implementation? The former is not worth for simple traversals (which are all linear time and very fast), but the latter is much more complicated. One possibility is to represent hypergraphs using bipartite graphs, and then use an existing graph library. This adds some inefficiencies, but if you have a clear understanding of the correspondence between graphs and hypergraphs, you can leverage existing graph algorithms. As for "rolling your own hypergraphs", yet another reason is that you can use C++11, which has cleaner syntax, standard hash tables (they are useful if you want to cluster hypergraphs or use string-based node labels), and supports threads in a way that organically integrates with into the language. For example, you can have a container (array/vector) of threads. 