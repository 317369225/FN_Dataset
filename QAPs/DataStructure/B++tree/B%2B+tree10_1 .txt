In filesystems, what is the advantage of using b-trees or b+trees as opposed to using inode indexes?In an inode indexing, with triple indirect pointers, the tree will have only maximum depth=4; I could not understand why btree has advantage over inode indexing in a filesystem?B-trees are balanced search trees that are optimized for large amounts of data. They are particularly well suited to on-disk storage. Searches, insertions, and deletions all take logarithmic time. The b+tree is a modification of the b-tree that stores data only in leaf nodes, minimizing search cost in the common and worst case, and (optionally) links together all the leaf nodes in a linked list, optimizing ordered access. The main benefits to a b-tree or b+tree is scalability and minimizing I/O. The rest of this answer applies to both trees, but for brevity I will just write "b-tree." B-trees, like most tree-based data structures, provide logarithmic time for most operations. Specifically, search, sequential access, insertion, and deletion are all logarithmic operations. But many trees could work in a filesystem and yield logarithmic scalability. Why a b-tree specifically? Because it minimizes I/O. B-trees are designed to maximize fan-out and minimize tree depth (b+trees take this even further). Because each node traversal in a binary tree is an I/O operation, limiting tree depth means limiting I/O. The tradeoff is complexity and storage inefficiency as not every node need be entirely full. B-trees are thus ideally suited for filesystems. The alternative—tables and indexes—are mostly linear in scalability. Worse, however, they are not designed to minimize I/O operations. Seeks are the enemy of the performant.   