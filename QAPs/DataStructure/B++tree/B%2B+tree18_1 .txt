By noting that a B-Tree combines a Linked List with a Binary Search Tree, in layman's terms. A linked list is a simple way to store and search data in O(n). But with a large amount of data to be searched, not all of it can be loaded into memory at once. So the searching will bring in windows/parts of the list at a time for each search iteration, increasing I/O. A binary search tree adds indexing ability - allowing the search for data to be done on meta-data keys alone. The search can be O(logn) and at each element, the left/right half can be discarded as the other holds the value which is sought. This saves space as only that element and the root node needs to be read into memory, and the upper level nodes can even be cached (based on any algorithm like LRU) to improve speed. But one element in a tree is too small, and trees tend to degrade to linked lists if the elements are added in sorted order. B-Trees: Solves both these problems because they provide the O(logN) search and memory saving properties of a BST, with the ease of a large linked list at each element. Ideally, the correct node is identified with the binary search method, and a fair amount of data can then be searched at each node because it's a list which is supposed to be read in one single I/O read. If we add height-balancing in the insert/delete operation then it will not degrade to a tree over time, and assure an O(logN) search time. Due to both these advantages, they are ideal for implementing indexes in databases. B+ Trees: This takes the point of B-Trees even further. Some databases can be so large, that the meta-data keys alone are too big to be stored in RAM in entirety. So the B+-tree only stores pointers to the keys themselves while storing the nodes of the B-Tree at the lowest level, which is read into memory only when needed. 