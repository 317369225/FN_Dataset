Why we are transposing or reversing the directions of all arcs (edges) in the Kosaraju two pass algorithm?
I really loved the algorithm because it's just so clever. Overview : Kosaraju's algorithm (two pass) is a linear time algorithm for finding the strongly connected components of a directed graph. We can described the algorithm as : Step 1: If G is a directed graph and S is an empty stack, then start DFS on an arbitrary node V of G(not in S).  When the recursion on any node v finishes, push that node into the stack and repeat until all of the nodes in the graph has been explored and the stack contains all the nodes ordered by their finishing time. Step 2 : Reverse the edges of the graph G to obtain the transpose graph [math]G^{T}[/math] Step 3 : Pop the top node V from the stack S, perform DFS on the transpose graph with popped node V as the source node. The set of all nodes visited from V would give the strongly connected component containing V, remove this set from the stack and the graph and repeat until the stack is empty. Or we can also run DFS on the transpose graph first to get the ordering and later run DFS/BFS on the original graph in the ordering. Both achieves the same thing, but the intuition for the need to reversing arcs seem to be something like this : Finding the connected components in an 'undirected' graph is easy because each call to DFS/BFS gets the set of all nodes that reachable from that node. So we can just loop over all the nodes in the graph and find the connected components. But in directed graph there's no guarantee that just because there might be a path from node [math]u[/math] to [math]v[/math] that does not mean that we can reach [math]u[/math]  from [math]v[/math]. Two nodes [math]u[/math] and [math]v[/math] in a directed graph are connected if there's a path from [math]u[/math] to v and vice versa. A 'strongly connected component' of an directed graph is the set of all nodes that can reach each other by following directed edges. Naturally a directed graph can be fully connected where there would be only one strongly connected component, or there can be 'disjoint' sets of strongly connected components(SCC). DFS on an arbitrary node [math]v[/math] of a directed graph would either produce a tree that contains all the nodes that are reachable from the node [math]v[/math] and all the edges that can be traversed from [math]v[/math] if the graph contains only one SCC. But if the graph contains multiple SCC's then repeated calling of DFS would create a DFS forest where each tree corresponds to a separate strongly connected component. So basically we can 'find' the SCC's of a directed graph by repeatedly calling DFS, but depending on the node we perform DFS on, we are going to get varied results. If we perform the DFS on a node that's part of a SCC t that does not lead to another SCC, then it's good, but let's say if we run DFS on a node that leads to all other SCC's by following edges, then it just yields the entire graph instead of giving us any idea of the number of SCC's or the nodes that are in each SCC. So we need a good 'ordering' of the nodes that we can perform DFS on. We can 'view' the directed graph in two ways, either we can see it in the fine-grained detailed node level where we see the edges between each node. Or we can 'shrink' the graph or take a high level birds-eye view where we see a 'meta-graph' where SCC's are considered as 'meta-nodes' [math]C_{1},C_{2}....C_{n}[/math] and there's an edge connecting  [math]C_{1}[/math] and [math]C_{2}[/math] if there's an edge from a node in SCC [math]C_{1}[/math] to a node in  SCC [math]C_{2}[/math] in the original graph. It yields a 'directed acyclic graph' where each SCC is a meta-node. There's no cycle because a cycle connecting several SCC's would just merge into one SCC. So the property is that every directed graph is a DAG of it's strongly connected components. source : algorithms by dasgupta,vazirani If we perform DFS on a node of the meta-node, it will explore all the nodes of that SCC. Every directed acyclic graph has at least one 'source node'(where in-degree = 0)  and at least one 'sink node' (where out-degree = 0 aka there's no out-going edges). If we run the DFS on a sink node in the metagraph(Or a sink SCC in the original graph) it would find exactly that component and nothing else. For example, if we run DFS on D or the large SCC containing {G,H....,L}, it would finish traversing that SCC. But if we run DFS on the source node A for example, we traverse all the nodes in the DAG which is giving us errors. Clearly, we need to find someway to ensure that each time we are calling DFS, we are calling that on a node that's lying in a sink SCC instead of a source one. So that creates two major questions : a) How to we ensure that we are running DFS on a node of a sink SCC, b) How do we continue searching for other SCC's after one gets explored? The stack we create by performing DFS in the first pass can help us with ordering the nodes. Each arbitrary node [math]v[/math] gets into the stack only when all the nodes that can be reached from [math]v[/math] has been explored and pushed into the stack. So if we label each node with a finishing time(an integer from [math]1...n[/math]) when their recursion finishes, the source node of DFS pass will have the largest finishing time compared to the nodes that can be reached from it. But well, instead of finding a way to quickly find a 'sink-node' in the original graph, we have just found a way to quickly find a source-node in the original graph, because it's sorted by the finishing time and the source nodes always have a bigger finishing time compared to the nodes that can be reached by it when we run DFS, technically we are tracking the finishing by the ordering of the stack implicitly since we are using a stack.(See algorithms by Sedgewick/Introduction to algorithms for the proof) The node that lies in at the end of the stack then lies on a source SCC in the original graph. Here comes the 'Reverse graph trick'. Turns out the SCC's remain same in the reversed graph/transpose graph(where all edges are reversed), but all source nodes become sink-nodes.(because we are reversing all edges, but not adding/removing anymore edge). So if do DFS on the reversed graph using the ordering in the stack,we are actually processing the nodes from sink to source in the reversed graph so we are definitely going to get the SCC's(all nodes that can reach one another) one by one. And let's say we were running DFS on the reversed graph first to get the ordering. In that case the sink nodes in the original graph becomes the source nodes in the reversed graph and gets the biggest finishing time values/post order in the stack, later when we process them in the decreasing order of the finishing time by running DFS on the original graph and pop the nodes from the stack, then we are processing the nodes from sink to source again. Each time we run DFS, we find the set of nodes that can be reached from the node(lying in a sink SCC) which is basically the set of all nodes in the strongly connected component that contains the node.  Each time we remove the set of nodes from the stack after getting the SCC, so we end up with a smaller graph and stack per run of DFS until the stack is empty and all nodes has been processed and all the SCC's has been obtained.  Another way to see it, in the first pass of the DFS each arbitrary node  [math]a,b,c [/math] that is reachable by node [math]v[/math] is pushed to the stack before [math]v[/math]. In the second pass of DFS we have to check the subset of nodes [math]a,b,c[/math] that can reach node [math]v[/math] because if they are in the same strongly connected component, then they are mutually reachable. Instead of testing each whether each node can reach [math]v[/math] in the original graph, we are asking "can node [math]v[/math] reach all those nodes [math]a,b,c..etc[/math] in the reverse graph?". So we are reversing the graph to check of two arbitrary nodes are mutually reachable or not. For getting a visual example this article seems to be the best : Strongly Connected Components - GeeksforGeeks For example, in DFS of above example graph, finish time of 0 is always greater than 3 and 4 (irrespective of the sequence of vertices considered for DFS). And finish time of 3 is always greater than 4. DFS doesn’t guarantee about other vertices, for example finish times of 1 and 2 may be smaller or greater than 3 and 4 depending upon the sequence of vertices considered for DFS. So to use this property, we do DFS traversal of complete graph and push every finished vertex to a stack. In stack, 3 always appears after 4, and 0 appear after both 3 and 4. In the next step, we reverse the graph. Consider the graph of SCCs. In the reversed graph, the edges that connect two components are reversed. So the SCC {0, 1, 2} becomes sink and the SCC {4} becomes source. As discussed above, in stack, we always have 0 before 3 and 4. So if we do a DFS of the reversed graph using sequence of vertices in stack, we process vertices from sink to source. That is what we wanted to achieve and that is all needed to print SCCs one by one. Resources : http://scienceblogs.com/goodmath... Coursera http://faculty.cs.tamu.edu/klapp... (lecture notes based on vazirani) Page on stanford.edu Correctness of Strongly Connected Components algorithm for a directed graph Kosaraju’s Algorithm - why transpose? Page on ed.ac.uk Strongly Connected Components - GeeksforGeeks Strongly Connected Components 