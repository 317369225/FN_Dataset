Which graph representation is better for competitive programming in C++: adjacency list or adjacency matrix?I want to implement some basic graph algorithms such as - bfs, dfs, dijkstra, mst- prim's and kruskal, max bipartite matching etc.. I want to know which is better representation for graph in terms of easy to manage with time and space - especially for competitive programming.
Lets start with the basics.. There are mainly 2 ways to represent a graph: 1) Adj Matrix 2) Adj List Matrix Representation of a graph is achieved by marking edges between 2 nodes as '1' or 'true' in a boolean matrix of the size n*n So if you want to mark an edge from a to b: In a directed graph: adj[a][b]=1 In an undirected graph: adj[a][b]=1 adj[b][a]=1 Now if the graph is weighted then you cant use a boolean matrix, you need to use an integer(or any other type depending upon the problem statement)matrix and then mark the edges as follows In a directed graph: adj[a][b]=weight In an undirected graph: adj[a][b]=weight adj[b][a]=weight So the memory requirement is V^2(V is number of vertices or nodes). Also for graph traversal algorithms link DFS & BFS this type of representation will have a worst case time complexity of O(V^2)...which in most cases will give you a time limit exceeded. Also it is very inefficient in cases of a sparse graph. Now lets discuss about the List Representation. This representation is achieved by adding other ends of edges to the starting node. So if you want to mark an edge from a to b: arr[a].push_back(b) for a directed graph (using array of vectors here) and if the graph is undirected: arr[a].push_back(b) arr[b].push_back(a) For a graph that is weighted you will have to store the weight of the edge as well...in this cause u can make a pair and then push that into the vector...like: arr[a].push_back(make_pair(b,weight)) The space complexity of this type of representation is O(E) i.e. order of the number of edges(E is number of edges). Also the time complexity is considerably decreased(compared to Matrix representation) in case of graph traversal algorithms. The complexity being O(V+E) . So for competitive programming I would surely suggest the List representation. Hope this helps....:) 