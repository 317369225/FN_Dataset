On Linux, how is size of the heap allocated for a program determined?
I think Travis' answer conflates the address space with the allocation. Linux processes are almost all descendants of init which is usually around 250-300KB RSS and about 2.5MB VSIZE.  The initial size of any process is inherited from its parent via fork() (technically a wrapper around clone() in Linux). Most of those cloned (writable) pages are CoW (copy-on-write) for both parent and child ... there are also many memory mappings, many of which are read-only (shared libaries ... .so files ... mostly).  There may also be some shared and writable memory mappings which may even be in the form of anonymous IPC (that is to say  mmap() without any actual file on any backing store). Writing CoW pages triggers allocations (handled by the kernel as part of the page fault.  I've read, in the distant past, that most (all?) user-space allocations in Linux start as references to a single CoW "zero" page (consisting of all ASCII NUL characters).  Page faults then "copy" in any free page (which is also blank ... a stream of ASCII NULs). An execve() causes triggers a number of memory mappings (the new, usually ELF binary, and all of its .so shared object files, for example). What I don't know is precisely when memory is *freed* under the circumstances surrounding a fork()/execve() pair of system calls.  It might be done by the kernel as part of execve() handling, or it might be done by the C runtime code (libcrt.so.0) ... perhaps a brk() or sbrk() and perhaps based on some of the binary's ELF headers? I suppose you might read through the Linux sources for the execve() system call and the GNU libc sources for libcrt to find out the details. Here's a page that seems to have a wealth of information on the Linux process memory layout: Anatomy of a Program in Memory that's part of a whole series of related articles.  It doesn't seem to answer your question directly, but I think the background will be useful; as will some of the others in that series.   The other one I'd recommend, in that series is: Page Cache, the Affair Between Memory and Files. By the time you've read those I think you'll see your question is difficult to answer.  The program's initialization as a process is pretty complex. It's also worth noting that a program, under Linux, might be linked against any of several different memory allocation managers other than the one that's built into GNU libc (Wolfram Gloger's ptmalloc)  For example there's TCMalloc : Thread-Caching Malloc, and jemalloc.  Some C programmers even prefer to write their own heap manager. I don't know if linking against those would have any significant effect on the initial size of the heap (which I interpret to mean at the point in time when a program's main() is being called.  I'd think that the various heap managers would only effect the heap as the program runs (and dynamically allocates space on the heap). 