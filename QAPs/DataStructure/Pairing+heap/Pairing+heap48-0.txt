How do I use dijkstra's algorithm in competitive programming?
I will first explain the algorithm The algorithm we are going to use to determine the shortest path is called “Dijkstra’s algorithm.” Dijkstra’s algorithm is an iterative algorithm that provides us with the shortest path from one particular starting node to all other nodes in the graph. Again this is similar to the results of a breadth first search. To keep track of the total cost from the start node to each destination we will make use of the distinstance variable in the Vertex class. The dist instance variable will contain the current total weight of the smallest weight path from the start to the vertex in question. The algorithm iterates once for every vertex in the graph; however, the order that we iterate over the vertices is controlled by a priority queue. The value that is used to determine the order of the objects in the priority queue is dist. When a vertex is first created dist is set to a very large number. Theoretically you would set dist to infinity, but in practice we just set it to a number that is larger than any real distance we would have in the problem we are trying to solve. Dijkstra’s algorithm uses a priority queue. You may recall that a priority queue is based on the heap that we implemented in the Tree Chapter. There are a couple of differences between that simple implementation and the implementation we use for Dijkstra’s algorithm. First, the PriorityQueue class stores tuples of key, value pairs. This is important for Dijkstra’s algorithm as the key in the priority queue must match the key of the vertex in the graph. Secondly the value is used for deciding the priority, and thus the position of the key in the priority queue. In this implementation we use the distance to the vertex as the priority because as we will see when we are exploring the next vertex, we always want to explore the vertex that has the smallest distance. The second difference is the addition of the decreaseKey method. As you can see, this method is used when the distance to a vertex that is already in the queue is reduced, and thus moves that vertex toward the front of the queue. Now I will take an example of a problem form Sphere Online Judge (SPOJ) SPOJ.com - Problem EZDIJKST   #include<bits/stdc++.h>#include<queue>#include<iostream>using namespace std;#define pp pair<int,int>using namespace std;const int INF=INT_MAX;class Prioritize{public:    int operator() ( const pair<int, int>& p1, const pair<int, int>& p2 )    {        return p1.second < p2.second;    }};int main(){	int tc,a,b,w;	int node,edges;	cin>>tc;	while(tc--)	{		priority_queue<pp, vector<pp>, Prioritize> Q;		scanf("%d%d",&node,&edges);		vector< pp > G[node+1];		for(int i=0;i<edges;i++)		{			scanf("%d%d%d",&a,&b,&w);			G[a].push_back(pp(b,w));		}		int s,d;		int dis[node+1];		for(int i=1;i<=node;i++)		{		   dis[i] = INT_MAX;		}		scanf("%d%d",&s,&d);		dis[s]=0;		Q.push(pp(s,dis[s]));		while(!Q.empty())		{			a = Q.top().first;			Q.pop();			int size = G[a].size();			for(int i=0;i<size;i++)			{			   b = G[a][i].first;               w = G[a][i].second;               if(dis[b] > dis[a]+ w)               {               	 dis[b] = dis[a]+w;               	 Q.push(pp(b,dis[b]));               }			}		}		if(dis[d]==INF)		puts("NO");		else printf("%d\n",dis[d]);	}} 