How is the virtual method table implemented in Java?
At the bytecode level, the invokevirtual operation is what triggers the Java equivalent of a C++ virtual method call [1]. As per the specification, the operation accepts an index (two actually, but it is combined to get a single value) which is used to get a reference to a method and a reference to the class in which the method is to be found. In HotSpot [2], this corresponds to a vtable index within the target class, resolving which the intended target method can be invoked. Depending on the class hierarchy, each class may have a differently sized vtable, and child classes that override methods of a parent can re-use vtable indices as Simon Kinahan has mentioned. However, in the JIT compiled code, the vtable calling sequence is typically not used. HotSpot performs inline caching, wherein the code optimistically assumes that the target of a virtual method always points to the same implementation (meaning the call site is monomorphic). In this case, a check is inserted into the code to verify whether the assumption actually holds (that is, the target hasn't changed), and then control is passed directly to the target method without involving any vtable lookups, akin to how a so-called 'unlinked' call site works. Loosely put, if this assumptions fails enough times, the code falls back to the long-winded vtable lookup approach. [1] Chapter 6. The Java Virtual Machine Instruction Set [2] VirtualCalls - HotSpot Internals for OpenJDK - Oracle Wiki 