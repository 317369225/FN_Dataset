What is the best way to sort an unsorted linked list?
Marc Khoury is right about mergesort working best with O(n log n) worst case performance and constant space Accepting O(n^2) worst case performance and ignoring optimizations on things like pivot selection and call depth quicksort is quicker to design and implement.  Asking a C or C++ using candidate to implement it (given a definition of quicksort) for linked lists would be a decent interview question covering termination, edge conditions, indirection, and recursion. With some compromises on temporary variables to keep things comprehensible I end up with iterative merge sort like this static struct node *split_after(struct node *in, unsigned count){    unsigned i;    struct node *rest, **prev;    for (i = 0, rest = in, prev = NULL; rest && i < count; ++i,         prev = &rest->next, rest = rest->next) {    }    if (prev) {        *prev = NULL;    }    return rest;}static struct node *list_merge_sort(struct node * const src){    struct node *rest, *in_head[2], *out_head, **out_tail;    unsigned increment, done, merge_src;    rest = src;     increment = 1;    do {          out_head = NULL;           out_tail = &out_head;        done = 1;                     while (rest) {            in_head[0] = rest;            in_head[1] = split_after(rest, increment);            rest = split_after(in_head[1], increment);                if (in_head[1]) {                done = 0;            }                while (in_head[0] || in_head[1]) {                merge_src = !in_head[1] ||                    (in_head[0] && in_head[0]->val <= in_head[1]->val) ? 0 : 1;                *out_tail = in_head[merge_src];                in_head[merge_src] = in_head[merge_src]->next;                (*out_tail)->next = NULL;                out_tail = &(*out_tail)->next;            }        }        increment *= 2;        rest = out_head;    } while (!done);    return rest;} and quicksort like this with naive pivot selection static struct node *list_quick_sort_helper(struct node * const src, struct node ***tail_out){    struct node *pivot = src, *head[2] = {}, **tail[2] =        { &head[0], &head[1] }, *rest, *next;    unsigned dest;    if (pivot) {        for (rest = pivot->next; rest; rest = next) {            next = rest->next;            rest->next = NULL;            dest = rest->val <= pivot->val ? 0 : 1;            *tail[dest] = rest;            tail[dest] = &(rest->next);        }        head[0] = list_quick_sort_helper(head[0], &tail[0]);        head[1] = list_quick_sort_helper(head[1], &tail[1]);        *tail[0] = pivot;        pivot->next = head[1];        if (tail_out) {            *tail_out = head[1] ? &(*tail[1])->next : &pivot->next;        }    }    return head[0];}  with list nodes like struct node {    int val;    struct node *next;}; Updated 104w ago • View Upvotes