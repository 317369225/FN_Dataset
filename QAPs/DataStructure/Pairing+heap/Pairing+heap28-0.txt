What's the most efficient way to find the kth smallest element in a min-heap?
Let's try to traverse your heap in increasing order. First, we look at the root. Next, we look at the root's smaller child. But which node do we look at from here? The next smallest could be another of the root's children, or it could be a grandchild of the root! So let's do the following. Let's call our original min-heap [math]H_1[/math], and let's introduce another min-heap [math]H_2[/math]. Whenever we visit a node [math]x[/math] in [math]H_1[/math], let's push a pair [math](v,p)[/math] for each child of [math]c[/math] of [math]x[/math] to [math]H_2[/math], where [math]v[/math] is the value at the child [math]c[/math], and [math]p[/math] is a pointer to that [math]c[/math]. To figure out which node to visit next in [math]H_1[/math], let's pop a [math](v,p)[/math] pair from [math]H_2[/math], and let's visit the [math]H_1[/math] node pointed to by [math]p[/math]. The [math]k[/math]th node we pop from [math]H_2[/math] will hold the value of the [math]k[/math]th smallest node in [math]H_1[/math]. How long does it take? Well, assuming [math]H_1[/math] is a binary heap, we'll do at most [math]2k[/math] insertions into [math]H_2[/math], so we'll say that the size of [math]H_2[/math] is [math]\mathcal{O}(k)[/math]. This means that each insertion is [math]\mathcal{O}(\log k)[/math], and each extract-min is also [math]\mathcal{O}(\log k)[/math], assuming we're again using a binary heap for [math]H_2[/math]. The total time is [math]\mathcal{O}(k\log k)[/math], as desired. 