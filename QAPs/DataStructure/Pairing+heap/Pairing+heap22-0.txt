How do I find the minimal range that contains a number from each sorted array?
You can do much better than brute-force. I think it can be solved in [math]O(n \log{k})[/math] where n is the number of all elements in the arrays and k is the number of arrays. This is my solution: Let M be a min-heap of minimums in each of these arrays. ARRAYS=[ [1 1000 2000] [20 1001 5000] [55 1002 222222] ] M=[1, 20, 55] There is no range that starts with min(M) and is shorter than (min(M), max(M)). For example, (1,55) is the shortest range that starts with 1. That is, any other range staring with 1 will be either of equal length or have an element larger than 55. So far the min_range is (1,55). Now let’s remove 1: ARRAYS=[ [1000 2000] [20 1001 5000] [55 1002 222222] ] M=[20 55 1000], min(M) = 20, max(M) = 1000. So, the minimum range starting from 20 is (20, 1000). min_range is still (1,55). Now let’s remove 20: ARRAYS=[ [1000 2000] [1001 5000] [55 1002 222222] ] M=[55 1000 1001], min(M) = 50, max(M) = 1001. So, the minimum range starting from 55 is (55, 1001). No change in min_range! Now let’s remove 55: ARRAYS=[ [1000 2000] [1001 5000] [1002 222222] ] M=[1000 1001 1002], min(M) = 1000, max(M) = 1002. So, the minimum range starting from 1000 is (1000, 1002). Now we’ve got a new min_range: (1000,1002). We continue this until one of the lists becomes empty, and then we have the min_range. This is my c++11 implementation of this (which instead of deleting elements stores a sweeping index for each vector): #include <cstdio>#include <algorithm>#include <limits>#include <tuple>#include <queue>#include <vector>using std::get;using std::numeric_limits;using std::pair;using std::priority_queue;using std::vector;pair<int, int> find_min_range(const vector<vector<int>>& arrays) {  // The result.  pair<int, int> min_range{    numeric_limits<int>::min(),    numeric_limits<int>::max()  };  // Sweeping index on each row.  vector<int> indices(arrays.size());  // M.   std::priority_queue<pair<int, int>, std::vector<pair<int, int>>,                      std::greater<pair<int, int>>> minimums;  // max(M).  auto max = arrays[0][0];  for (auto i = 0; i < arrays.size(); i++) {    auto v = arrays[i][0];    minimums.push({v, i});    if (max < v) {      max = v;    }  }  while (true) {    auto min = minimums.top();    auto min_val = min.first;    auto min_row = min.second;    minimums.pop();    if (long(min_range.second) - long(min_range.first) >        long(max) - long(min_val)) {      min_range = {min_val, max};    }    indices[min_row]++;    if (indices[min_row] == arrays[min_row].size()) {      return min_range;    }    auto v = arrays[min_row][indices[min_row]];    if (max < v) {      max = v;    }    minimums.push({v, min_row});  }  return min_range;}int main() {  vector<vector<int>> a {    {1, 1000, 2000},    {20, 1001, 5000},    {55, 1002, 222222}  };  auto res = find_min_range(a);  printf("Minimum range is (%d, %d)\n", res.first, res.second);  return 0;} 