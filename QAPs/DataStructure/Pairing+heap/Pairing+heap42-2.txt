Why is it impossible to have a comparison sort better than O(nlogn) time?
Following is a list of not all but Important sorting algos.. 1. Quick Sort (has strong relations with order statistics) 2. Heap Sort (based on heap or almost complete tree data structure) 3. Insertion Sort (based on how you sort your "playing cards") 4. Merge Sort (based on divide and conquer like quick_sort but is stable sort i.e. preserves the input order of equal elements in sorted output). 5. Counting Sort (not a comparison sort unlike above all). Is linear time complexity possible with 1-4 comparison sort algorithms? lets try to get this in a lucid manner.. It can be easily found out by using a decision tree. Decision tree is nothing but  a binary tree in which each of the internal node is a pair of elements(a,b) and its left child carries the result that (a <= b) and right child carries the result ( a>b ) and thus each of the leaf carries a supposed sorted sequence i.e if the conditions from root to a particular leaf are true, the order of elements in leaf is sorted order.  Now, say you have 'n' elements, sorting order may be any out of n! combinations and maximum number of leaves possible is 2^h, where 'h' is the height of the decision tree.Thus, n! <= 2^h (possible number of sort orders <= total possible leaves) Note: in the figure; n! = 6; total possible leaves = 8 Now taking log on both sides; n(log(n)) <= h Hence, lower bound on 'h' is n(log(n))..! Hence to reach a sorted sequence, minimum n(log(n)) comparisons needs to be done. Updated 101w ago • View Upvotes