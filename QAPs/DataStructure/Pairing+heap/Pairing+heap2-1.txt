What is a Fibonacci Heap?
I want to complement Adam D'Angelo's answer a little. A Fibonacci heap is a type of heap that supports merging, insertion, decrease-key* and find-min in [math]O(1)[/math] amortized time, and delete and delete-min in [math]O(\log n)[/math] amortized time. There are actually 3 improvements here over a binary heap: 1. A fast merge operation, which a binary heap cannot support in less than [math]\Theta(n)[/math] time. 2. An insert operation that takes [math]O(1)[/math] amortized time, rather than [math]O(\log n)[/math] time as with a binary heap. 3. A decrease-key operation that takes [math]O(1)[/math] amortized time, rather than [math]O(\log n)[/math] time as with a binary heap. The first two improvements were achieved with the discovery of the Binomial heap (in my opinion, a very beautiful and elegant data structure). The binomial heap does not, however, support decrease-key in [math]O(1)[/math] amortized time, requiring logarithmic time just like a binary heap. The significance of the Fibonacci heap is that it achieves the third improvement as well. The delete and delete-min operations cannot be faster than logarithmic time in any comparison-based data structure that also supports all the [math]O(1)[/math] operations that a Fibonacci heap has, due to the [math]\Omega(n \log n)[/math] lower bound on comparison-based sorting**. A Fibonacci heap therefore achieves the optimal asymptotic complexity for all the operations that it supports. The discovery of the Fibonacci heap allowed a number of existing algorithms to be sped up. Algorithms that relied on priority queues and performed an asymptotically larger number of decrease-key operations than delete operations were improved. For example, Dijkstra's algorithm for finding shortest paths on a graph containing [math]V[/math] vertices and [math]E[/math] edges needs [math]O(E)[/math] decrease-key operations but only [math]O(V)[/math] delete-min operations, and keeps at most [math]O(V)[/math] entries on the heap at any given time. With a binary or binomial heap, [math]O(V \log V + E \log V)[/math] time is required; a Fibonacci heap improves this bound to [math]O(V \log V + E)[/math]. As Adam already mentioned, the Fibonacci heap ends up having high constant factors, so it hasn't been used much in practice and is mostly of theoretical interest. The pairing heap was an attempt to achieve the same asymptotic bounds with lower constant factors, but the conjecture that the pairing heap achieves the same asymptotic bounds as the Fibonacci heap has since been disproven. * Decrease-key is what you get for min-heaps. It's increase-key for max-heaps. Max heaps also have delete-max and find-max instead of delete-min and find-min. ** Suppose you had a delete-min operation that was faster than log-time. You could then insert [math]n[/math] entries into the heap in [math]O(n)[/math] time (since insert is [math]O(1)[/math]), and then do [math]n[/math] back-to-back remove-min operations, which will return the elements in sorted order. If remove-min were any faster than log-time, the total time required would be less than [math]\Theta(n \log n)[/math]. Updated 99w ago â€¢ View Upvotes