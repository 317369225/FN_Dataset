What are the best programming interview questions you've ever asked or been asked?
I recently interviewed for a startup (Rubrik). There were 3 back to back technical interviews lasting for about an hour each. The startup is all about cloud storage. They asked me some really good questions. 1st Interview - The interviewer was previously a kernel engineer at Facebook. He seemed experienced. He asked me what I knew about cloud computing. I told him about a few protocols I knew. He further asked me some applications of those protocols. Later he asked me about the programming language with which I am most comfortable. I had been using C++ for about 2.5 years. That's what I told him. He - Have you used malloc (C library function - malloc())? Me - No sir, I am not much familiar with C, I use C++ and I am familiar with 'new' He - Let's code it up. Allocate an array of size 32k bytes. Each malloc request will require you to allocate exactly 2 bytes of memory. Design a memory efficient malloc function to handle these 16k memory locations. Me - Talked about how we could use a boolean flag to mark if a particular memory location is free or not. I further asked him if he wanted me to optimize the malloc function for space or time. That was a dumb question though. It is obvious that since we are designing a memory management system, it has to be optimized to minimize memory usage. Anyway, using a simple boolean flag wont help here. Because, for each 2 byte memory location, we will have 1 byte of boolean flag. So, that's 66% efficient. I suggested him that we can instead use a vector of boolean in C++. The language internally optimizes it to use 1 bit for each element of array instead of 1 byte. That idea increased the efficiency to about 93%. The interviewer seemed happy and coding malloc (and then later free()) was straightforward. 2nd Interview - The interviewer was previously a tech lead at Oracle. Seemed to be a highly experienced person. He asked an interesting question. Code up the 'diff command' that you use in Ubuntu (compare files line by line) - for a while, I went blank and I blabbered about some hashing. Soon I realized it was nothing, but the longest common sub sequence problem, which can be solved by dynamic programming. He asked me to code it up. I coded a top down DP. He further asked me to code it iteratively. It was a easy to covert the recursive code to an iterative one (bottom up DP). He further asked me to construct the actual diff and print it on the screen in the format: Line x deleted Line y added Line p and Line q are same He then moved on - suppose one of the line of one file is 'AAAA' and the same line in other file is 'AAAB'. Modify your existing code so that the algorithm identifies that the line 'AAAB' is nothing but an edited version of line 'AAAA'. I suggested that instead of checking file1[i] == file2[j], we can rather have a similarity function: similarity(file1[i], file2[j]), which finds the edit distance of i-th line of file1 and j-th line of file2, again using dynamic programming. And depending on some cut-off value of edit distance, we can decide if they are same lines or they are different. Thank God, he didn't ask me to code it up 3rd Interview - This was a piece of cake. The interviewer gave me a struct Node that contained 2 pointers: Node *left, *right. He then asked me to complete the insert function of the 'complete binary tree' (Complete Binary Trees ). You should try this one yourself. It is a simple O(logN * logN) algorithm. All you need to decide is that you have to recur to root -> left or root -> right based on something (think!). He then asked me to convert the recursive code I wrote to an iterative one which was quite easy using a while loop. In another interview with Tower Research Capital LLC (Tower Research Capital), I was asked very standard data structures and algorithms related problems (and some discrete mathematics problems). Note that the questions is about the best programming interview questions. However, I am mentioning these for completeness (in case anyone is interested): You are given k lists which are all sorted. Merge them into a single list Given an array A[0 ... N - 1], construct and array B[0 .. N - 1], where B[i] = NGE(A[i]). NGE(A[i]) is defined as j such that j > i and A[j] > A[i] and j is the smallest such j. Basically NGE is 'Next Greater Element' Prove that in a group of 6 people, if every pair is either a friend or an enemy, then there exists a triplet (A, B, C) such that A-B-C are all mutual friends or are all mutual enemies (hint - Pigeon hole principle) You are given a binary tree. Find the maximal sub-tree of this binary tree which is a binary search tree. Note that the question was poorly phrased. Actually, you are supposed to find a node in the binary tree such that the (entire) sub-tree rooted at this node is a binary search tree and that this binary search tree is maximal such binary search tree I had mentioned about a socket programming project. I was asked ins and outs of socket programming I had mentioned that I knew python programming. I was asked about some parsing function in python (which frankly speaking I did not know) I personally feel that the first interview was a challenging one and they asked some really good questions (especially the diff command problem). I hope that helps 