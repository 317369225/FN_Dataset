I recently noticed that some companies/developers, migrated or adopted Go language over Node.js. Why is that?
We recently chose Elixir / Erlang as our main back-end language at Taskworld, moving away from a 100% Node.js solution. The team evaluated 4 different alternatives, building a simple REST API using Go (using Gorilla), Rust (Iron, nickel), Scala (Spray) and Elixir / Erlang (Phoenix, Cowboy). Elixir won by a slight margin (over Go). We still use Node and React/Flux for our front-end. It's perfect for us as we pre-render of our React components on the server and rely on Browserify and Gulp as part of our dev cycle. But we decided we didn't want to build a large back-end in JavaScript, for a number of reasons; 1. The mutability of JavaScript objects. This one's pretty simple; Developers pass objects to functions by reference and then end up mutating those objects - in fact, the language encourages them to do so. This can lead to subtle, hard to detect bugs. When writing React code (Flux stores in particular), we need to work around this problem by constantly cloning objects on return because JavaScript objects are also returned by reference (objects are allocated on the heap). Having to keep track of what needs to remain a reference and what needs to be cloned/copied is more than just a nuisance, it's inefficient as cloning large objects is slow. This problem gets magnified when writing a large back-end, which leads to point number two.. 2. Having to test EVERYTHING. There's no leaning on the compiler when writing JavaScript. Problems are normally spotted at runtime, and that increases the need for testing. Don't get me wrong; Testing is important no matter what language you use. But the amount of tests needed to get decent coverage differs greatly from language to language. Statically-typed languages like Go, Rust and Scala allow you to detect many errors at compile time (Rust is especially great at this), eliminating the need for some of the unit testing. We chose Elixir / Erlang, despite it using dynamic typing, mainly because of it's immutable types. Elixir's functional style, paired with Pattern Matching and Specs make for more solid code. With JavaScript types being what they are (i.e. inconsistent), it forces developers to test more thoroughly. 3. Asynchronous programming and non-blocking I/O. While this has upsides and is arguably the main benefit of using Node.js, it's implementation in the Node.js API, with the introduction of the Node callback convention, makes for some odd-looking code. However you choose to deal with callbacks in Node.js, be it through Fibers, Q / ES6 Promises or Async (we've used all of them, but lean towards Q), having to constantly work around "callback hell" by wrapping functions calls does get old after a while. Most common back-end programming tasks require a standard synchronous flow; i.e. fetch data, process the data, fetch more data based on the result, do more processing and so on. Having to compensate for the async programming model of Node.js 75% or more of the time just can't be considered "right". We much prefer Processes in Elixir, or Go routines, to do parallelism in the back-end. UPDATE: For more on why the team choose Elixir over Go, have a look at my response in the comments. Cheers. Updated 53w ago â€¢ View Upvotes