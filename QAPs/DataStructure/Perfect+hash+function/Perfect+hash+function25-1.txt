Imagine I had a large, strictly ordered set of sparse integer numbers, without duplicates. Can I write a function that returns the position in the set of a given number, without 'storing' the full list of numbers as part of the function?
You do not state that the integers (I'll call them a1, a2, ... an) are known to follow any particular distribution.  If there is no known distribution, then an approach like the following (using C's ternary conditional operator) might be my first attempt: Find a bitmask that distinguishes a1 from 0, call it m1.  Calculate a1&m1, call it n1.  The first part of the function will be ((x&m1)==n1)?1:0. Apply this function to a2, call the result r2.  Say d2=2-r2.  Find a bitmask that distinguishes a2 from a1, call it m2.  Calculate a2&m2, call it n2.  The second part of the function will be ...+((x&m2)==n2)?d2:0. Apply this function to a3, call the result r3.  Say d3=3-r3.  Find a bitmask that distinguishes a3 from a1 and a2, call it m3.  Calculate a3&m3, call it n3.  The third part of the function will be ...+((x&m3)==n3)?d3:0. Keep going until you have n terms. If something is known about the distribution of the numbers, though, perhaps you can do better.  If the distribution is known to be fairly flat, for instance, or can be made to be fairly flat by some transformation (such as, taking the logarithm, like in your example), I would start with the equation of a least-squares fit to the points (1,a1), (2,a2), ... (n,an); call it f0.  Then, find the largest set of consecutive 'i's such that the values of floor(f0(i)+0.5) are either all above ai, or all below ai.  Add a term ((x>=(minimum i in set))&&(x<=(maximum i in set)))?1:0 if below, ...?-1:0 if above, and call the function f1.  Keep going until floor(f(i)+0.5)=ai for every i. 