How efficient is tr1::unordered_map at lookups if it grows to hundreds of thousands of keys?
According the standard(i'm not sure, fix me if i'm wrong), unordered_map::iterator should keep valid after insert/erase, which means the implementation must using closed-addressing conflict resolution,  that's not very space and cache friendly(esp for small objects, like int). You can implement a open-addressing version, only drop the requirement of keeping iterator valid after insert/erase. I meet the same problem in real. I packed lots of strings to a pool separated by zero byte, implement hash<char_intptr_t>,  char_intptr_t unique_str(char *s), and hashmap<char_intptr_t, void*>. You can also cache the hash in char_intptr_t, if time requirement is stricter. 