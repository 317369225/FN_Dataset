Are there any hashing algorithms that are mathematically proven to produce unique, collision-free hashes?
[EDITED 11/9/2015 to add initial paragraph] Before starting, note that this ONLY works if you're working on a floating point monster, like a CDC 6600 or an early Cray (like an XMP or YMP) or certain IBM models. If you're running on a RISC chip, it will suck big-time. If you're running on a non-pipelined CISC chip with multiple cycles per  FP instruction, it will also suck big-time. But on the right hardware, it screams, and generates a huge amount of entropy due to taking collections of "characters" and using the bits to build "artificial" floating point numbers. So, here's what I did. Not mathematically proven, but in practice, very low collision rate. And damned fast. Take your string, pad to (sizeof float). Cast the front of the string as (float *) [vs (char *)] Create an iterative loop to floating point multiply the i-th and (i+1)-th elements, accumulating the results. Take the accumulated results, cast as a (u_long) [assuming (sizeof u_long) == (sizeof float), it not, adjust size accordingly). That's your hash key. Take that, AND with 0x000000ff (assuming 32 bit u_long), cast as (int). That's the index to the look-aside table in case of collisions. Your colleagues will have their minds blown by the C code that produces this result. You're welcome. And no, you can't do this shit in Java. Updated 12w ago • View Upvotes