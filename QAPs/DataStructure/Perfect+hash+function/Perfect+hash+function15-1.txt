In a realistic Trie implementation, how is a node stored compactly and efficiently?
I know this sounds unusual, but actually having a hash table to map from the character to child tree node actually gives you a balance between O(1) amortized time lookup and also having O(#children) memory size. I've implemented tries this way and although it has a slightly higher memory footprint it is very fast -- especially if you use something like Java's dynamic resizing. Even better is if you are just using it for reads, you can work out a perfect hash function and have the best of both worlds. The other option is that if you are not doing writes to the tree and mostly you are reading it, is to keep the list of children sorted. This makes it O(log(#children)) (using binary search on the sorted list) though, but balances compact memory with efficient computation. 