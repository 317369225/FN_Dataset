Is this an efficient implementation of bubble sort?Ah, bubblesort. One of my favorite algorithms, because it showed me just how awesome and awful algorithms can be. In my first job out of college, I was working in scientific programming and was asked to see if I couldn't speed up a satellite topology simulation that took a couple weeks to run on our supercomputer. Not having a clue about the problem domain, I decided I'd focus on other stuff. I discovered that the simulation worked by running its core algs into a massive FORTRAN array, sorting it, and analyzing it. It turned out that the original developers - who were aerospace guys, not programmers - did two things: 1. They initialized the array to 999999 so they could indicate the end. I changed this to use an index and got rid of the initialization. 2. They used bubblesort on this huge array. When I asked why, they said it was because it was nice and short, so it must be better than the more complicated sort they'd gotten rid of. I replaced the bubblesort with a FORTRAN heapsort. We then did a run to test my fixes. It ran in about 20 minutes. They spent another week convincing themselves that it ran correctly and that my fixes hadn't somehow corrupted their analytics algs. The sim now ran so fast that we were able to complete a proposal for a new satellite that we expected to miss because the deadline was coming up faster than we could complete the sim work (using the old version). Lessons learned: 1. Algorithms and all that big-Oh stuff really does matter. 2. Just because someone has a PhD and "knows how to code" doesn't mean they actually do, at least outside their area. 3. Throwing hardware at the problem doesn't necessarily make it go away. 