Is this an efficient implementation of bubble sort?In addition to what others have said: Iterating over primitives in arrays is typically faster than iterating over collections (ArrayLists). Your casts are also unnecessary. Let's examine one of your lines: int first = (Integer)arr.get(i) You have already defined your ArrayList to hold Integer objects; so, this is superfluous. (The Java compiler's optimizer might ignore this superfluous cast, but I'm not sure.) Your array will return an Integer object. But you are then casting it to an Integer object, which does nothing (but may incur a performance penalty). Java then must unbox the Integer object to store it in an int primitive. This is incredibly inefficient. I suggest running some benchmarks to get a feel for it. It would have been more consistent to use Integer objects on both sides, but it would be ideal to simply use an array of int primitives and store the value in an int. For example: int first = myArray[i] How much faster it is in practice will depend on a lot of factors. The difference in speed between a program that uses Integer objects and one that uses int primitives might be extremely small, if it's detectable at all. And Java evolves very quickly; so, this may not even be true eventually. The most important reason for the speed increase is that, with arrays, there is no indirection. When you create an array, you reserve a contiguous chunk of (logical) memory that can be indexed directly with no function calls or chains of references. While ArrayLists are, in fact, backed by arrays, they are arrays of Objects, not primitives, accessed by function calls. Java does something called Autoboxing to allow you to access these values without explicitly calling a function, but there is still a real performance cost associated with using Objects instead of primitives. In addition, ArrayLists have an extraneous range check, as you can see in the get() method of the source code here: Source for java.util.ArrayList Bubble Sort is generally only a good choice for tape drives, or implementations that, for whatever reason, behave as tape drives (which is rare). When random access is fast, there is no reason to use Bubble Sort. Its average time complexity is , much worse than other, algorithms. Since Bubble Sort only does adjacent comparisons, a tape must only move one cell backwards or forwards for each comparison, which is less expensive on tape than other algorithms' comparisons. Bubble Sort has O(n) performance if the input is already sorted, which could, conceivably, make it an appropriate choice under certain circumstances. 