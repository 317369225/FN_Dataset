What is the difference between bcrypt and general hashing functions like MD5?
EDIT (6/2/13): Marsh Ray made a great point in his comment below. Bcrypt is unfortunately an overloaded name: it's *both* a one-way hash functions for securing passwords and a cipher algorithm. As Michael Hamburg pointed out in his answer, the cryptographic hash function bcrypt is designed to be slow to discourage what are called "offline attacks". Going back to the playground analogy I gave toward the end of my original answer, the secret group doesn't trust outsiders. Eventually the outsiders get their hands on somebody's list of code words. The code words can't be decrypted to find the original message because they're simply hashes. However, if one of the outsiders can guess exactly what the original message said, they can check whether the guess hashes to one of the code words on the list. The solution? Generate *lots* of guesses and check all of them for correctness. With enough work they'll eventually find something that's both a plausible message and has a hash that matches one of the code words. No part of the outsiders' strategy depends on going to somebody in the secret group to confirm whether they figured out the secret. In fact, they could get a lot of the work out of the way even if they didn't already have the list. This is why whenever you hear about a website's database of user logins and password hashes leaking (happens *way* too often), it's especially scary if the password hashes are something fast like MD5. Consider trying to build a database of plausible passwords anybody may use and their corresponding MD5 hashes.  That's going to be a *lot* faster than generating a similar database for bcrypt hashes instead! Bcrypt is designed to take so long per guess that attackers have to invest so much in computational resources, hopefully more than such a database would be worth. Another important aspect of the bcrypt hash function is it has a tunable parameter that determines how much computational work (and therefore time) should be spent hashing the password. Keep in mind this is *not* a suggestion for the hash function to sleep for so long or something. Implementations of bcrypt should arrive at the correct output as quickly as possible, but getting the correct result requires more work as the work parameter increases. If attackers don't already know what work parameter was used by the secret group or website, a successful offline attack would involve guessing both the correct password *and* work parameter, further discouraging attackers from doing this. Actually, it's even worse for than that for the attackers. Bcrypt requires a "salt", which is just a random sequence of numbers that's covertly associated with each secret. The salt is yet another input to the hash function which affects the output, so really somebody doing an offline attack has to guess three things correctly to succeed: a password, the corresponding salt, and the work parameter. And if it's not known that the secret group uses bcrypt rather than some other cryptographic hash function, the attackers have to guess that too. Source: To learn more about bcrypt's motivations and how it works, I highly recommend reading the paper A Future Adaptable Password Scheme by Niels Provos and David Mazières. USENIX Technical Program - Abstract - USENIX 99 In terms of their applications, bcrypt and MD5 are very different.  Bcrypt is a cipher and MD5 is a cryptographic hash function. Cipher: Consists of two algorithms, one for encryption and one for decryption.  Encryption takes the data to conceal (and usually other inputs) to produce an unreadable version of the data.  The concealed data has enough information in it to get the original, readable data, but the best ciphers make this really difficult without privileged information.  The decryption algorithm takes the concealed data, along with any necessary privileged information, to return the original data. Cryptographic hash function: These functions take a string of any length and return a fixed-length string.  Whenever you input the same string you can expect the same result.  The best functions make it hard to find an input string that will generate a preselected hash string.  Also, the resulting string intentionally doesn't contain enough information to retrieve the original data.  As a result they're useful for identifying data and ensuring that data have remained unchanged. Suppose there are a bunch of kids on a playground who love to gossip in secrecy.  A small group has a great information source but doesn't want to let any of the information leak outside their group.  To overcome the problem, they invent a language and a means for translation.  Whenever they communicate sensitive information they use this new language.  The speaker has to "encrypt" the data and the listeners have to "decrypt" it, so their language is analogous to a cipher. Now let's suppose sometimes when information is shared within the group, some group members aren't around.  When the information sharer tells everyone, the group agrees on a code word that they'll use to associate with the new information.  What happens when one of these kids encounters one of the others who wasn't there for the original message?  Perhaps somebody else already told him/her, but we can't be sure unless we share the original message again.  ...Or wait, we can just see if he/she recognizes the code word for the message!  If he does, then we assume he already knows and if he doesn't then we tell him the whole message and the code word associated with it.  If the group chose a standard hash function like MD5 instead, they wouldn't even have to decide on code words anymore; instead they would just compute them for each message as needed.  Note that using a hash function requires that there is no variation in the message as it's conveyed.  In fact, the MD5 hash could be used to ensure the speaker and listener agree on what the message actually was. Alright, I'm going to teach some kids how to do MD5 in their heads so they always win the game telephone. Updated 3 Jun 2013 • View Upvotes