How does Python's built-in hash function work?
A google search found this link from 2002, which should still be relevant. All Python hash implementations are done with longs, and are then converted to int. A hash code of -1 is reserved to denote an error in the hash. Integers: returns the integer, or -2 if integer == -1 Strings: class string: def __hash__(self): if not self: return 0 # empty value = ord(self[0]) << 7 for char in self: value = c_mul(1000003, value) ^ ord(char) value = value ^ len(self) if value == -1: value = -2 return value (c_mul essentially implements overflow in Python) Tuples: I haven't found the implemention in the Python source code, but it should be similar to this version (which is accurate up to Python 2.4, apparently.) class tuple: def __hash__(self): value = 0x345678 for item in self: value = c_mul(1000003, value) ^ hash(item) value = value ^ len(self) if value == -1: value = -2 return value Decimals: I didn't find the implementation for floats, but Python has a built-in Decimal class that handles arbitrary size, and the hash gives the same hashcodes. def __hash__(self): """x.__hash__() <==> hash(x)""" # Decimal integers must hash the same as the ints # # The hash of a nonspecial noninteger Decimal must depend only # on the value of that Decimal, and not on its representation. # For example: hash(Decimal('100E-1')) == hash(Decimal('10')). if self._is_special: if self._isnan(): raise TypeError('Cannot hash a NaN value.') return hash(str(self)) if not self: return 0 if self._isinteger(): op = _WorkRep(self.to_integral_value()) # to make computation feasible for Decimals with large # exponent, we use the fact that hash(n) == hash(m) for # any two nonzero integers n and m such that (i) n and m # have the same sign, and (ii) n is congruent to m modulo # 2**64-1. So we can replace hash((-1)**s*c*10**e) with # hash((-1)**s*c*pow(10, e, 2**64-1). return hash((-1)**op.sign*Page on Op*pow(10, op.exp, 2**64-1)) # The value of a nonzero nonspecial Decimal instance is # faithfully represented by the triple consisting of its sign, # its adjusted exponent, and its coefficient with trailing # zeros removed. return hash((self._sign, self._exp+len(self._int), self._int.rstrip('0'))) So, decimals are considered as a tuple for hashing. Also, self._int is a string, not a number. Updated 23 Jan 2014 â€¢ View Upvotes