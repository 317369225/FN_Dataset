What is the fastest secure hash function recommended for general purpose use on x86?Needs to be both collision and preimage resistant. This is a follow-up question to How secure is MD5?.
MD5 might be fast but it's broken since long time ago. Even letting the illustration of secondary preimage attack for creating rogue CA certificates. SHA-1 is also broken. Collisions can be generated with 2^69 operations instead of 2^80. It might seem practically impossible but cryptographically this collision attack makes it 2048 times easier to find one. So it's broken :) Currently there are no know attacks against SHA2-256 and RIPEMD-160. Neither preimage, nor secondary preimage (weak collision) or strong collision attacks. Actually you already have the required tool to test the speed of a particular cryptographic hash function for your platform by using OpenSSL. Well, your choices are limited with supported algorithms in OpenSSL but hey, do you really want to use some non-standard, exotic CHF anyway? The OpenSSL command 'speed' will help us. Example: $ openssl speed sha256 You can see the list of supported algorithms with the command: "openssl speed --help" You're not only bound to hash functions but can also test symmetric-key and asymmetric-key algorithms. For the lazy reader, I created a spreadsheet and some nice bar chart galore comparing MD5, SHA-1, RIPEMD-160 and SHA2-256 algorithms with different block size inputs. http://spreadsheets.google.com/p... Raw results are available at http://gist.github.com/446104 The answer to your question is RIPEMD-160. Would I use it if I was in your shoes? Probably not... SHA2-256 is a standard and will continue to be. RIPEMD-160 can be secure enough with 160 bits and faster than 256 bits SHA2-256 but it might not be supported in the future or on a 3rd party's platform. Look at the graphs, run your own openssl speed tests on your target platform and think about your block sizes. Look at the results again and decide if it's worth the adventure... Updated 18 Mar 2011 â€¢ View Upvotes