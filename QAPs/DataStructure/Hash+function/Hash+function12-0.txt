Hash Functions: What is an intuitive explanation of the HMAC algorithm?
Intuitive Answer HMAC  is a code that allows the recipient to verify both the data integrity and the authentication of the message. To see how HMAC works I'll use an analogy, suppose I put a secret message in an envelope and send it to Alice and suppose John wants to intercept it. Now consider these three scenarios I put the message in the envelope with a key (e.g. password), seal it, and send. John intercepts my envelope, opens it, and reads my message. This is the problem with basic authentication (BA).BA:  Message + Key Now, I decide to encrypt the message by hashing it with a secret key (you can find more on hashing on wikipedia). Now the message is a code that only Alice can understand. John intercepts the envelope, opens the message and sees nonsense. However, he assumes that the contents include a message and a key in some form. Due to the properties of hash functions, John can also create a valid code and send it to Alice as an impostor. This is the so-called message authentication code (MAC). MAC:  Message + Key -> Hash(Message + Key) -> Secret Code Since John can reproduce the same secret code, I want to obscure that as well. HMAC takes "Secret Code" and hashes it again to make another code in the following way HMAC:  Message + Key -> Hash(Message +Key) -> Secret Code 1 -> Hash(Secret Code 1 + Key) ->  Secret Code 2. Turns out John can't reproduce or read Secret Code 2. More Info MAC A message authentication code (MAC) solves the problem of someone opening your envelope and getting your info by taking your key and running it through a hash function, which acts like a sort of scrambler. Now, the hacker opens the intercepted envelope and reads a bunch of nonsense that only the server can decipher, so problem solved, right? Not entirely, smart hackers can decipher MACs. Here's why: Let MAC = H(message | key) where H is the hash operation and | is concatenation. H suffers from the flaw that it is possible to append data to the message and make another valid MAC without even knowing the key. Well, we can try to get around this by doing H(key | message ) or H(key | message | key), but it turns out these methods have similar flaws. HMAC  Keyed-hash message authentication code (HMAC) solves the MAC problem with the solution HMAC = H(key | H(key | message))  Or in terms of MAC we have HMAC = H(key | MAC), so you're just hashing the MAC output code again with the secret key. Now, you can no longer create a valid MAC since it is masked by a hash function. The only reason the hack worked with MAC is because the attacker got access to the scrambled (key | message) pair and played around with it. With the extra hash, this information is no longer available. 