How do I implement a binary tree or hash function?
The two concepts aren't very related. A Binary Tree is simply organising a list of items such that you start with one called a root. Each item then can refer to 0, 1 or 2 subitems (called left and right branches). To visualize it it looks something like this: You generally implement this using something similar to a linked list (other ways are also possible, this this is probably easiest to understand): Create each item (node) as an object or structure with 3 fields: value, left, right. You always keep a reference to the root (1st) node. Then adding to that tree you decide how you fill it (that's dependent on your own choice). Usually with something like a BST (Bynary Search Tree) you'd compare the new item to the root's value, if it's less-than then you continue to the left node, if not continue to the right. If there's nothing stored there add the new node as that (either left/right). If there's already a node in that spot, repeat from that node as if it's the root. A Hash function is simply taking one piece of data and then using some formula to calculate a value from that. There are various formulas you can choose or even invent your own. Hashing has many uses, e.g. encryption, access security checks, error detection, etc. But I think the only one which relates to trees is using it in hash tables. To implement you start with a hash function you've chosen / created together with an array which you keep adjusting size as more items are added (usually keeping the array larger than the needed count). You use the hash function to calculate the position any item needs to be placed into / found in that array. If the function gives the same position for two different items you have discovered a "collision". There are basically 3 ways to alleviate such scenario (you can use any combination of them also): Attempt to modify the function such that these clashes don't happen. Recalculate the hash to produce a new hash code so it gives you a 2nd alternate position. Use buckets in each position in the array, so clashing items are stored in a bucket. These you can implement as arrays themselves, or lists, or whatever other collection class you choose. 