Why do bloom filters have multiple hash functions?
Additional hash functions help decrease the chance of a collision, and therefore, increase the certainty of your queries. For example, suppose you have a bit array of size 10.  Now suppose you have two numbers: a=5  and b=55  .  Maybe your hash function is x mod 10  .  Then both a  and b  hash to 5.  Suppose you insert a  into the Bloom filter and test to see if b  is present.  Your query on b  will say that b  is in the Bloom filter since the bit at index 5 is set to 1  . Now, suppose we have two hash functions.  Maybe the first hash function is x mod 10  , and the second hash function is (⌊x/2⌋+1) mod 10  .  If you insert a  , it will set the bits indexed by 5 and 3 to 1  .  Now, if you test to see if b  is present, it will correctly return false since the bits indexed by 5 and 8 are not both 1  . A more explicit explanation of the paragraph above: hash1(a)=5 mod 10=5  hash2(a)=(⌊5/2⌋+1) mod 10=  3 mod 10=3  hash1(b)=55 mod 10=5  hash2(b)=(⌊55/2⌋+1) mod 10=  28 mod 10=8  If you read up on Bloom filters on Wikipedia, you will see that (m/n)ln2  is the optimal number of hash functions to have for an m  -bit Bloom filter storing n  numbers. Updated 14 May 2014 • View Upvotes