Which is the fastest yet "random" hash function?
Unfortunately, you're dealing with a very difficult problem. First of all, you need to know how to extract randomness from your data. In order to do this, you need to treat your data like a number and think about how it's distributed between 0 and 2^n-1 assuming that it's limited at n bits. Then you need to find a transformation that outputs a bit string with the maximum entropy (see enwp.org/entropy) from an input in the set of inputs you're looking to hash. Since you want k hashes - I'm unsure why unless you're using a bloom filter or cuckoo hashing technique - you need to know a little about sampling without repetition. You see, in order to minimize collisions you need to choose locations in your array that are separate from each other. Since you're generating k hashes, you can guarantee that at least those k will not map to the same locations. That coincidentally requires less entropy than allowing them to map to the same locations. The problem is that it is more complicated to do. The next problem you run into is that you will be very lucky to find a k, entropy of input, length of array combination that leads to a perfectly uniform distribution. If you are optimizing for uniformity you will most likely not achieve perfection. Here's why: Your hash function outputs a bit string uniformly distributed between 0 and A. It gives log2(A+1) bits of entropy. That hash function's output is mapped into k locations in the array. The entropy required for this operation is log2(B choose k) where B is the length of your array. If A+1 != a natural multiple of B choose k, you will have unevenness in your distribution and certain locations in your array will be favored over others. The question of speed is now an afterthought after taking the above into account, however I would recommend a LUT so as to trade memory for speed. 