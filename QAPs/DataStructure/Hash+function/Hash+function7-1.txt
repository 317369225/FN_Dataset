Why can't hash functions be reversed?
They can. Generally the objective for a Hash function is that it maps from your dataset to your buckets as uniformly as possible (so as to minimise collisions), being reversible is irrelevant for "hashing". (% N makes a fine hash function for N buckets.) However, for a Cryptographic hash function the whole idea is to make it infeasible to invert (basically this means that it's unreasonably expensive to brute force and there are no "tricks" to solve). (% N makes a *terrible* cryptographic hash function.) Some cryptographic hash functions are later found to be broken (that is, feasibly reversible), and IMO it's probably safe to assume that a function will be broken eventually. There is a long list of cryptographic hash functions, although many have been found to be vulnerable and should not be used. Even if a hash function has never been broken, a successful attack against a weakened variant thereof may undermine the experts' confidence and lead to its abandonment. For instance, in August 2004 weaknesses were found in a number of hash functions that were popular at the time, including SHA-0, RIPEMD, and MD5. This has called into question the long-term security of later algorithms which are derived from these hash functions â€” in particular, SHA-1 (a strengthened version of SHA-0), RIPEMD-128, and RIPEMD-160 (both strengthened versions of RIPEMD). Neither SHA-0 nor RIPEMD are widely used since they were replaced by their strengthened versions. The example of Password hashing is usually made more difficult to break by storing a salt, a variable also passed to the hashing function, for each user (which means that you have to break each user's hash individually, and can't use "rainbow tables"), and using algorithms, like bcrypt, which are inherently slow and difficult to parallelize, see a security.stackexchange answer about bcrypt. (Note: best practises will likely change at some point in the future.) 