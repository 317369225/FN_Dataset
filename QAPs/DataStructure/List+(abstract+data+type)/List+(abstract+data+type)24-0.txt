How do data types in programming languages help in building software?
Oh, good question. I am going to assume here that by "data types" you mean "a particular representation of some data," rather than "the type in a particular type system," that way I can explore both how dynamic languages and statically typed languages approach the problem. What is type, and what is data? Languages fall into two categories: typed and untyped (or uni-typed¹). In a typed language, expressions have different types, and when combining a particular expression the types must align. That is, if you have an expression of type `Number + Number`, it's not possible to write `"foo" + 1`, because the subexpression `"foo"` would not have the type `Number`. In an untyped language, all expressions have the same type, therefore one has no constraints in how expressions can be combined (except for the language's own grammar). So, in an untyped language, `"foo" + 1` is a perfectly valid construction, because that expression's type is `Object + Object`. Dynamic programming languages are untyped. Note that expressions have types, not values! That is, we don't have types for the data itself, only for its syntactical representation in the language! If that's the case, then, what is data? And more important, what would be a data type? Data would be a particular piece of information. Numbers, text, lists, signals, pictures. They're all pieces of information. The interesting part begins when we have to talk about that information in a computer. Our computers don't know what a "number" is, or what "the picture that is used for this user's profile" is, so if we want to talk about any of those pieces of information, we need to represent them somehow in a way the computer can understand². Turns out we're rather limited in this area because existing computer architecture can only represent things as sequences of bits. So, if one were to look at a particular slice of a computer's memory, they would have no way of telling what the sequence of bits `1110010100010001110` means! Is it a number? Some text? Part of a picture? There's only one way to know: Data types A data type (here divorced from the concept of "type" in a type system) primarily tells you how to interact with a particular piece of information. Additionally the data type might tell you how that information is represented as more primitive things, or how to interpret a particular more primitive things as that data type (and whether that is a valid interpretation!). Those primitive things could be a sequence of bits, or just different structures in the same language (for example, one might represent a Map structure as an array of tuples). A data type that only tells you how to interact with a particular piece of information, but doesn't tell you how that information is stored, manipulated, or retrieved concretely is called an Abstract Data Type. ADTs are interesting because you can switch the implementation by another without changing anything else in your program, if you're more concerned about performance or space in a particular context. There are a few major reasons that make data types fundamental in programming languages: Correctness: data types ensure that the interactions with a particular piece of information are always correct. It's easier to guarantee that manipulating a string always result in correct strings, than that manipulating vectors of bytes ending in a null byte result in the same thing. Performance: different data types might be encoded differently such that one is able to interact with them in more efficient ways. For example, if all numbers were encoded using infinite precision, multiplication would be really slow. Encodings such as "byte", "integer32", and others ensure that working with smaller numbers can be done in a much faster way. Memory usage: sometimes related to performance, sometimes not (depends on the context), how much space a particular representation of the information takes might affect directly certain applications of it. Succinct Data Structures³ are being researched quite a bit today because of this. While performance and space are interesting topics when talking about data types, I'm going to focus the rest of the answer on correctness, which is where most of my interest lies, and because it's also what I'm more familiar with. Data and programs Data is one of the most important parts of programming. Usually, data is what our programs are all about! Structure and Interpretation of Computer Programs even starts by stating so: (...) Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called data. The evolution of a process is directed by a pattern of rules called a program. People create programs to direct processes. In effect, we conjure the spirits of the computer with our spells. So, if programming is the act of directing processes such that they might manipulate data, it's important that these processes manipulate data in an efficient and correct way. In this view, modelling data such that it can be manipulated correctly is an integral part of all programming tasks, and data types are essential for that kind of modelling. Data types mostly falls out in scalar (single values, like numbers, strings, and booleans), and compound (values that are made out of other values, like lists, maps, and trees). Compound values may be either product types, which model the existence of all parts of the type at the same time (like tuples and vectors), and sum types, which model the existence of alternative representations of the type, with only one representation existing at any given time. (* A record holding information about an URL *)type url = {  protocol : string,  domain : string,  path : string list,  query : string * string list}(* A sum type representing possible results of a query *)datatype request_result =  SUCCESS of url list| NOT_FOUND| DATABASE_ERROR of string In the previous example, an URL is made out of protocol, domain, path and query, but all of that information is always available. A Request Result, on the other hand, can be either a Success (with the list of URLs returned), a Not Found, or a Database Error (with a description of the error), but it can never be both a Success and a Not Found. While sum types are essential for correctly modelling data and interactions with that data, most programming languages only support product types, and you have to emulate sum types somehow. In Java, for example, you'd be able to do it by using class hierarchies and subtyping: abstract class RequestResult {}class Success extends RequestResult {  private List<Url> urls;  public Success(List<Url> urls) { this.urls = urls; }}class NotFound extends RequestResult {}class DatabaseError extends RequestResult {  private String reason;  public DatabaseError(String reason){ this.reason = reason; }} In an object oriented language, you'd be able to do it by using dynamic dispatching, where all objects respond to the same message in different ways: var Success = {  get: function(pattern){     pattern.Success(this.urls)   }}var NotFound = {  get: function(pattern) {    pattern.NotFound()  }}var DatabaseError = {  get: function(pattern) {    pattern.DatabaseError(this.reason)  }} In Clojure you would usually use a vector with a tag, and deconstruct the rest of the data based on the tag. This is also used in C for representing objects, and commonly used in the implementation of dynamically typed languages: (defn success [urls]  [:succes urls])(defn not-found []  [:not-found])(defn database-error [reason]  [:database-error reason]) Products, Sums and Coherence You might be asking yourself if all these mathematically sounding words, such as products and sums are actually useful in writing real world applications. Perhaps you have never heard of them and is now wondering how they could help you. The thing is that how you model your data also affects how you interact with it. And to interact correctly with an information, it's important to have coherence⁴. Let's go back to the URL scenario before. Imagine you have to make an HTTP request to a particular URL, but your programming language does not support any form of product type. Here's what you would write: let protocol = "http"let domain = "www.google.com.br"let path0 = nil let query_key0 = "q"let query_val0 = "google"(* 0 and 1 stand for the number of paths/query arguments *)let results = GET(protocol, domain, 0, 1, query_key0, query_val0) That example is already really bad as it is (but we do use something similar to serialise data in binary formats!), but it could be even worse. Imagine if you had to deal with many URLs at once and do some URL resolution as if a user had navigated from one to the other? Can you imagine doing that this way and getting it correctly every time? Particularly, I don't think I would be able to do that. The same thing is true of sum types⁵. We could model sum types poorly in a language that only has product types, and most people get by doing just that (I imagine those people would also be able to cope with a language not having product types by doing the thing above), but it's far from the ideal way of modelling that data: public class Result {  public List<Url> urls;  public boolean notFound;  public String databaseFailureReason;  public Result(List<Url> xs, boolean a, String b) {    this.urls = xs;    this.notFound = a;    this.databaseFailureReason = b;  }}Result res = getResult();if (res.notFound) {  /* handle cases where no results were found */} else if (res.databaseFailureReason != null) {  /* the database failed, maybe retry? */} else {  /* our records are PROBABLY safe to handle here* */}// *unless someone did new Result(null, false, null) Conclusion Data types are extremely important in programming because they allow us to model data in ways that directly impact how we use that data. This has implications on the amount of memory necessary for running a program, how fast that program can be executed, and how easy it is to reason about the program and manipulate data correctly. Plus, sum types are awesome. Use them (where they make sense)! Footnotes: ¹: Harper argues, in Dynamic languages are static languages, that dynamically typed languages are actually statically typed languages with just one type. This view is countered by Sam Tobin-Hochstadt in On typed, untyped, and “uni-typed” languages, on the ground that it doesn't help understanding how people use dynamically typed languages and reason about their programs in them. Similar defenses have been done by Matthias Felleisen (as described in Rahul Goma Phulore's answer to What is something possible in dynamic type programming, which is not possible in Scala?) and Quildreen Motta's answer to What are the arguments against Robert Harper's view of untyped languages as unityped languages? ²: The problem of types, data representation and abstraction is very neatly covered in Cardelli's "On Understanding Types, Data Abstraction and Polymorphism" (http://lucacardelli.name/papers/...), and further refined on Cook's "On Understanding Data Abstraction, Revisited" (http://www.cs.utexas.edu/~wcook/...). ³: Edward Kmett has an interesting video on Succinct Data Structures, with some introduction to the concept, and there might be some more thorough or introductory material on them elsewhere, unfortunately they're not something I'm too familiar with. ⁴: Daniel Spiewak has a great talk about the importance of data coherence in designing correct applications: ⁵: For more information on how sum types can be used to correctly model interactions with data structures in a program, see the blog post Worked example: Designing for correctness 