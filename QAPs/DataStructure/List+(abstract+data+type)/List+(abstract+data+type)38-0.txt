What kind of programs are best written in Haskell?
Compilers. The reason is that compilers tend to operate on structures (syntax trees, intermediate representation trees) that are best expressed in a language that has some sort of algebraic data types. Let me explain what that means by example. An example of why you might want an algebraic data type is if you are writing a little interpreter that deals with arithmetic expressions. Say each arithmetic expression is either a number or two arithmetic expressions with a plus sign in between or two arithmetic expressions with a minus sign in between. What you want to be able to do is (1) build arithmetic expressions and (2) write algorithms that operate on them. We'll gloss over the parser that builds the expressions. In a language like Haskell, that would look something like this: data Expression =   Number Integer  | Plus Expression Expression  | Minus Expression Expressionan_expression =   Plus (Minus 3 4) (Minus 2 (Plus 1 1))evaluate exp =  case exp of    Number i -> i    Plus x y -> (evaluate x) + (evaluate y)    Minus x y -> (evaluate x) - (evaluate y) As you can see, when we define what the Expression type looks like, we specify three different structures that a value of type Expression might have. Each value of type expression will be labeled, so we know which kind of expression we're dealing with. Now, when we are dealing with a value of type expression, we'll always have to write three pieces of code, for dealing with all three cases. This is precisely the way that a lot of algorithms inside a compiler work. Take for instance this data type representing a C program https://github.com/jaapweel/piff... and this algorithm that does some simplifications on values of that type https://github.com/jaapweel/piff.... But until recently, there were no languages that supported writing such algorithms in a natural style other than ML and its derivatives (Standard ML, OCaml, Haskell, Clean, etc.) Recently, Scala has been added to that list. If you are writing a compiler in Java, the most natural way to deal with algorithms that look like the above is to have an Expression class with subclasses NumberExpression, PlusExpression, and MinusExpression. The Expression class would then have an abstract evaluate() method that would be specialized in all three subclasses. That means that what is logically one algorithm is now spread all over your code. You can get around that using the Visitor pattern, which ML and Haskell programmers tend to think is nothing but a big kludge to get around the fact that Java does not have algebraic data types. (Disclaimer: yes, of course Lisp is so flexible that it can easily be made to do this, or anything else. But it won't check your types.) 