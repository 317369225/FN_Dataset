How can I solve this problem? Please help!
I think this can be solved using Dynamic Programming  . P.S. I will try to deal with a more generalised version of the problem. (where a vertex can have any number of vertices connected to it ) . Given : the graph is a tree ; has (n-1) has bidirectional roads each one associated with a positive weight . Root the tree at 'C'. Now you need to visit (say) 'm' other vertices . Let the vertex 'C' have subtrees T1,T2,T3....Tk. Now you need to allocate 'k' integers (say a1,a2,a3...ak) such that we shall visit 'ai' vertices in the subtree rooted at 'Ti' . So there are a hell lot of combinations . This can be solved using DP . Let us define a DP state as follows : For vertex i' , dp[j][k] = minimum cost for covering 'k' vertices from the first 'j' subtrees of 'i' . DP transition : Lets take a vertex 'i'. (assuming DP values have been calculated for all its subtrees (T1 to Tk) ) . Initially :  j=0 , dp[j][0]=0;                           dp[i][1]=0;                   // the vertex 'i'  is visited already                           dp[j][x]=INF for x!=0,1 Now for each j=1 to k: Suppose we need to calculate dp[j][x] . We can allocate 'y' vertices to the subtree Tj and 'x-y' vertices to the subtrees (T1 to T(j-1)) , both of which we know already . In this way we populate the entire DP table. The pseudocode of the function goes like this : calc(int C)                                                // vertex 'C' {    dp[C][0,1]=0;    dp[C][x]=INF  for all x!=0,1;    for(i=1;i<=k;i++)                                 //  for all the children of 'C'        {      temp[0 to m]=dp[C][0 to m];          //  initialising array 'temp'      calc(i);      for(int j=1;j<=x;j++)                         //  For temp[j] or DP[C][j]      {        for(int l=0;l<=j;l++)                       //  Allot 'l' vertices for subtree 'Ti'        {                temp[j]=min (  temp[j] ,                      ((l!=0) ? (2*cost((C-Ti) edge)) : 0) +dp[C][j-l]+dp[Ti][l] );          }       }           dp[C][0 to m]=temp[0 to m];    }    return ; } Now call calc(C) and answer will be dp[C][m] . More resources on DP in trees : DP on Trees Tutorial - Codeforces P.S. This is my first answer in Quora.Correct me if I were wrong anywhere :) 