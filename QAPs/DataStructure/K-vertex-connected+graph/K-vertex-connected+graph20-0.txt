What are some examples of Graph Algorithms being used to solve interesting problems?
2-satisfiability In the general satisfiability problem, we are given a bunch of constraints over binary variables, and we would like to know if there is an assignment to the variables that respects all given constraints. In the 2-satisfiability problem, every constraint involves at most two variables. This problem has several applications of its own (in that many natural problems can be formulated as 2-SAT instances). A linear-time algorithm for the problem involves formulating the instance as a graph where the vertices correspond to literals (variables and negations of variables), and using directed edges to model implications from the constraints. Given this modeling, the problem boils down to finding strongly connected components, which in turn is an application of DFS. This is an algorithm from 1979, due to Aspvall, Plass & Tarjan. [Wikipedia] 2-satisfiability Deadlock Recovery using Feedback Vertex Set The feedback vertex set (FVS) problem on a graph asks for the smallest subset of vertices whose removal makes the graph acyclic. While the problem itself is NP-hard, there are several better-than-trivial exact algorithms and it also admits a polynomial-time 2-factor approximation algorithm. The FVS question models the deadlock recovery problem closely - when we have a set of processes with dependencies, then it is natural to define a graph where the processes are vertices, and there is a directed edge from process A to process B if A is waiting for B to finish. (This is called the Wait-for graph.) In this formulation, every cycle corresponds to a deadlock, and a FVS would correspond to (one of) the smallest set of processes that need to be killed to break all deadlocks.  There are countless examples along these lines, I'll just state a few more (for now), in no particular order. Graph layout algorithms have frequent applications in VLSI design. See this survey: ftp://ftp-sop.inria.fr/coati/per... Graph cuts (and essentially, the maximum flow algorithms that yield cuts of minimum size) are extensively applied to problems that arise in the context of computer vision: http://en.wikipedia.org/wiki/Gra... Perfect Matchings in bipartite graphs is used to analyze d-ary Cuckoo Hashing. See, for instance, this paper: Page on Www Many scheduling problems can be solved using an appropriately formulated vertex or edge coloring instance - see Edge coloring and Graph coloring. Single-linkage clustering is essentially a variant of Kruskal's algorithm. While not an algorithm per se, I found it quite fascinating that the problem of monotonicity testing admits a nice algorithm whose analysis uses facts about vertex covers and matchings in a certain violation graph. More here: http://www.cse.psu.edu/~sofya/pu... The following example doesn't apply a graph algorithm to solve a problem, but it is a fairly fascinating application of basic graph theoretic notions "applied" to prove a theorem, so I thought it'll make an interesting addition. The Amitsur–Levitzki Theorem This particular example occurs at the end of the first chapter of Bollobas' text, Modern Graph Theory, to illustrate that very simple notions from graph theory can come in handy for establishing non-trivial results. This particular result is about what are called polynomial identities. The commutator of two elements a,b of a ring [math]S[/math] is [math]ab - ba[/math]. Further, if [math]a_i \in S[/math], [math]1 \leq i \leq k[/math], then we write: [math][a_1,\ldots,a_k] = \sum_\sigma sgn(\sigma) a_{\sigma 1 \sigma 2 \cdots \sigma k}[/math] where the sum is over all permutations [math]\sigma[/math] of [math]\{1,2,\ldots,k\}[/math]. If [math][a_1,\ldots,a_k] = 0[/math] for all [math]a_i \in S[/math], If [math]A_1,\ldots,A_{2n}[/math] are any [math]n \times n[/math] matrices with entries in any commutative ring, then [math][A_1, \ldots, A_{2n}] = 0[/math].  I won't go into the exact graph theoretic formulation here, but I'll hint that it has something to do with the fact that matrix products have an interesting correspondence with walks in a graph. The proof is certainly elementary and in some ways perhaps more transparent/visual than the original algebraic proof, with intuitive geometric notions replacing algebraic definitions. [Reference] An Application of Graph Theory to Algebra: Page on Ams 