How does static program analysis work?
The technical term is symbolic execution.  It's very similar to model checking, except that (a) the input language is typically ill suited to the purpose and (b) data values are less precise.  In brief, the steps are: Create a flowchart-like execution graph with conditionals creating forks, loops pointing backwards, etc. Walk through the graph, following all data-dependent conditions.  For example, if the condition is "if (x > 20)" and the value of x is completely unknown, then you follow the positive path with x as "anything > 20" and the negative path with x as "anything <= 20".  Often you'll have to unroll loops and such to track different paths as the values change. Apply heuristics to reduce the state space.  As with model checking, the number of states you're dealing with can rapidly get out of control, so you end up using all sorts of tricks to recognize and combine functionally-equivalent states. At each step, apply correctness tests.  Some tests check a variable's current value vs. current use (e.g. dereferencing a null or possibly-null pointer).  Others test all variable states at any function return (e.g. memory leaks).  Still others don't fit into either category (e.g. dead code, infinite loop).Writing a serious static analyzer is a lot like writing a serious compiler, easier in some ways (no need to worry about execution time) but harder in others (exploding state space).  Everywhere you turn, there are new kinds of things you'd like to check for but you can't even be sure if they're expressible let alone decidable.  If you want a serious challenge, it's a great place to be. 