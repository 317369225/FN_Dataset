Is F# a really well designed programming language among ML family?
F# is a very well designed pragmatic ML-like language. F# departs from other MLs in several important ways. The FFI to C# and the rest of .NET is so closely integrated into F# that the string and array types are actually the .NET string and array types so, for example, they permit null which is something no classic ML would do. In practice this is rarely an issue and null reference exceptions are almost unheard on in F#. MLs are notable for their sophisticated higher-order module systems. In contrast, F# does not support higher-order modules at all. F# offers only first-order modules with comparable form of abstraction. F# supports object-oriented programming, of course, but primarily for interop with the rest of .NET. In practical terms the lack of a higher-order module system is most felt when you want to abstract one collection type over another, something most commonly done in the context of graph algorithms. F# also differs from ML in some important ways: F# is the only ML-like language to offer values types and reified generics, two features that when combined permit much more efficient solutions to common problems such as hash tables (see Hash table insertion performance: F# vs OCaml vs Haskell). F# adopted a beautifully-pragmatic solution for user-defined operator overloading. OCaml has no overloading at all. SML overloads for pre-defined types (e.g. int and float but not complexes, vectors and matrices). Haskell's type classes allow arbitrary overloading but is unpredictable and often results in substantial slowdowns. F# is the only FPL with Intellisense. This feature of Visual Studio makes it vastly easier to explore APIs. In contrast, with OCaml I was constantly trawling through the documentation using ocamlbrowser in another window using its lame Tk-based user interface. .NET makes it very easy to write a wide variety of useful programs such as GUI applications in F#. This is nightmarishly difficult in languages like OCaml, SML and Haskell by comparison. I have found F# to be far more reliable than OCaml when using third-party libraries that are written in other languages. Specifically, F# has seamless interop with the entire .NET ecosystem thanks toÂ  a common-language runtime which includes a great many useful libraries. In comparison, OCaml has poor interop with libraries written in other languages. For example, when I tried to use OpenGL from OCaml I found bugs in Xavier Leroy's automated FFI generator, I found bugs in Jacques Garrigue's hand-written OpenGL bindings, I was not able to write working bindings myself due to poor FFI documentation and when I shipped OpenGL-based OCaml code it was plagued with bugs on other people's computers to the extent that I had to shelve the entire product line. In contrast, I have shipped many F# applications and rarely had any such problems. F# inherits a really nice virtual machine and garbage collector from .NET. In particular, the .NET GC is better than the GCs in any of the other languages you've listed.I would say that F# is definitely worth learning if you want to develop serious applications using an FPL. On a related note, I have found the F# team at Microsoft to be far more responsive to bug reports, fixes, benchmarks and other contributions that I have made compared to the OCaml team. I found a great many bugs in OCaml when I was using it. For example, if their regular expression library found many matches then enumerating over them would cause a segmentation fault due to a stack overflow. I debugged it myself, rewrote their code to fix it with no measurable performance degradation and provided INRIA with the complete solution but it took 3 years for that fix to get back to me. In contrast, when I found bugs in F# they were always fixed promptly for the next release. I have also found Microsoft to be much more responsive to feature requests. For example, I asked Microsoft to add support to (early) F# for pattern matching over records and they added it. When I asked INRIA to add features to OCaml they didn't. 