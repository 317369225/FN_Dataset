What's the hardest bug you've debugged?
There was this one bug that kept awake for quite some days. Basically the box was crashing at boot. We had the same software running on multiple platforms/processors and this was seen only in only one platform which has a ppc processor. It happened in release N+1 , but not in N. The difference  in N and N+1 was some new code that was not executed at boot at all. Frustratingly, the crash never used to happen at the same  point in code , but at different points in code. Hence the general suspicion was there was some random memory corruption. But all attempts to find a pattern/hints in the crashes was futile. And suddenly one day pretty late in the night when I was looking at the crash dump in gdb helplessly, I realized that it was a value in the same register which was having a bogus value. Also I figured out that the crash  happened right after an interrupt had occurred. I was pretty confident that something was amiss with the interrupt handler and  that the registers were not being saved/restored correctly in the interrupt winding/unwinding code. At that time I was not familiar with ppc instructions at all, but that's the beauty of RISC.  I could bootstrap very easily.  But after spending many hours I found that ISR codes looked clean and neat. I had again hit a roadblock and that is when I decided to keep my ego aside and ask my friend for help. The chap acted as a wonderful "whiteboard". He asked me to list what all I had found and we had a clear picture of a "window" where the problem could be. The ISR code was actually a C function with inline assembly   SAVE_SOME_REGISTERS   A_FUNCTION_CALL   SAVE_OTHER_REGISTERS   do_something   RESTORE_REGISTERS SAVE_SOME_REGISTERS saved all the registers that would be used by a A_FUNCTION_CALL.  But in release N+1, some new code had been included that resulted in the offset between ISR code and A_FUNCTION_CALL to be bigger. In powerpc jumps are limited to signed 26-bit displacement. In this case the offset between the two pieces of code was greater than 2 ^ 26.  To achieve this one needs to compile with the --relax option. This results in the insertion of trampoline regions. See @PowerPC ELF32 - Untitled  This does what exactly what the name suggests. Jump to trampoline region and then jump to the function there so that all jumps are between the 26 bit offset.  But for this some additional registers are required which was not saved in SAVE_SOME_REGISTERS. Hence those registers got clobbered and when we returned back from the ISR, when these registers were accessed the box crashed. It was a lesson in humility for me (without that white boarding session I would have been nowhere) ,but the entire experience was  extremely rewarding and frustrating at times. It won me some bragging rights for a while. 