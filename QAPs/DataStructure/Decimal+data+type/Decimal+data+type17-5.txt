What are the differences between the double and float data types?
The standard defines five basic formats that are named for their numeric base and the number of bits used in their interchange encoding. There are three binary floating-point basic formats (encoded with 32, 64 or 128 bits) and two decimal floating-point basic formats (encoded with 64 or 128 bits). The binary32 and binary64 formats are the single and double formats of IEEE 754-1985. They are represented as flat and double datatypes in Java float (binary32): occupies 4 bytes (32 bits) Can be divided into 3 parts : (from leftmost to rightmost bit) 1. sign bit : 1 indicates negative, 0 indicates positive or zero 2. exponent : 8 bits 3. significand precision : 23 bits IEEE Short Real exponents are stored as 8-bit unsigned integers with a bias of 127. Let's use the number 1.101 x 2^5 as an example. The exponent (5) is added to 127 and the sum (132) is binary 10000100. The binary exponent is unsigned, and therefore cannot be negative. The largest possible exponent is 128-- when added to 127, it produces 255, the largest unsigned value represented by 8 bits Before a floating-point binary number can be stored correctly, its mantissa must be normalized. The process is basically the same as when normalizing a floating-point decimal number. For example, decimal 1234.567 is normalized as 1.234567 x 10^3 by moving the decimal point so that only one digit appears before the decimal. The exponent expresses the number of positions the decimal point was moved left (positive exponent) or moved right (negative exponent). Similarly, the floating-point binary value 1101.101 is normalized as 1.101101 x 2^3 by moving the decimal point 3 positions to the left, and multiplying by 2^3 Say, s -> the value of the sign bit e -> the decimal representation of the exponent b[i] -> ith bit in the mantissa The corresponding decimal floating point number value is double (binary64) : occupies 8 bytes (64 bits) Can be divided into 3 parts : (from leftmost to rightmost bit) 1. sign bit : 1 indicates negative, 0 indicates positive or zero 2. exponent : 11 bits 3. significand precision : 52 bits IEEE long Real exponents are stored as 11-bit unsigned integers with a bias of 1023. Let's use the number 1.101 x 2^5 as an example. The exponent (5) is added to 1023 and the sum (1028) is binary 10000000100. The binary exponent is unsigned, and therefore cannot be negative. The largest possible exponent is 2^10 ie 1024 -- when added to 1023, it produces 2047, the largest unsigned value represented by 11 bits Before a floating-point binary number can be stored correctly, its mantissa must be normalized. The process is basically the same as when normalizing a floating-point decimal number. For example, decimal 1234.567 is normalized as 1.234567 x 10^3 by moving the decimal point so that only one digit appears before the decimal. The exponent expresses the number of positions the decimal point was moved left (positive exponent) or moved right (negative exponent). Similarly, the floating-point binary value 1101.101 is normalized as 1.101101 x 2^3 by moving the decimal point 3 positions to the left, and multiplying by 2^3 Say, s -> the value of the sign bit e -> the decimal representation of the exponent b[i] -> ith bit in the mantissa The corresponding decimal floating point number value is 