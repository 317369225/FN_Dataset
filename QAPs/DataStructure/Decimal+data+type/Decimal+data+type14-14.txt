What's the hardest bug you've debugged?
Positions 2-10 for me were all race conditions of various sorts, but it turns out that position 1 was not.  I was working at Revivio, which made a storage appliance, and we were trying to deal with some mysterious hangs.  These were hard hangs which would kill even our kernel gdb stub, so normal debugging wasn't possible.  I was wishing for some kind of hardware support so we could examine memory even though the CPU was out to lunch, when I realized we had it.  These machines were connected via IB, so I wrote some code to export one machine's kernel+vmalloc regions to another and wrote a little program to slurp that into an ELF file that gdb on the second machine could understand.  Those were two fun hacks all by themselves, but I wasn't done yet. In phase two, I started collecting dumps but they didn't make sense.  I started to notice that some kernel stacks were getting corrupted, e.g. with one frame pointing into the middle of another, and addresses (including code addresses) on the stack that could have nothing to do with each other in any possible call sequence.  I added guard pages and memory scrubs and extra pointer checks in various places, to no avail.  I sort of gave up and started looking at the few dumps where it seemed like a task struct had been corrupted instead of a stack (which I had previously written off as likely bugs in my IB/ELF hacks).  Finally I realized what was happening.  Sometimes a task would allocate so much in a single stack frame that it would jump all the way over the rest of its stack, all the way over its own task struct and any guard areas, into the next task's stack.  Then it would return happily, but the next time the "victim" ran it would explode. In phase three, I wrote a script to disassemble each of our many kernel modules and find large subtractions from the stack pointer.  I found and fixed not only the likely culprits for the hangs we were seeing, but many more that were likely to cause problems later. Moral of the story?  If you have people who aren't used to writing kernel code, review their work very carefully for things like stack abuse and synchronization/reentrancy problems that they never had to deal with on Easy Street, until they're fully trained. 