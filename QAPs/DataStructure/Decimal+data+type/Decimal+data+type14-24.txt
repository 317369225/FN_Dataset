What's the hardest bug you've debugged?
This isn't the hardest bug I've ever debugged... on an absolute scale. I've tracked bugs down to the compiler - and figured out what the vendor was doing wrong for them, in enough detail to point them at the compiler bug. On more than ten occasions, on everything from VC++ to xLC++. I've tracked a bug down to a kernel error (Linux 2.2 pthread bug) and discovered that glitches were in the hardware (68060 and a custom TI processor). I've debugged my own Linux kernel modules and libraries in the kernel on Windows. But this one was the worst I'd ever encountered at the time, and took longer to debug than anything I've faced before or since. And, notably, it was my fault, which has not been the case with any of the other really bad ones. I got hired by a company that needed to port a server, written in Windows, to Linux and Solaris (and eventually AIX and HP/UX). This wasn't the only reason they hired me, but it was the urgent requirement that made them need me desperately. I tackled the porting job, and my first pass was a little messy. I pretty much removed as much Win32 specific code as I could, then wrote emulations of the Win32 APIs I couldn't remove on top of a POSIX layer. This means I emulated the Win32 CRITICAL_SECTION and InterlockedXXX routines, ThreadStartEx, CreateFile, etc. I got the port working, and turned my attention to other tasks. Two years later, a report shows up of a crash on Solaris. It doesn't show up very often - once every several months - but the logs show that it has something to do with access attempts on a reference counted object that has been deleted. This is odd... that code has been working perfectly for a long time on all platforms, and the Linux implementation is the same as Solaris. I set up a test case in which references are created and released over and over again in multiple threads. On a four processor Linux machine, it never happens. On an eight processor Sun box, it hits - after two days. Well, crap. I look over the class implementation. Nothing. Then I look at the emulation of InterlockedIncrement and InterlockedDecrement. Nothing. I thought. On my tenth re-review, I suddenly noticed something. The shared object that synchronizes the increment and decrement functions... is shadowed. I had a copy-and-paste error, and had missed it over and over again. Increments are atomic, decrements are atomic, but increments and decrements on exactly the same instruction cycle are not. This is when I began my obsession with enabling and paying attention to every warning available. And over a decade later, I'm even more obsessed. Most of /Wall on VC++. -Wall -Wextra -Weffc++, plus several more including -Wshadow (which would have caught this bug) on gcc. -Weverything on clang. Static code analysis on for VC++ and clang. Defensive use of static_assert all over the place. Preconditions and postconditions. Essentially, anything to catch bugs when compiling, instead of trying to find them at runtime... 