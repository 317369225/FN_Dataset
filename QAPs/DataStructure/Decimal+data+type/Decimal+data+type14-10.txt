What's the hardest bug you've debugged?
Three.  All having to do with rare events. 1970: I worked on Data General Nova minicomputer serial number #3.  [The Nova was essentially the first RISC machine, with a stunningly odd set of  arithmetic instructions, including ADCZL# 2,3,SBN.  You don't have to  know what this means to realize  this is an odd machine]. We coded an assembly language device driver... that mostly worked.  Occasionally it would fail.  (We're doing debugging with front panel switches and a really bad debugger, remember that #3?).   It turned that an indexed branch with a negative offset would sometimes go to the wrong place... how?   I chased this for days before I got down to  an instruction sequence   "interruptdisable", "jmp -index[reg]", "interruptenable" where the problem occurred with relatively high frequency (but never when you single stepped it).   We decided that disabling interrupts set a flop near the ALU  (you know you are desperate when debugging code when you decide to look at the circuit diagram of gates that make up the CPU)  and the extra current demand would make the ALU math slightly flaky.   We sent the CPU back to Data General, they told us we guessed right, they fixed it and sent it back. Voila, problem solved.   Nice to spend weeks to find a design error in somebody else's hardware. Moral: don't depend on a flaky circuit design. 1974.  On a one-of-a-kind 16 bit VM minicomputer I and another fellow (Dennis Brown, hello!) designed had a fancy-shmancy register-chip in it to hold the CPU's registers.  I designed an assembler and linker for it; the linker would print a symbol table of names and corresponding addresses on a teletype at the end of the link edit step.    Sometimes... the symbol name would print out as complete garbage, but the address was fine and other symbols might or might not be fine.  Ultimately we found the culprit: the register-chip bits would turn from zero-to-one sometimes when it got really hot; it would only get really hot when the program was doing heavy duty math in the registers; and the linker was taking a radix-50 encoded symbol and tearing it apart by doing a repeated divide-by-50 (tight loop: compare, shift, subtract, repeat).    Problem went away when we blew a lot of air of the register chip. (Freeze spray? in 73?)  Cure: complain to the register-chip vendor, get a replacement chip. Moral: don't depend on a flaky chip. 2012-2014:  Using MS Windows, with working thread-switching code on Win32.  The thread switching code used MS Win32 API  commands to SuspendThread, GetThreadContext, SetThreadContext, ResumeThread.  This code was written around 1999 (yes!) and had been stable for 15 years(!).   On Windows Vista ... sometimes (once every few million times!) the app doing the thread switching would crash.  Try and find such a problem; it occurs abominably rarely and the symptom is "die horribly".  This almost made me tear my hair out.  I tried huge numbers of experiments, adding consistency checks in an astonishingly large number of places in the code, to little avail.  Eventually discovered it was Wow64 emulation of these formerly rock-solid calls.... GetThreadContext *lies* about the thread context, that is, it is supposed to return what is in the registers of a suspended thread, but sometimes returns trash.  This is incredibly hard to detect: what do you look at, to see that it is wrong?   I didn't debug this so much as recognize, via desperate web searches over 1-2 years, that another person had encountered the same problem; see WOW64 bug: GetThreadContext() may return stale contents.  Why didn't I notice on XP-64? Because there it *works*, at least I have run it literally billions of iterations without ever encountering a problem).   This is an unforgivable sin for an OS call: a system call for managing thread context that is simply unreliable.  To this day, MS has not fixed it; they say Windows 8.1 will tell you when GetThreadContext just lied to you, which is hardly a good cure.  [I have no evidence yet that Windows 8.1 tells me this reliably]. Moral: don't depend on a flaky software vendor.  (But hardware you can get fixed). 