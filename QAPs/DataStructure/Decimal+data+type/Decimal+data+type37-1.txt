Why would you append an F to the end of a value of a floating point literal in Java? (e.g. float ratio = 0.2363F;) Isn't that already specified in the data type "float"? What happens if I don't include the f? Does something similar happen in the integer data types?I'm learning java by myself reading some books. Im having some trouble understanding the following statement: "Java assumes that all floating point literals are of type double".
I think what you want to know is why use float ratio = 0.234F; instead of simply using float ratio = 0.234;. When the language is being interpreted two things need to be done syntax check and semantic check, to see if the statement makes any sense according to the grammar and context. Once the syntax check is complete semantic check begins where the interpreter checks if the meanings assigned to individual entities after the syntax check actually make any sense together. lets apply this to our problem... When the interpreter sees float ratio = 0.234; it knows what float means because its a reserved keyword it infers that ratio is an identifier = is an assignment operator 0.234 is a double literal and ; is a delimiter because that's just how the language has been defined. So the statement is syntactically correct but when the semantic check begins it sees that you are trying to store a 64-bit double literal into a 32-bit float variable which will lead to loss in precision so it will give you an error or a warning. Maybe you intended to do that but the interpreter is not going to take responsibility for a failed rocket launch just in case you didn't (something similar has actually happened in the past! see Cluster (spacecraft)) If you use float ratio = 0.234F; its fine because 0.234F is interpreted as a float in the first place. You also asked if something similar happens with integers. Implicit typecasting is the keyword here. public class test{ Â  public static void main(String[] args){ int a = 54; long b = 54; long c = 54L; } } ^this will run without errors or warnings, but what's the difference between 54 and 54L? When the interpreter sees 54 it infers a int literal(default behavior) being assigned to a long variable so it implicitly typecasts it into a long type but here no precision is lost so no warning or error is shown. So why use 54L then? come on! The interpreter helps you all the time why not give something back ;) 