How char is changed into int while doing calculation C?
No, a and b do NOT have the same value here. And it has nothing to so with char data type. You can get the same 'paradox' by assigning 0xFFFFFFFb to an int and an unsigned int and repeating the program (I assumed 32-bit int. If you are in TurboC or anything similarly prehistoric, you can use FFFb instead) See, you assigned the same hexadecimal number to both, but you asked C to interpret it in two different ways. Fb when written in binary reads 11111011. Now if you say this is a signed data type (which is what you do when you declare it as char), that means the left most bit is the sign bit. So here the sign bit is 1. Now as soon as C sees the sign bit is 1, it figures out the number must be in 2's complement form (it has high reverence for your intelligence. So it thinks you must have meant to input a negative number in a super clever way through hexadecimal). So now it goes about laboriously converting this number and comes up with -5. (-!(1111011-1)=!(1111010)=0000101). However when you say it's unsigned, C figures that you did really mean Fb, and does not think the first bit is the sign bit (because unsigned numbers by definition are positive. So it makes no sense to waste one bit storing the sign, when you already know the sign Â So first bit is part of the number now. Not a sign bit). So now it doesn't think the number is in 2's complement form either (only negative numbers are), and performs a direct binary to decimal conversion. That gives it a value of 251. Hence the two numbers become 'not same'. (And your idea of -53 I assume comes from interpreting the first 1 as sign, and then directly converting the rest? Modern computers always store negative numbers in 2's complement form. So C will never convert 0xFb to -53). 