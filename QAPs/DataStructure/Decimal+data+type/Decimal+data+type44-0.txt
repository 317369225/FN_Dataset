What is Math.rint() in Java?
As per documentation It Returns the double value that is closest in value to the argument  and is equal to a mathematical integer. If two double values that  are mathematical integers are equally close, the result is the integer value  that is even. now Math.rint(double a) delegates to the rint method of StrictMath class. public static double rint(double a) { return StrictMath.rint(a); // default impl. delegates to StrictMath } so the magic is present inside StrictMath rint method. Here if absolute value of argument is not less than 2^52, return value would be the argument, otherwise the logic to get closest doule value which is equal to mathematical integer. public static double rint(double a) { /* * If the absolute value of a is not less than 2^52, it * is either a finite integer (the double format does not have * enough significand bits for a number that large to have any * fractional portion), an infinity, or a NaN. In any of * these cases, rint of the argument is the argument. * * Otherwise, the sum (twoToThe52 + a ) will properly round * away any fractional portion of a since ulp(twoToThe52) == * 1.0; subtracting out twoToThe52 from this sum will then be * exact and leave the rounded integer portion of a. * * This method does *not* need to be declared strictfp to get * fully reproducible results. Whether or not a method is * declared strictfp can only make a difference in the * returned result if some operation would overflow or * underflow with strictfp semantics. The operation * (twoToThe52 + a ) cannot overflow since large values of a * are screened out; the add cannot underflow since twoToThe52 * is too large. The subtraction ((twoToThe52 + a ) - * twoToThe52) will be exact as discussed above and thus * cannot overflow or meaningfully underflow. Finally, the * last multiply in the return statement is by plus or minus * 1.0, which is exact too. */     double twoToThe52 = (double)(1L << 52); // 2^52 double sign = FpUtils.rawCopySign(1.0, a); // preserve sign info a = Math.abs(a); if (a < twoToThe52) { // E_min <= ilogb(a) <= 51 a = ((twoToThe52 + a ) - twoToThe52); } return sign * a; // restore original sign } Eg. Math.rint(10.856) // returns 11.0 Math.rint(10.456) // returns 10.0 So Long story short, it returns a closest double value which equal to mathematical integer. :) Disclaimer: Newbie, so please correct me if wrong. 