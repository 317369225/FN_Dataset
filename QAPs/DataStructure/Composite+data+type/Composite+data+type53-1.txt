How do I transition from Haskell to Java?
LOL, why would anyone want to? Just kidding. I realize there are lots of sensible possible reasons. Maybe you are expected to Java for a living? I tried to move in the opposite direction. I'm reasonably proficient at functional programming in less pure languages such as Clojure, but failed to understand the finer points of Haskell. Still, I think I can point out things you will need and want to know. OK, so in the IO context (err, monad?) you have these sequences of statements in a DO block (?), that you have a reasonable expectation of having executed in exactly the sequence you give. Because IO and DO somehow foil the magic of laziness and the idempotency of operations. This, if you've made sense of my poor explanation of how things are in Haskell, is how essentially all your code works in Java. With some caveats I'll address in a moment, every chunk of code you write gets executed in the order you write it down, give or take flow-altering constructs like IF, SWITCH, WHILE and FOR loops. There is no laziness unless you explicitly program some in. The statements in your flow of control are executed as they stand, one after the other. I think this should be an easy part of the transition for you. The hard part is that most statements can have side effects, and many do. Functional programming creates new instances of variables in a new context with possibly changed values; imperative programming uses mostly just one variable for a given purpose, and changes the value of that variable whenever it's deemed useful. Any code executed after that change will see the new value. This is pretty simple conceptually too but it trashes most of the assumptions you're used to making in a functional concept: especially if you have multiple threads of control, variables could be changing on you at seemingly random times. In fact, you need synchronizing or locking constructs if you want to isolate variables from being changed at awkward times by different threads. Next up, objects! Haskell has structured data types that you declare (err, whose structure you declare) using, I think, the DATA statement. In Java, all data structures are called classes. A class is a bag of 0 or more variables (any of which can themselves be classes) plus 0 or more methods (what Haskellers would call functions, more or less). Once a class is declared, instances of it ("objects") are created using the NEW keyword. The variables can be initialized via parameters during construction, or you can do that later via code either in the object's methods or from outside the object if the visibility of those variables has been declared as PUBLIC or your class provides accessor methods (whose names by convention start with GET... and SET...). Is this the kind of information you were hoping for? If so, I can continue. In a few hours. A bit of OO philosophy I've mentioned before that all non-FINAL variables in Java can be changed by any code that's able to access them. This has significant impact on how people code Java. At the risk of sounding facetious, the norm in Java is to code like you're one of a band of mutually hostile chimps with no long-term memory. Everyone, your past and future selves included, could be your enemy, intent on sabotaging your work by changing values in your data. Significant effort is expended on fencing and walling your data in against writing, sometimes even reading, by any code that doesn't explitly need to. A variable declared FINAL can only be assigned to once, in a constructor or initializer. This kind of variable behaves like what you're used to from functional programming. Access to variables can be restricted via the modifiers PUBLIC, PROTECTED and PRIVATE that you can read up on. Whichever modifier is applied controls which classes get access; those that do can both read and write (unless FINAL, of course). This is often not fine-grained enough, so a frequent practice is to make all instance variables (err, "fields") private and then write accessor methods for reading and writing. This lets you regulate access separately for reading and writing. A field that's read-only outside its own class is implemented by making the field PRIVATE and providing only a read accessor ("getter" because the method name is by convention "get" + the field name). Why classes? A short digression. A class in OO is the definition of a data structure that encapsulates (and protects, protection is important!) a collection of data fields. You could liken it to a tuple in functional languages. It also includes a set of methods, i.e. functions that get "privileged" access to the fields in the class but other than that can basically execute any code you want. The underlying idea is that a class represents some real-world entity. At GM, classes may represent assembly lines, cars and trucks; in an accounting firm, classes will represent clients, invoices, ledgers. You get the idea. The class contains the data relevant to the real-world thing being represented, but also the behaviors of that thing. Your CAR class may have a DRIVE method, your CLIENT class may have a SEND_INVOICE method. For housekeeping purposes, decomposition and plain getting things done, there will typically also be methods that don't represent real-world "behavior" but fiddle with the object's state or offer other functionality. There will often be a plethora of accessors (see below). Steve Yegge (I think) once wrote a cute essay called Execution in the Kingdom of Nouns . This whimsical tale analogizes functions as verbs and objects as nouns. Besides being a fun read, it may help you understand the role of objects in OO, and some of the shortcomings that are today motivating people to abandon OO for functional programming. Hence my surprise at your question. More classes nuts and bolts Classes can inherit from other classes. If class B inherits from A, then class B has all the non-PRIVATE fields and methods of class A and can add its own. Class B can also access PROTECTED fields and methods of A, but "outside" users of class B can't see or access them. Inheritance is single, i.e. every class can only have one parent class. This turns out to be a huge pain. My wife is a physician and a woman. If I wanted to build a class to represent her and people like her, would I inherit from class Woman or class Doctor? I can't have both! And the selection of fields and methods available to me will depend on this choice. Junior Java programmers often tie themselves into knots in the process of coming up with a class hierarchy for their objects that is both clever and useful. Interfaces offer some relief. A class can implement any number of interfaces, but interfaces are just collections of method declarations. The code for those methods still has to come from a real honest class. Interfaces help you specify which operations a class can perform, i.e. what it can do, but they're less help with what it has. A little more realistically, I could design TheWife as a class that extends (inherits from) class Woman which extends class Person; and this would reflect the consideration that in real life, the attributes of her most important to me are contained in her person-ness and woman-ness. To round her out, TheWife would implement an interface Doctor, which would declare the HEAL method. The above looks like a workable implementation for my contrived design task, but experienced Java practitioners now tend to eschew puttering with class hierarchies. Inheritance give classes identity; this is sometimes called an "is-a" relationship. But because of the shortcomings of what you can represent with single inheritance, there's a trend toward putting "inherited" functionality into objects tied into the "inheriting" one by composition rather than inheritance. In the wifely case, my TheWife object could have two fields for PERSON and maybe OCCUPATION and these would be references to Woman and Doctor objects, respectively. I would be representing the richness of my wife's qualities via "has-a" relationships, i.e. I'm saying she has the capabilities and attributes of a person and those of a physician. Once the relevant methods are parts of foreign objects linked by field references, I can no longer pretend my methods are methods of the composed class. Typically, I'll build dummy copies in the composed TheWife class of all the methods I'm interested in using, and those will end up as wrappers calling out to the methods in TheWife.person and TheWife.occupation, as appropriate. I've avoided some of the headache of inheritance, at a cost of a whole bunch of methods I need only for organizational purposes. Bleh! How to solve a problem in OO So this is pretty much as straight-forward as you'd expect: given some problem, you read the description and identify all the actors, artifacts and end results, all the data objects, temporaries, communication objects and so forth, you give them all meaningful names, decide what data they should encapsulate, write that into them as data fields, and then add a bunch of methods to implement behavior and solve the various organizational problems associated with accessing but simultaneously protecting and encapsulating your objects' data values. Simple programs will have a "boss" object that instantiates a handful of other objects and orchestrates the interaction. Heavy-duty programs may benefit from the use of frameworks to provide features like dependency injection, component plugging and lifecycle management, hot patching, error handling and so on. By this point at the latest you should be familiarizing yourself with the Gang of Four Patterns book I mentioned in my recent comment. 