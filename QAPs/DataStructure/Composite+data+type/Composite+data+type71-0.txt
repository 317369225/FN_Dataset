Functional Programming: What is a functor?
Easy: at least in Haskell, it's any type that you can map a function over. Think of it as generalizing the idea of map for lists. Normal map looks like this: map :: (a -> b) -> [a] -> [b] If we just replace the list type (the []) with any functor, we get our generalized map, called fmap in Haskell: fmap :: Functor f => (a -> b) -> f a -> f b Any type f with a function like this is a functor, with one additional restriction: the map function has to preserve the "structure" of the value it's mapping over. For lists, this means it can change the elements but not the size of the list. For every other functor, it has a similar constraint, but since all these types are different, enumerating these constraints is not practical. Instead, we can sum them into the following law: fmap id == id That is, mapping the identity function, which itself does nothing, cannot change the input at all. It's also interesting to look at how parentheses work in the type signature: we can also write fmap's type like this: fmap :: Functor f => (a -> b) -> (f a -> f b) That is, instead of thinking about it as mapping functions over a value, we can think of it as transforming normal functions to functions "over" f--lifting the function to work on a new type. This alternate way of thinking about it can help you understand the idea especially if you ever want to read up on the category theory behind it. Of course, to make life more exciting, functor has a completely different meaning in ML. There, a functor is part of the module system: it's a module that takes another module as an argument. These are used for things like sets which require a type coupled with a comparison function. They're used somewhat similarly to typeclasses in Haskell. Updated 29 Mar 2014 â€¢ View Upvotes