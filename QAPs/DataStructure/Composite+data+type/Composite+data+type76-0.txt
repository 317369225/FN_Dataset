Is it still reasonable to say mainstream languages are generally trending towards Lisp, or is that no longer true?
I'm going to offer counter-examples to many of the things mentioned by Richard Tibbetts: There is a clear need for macros and an extensible parser in many projects today. Evidence for this is anything that uses XML for configuration. Some languages like Ruby are on the right path - look at what's going on with Puppet's syntax and attempts to "add" Ruby to it. What is actually harmful to understanding and reuse in real applications is the *lack* of language extensibility. But Lisp practice isn't staying still. The popularization of named readtables is taking Lisp DSLs to a whole new level (I used them to write a complete C front-end for Common Lisp: https://github.com/vsedach/Vacietis). Going beyond these techniques would be fully composable parsers. Perl 6 comes with support for Parsing Expression Grammars, which are composable. I've heard that Pratt parsers (implemented by Vaughan Pratt in Lisp in the early 70s) are composable too, but no one seems to be using them that way. When it comes to compiler optimizations, things aren't as obvious as they first appear. Lisp implementations took up dispatch inline caching shortly after the technique appeared in Smalltalk. Method specialization is provided in a much more general way by Common Lisp's compiler macros, which enable generalized partial evaluation. And all Lisp compilers are JIT. Where Lisp is missing out is in not having compilers that use SSA as the intermediate representation, and all the optimization work done around that. And although all Lisp compilers are JIT, currently none of them do anything like runtime type feedback or profile-driven inlining. On the other hand, what other compilers (including most Lisp ones today) are missing out on is CPS as an intermediate representation. It's wonderfully simple compared to SSA or other compilation techniques, and Olin Shivers has been advocating its revival for some time. And not in vain - Dimitrios Vardoulakis, one of Olin's PhD students, has developed a very promising new control flow analysis technique for CPS representation called CFA2 that's already being used in JavaScript tools at Mozilla. When it comes to garbage collection techniques, the holy grail of "advanced" is the same as it was in the 1980s - read and write barriers. The state of the art hadn't actually advanced since generational GCs until Azul Systems came along, first by coming up with new methods for parallel and concurrent GCs on their custom hardware with read barrier support, and then more importantly by figuring out how to implement a read barrier by using the virtual memory virtualization features on Intel processors with VTx extensions. That was the first real advance in practical GCs since the 80s and it will still be a while before it shows up in runtimes (for various reasons, most of them having to do with getting the needed interfaces into operating system kernels). In terms of security models, the first and last word is capabilities. Jonathan Rees showed that capabilities can be implemented straightforwardly in Lisp in his 1995 PhD dissertation (http://mumble.net/~jar/pubs/secu...). Scheme48 still has that code. When it comes to distributed systems, modern Lisp implementations don't have that many options, because like everyone else it is still catching up to Lisp work done in the 1980s. MapReduce is nothing but a very verbose Connection Machine Lisp. Gary Sabot's Paralations are a great foundation for BigQuery-style distributed data processing, but no one's heard of them. Forget about his ideas on declarative locality specification. Guy Blelloch's NESL might as well be alien technology. The one area where Lisp is surprisingly weak and truly technologically behind (especially considering its meta-circular nature) is virtualization. There has never been a good multi-user Lisp implementation. The most advanced work on the subject remains that done by Jonathan Rees (his dissertation and SchMUSE system; see also the neat demo by Darius Bacon: https://github.com/darius/consp). On the whole, I don't think Lisp will be "mined out" any time soon, especially considering that Lisp is a moving target and is still rapidly advancing. 