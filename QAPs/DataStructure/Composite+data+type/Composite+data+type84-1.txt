What are some functional programming design patterns?
Here are two that come to mind. The worker/wrapper pattern is a way of preventing leaky abstractions when making use of tail recursion. Say you want to write a factorial function. Here's a simple recursive definition of factorial in pseudo-Haskell (*): fac 0 = 1 fac n = n * (fac (n - 1)) Elegant and obviously correct. But for a large value of n, it'll overflow the stack--it calls itself recursively n times before any of the calls return. We can take advantage of tail call optimizations to rewrite this function in a tail recursive form, using an accumulator: fac 0 acc = acc fac n acc = fac (n - 1) (acc * n) But now to actually use this function, we have to call it with an extra, totally useless argument, that'll mess things up if we pass it anything but the magic value 1: fac 2 1 = 2 fac 3 1 = 6 fac 4 1 = 24 -- so far so good but... fac 2 2 = 4 -- oh dear fac 3 2 = 6 -- this isn't right fac 4 2 = 48 -- and all because we have this extra argument Like Haskell, we can, in pseudo-Haskell, define a function within another function. By this, we can write an outer "wrapper" function that presents a nice API, but have the heavy lifting done by an inner "worker" function, that's not exposed outside of the scope of the wrapper: fac n = fac' n 1 where fac' 0 acc = acc fac' n acc = fac' (n - 1) (acc * n) The key is that fac' (pronounced "fac-prime") is exactly our tail-recursive fac function from above, and all this fac wrapper function does is make sure that fac' gets called with the right arguments. The zipper is a way of taking a functional data structure (a list, tree, or whatnot) and changing your perspective on it so that it's easy to simulate in-place updates, which is something you generally can't do with a functional data structure. This takes a little longer to explain than the previous pattern, so I'll just refer you here to the original paper: Page on yquem.inria.fr (*) Not actual Haskell, to avoid the question of laziness. Updated 16 Dec 2014 â€¢ View Upvotes