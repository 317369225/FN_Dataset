Is it true that Python is a dying language?A friend of my grandmother is a Computer Scientist from MIT, he told me that I should not learn Python because it's a dying language and that I should learn Assembly because it's better than Python.
Since assembly language is just a thin layer over machine language, it's directly tied to each processor family, and dies with it. Assemblers of various kinds have been around since at least 1949, but it's not the same language at all. It's much, much easier to write an assembler than to write a compiler or interpreter for a high level language though. It seems your grandmother's friend has discovered that the development of high level languages was all a big mistake. If that's true, it would be very sad, since it implies that 65 years of hard work in research and development of programming languages by thousands of scientists and developers was all wasted time. :-) I don't think his finding is widely known in the business. Considering how often modern software development organizations use Python, and how little they use assembly, Of course assembly language has its uses: If you really want to learn how the hardware works, assembly get's you closer than anything else than using ones and zeros. Considering the complexity of modern hardware, I'd suggest that you stick with something really simple, like PIC micro-controllers. Also, if you are writing a compiler, you probably need to write some assembly code, at least if you write the first compiler for a new processor family. For many other uses, Python is a pretty good language. For some applications, it will turn out to be too slow, and assembly would be faster, but C will be about as fast, and your C code will work on all platforms. Many startups make big successes with Python, and then they have to rewrite some things in Java, C++ or C as they scale up and saving CPU cycles is a million dollar business for them. If they had started with assembly instead, it's more likely that they run out of funding long before their very fast but difficult to understand code is feature complete. Actually, it's not just that assembly varies with the processor architecture, you also need to deal with a lot of technical details that vary with operating system etc. To give you and example, here is a simple Python program which prints the text "Hello World" on the console: print("Hello World") That wasn't so hard, was it? In x86 assembly for modern Linux versions, it looks like this: section .text global _start ;must be declared for linker (ld)   _start: ;tell linker entry point   mov edx,len ;message length mov ecx,msg ;message to write mov ebx,1 ;file descriptor (stdout) mov eax,4 ;system call number (sys_write) int 0x80 ;call kernel   mov eax,1 ;system call number (sys_exit) int 0x80 ;call kernel   section .data   msg db 'Hello, world!',0xa ;our dear string len equ $ - msg ;length of our dear string For FreeBSD (still x86 assembler) it will look like this instead: section .text global _start ;must be declared for linker (ld)   _syscall: int 0x80 ;system call ret   _start: ;tell linker entry point   push dword len ;message length push dword msg ;message to write push dword 1 ;file descriptor (stdout) mov eax,0x4 ;system call number (sys_write) call _syscall ;call kernel   ;the alternate way to call kernel: ;push eax ;call 7:0   add esp,12 ;clean stack (3 arguments * 4)   push dword 0 ;exit code mov eax,0x1 ;system call number (sys_exit) call _syscall ;call kernel   ;we do not return from sys_exit, ;there's no need to clean stack section .data   msg db "Hello, world!",0xa ;our dear string len equ $ - msg ;length of our dear string 