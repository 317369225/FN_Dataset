What does object-oriented programming do better than functional programming, and why is it the most popular paradigm when everybody seems to say functional programming is superior?
As pointed out in other responses, FP is apparently widely misunderstood, not taught nearly as widely as OOP, and yet OOP can also be interpreted in different ways. So, below I refer to OOP as a practice of using several well-known languages (C++11, Java, PERL and Python), and the same for FP (Haskell and F#). Needless to say, some languages now allow using both OOP and FP (C++11 supports lambdas, which can be stored in a container object). This not only blurs the boundaries, but also adds inertia --- fewer reasons to learn a new language. So, the simplest answer is that OOP languages were the first to offer commercially viable, robust solutions. Some would argue that functional languages have not reached that point until about five years ago (F#). OOP is powerful enough to express what needs to be expressed in practice and simple enough so that many programmers can do this in a consistent way. It is also simple enough for compilers to do their job well and produce fast binaries (at least after 30 years of robust compiler R&D). Some OOP languages come with extensive domain-specific libraries (Java, PERL, Python) which allow programmers to think in domain-specific terms. C++11 supports typed numerical quantities, e.g., you can multiply meters/second^2 by seconds and get meters/second --- very handy to avoid mistakes in kinematics applications. FP forces you to change the way you think about programs and algorithms.  In at least some cases, FP supports very short and elegant (minimalistic) programs that would be longer in other languages. Its propensity to avoid mutable states is convenient for parallel programming. But the jury is still out on whether FP expresses well what needs to be expressed in practice - forcing people to change the way they think is not always good. Apparently, FP is still too sophisticated for large teams of programmers to produce clear, consistent and reusable code (this may be a problem with education). It is also too powerful for compilers to do their job as well as OOP compilers. FP is often introduced using elegant, but pointless and/or misleading examples. For example, computing the N-th Fibonacci number using straightforward recursion or dynamic programming (at runtime) is a bad idea, even if you manage to do this in linear time, because there is a much faster algorithm (which can also be expressed in FP, but perhaps takes more braincycles to understand). It's not entirely clear why this effect is hitting FP particularly hard --- perhaps, because FP is appreciated for its mathematical beauty and not practical utility. So, there you have it --- FP does not find as much practical use because it is appreciated for its mathematical beauty. OOP languages and compilers are developed with practical applications in mind. Given the number of people involved in this development process, the amount of innovation going on is tremendous. In particular, the syntax is being simplified and extended, while the compilers are continually improved. Extended syntax sometimes incorporates competing approaches. For example, C++11 includes lambda expressions, integrates them with other language facilities, and makes them very useful for parallel programming. This gives me one less reason to look into Haskell or F#. Updated 10 Nov 2013 • View Upvotes