Functional Programming: What is a functor?
To provide a rather-different perspective ... In OCaml, a functor is a module that's parametrised by another module ... (Or, equivalently, it's a function that takes a structure as its argument and returns a structure.) And, just as there are types that classify values, there are signatures that classify modules; in just that way, the argument to a functor can be constrained by some particular signature. What is this useful for? Well, among other things, to simulate type classes: `Set` is a meaningless type -- it must be a set *of something*. But, internally, since sets are implemented as binary trees, the 'somethings' must have a (total) ordering. That is there is a functor called `Set.Make` parametrised over an ordered type (conforming to the signature `OrderedType`) and returning a structure representing sets of that type using the ordering specified. As an example, who wouldn't want to have sets of `string`s!? (* Just to show that we can arbitrarily choose the    comparison function, lets compare the first character    only of the strings; we'll not do error handling.  *) module OrderedString = struct type t = string let compare s s' = compare s.[0] s'.[0] end   module StringSet = Set.Make(OrderedString)   let _ = let flip f x y = f y x in let ss = List.fold_left (flip StringSet.add) StringSet.empty [ "foo"; "bar"; "baz" ] in print_endline (string_of_bool (StringSet.mem "fuzz" ss)) which, of course, prints `true` because of our ... exotic comparison. 