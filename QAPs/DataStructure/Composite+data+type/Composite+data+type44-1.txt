Functional Programming: What are monads and why are they useful?
A monad is not inherently anything to do with state. Its a design pattern that appears all over the place in all programming systems, but is only formally captured in languages with very powerful type systems like Haskell and Scala. Most languages are not powerful enough to capture design patterns in any reusable form, so this isn't much of a surprise. Monads are useful when three things are true: 1. You have some kind of "container" for values, not necessarily a collection but some kind of object whose job it is to provide one or more values when you ask for them. 2. You don't want to ask for the value or values from the "container" every time you want to do something with them. Maybe its expensive to get them out, or maybe it just wouldn't be very elegant. 3. Nested "containers" are basically equivalent to a single container with the values from the leaf containers. Now "container" is a bit abstract, so lets be concrete - examples are lists are other collections, promises or futures in concurrency systems, stateful references, optional values, and so on. None of these things is specific to Haskell, but only Haskell, Scala and other ML-family languages have the sophistication needed to capture what's common between them. Haskell also uses monads to model IO and other imperative feature - this is a bit confusing, because in this case the "value in the container" is the state of the entire universe outside of the Haskell program. There's something marvellously self-centred about that. Monads must provide three things that match the three constraints above: 1. A way to put a value into the monad - this function is often called "unit". 2. A way to perform an operation on the values in the monad and return a new monad with the new values. This is called "map" 3. A way to flatten nested monads. This is called "flatten" or "join". Often 2 and 3 are combined into a single operation called "flatMap" or "bind", which both performs an operation on the values in the monad. It doesn't matter which description you use, as you can make flatMap by composing map and flatten, or make flatten by composing flatMap and unit. Note that if you don't have a "flatten" operation, you have another kind of thing called a "functor". In non-functional languages, this distinction isn't quite so clear, and in dynamic languages it might disappear entirely as the same object might behave both as if it were flattened and as if it were not. e.g Javascript promises appear to work this way, and there are several debates online as to wether they're functors or monads. 