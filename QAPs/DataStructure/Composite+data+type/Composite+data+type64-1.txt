What does object-oriented programming do better than functional programming, and why is it the most popular paradigm when everybody seems to say functional programming is superior?
The reasons posted above in other answers are bogus in my opinion and are superfluous comparisons, exposing fundamental misunderstandings about what "Functional Programming" is. Most people who talk about OO vs. FP do not have enough real experience writing application code in Functional languages. First I pose the question, "What does Object Oriented Programming mean?". In practice everyone has a different definition in mind, making it a virtually worthless in a discussion. Does it mean programming with objects? A class system with nominal sub-typing? structural sub-typing? polymorphism? prototypical inheritance? open-recursion? bounded polymorphism? interfaces? methods? There are a variety of languages that bill themselves as OO, but are wildly different. In contrast if you remove all the buzzword-y meaning attached to it, and ask a true practitioner of FP. It is about using pure functions (in the mathematical sense, aka mapping from inputs to outputs) as the fundamental unit of abstraction. Functional Programmers value pure functions because they are much easier to reason about and compose, allowing us achieve the promises of the modularity, and code reuse that OOP had promised. Often times objects become little more than a wrapper for semi-global-state and program invariants typically require objects to be in specific states for system to function correctly, and things usually will blow up in an exception or crash. Functional Programmers attempt to write total functions as much as possible for these reason and avoid things like null or random throwing of exceptions. The other important thing is that many functional programmers are writing code in a statically typed languages with rich type systems. Allowing one to write truly generic code. Fulfilling another failed promise of OOP which usually results in strange inheritance hierarchies and methods ending up in a base class where they don't belong. For example languages like Java and Scala allow you compare *any* objects, a failing that is impossible if your equality function has the correct type. You can see some of these issues even appear in Scala's collection library where they attempted to use "OO" to be generic and ended up exposing functionality on types that shouldn't have said functionality. Another big advantage of FP is that most FP languages provide a way to encode ad-hoc polymorphism or type classes, making it easy to write truly extensible chunks of code. Even Go has adopted a limited form of this in its interfaces. Type classes implement possibly abstract functions, and allow *anyone* for *any* type implement the functionality. This is the promise of interfaces. Though I can write my own type class and provide implementations for others types. For example I can implement serialization as a library and not worry about a class not inheriting my interface. Finally although the detractors would like you to believe that FP is best left to academics and those wanting to write "cute" pieces of code. It's principles and practice are seeing more and more use. For example Scala, which enables functional programming and makes it easier than many languages, is growing in popularity. Big companies like Twitter are running their backend almost entirely on Scala code. They are applying functional programming for great benefits. Just look at any of their open source analytics projects on their GitHub (seeÂ  https://github.com/twitter). Another good example is Facebook who has been recently applying Haskell (check out The Haxl Project at Facebook (slides from my talk at ZuriHac) for large scale filtering and analysis on their data sources. People like Gabriel Gonzalez are using it to speed up the cutting edge biotech research (see An all-atom protein search engine powered by Haskell). Galois is using Haskell and other tools to build high assurance systems. There are many more examples of these tools being used in the wild for great effect, and one can list many more "real" companies using FP for "real work". Many people including myself use FP precisely because it provides more practical value than many so called "practical tools", I find myself writing cleaner, shorter, faster, and easier to maintain code routinely, and when I go back to writing C++ or Ruby I definitely feel crippled. As a parting note one may ask, "If this is so great why isn't everyone using it?". I believe much of this is that adoption is slow. Even when people agree that X or Y is better it takes time for these things become known quantities. It is impossible for people to adopt tools that they haven't heard about or don't understand. I think much of this is about education, people didn't start writing OO code over night, and they won't start writing FP overnight either. There is also a second component that software developers tend to stick to what they know, and asking them to learn a new tool or stack for reasons that they aren't 100% sure, or without a clear value proposition for themselves is hard. Many of us in the FP community are evangelists, and working hard in educating and informing anyone willing to learn about it. Note: I apologize for any spelling or grammatical mistakes, this turned out to be pretty lengthy answer. 