Is there an advantage to currying other than concise partial application?Conversations like this one on StackExchange mention several cases where partial application is useful, but is there another reason? Otherwise, one could imagine that a light partial application syntax for, say, records might lead to equally nice- or nicer-looking programs, given the asymmetry curried functions have between taking multiple arguments and returning multiple values.
First a small disclaimer, currying and partial applications are different things. The question doesn't seem to imply this particular misconception but it's important to emphasize this to all readers. Currying and uncurrying are fundamental properties of the way functions and algebraic data types work. The type (a,b)→c is isomorphic to a→b→c because there's a correspondence between exponentiation and functions and between products and tuples. A tuple type (a,b) has properties similar to a product a×b and a function type a→b has properties similar to the exponentiation b^a (b raised to the ath power). As in regular numeric algebra products and exponentiation are distributive, so we have the following transformations: (a,b)→c = c^(a×b) = (c^a)^b = (a→c)^b = b→(a→c) Notice that we have b and a reversed here, but (a,b) and (b,a) are isomorphic (which means the product is commutative). Currying isn't something ad-hoc that we try to bolt-on FPLs, it's a fundamental property of how types form algebraic structures that have well know properties. Currying is a way to relate functions from tuples (i.e. functions that take functions as arguments) to functions of functions (functions that return functions). Partial application relates to how function arguments can be applied. Partial application isn't a special case or syntactic sugar provided by the language. If you have a FPL that's influenced by the λ-calculus (e.g. SML, Haskell, OCaml) you apply functions to arguments. There's no concept of partial application, because all applications are of a function to a single argument. If we have a function f that "takes" 2 arguments and return something (e.g. f :: a→b→c) what we actually have is a function that takes an argument and returns a function that takes an argument and returns something (e.g. f :: a→(b→c)). By convention the arrow (i.e. →) is right-associative, so we don't need to write the parenthesis. A function application is left-associative and that works perfectly with the right-associativity of function types. In our example the following equality holds f a b = (f a) b, because they are only different in the surface syntax, but their corresponding ASTs are identical (modulo parenthesis). We have two applications in this example, not one with two arguments. Why would we prefer functions that are curried instead of uncurried? The answer to this relies on the fact that in FPLs functions are first class values and it's useful to have more possible functions. Going back to our example function we could use it in five ways: As a value of type c, by applying it to a then to b (i.e. (f a) b). As a value of type b→c, by applying it to a (i.e. f a). As a value of type a→c, by applying it to b (i.e. λa→(f a) b). Here we need to create an explicit λ in the surface syntax. As a value of type a→(b→c), by using it as is. As a value of type b→(a→c), by inverting the arguments (i.e. λb→(λa→(f a) b)). There's a well know combinator called flip that does this for us, the implementation is the same of what I wrote here.We can directly use function application to use our function as 1, 2, or 4. Using a simple flip combinator we can express 5 as flip f and 3 becomes (flip f) b (with explicit, but unnecessary, parenthesis). If the function was in its uncurried (i.e. taking tuples as arguments) then we would need to use more combinators, other than just the humble flip combinator, to achieve all five ways. The strength of FP is not on first-order functions (i.e. functions that take and return non-function values) but on higher-order functions (i.e. functions that take or return function values), when you start using those you end up "partially applying" functions frequently, because we need to pass a function as arguments to other functions or return functions that we can build via functional composition or may other combinators. Updated 29 Oct • View Upvotes