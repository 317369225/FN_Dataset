Why do some people not like OOP and prefer functional programming?Is it just a matter of taste, or are there some other reasons behind it?
OOP is fundamentally a tool, and no tool is perfect. It doesn't matter how great a tool is; if your toolbox is otherwise empty, you're going to be a poor programmer. As a programming paradigm, OOP exists either side by side or in tandem with other programming paradigms, such as imperative, functional, logic-based, symbolic, et cetera. Each of these have their own strengths and weaknesses, and this is true for OOP as well. So what does OOP do particularly well? Good OOP is modular. OOP encapsulates programs into independent chunks -- objects -- and strives to keep communication between these objects manageable. That, in theory, allows for code reuse, and lets programmers treat an object as a "black box," meaning they don't have to care about how it looks inside. In other words, complexity goes down. Good OOP models the problem area. Objects are named in ways that make sense for reasoning about the problem at hand. They interact with each other in ways that mimic their real-world behavior. This lets a programmer reason about problems using real-world heuristics. Good OOP is extensible. Many OOP languages, due to their makeup, are designed to allow programmers to add behavior without large-scale re-writing of the program itself. Variant behavior is confined to subclassed objects which are called polymorphically, so that the larger program doesn't need to know the specifics of a given object in order to execute it. This (again in theory) makes a program extensible and reduces bloat. This all sounds good, yet people still evangelize about Functional Programming. So why would FP be better? What does OOP do poorly in comparison? OOP is stateful. In your typical object-oriented programming language, objects are usually a collection of data. The data of an object can be in a myriad different states, which together describe what the object models. The object is created full of values which are then set to different values. Here's the thing, though: most of these possible combinations don't actually make any sense. While it is advisable to have routines that check that there are no incompatible values in the object (for instance, so that a bottle of water isn't simultaneously at 5000 degrees Celsius and frozen solid), errors do slip through simply due to the nature of objects. The computer is, after all, ultimately a state machine, and OOP simply mirrors that concept. In programming terms, we say that programs can be more or less stateful. OOP has lots of state, which translates to lots of opportunities for things to go wrong. In FP, however, state is largely eliminated. We don't have an object full of garbage values that then must be massaged into shape; we simply have a set of functions that describe the actual situation. Because FP reduces spurious state, so the theory goes, the risks of a random forgotten value polluting the program is reduced or eliminated. This also means that FP is testable in a way that not all OOP programs are. An object may depend on how it's initialized, on how it's been called during the course of the program, and its variables may be altered according to its (hidden) internals. By contrast, given the same input, a function will always reliably produce the same output. This simplifies testing and is a godsend when debugging. Another point in its favor is that FP is generally terser than OOP. A lot of OOP demands you write boilerplate code and redundant syntax. That's where the bugs hide. Typically, a modern FP language like Haskell lets you express your ideas in a fraction of the code required. Since Functional Programming (to the initiated, at least) often leads to more straightforward expressions of code, the program becomes simpler, reducing bugs. However, as with other paradigms, FP is not a silver bullet. Hence the reason why most FP languages still give you the tools to write imperative programs. In fact, more and more traditional OOP based programming languages have begun to add FP capabilities: Python has a kind of truncated Lambda Function, Java can interact with Clojure, C++ allows for FP with its anonymous functions and metaprogramming, and even Fortran is getting in on the FP game. See also: Michael O. Church's discussion on Functional Programming Dima Korolev's answer to What are the advantages of Functional Programming over Object-Oriented Programming? Updated 24 Apr â€¢ View Upvotes