What are the theoretical and practical weaknesses of Objective-C?I'm an amateur, and I love objective C (when working with XCode and all the Apple frameworks), but I saw this interesting answer re python (Jesse Tov's answer to What are the main weaknesses of Python as a programming language?) and I am curious about what our learned quorans might say about objective C.
Objective-C is a rather rough mix of C and Smalltalk. The general syntax comes from C, but all the object oriented stuff is Smalltalk-like and was added as an extension to C, and it shows (C++ on the other hand added object orientedness to C by adhering to C's general syntactic style). The manual reference counting memory management paradigm is a improvement over C, but it is still pretty rudimentary and sometimes confusing, leading to bad memory errors from inexperienced (and sometimes even experienced) programmers. It is, however, being deprecated in favor of automatic reference counting on both Mac OS X and iOS. Unless I am mistaken, the Objective C vtable us a hash table as in python and not an array as in C++ or Java. This makes calling methods slower, though it shouldn't matter for most purposes. (Note: this is optimized in various was using caching, see Alejandro Ramirez's comment) The Objective C type system is bullshit. In what universe does calling a method on an object that obviously doesn't have it only results in a compiler warning? Objective C has a one size fits all type called id that by itself completely defeats the purpose of having static typing in the first place. On a related note, say you want to create a dynamic array of integers in Objective C. For that you have to actually wrap each integer in an object (NSNumber), and unwrap it each time you want to use it. Well, this is annoying but at least that doesn't mean that the array will be three times as big as if it stored the integers directly[1], right? Wrong? Well I'll be damned... (Note: this has recently been optimized, see Alejandro Ramirez's comment, wrapping integer literals is also easy using the @1 syntax). Again, this comes down to Objective C being a mix of a statically typed language (C) and a dynamically typed one (Smalltalk), resulting in a type system that is sometimes static and sometimes dynamic. Objective C is also very verbose, owing in great part to the fact that method names are extremely explicit by convention. Now, it might seem like I think Objective C is a bad language, and I don't. I don't particularly like it because I think it is inconsistent in its syntax, but it has stood the test of time and that is already a big deal for a language. Most importantly, computer languages are full of compromises. I wrote this from the point of view of a C++ programmer, and therefore most of these also apply to dynamic languages such as python. Had I written this from the point of view of a python programmer, I'd have found a bunch of weaknesses that also apply to C and C++. On nearly all of these issues, taking the opposite solution would have resulted in a weakness as well, albeit a different one. Interestingly, the integer array argument also applies to Java, so Objective C is not alone (though Java has made significant effort in the way of making this less painful for the programmer, and Objective C has not). [1]: 4 bytes for the integer itself + 4 byte for the vtable pointer in the object + 4 byte for the pointer in the array. On a 64-bit system, both pointers are 8 bytes, so it becomes 5 times as large. And this is assuming NSNumber is exactly as large as an integer, which it most likely is not since it handles other number types (so it is probably larger). Updated 16 Sep 2012 â€¢ View Upvotes