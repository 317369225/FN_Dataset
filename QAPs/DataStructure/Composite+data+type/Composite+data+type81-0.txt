What are the disadvantages of using Node.js?
Ah, so this question is fairly old, but I'll throw in an analysis of Node today (0.10~0.11), and contrast with the alternatives for building applications in the same niche (heavily I/O bound applications). Most of the points will consider the usage of Node.js with JavaScript, with some considerations for alternative languages. Node is a neat platform, it has an attractive ecosystem, and it's got one of the only package managers that actually work. It also rides on the popularity of the JavaScript language, which gives it somewhat of a hype status. However, there are a few points where it falls short, even within the niche that it was designed for. Bad concurrency primitivesNode's core is entirely built on top of the premise of asynchronous I/O. Being a single-threaded platform focused on I/O bound applications on top of a language that does not guarantee purity and has no support for co-routines, this is an understandable choice. It is much better than heavy-weight threads with shared state, as you have in Java and similar mainstream languages. But it's a poor model of concurrency to expose to the platform, none the less. JavaScript doesn't really have any good primitive for concurrency (although generators will allow cooperative concurrency, and can be used experimentally in Node today), and the core, along most libraries in the ecosystem, just straight up expect you to use continuation-passing style, which leads to non-compositional code, codebases that are difficult to reason about, and lots and lots of duplication and call-site specific glueing. In JavaScript land the alternative with most acceptance is Promises/A+, but Promises/A+ are Considered Harmful, specially due to how they automatically catch synchronous errors thrown in a function (but nothing else), and the automatic flattening of “thenables”, which leads to behaviour that is difficult to reason about, and impossibility of expressing some abstractions. Truly monadic specifications for promises were proposed, but ultimately rejected by the community and TC-39¹. With generators, people started experimenting with Communicating Sequential Processes. A move to CSP would be pretty interesting, but they're fairly experimental right now. Single-ThreadedNode being single-threaded means that one does not need to care about the problems of synchronising between threads, or shared mutable state (given JS's semantics). However, it also means that unlike preemptive concurrency, the programmers themselves have to decide how to deal with concurrency, with the default being no concurrency at all! It's easy to write some part of the code that might take a long time to finish in some edge case, and then lock the whole system up. Not a good thing to happen. Green threads (like in Haskell), or lightweight processes with message passing for communication (like in Erlang) would be a better idea. Lack of maturityMost of the core libraries have reached the status of stable, and you can trust them to usually do the right thing. But the ecosystem itself is still fairly immature. It's also difficult to assess the quality of a particular module (core or otherwise) because of the lack of features for ensuring the quality of code from JavaScript itself — for example, in Haskell you can rely on the type system, QuickCheck and SmallCheck tests, and the language semantics; JS has nothing like that (there are some ports of QuickCheck, though). The way npm is structured also makes it quite difficult to find trustable packages, and the ease of publishing your own package, alongside the Unix-philosophy that runs through part of the community (small modules that do only one thing, and one thing well), make it harder to spot packages that are reliable and proven. Reliance on stringly-typed² programmingThere's a rampant cult of “strings are easy” in the community, which leads to many bugs due to unnecessary reliance on strings, rather than proper data structures. Some of the XSS bugs found in Express are due to this mentality. Since it's a cultural thing, and JavaScript itself doesn't do much to make the alternatives be perceived as easier, it ends up making it even harder to trust thirdy-party libraries. Hard to make things fault-tolerantThis was somewhat alleviated with the introduction of Domain, but they're still too low level, and don't give you all of the tools necessary to make systems reliable and fault-tolerant, as Erlang/OTP does. JavaScript's semantics don't help here as well, there are no mechanisms to handle or recover from errors that are thrown asynchronously, for example, and processes in Node are not lightweight like Erlang's. JavaScript's semantics and cultureEven if you end up using an alternative and more principled programming language, like PureScript, most of the code you'll be running on top of will have JavaScript's problems all over (and this includes Node's core). This ranges from the implicit data structures conversions that the specification defines under the hood for all operators in the language (besides ===), to the culture of heavily ad-hoc overloading variadic methods depending on the value's type tag. These are about all the things I can think off the top of my head, but there are some other fairly specific problems in the tooling around Node, some problems in npm (like the very existence of peerDependencies), which are a direct result of the semantics of JS. As these are not directly related to every possible Node application, and you might never run into them, I decided to leave them off. ¹: Promise.cast and Promise.resolve ²: Stringly Typed 