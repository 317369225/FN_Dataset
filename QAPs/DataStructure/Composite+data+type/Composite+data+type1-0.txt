What are pros and cons of PostgreSQL and MySQL?With respect to reliability, speed, scalability, and features. I've heard a lot about how Postgres is superior to MySQL in a number of ways, but I only have a loose understanding of the differences.
First off, I believe that whatever you're doing, you'll probably be fine using either. That said, having used both, I'm generally more frustrated when using MySQL than when using PG.  Here's a sample of the problems I've encountered with MySQL. I haven't updated my list in a while now - please feel free to correct me on things - but hopefully it's a little more illustrative than the Wikipedia feature matrix, and a little more specific to MySQL vs. PG. (This list is a cleaned-up selection from my notes wiki at http://yz.mit.edu/notes/Hackery) No referential integrity. No constraints (CHECK). No sort merge join, let alone hash-join. http://www.dbms2.com/2008/07/10/..., http://www.mysqlperformanceblog.... Generally poor at analytical workloads, since it's designed for transactional workloads. No group commit (!) https://www.facebook.com/note.ph... Can't specify TEMP table more than once in a query - WTF? (Still not fixed!) http://bugs.mysql.com/bug.php?id... Multiple storage engines has always restricted progress: http://www.mysqlperformanceblog.... (PG also supported multiple storage engines in 80s, then concentrated on one) No WITH clause: http://stackoverflow.com/questio... Crappy errors: “Incorrect key file for table ‘stock’; try to repair it” on alter table stock add constraint pk_stock primary key (s_w_id, s_i_id); where stock is in InnoDB (which has no “repair table”) means I have no /tmp space (and Googling for this turned up nothing) Optimizer only recently started working properly with certain subqueries Crappy EXPLAIN output - somewhat better when using the visual-explain tool from Percona. InnoDB auto-extends ibdata1 file; only way to trim (garbage collect) is dumping and loading. Scoping is broken: create table t(a int, b int) gives "Query OK, 0 rows affected (3.30 sec)" while select a, (select count(*) from (select b from t where a = u.a group by b) v) from t u gives "ERROR 1054 (42S22): Unknown column ‘u.a’ in ‘where clause'" MySQL only recently got such things as per-statement triggers and procedural language support. “InnoDB is still broken…Just last week we had to drop/re-create an InnoDB-table in one project because it would not allow to add an index anymore, no matter what we tried…Mysql::Error: Incorrect key file for table 'foo'; try to repair it: CREATE INDEX [...]” http://news.ycombinator.com/item... MySQL has only its own internal auth system, whereas PG supports a wide array of auth providers. PG has more supple ALTER TABLE implementation. MySQL doesn’t support ASC/DESC clauses for indexes http://explainextended.com/2010/... Optimizer leaves plenty to be desired, e.g. not pruning unnecessary joins. OK documentation, but still considerably unpolished compared to PG's.  Random omission: auto_increment jumps up to next power of 2 but inconsistently across versions (platforms?). (Older issue, not sure if it's still relevant) Crappy concurrency, >3 cores sucks vs PG: http://spyced.blogspot.com/2006/... This is all just comparing the core standard SQL systems, and leaving out things like PostGIS and extra bells-and-whistles like anonymous code blocks (which are useful!). As for the flip side: The biggest disadvantage of PG for me had been the lack of replication, but it's recently gotten both asynchronous and synchronous replication. Another recent addition that MySQL had earlier is true serializable transaction isolation. There's various other things, e.g., Robert Haas is working on the index-only scans performance optimization, which MySQL has and PG doesn't. (Update: index-only scans were added in Postgres 9.2.) Although community and support is large for both, MySQL's is larger. Updated 29 Jan • View Upvotes