What does object-oriented programming do better than functional programming, and why is it the most popular paradigm when everybody seems to say functional programming is superior?
The main goal of OO, going back to what Alan Kay was trying to do with Smalltalk, is that programming is about communication between objects, and that complex system behavior would be achieved by forming "small computers" (objects) that themselves contain simple behaviors, and work together only by exposing interfaces and passing messages. The crucial differences between OO as he envisioned it and what many programmers have worked with is that his objects are late-bound via. message passing (only at run time), whereas current implementations have object instances bound to messages at compile time. Secondly, implementation inside an object is supposed to not *ever* be exposed to other objects. Functionality can only be accessed via. an interface. This principle gets violated all the time in the implementations programmers have used. Without hiding implementation, you cannot contain differences between objects, which should be using the same interfaces. This detracts from the power of polymorphism, and it degrades reuse. What OO was supposed to be good at was modeling complex system behavior. So it can be good for simulations. It became popular because of the popularity of graphical user interfaces, which naturally lent themselves to the OO paradigm. The original idea with FP was, as others have said, that any computation can be accomplished via. functions. Transformations in state come about as the result of interactions between functions, not through changes in data. Most implementations of OO internalize state inside objects, though it's conceivable that if OOP was thought about (and implemented) differently, object state could be made immutable. This can make OO systems hard to manage, because state becomes diffused into thousands of objects, any one of which could go haywire, due to a bug, and then you have to hunt for the errant object instance. Internalized state has the advantage, though, that it enables greater abstraction. A potential disadvantage of pure FP is that state is always external, always visible. Every time you change state, it's because of another function call. There are many instances when this is desirable, but there are some where it's not. This is the reason the monad structure was developed. It enables what normally results from side-effects without exposing the rest of the system to side-effects. FP has become popular of late because of a perception that pure FP is the best solution yet devised to eliminate side-effects, which makes it ideal for parallel computation. This has been an area of particular interest, because microprocessors ran into a speed limit several years ago, and people have been looking for ways to use multiple processors, which has been an increasingly onerous challenge using languages that were designed to run only on a single core. Multithreading is an escape hatch from that, but it leaves thread management up to the programmer, which is a dicey business. OO can do parallelism as well. The one example of an instance I can think of for that is Erlang. It's just that for most programmers OO has been debauched to the point that the original idea of it has been lost, and in the minds of programmers its nothing more than institutionalized abstract data types; no better than imperative programming with an extra level of namespace and scope. 