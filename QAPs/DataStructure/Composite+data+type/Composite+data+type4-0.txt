Are there practical examples of using Ufora outside of the lab?Ufora is a parallel engine for machine learning and numerical computation (See Homepage). It looks interesting, but I haven't hear of any 3rd party using it.
Short Answer: No, I don't think so. Longer answer: I also took a look at Ufora when it went open source, and my understanding is that it won't really be something of interest to a lot of PyData folks operating in the wild, if you will, until it implements support for key libs like numpy.  That's supposed to be coming in the next release. Another caveat I noticed when looking into it is that it's not exactly plug-and-play like advertised.  That is, you still have to write unique code for Ufora computations, in the sense that the calculations must be written as "Pure Python".  "Pure Python" looks to be a euphemism for strictly functional code that treats all datastructures as immutable (including both composite data types like lists as well as objects).  There are also other weird limitations (dicts can only be constructed from iterators, and they perform poorly). I can still see the applications, but it's not as if you don't have to spend engineering time formulating how your particular application can be: written in a functional programming style and optimized for Ufora's brand of JIT and parallelism heuristics.It's not immediately clear to me why this would be inherently more desirable from a developer's perspective than, e.g., formulating your application to work with PySpark, etc.  I don't know if I would consider such a strongly restricted subset of Python the equivalent of working with "native Python" like the Ufora project claims.  The part of Ufora I found alluring at first glance was the idea that researchers and analysts who are used to prototyping in Python could theoretically go straight to scalable applications.  This is the target group that may lack a strong software dev/engineering background, and may not be as familiar with things like C/C++, the functional paradigm, distributed/concurrent patterns, etc. However, it's clear Ufora isn't that kind of magic.  If you must program strictly functionally, learn new coding patterns to maximize parallelization, avoid mixed/non-static types, etc, at what point does it just become easier and more efficient to learn threaded programming in Scala?  I guess I'm just not sure I'm a big fan of the tradeoffs associated with optimizing Python for single core performance, since at that point you're not much better off than you were writing your application using something like Cython or the like.  The stack introspection/automated parallelism idea is still really cool though; if it were somehow separated from the other aspects of Ufora, it could have the benefit of providing existing applications with some degree of turn-key performance boosting, while leaving it up to the developer to decide how much time to spend re-factoring the code to match Ufora's heuristics. All my musings and gripes aside, if the necessary expansions of the compatible Python subset come online as expected, it looks like Ufora could be a totally valid alternative approach to optimization for scale.  I'm also really curious to see production-ready examples. 