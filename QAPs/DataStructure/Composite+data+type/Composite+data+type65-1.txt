
★★★★★I would say that Haskell is the best programming language, full stop. Of course, this does not mean that Haskell is the best language for every task. In fact, it does not even necessarily mean that Haskell is the best language for any task! (Although I think it is.) What it means is that, over all the different tasks and concerns I can imagine, Haskell is a consistently good choice more than any other. So how can I make such a bodacious claim? I will give you my high-level reasoning, based mainly on my own experience: I personally rank languages on three largely orthogonal axes: productivity, maintainability and performance. That is: how quickly, comfortably and efficiently I can write code; how easy it is to ensure the code is correct, refactor it and add features; and how fast the resulting code can run. For different projects, the different axes will have different weights. If the weights are about equal, Haskell is the best choice. Moreover, I do not know any language that can beat Haskell along any two axes: sure, there are (in fact, many) languages that perform better, and there are languages that lead to more correct, more maintainable code, and there are even languages that are more productive. But never more than one at a time. Why is Haskell so productive? Partly, it's just incredibly elegant, concise and expressive. However, a large part is also played by abstractions: Haskell has a dazzling array of surprisingly simple yet general concepts like functors, algebras, monoids, monads and so on. These make Haskell code surprisingly reusable, but they actually also make it easier to write in the first place! In particular, when you're programming against--or just thinking in terms of--a simple abstraction instead of a complicated domain-specific element, there are fewer possibilities to consider. Fewer places to make mistakes. A smaller search space. Programs with these abstractions tend to just "fall" into place surprisingly often--you realize that some particular abstraction is appropriate, say the List monad, and the code almost writes itself. In fact, if it's polymorphic enough, it literally writes itself! And what makes Haskell so maintainable? Actually, it's largely the same features that make it so productive: abstractions. And, of course, the type system. Oh yeah, and since everything is functional, the code is far less coupled than even extremely well-written OO or procedural programs. All dependencies are explicit either through function arguments or types, so you always know which parts of the code affect which other parts. Moreover, just writing in the functional mould pushes you towards writing better code. In Haskell, types are not just a way to catch bugs, they're really a new basis for programming. It's not like you write a program and then struggle to make it typecheck; instead, you come up with types and the program grows organically around them. This is so powerful that you can often move around and refactor code without actually putting much thought into what it actually does, simply because a whole bunch of useful refactorings are guaranteed to keep the program equivalent. I can jump back into code that I've written months or even years ago and improve it, knowing I can't break anything as long as I follow some simple algebraic rules. This has given me a new experience with programming: I actually do consistently leave code I visit in a better state than I found it. I make small improvements to the code I'm working on or even just reading; not something I've ever found natural in other languages. Hell, in some of my projects, the code actually got shorter as I added features! This happened because it was so easy to come up with better, more general ways to rewrite parts of it to be much more reusable. So what about performance? Unfortunately, this is certainly Haskell's weakest side. Not that weak: it'll trounce what I see as its main competition--languages like Python--any day. It's certainly good enough for most of the run-of-the-mill applications like web services. But it isn't quite as good as Java, much less C or C++. And it's more difficult to reason about things like memory usage than in very low-level languages. And what if we want to do something like embedded or hard realtime programming? Happily, there is at least a partial solution: DSLs embedded in Haskell that end up generating C or assembly or whatever instead of being executed by Haskell proper. After all, C is a great language for having very direct control of the hardware; unfortunately, it does not have any good facilities for crafting nice abstractions. And Haskell is perfect for abstractions, but not great for hardware control. So we can get the best of both worlds by generating code from Haskell! A project in this general vein is Atom[1], a "DSL for designing hard realtime embedded software". There are other projects like this one, and it's actually quite easy to write a domain-specific variant of your own. So while Haskell itself does not have the performance profile for certain (relatively specialized) areas, it can still be an option! Certainly approaches like this do not cover all of the domains Haskell is weak in, but they do make it practical in a bunch of unexpected places. And, of course, it's strong on its own merits in a whole bunch of other--largely high-level--areas. So Haskell is a language that performs disproportionately well over the three axes I care about. But I think some facets of the language I don't care about are just as interesting as the ones I do. In particular, you'll note how I never talked about how Haskell is difficult to learn. And it really does take more effort to learn than other languages. Not so much because it's inherently difficult but because it's so different from anything else you've done. While learning Haskell, and learning it properly, is certainly difficult and time-consuming, it is by no means impossible. More importantly, learning Haskell well enough to benefit from it is an O(1) action with a reasonable constant size; its benefit is proportional to how much programming you do. As long as you plan to use it often enough, the benefits will easily dominate the cost. In fact, this is a conclusion I have about technology in general: if you're going to be using something often, a steep early learning curve is almost always more than worth it. What about libraries? Well, those certainly are an issue. Not nearly as much an issue as some people make it out to be, but certainly an issue. Haskell is sorely deficient in several places; for me, the biggest problems for me have been with GUI toolkits. There are decent bindings to wxWidgets and GTk, but both are very finicky to build and somewhat annoying to use. I'm sure other areas have similar problems, but nothing else I've done has been seriously limited by libraries. And, on the flipside, Haskell has some very good libraries in other areas. Web development is particularly rich: not only do you have Yesod and Snap, which are both great frameworks, but you also have some really cool libraries like JMacro which make it easy to generate JavaScript code programatically. So if you're working on web technology, Haskell is a great choice. This is particularly true because you tend to have far more control over which language to use on a server as opposed to which language to use on a native program. Haskell also has several incredible libraries that are almost unique. Parsec makes writing readable parsers with good error messages surprisingly easy. In practice, Haskellers don't use regular expressions for things--sufficiently simple things can be done with library functions, and anything more complex is both easier and more readable in Parsec. QuickCheck is a system for randomized testing of your code, which is more thorough than unit testing. The surprising thing is that QuickCheck is actually not that difficult to use or set up; this convenience is very difficult to reproduce in a language without typeclasses. There are also some great libraries for slightly more esoteric tasks like sbv for using SMT solvers and ad for automatic differentiation. One question that often comes up is why more people don't use Haskell. The main reason I've found? Most of the programmers I've talked to haven't even heard about Haskell. And the majority of the ones who have tend to know virtually nothing about it, mostly misinformation--Haskell has a very unfortunate reputation as an impractical, overly academic research language. A reputation that is largely undeserved. Most of the remainder are programmers fazed by the learning curve, people who didn't quite get to being comfortable in Haskell and understanding its philosophy (which is very important to being productive). And the small amount who have? Most of those are the ones who are fanatical about the language! Sure, there is some number of extremely intelligent and well-informed people who really do not like Haskell (e.g. Robert Harper), but they're surprisingly rare. And some of those I know just happen to work in particular niches that simply do not fit Haskell terribly well at the moment. Now, is Haskell perfect? By no means. I can think of at least a score of ways to improve it, many fairly small but some pretty major. A good portion of those improvements are already being worked on, but some will probably never come around. (Unless I implement them myself, I guess. One day...) But ultimately, it brings nothing to mind as much as the hackneyed Churchill quote about democracy: Haskell is the worst programming language, except for all the others. 