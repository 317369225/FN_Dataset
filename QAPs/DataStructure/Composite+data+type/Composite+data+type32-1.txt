Why are C# and Java not considered as Object Oriented Language compared to the original concept by Alan Kay?Today I just learned that C# and Java don't support Object Oriented Programming (OOP) if judged by the standard of the original concept coined by Alan Kay.  Does that mean that all the things we've been learning about OOP and reading in books are a complete non-sense? Could anybody explain to me why?
Sorry Chris, I realised only today that you asked this as a question. I'll repeat as an answer what I, basically, already told you in that comment thread (but I'll update with info that emerged later in the discussion between me and Mark). What we today call OOP is not a nonsense. It just is not OOP (in the original sense). There is OOP in the original sense and than there is OO as used in OOA/OOD (Object Oriented Analysis and Design). The concepts we often associate to OOP today are extremely important in OOA/OOD. But the result of an high level OOA/OOD process, which is (or at least should be) a language independent process, still needs to be transformed into a detailed language-dependent design and then into code. That's when one decides how those concepts are translated. And it may or may not be done in terms of OOP. The mistake is thinking that a procedural, structured programming environment, when used to implement a design which comes from an OOA/OOD process has to be intrinsically OOP. It's not. It still is procedural structured programming. If the language supports nominal sub-typing in the form of a class hierarchy such an implementation may be easier. But it still is not OOP. In fact, in OOP (in Alan Kay's sense), subclasses are not subtypes of their superclasses. Inheritance by subclassing in real OOP is mostly for implementation reuse, not for interface reuse (even if most, if not all of the interface is inherited as well). An IsA relationship is expressed through "inheritance", in the sense of subtyping, in OOA/OOD. But it does not need to be such in an real OOP implementation. In fact it's quite possible, and not rare, that if B is a "subclass" of A in the OOA/OOD document, in the OOP implementation the B class ends up not being a subclass of the A class. It ends up being an effective (protocol level) subtype, but its implementation may very well be in terms of a completely different base class. As Mark Miller have said (elsewhere on Quora) it's pointless to just say to students that C++/C#/Java are not OOP languages. I sometimes do here on Quora, but Quora is not school and I'm not a teacher (providing full explanations a gazillion time is futile, and on Quora that's what it would take, in a school you hopefully do it at most once per course). In a school either you "give in" and pretend that the current usage of the term OOP is correct or you do say it's incorrect but common and explain why, what the original meaning was and how, through the usage done of "OO" by the methodologists (the analysis and design folks), it has now become misunderstood. You eventually wrote (elsewhere on Quora): This is why when somebody asks me about learning OOP, my mind wouldn't go directly to Smalltalk and LISP.  Mainly because these are not very practical in term of getting a commercial job. If someone asks you about learning OOP you'd arguably ask "the real OOP, which is not used much in industry today, or what today is called OOP, which is not OOP, but it's what is commonly used and mistakenly called OOP?". Chances are they want to learn the modern thing, but may (or may not) become curious about the real thing. Which, in spite of not being used, is still something very much worth knowing (as are functional programming and logic programming, even if this is yet another topic). You also eventually wrote (elsewhere on Quora): In anyway, I don't believe that C# or JAVA are completely non-OO compliant. OOP is not a specification to which something can be compliant. It's hard to explain if you do not know Smalltalk and/or CLOS. OOP is an interstitial quality of a programming (that's the P) environment. And it has nothing to do with the design concept of OOD or the implementation of it. While the P is important, it is not essential. At least not if one uses OOP in a more general, and therefore looser, sense. In a loose sense the internet (not the web) is an OOP system (without, strictly speaking, being a programming environment, and therefore without being a P). (Internet) ... possibly the only real object-oriented system in working order. - Alan Kay The Internet was done so well that most people think of it as a natural resource like the Pacific Ocean, rather than something that was man-made. When was the last time a technology with a scale like that was so error-free? The Web, in comparison, is a joke. The Web was done by amateurs. - Alan Kay C#, C++, Java have basically nothing of an OOP system or programming environment. Objective C, JavaScript and, in some sense, Python or even Ruby, are far far more OOP (even if they really are not really OOP. But at least they go far closer). OTOH C#, C++, Java are as good as (and in some senses may even be better than) an OOP environment when it comes to implementing an OOA/OOD design. Again: suitability for implementation of an OOD has nothing to do with being OOP. Actually I made up the term "object-oriented", and I can tell you I did not have C++ in mind. - Alan Kay ... if you say that “Java is an Object-oriented language”, then to adapt your very phrase, “communication isn’t reasonably happening”. - Alan Kay From the question details: Does that mean that all the things we've been learning about OOP and reading in books are a complete non-sense? They are not non-sense. They make perfect sense. One may argue if they should be part of a teaching curriculum. I'd argue that universities should not aim to prepare students for a job (that's what vocational schools should be for) and should instead teach them knowledge, or better yet how to acquire it. There's a big difference between knowing and doing. When my father graduated as an engineer the university Rector said something like: we did not teach you to do, nor we gave you knowledge. We taught you the basis you need to go and reach for and acquire knowledge, including, but not limited to, the knowledge about doing. Now that you are done with your university studies, it's time for you to start learning. Hopefully a process that will never end. Some people are incredulous when hearing the very fact that the term OOP does not really mean what nearly all sources, books, universities are teaching today. But it is a (sad) fact. The the term OOP was coined more than 40 years ago but after 20~25 years, once it started to become popular, it has been totally redefined, in part for opportunistic reasons and in part for ignorance, in a way that strongly recalls an Orwellian dystopia (at least for those who have some attachment to the original concept). George Orwell understood that “colonizing” already existing terms and changing their meanings (even to their opposites) quite undermines progress in most ways. ... More personally, why should the definer of a term and a design principle have to come up with another term because others have been both careless and opportunistic? Should such definers and designers have to change their CVs because of the errors of others? I really don’t think this discussion would be happening in a real field such as Physics. - Alan Kay I'll close this answer the way I opened it. All you've been learning and reading about OOP is not a non-sense. It just is not OOP. 