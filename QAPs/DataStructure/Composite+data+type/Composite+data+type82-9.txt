How many lines of code can a good programmer write in one hour?
The most I've ever achieved was an average of about 10,000 loc/month sustained over three months. Maybe 500 loc/hour but possibly quite a bit higher as there was a lot of auditing involved - I was converting code so after I wrote the translator I was testing its converted code. (I should clarify this - the lines of code was the translator and about 5k LOC to implement the FORTRAN formatted IO libraries, not the amount of code being translated.) That was using the Think Pascal Object Pascal environment on a Mac writing a FORTRAN -> Object Pascal translator and accompanying runtime libraries. There was quite a lot of similar code so copy-paste-edit. I ended up with severe tendonitis on my right arm due to all the triple-clicking to select a line. Update There's been a bit of scepticism about the rate and dangers of producing code at this rate so I'll expand here for people who don't read comments. The domain of the code being translated was horrendous 1960's era FORTRAN, in some cases line after line of arithmetic If (that's a 3-way GOTO for people who don't know the language). It was transport modelling software that was intensely data-driven. As such, the acceptance testing was both demanding and well-organised. There was a huge body of input models and known outputs plus new data was run in parallel on the old system for months after delivery. Ironically, the acceptance testing uncovered some mis-filing of inputs vs matching reports when ported code generated not-quite-matching results. (I nearly had a breakdown hand-debugging and trying to work out why the numbers didn't match before giving up and telling the client I couldn't work out why this example was failing.) The sheer complexity of the code was one reason I started automating the translation - hand translation with a series of search and replaces was unacceptably slow. The FORTRAN used lots of tricks so my implementation had to be very accurate. Those tricks included mapping bits of common memory differently to reuse space and relying on the way the formatted I/O library would reuse its specification given more arguments than specified. Comment: Whilst measuring LOC produced is a lousy measure of progress, LOC touched can be a very good one as a relative metric. By touched, I mean added, edited or deleted. Mapping the degree of change in different modules of your system over time gives a good idea of relative focus and growth. It may also be a good hot spot indicator of problems in an architecture. If a given area is repeatedly being maintained, for reasons other than major growth in features, that usually indicates an architecture problem or simple code quality issues. In rare cases, it may also indicate a team problem - if someone is rewriting another team member's work out of caprice. Updated 28 Aug â€¢ View Upvotes