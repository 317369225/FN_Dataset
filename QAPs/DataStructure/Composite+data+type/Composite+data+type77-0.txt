In what ways are the major modern functional languages different from each other?... compare and contrast Haskell, OCaml, Clojure, Scala, Erlang, and F#, say, (or whatever subset you know about).
Statically Typed Of all the languages, Haskell is the "most functional": it's functional first and only layers imperative features on top of a solidly functional base. It's lazy and all effects have to be managed by the type system: normal code cannot work on mutable state or have any side effects whatsoever. It has a surprisingly expressive type system with no inheritance or sub-typing. Haskell has an incredible runtime system with top-notch parallelism and concurrency features including some very efficient green threads, software transactional memory and libraries for deterministic parallelism. OCaml has some strong similarities to Haskell. It has similar algebraic data types and full type inference. It has a fast compiler that produces reasonably fast code. Since it's strict, many people find it easier to optimize than Haskell. Compared to the other functional languages I'm familiar with, it's probably the most memory efficient. At the same time, it has some really surprising drawbacks: a global interpreter lock heavily limits its concurrent capabilities, it has the weakest set of libraries of the lot with a very limited standard library and it's syntax is pretty ugly. OCaml supports some object oriented features with structural sub-typing and full type inference; however, most people don't like to use the OO subset of the language. Unlike Haskell, it has pervasive side-effects: mutable refernces, mutable arrays and even mutable strings! Both OCaml and Haskell compile to native code, with reasonably easy interfaces to C. Interfacing with C++ is also possible but is a bit of a pain. SML is very similar to OCaml, just generally more elegant. It's one of the  very few fully specified languages along with Scheme. Unlike OCaml, it  does not have any OO features. For better or for worse, it's been  stagnating lately and is mostly used as a teaching language now. Both OCaml and SML have very powerful module systems, something really missing from Haskell. Many advances in programming with modules and module typing come from SML and OCaml. To some extent, these module systems play the same role in program organization as OO classes do in OO languages. Scala is much more of a compromise language than Haskell or OCaml. It can't really decide whether it wants to be functional or OO, so why not both? It suffers a lot from trying to be like Java, including unfortunate syntax, nominal sub-typing, limited type inference, no proper tail calls... etc. It has a capable OO system with classes, traits and nominal sub-typing. Being similar to Java and running on the JVM makes interoperation with Java libraries very easy. Since the design of Scala is full of compromises, it isn't very good for more advanced functional programming: read this detailed account by Edward Kmett about the problems they've had with Scala at S&P Capital IQ. F# is Microsoft's .NET take on OCaml. It throws all of the exciting module features in order to be compatible with C♯ and .NET in general. It has nominal subtyping and more primitive type inference than OCaml et al. On the other hand, it has some really cool features like active patterns and type providers and, of course, integrates really well with the rest of the Microsoft stack. In practice, it feels much more comprable to OCaml than Scala. Dynamically TypedErlang is a language with a very clear design goal: large, fault-tolerant distributed systems. And it does really well at this task, with lightweight process and an extremely resilient runtime system. Erlang is well-known for its let-it-fail philosophy to error handling: if you have a problem, just crash your process and replace with another one. Unfortunately, outside distributed systems, Erlang is quirky and relatively ugly language with odd syntax and surprising shortcomings. (They only had maps added recently!) I would not use it for anything involving non-trivial logic or really anything outside large distributed systems. Scheme is a very elegant, minimalistic take on Lisp. It's designed to be small, self-contained and multiparadigm. While it supports and often encourages functional programming, it has imperative features at its very core. In practice, I've found code in Scheme is often at least partly imperative. A recent extension is Racket which provides additional libraries and features. Both Scheme and especially Racket are heavily geared towards developing DSLs, even more so than the other languages on this list. It's one of the first languages to include proper tail calls in the standard. Along with SML, it's the only fully specified language on this list. Clojure is a Lisp for the JVM. It encourages functional programming, immutability and persistent data structures far more than Scheme or Racket. That said, it still has side effects and mutation at its core, it's just that common idioms and practices avoid them. Being on the JVM means it has some similar features to Scala: easy Java interoperability but some execution limits like no proper tail calls at all. It's the only language on this list apart from Haskell that has had any luck with software transactional memory. Updated 20 Oct 2014 • View Upvotes • Asked to answer by Joe Wezorek