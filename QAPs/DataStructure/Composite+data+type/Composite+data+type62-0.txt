What is the difference between a function and a functor?Particularly, in Scala.
Let's start with a category theory definition of a functor. A Functor relates categories together and is essentially a transformation between categories. Given categories C and D, we can have a functor F: C -> D that maps: (a) any object A in C to F(A) in D and (b) morphisms f: A -> B in C to F(f): F(A) -> F(B) in D. Now let's see what it translates to in Scala. A function in Scala, just like in any other programming language maps values - take a data value as input and produces some data value as outputs. A functor, on the other hand is a higher order structure in the sense that it's defined as a mapping between categories of Scala types (just as we speak about the category Hask when we talk about Haskell). In Scala type system we can have a type A, parameterized by another type, denoted by A[_] and is called a type constructor. Substituing Int in A, we get a concrete type A[Int] which is an instance of the type constructor A[_]. Note that in the above definition in category theory, a Functor generates a type since in Scala we are talking about the categories of Scala types. Hence it's logical to represent a Functor by a type constructor. If we have a Scala function: f: A => B, the type constructor F[_] is a functor if we can lift the function f into it, i.e. given a functor instance F[A] and the function A => B, we can get another functor instance F[B]. Stated in another way, the functor F[_] maps the function A => B to F[A] => F[B], which is precisely what the category theoretical definition (b) states. Hence the type of a functor can be represented in Scala as F[A] => (A => B) => F[B]. can be represented in Scala as F[A] => (A => B) => F[B]. Scalaz (https://github.com/scalaz/scalaz/) implements a Functor as a typeclass and provides many instances of the typeclass. It defines a Functor as a trait: trait Functor[F[_]] { def fmap[A, B](r: F[A], f: A => B): F[B] } As per the above definition, an alternate view of a functor is as an abstraction that can be mapped over. In fmap, we map the function f over the functor instance F[A] to generate F[B]. A classic example is the definition of List as a functor, which just uses the map function. implicit def NonEmptyListFunctor = new Functor[NonEmptyList] { def fmap[A, B](r: NonEmptyList[A], f: A => B) = r map f } Incidentally a function can also be an instance of a Functor where by mapping we mean function composition: implicit def Function1Functor[R]: Functor[({type l[a]=(R) => a})#l] = new Functor[({type l[a]=(R) => a})#l] { def fmap[A, B](r: R => A, f: A => B) = r andThen f } 