Functional Programming: What are monads and why are they useful?
As Simon Kinahan said, Monads are just a design pattern mostly specific to Functional Languages that need to encapsulate the transformation from one type to another. As nice as Tikhon Jelvis answer is, I think it is fundamentally the problem with why Monads are so difficult to understand. It is one of the reasons it also took me a long time to understand the concept. The mathematical explanation works if you understand mathematics. The functional language explanation works if you understand functional programming. How then do you explain the concept to someone who doesn't understand either? Design patterns exist to cover some flaw or missing language construct in the language. It is entirely possible and in some cases acceptable to use monads in other languages. Take for example the Maybe monad. It is more difficult to implement in Java or other languages where null pointer exceptions halt the execution. In Swift, the Maybe monad is implemented in the language. For example as opposed to doing this: if (value == nil) { return; } You can do this: var otherValue: Int? = nil if let value = otherValue { // Use value to perform some task. } else { // otherValue is null. } It is also possible, if you have a function that is Optional, to assign a default value. func doSomething(optValue: Int?) { let value = optValue ?? 10; } The Swift language moves the Maybe monad from a design pattern to the actual language, simply because Maybe or Optional is such a common pattern for managing null pointer exceptions. There are monad languages for languages in that implement certain monads from functional languages. Looking at the Java implementation provides greater explanation for what Monads are and their purpose. Why? Monads exist in functional languages, especially pure FP languages, since there must not be side effects from functions. A function must return the same output for the same input. There are cases where this is not the case. The Maybe monad could return Nothing or it could return some value with some type. The reality of programming is that it is not math and not pure. You are going to have side effects and therefore you need a language construct that allows for side effects in a language that does not allow for side effects. Monads work by deferring the side effect until the value is evaluated. It does this by implementing an interface of up to 3 methods. The simplest explanation for Monad, that removes all nuance, is that it is an object implementing an interface that the language uses to perform deferred type conversions. Tikhon Jelvis provides the best technical explanation for the methods that are implemented for Monads. Then again there are other tutorials and resources that has the same information. 