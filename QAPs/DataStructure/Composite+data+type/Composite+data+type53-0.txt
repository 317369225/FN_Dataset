How do I transition from Haskell to Java?
I've done it, although I already had the very similar C# in in my toolbox (mentally), and I'm just going to quote from Carl's answer: LOL, why would anyone want to? He got that right. If you can - just don't! or at least use C# instead, and I would prefer C++ (if possible). If you will still use Java, I'm just going to assume you're forced into it and base my answer on that. I was forced to use Java because Java was the only right tool for the job. It should be a crime to create platforms that make Java the right tool bu--before I continue I'm going to state that I have strong opinions & I'm heavily biased against Java (it's not the first time I have to state that in an answer), you might want to take what I say with moderation. But anyway, turns out the guys at Google thought it would be great to make it the main language for Android. I'm going to write from that experience. I won't write on too much, just the things that struck me as the most important. Interfaces are surprisingly great!This will put a smile on your face: you don't have to write a concrete class to instantiate an interface. You can just write the value as an anonymous object! I've used this a lot and it helps a lot with still being somewhat functional. Java didn't offer me a good equivalent of Action and Func (the ones that take multiple parameters) that I missed so very much from the .NET world. I wrote an interface for functions, and I could have Func by currying! I also wrote a Unit class with one read-only static instance and a hidden constructor and now I have Action too! Note: if you don't use the language's lambdas, use an IDE that can hide needless content (IntelliJ IDEA and inherently Android Studio do that) for these kind of stuff because the syntactic noise will be too much. Anyway: use them! AbstractionYou'll have to manage with much less of it, I'm afraid. Use contracts, assertions, documentation and whatever you can to constrain to sane values. You're going to rely on how you name your identifiers. This will require more common sense from the developers. This also means you have to do sanity checks. Your function wants a String? check if what you receive is null. And rule of thumb: report errors as early as possible! If you're going to crash, just do it. Discriminated unions (ADTs)Do not give up on them and do not forget them. They are incredibly useful. Java doesn't support them? that's okay. You have to respect the OO world you're in? no problem. Here's what you do: Make a package for it (for access; you will need that to make sure your type is closed). Make an abstract base class, even if it will be empty, with the name of the ADT. You can also put there what's common to all of the ADT's constructors (probably should). Do not expose it's Java constructors. Make a class that extends the base class for each ADT constructor. Be efficient: if an ADT constructor has no arguments, hide the Java constructors and expose a static read-only field for just one instance. (You want it read-only so you won't see this: yourPreciousInstance = null; // HAHAHAHAHA BOW TO ME). PatienceBasically, it's not fun and it will require a lot more patience to write good idiomatic code and I ask you to only work when you have the patience. Otherwise you will make bad software. So when you feel emotionally bad about it, please leave it alone, then keep your eyes on the prize, and once you feel better from that, continue. Things are just slower. This isn't the main issue but syntax isn't as succinct, it's even { kind of {   annoyingly {   blocky  }   } } and; quite; "semicolony"; It's cumbersome and I find it inferior to mere indentation. I think the most annoying part in the syntax is actually what it doesn't do. No automatic properties. Want a field? write a field declaration, a getter, and a setter. You better have an IDE. Don't forget to give the right access modifiers because it can't help you there. And don't screw it up! because you can: make sure the initial value is okay, and check for null in the setter if you can't have that. Consider when to be idiomaticYou're in an object-oriented world now. I know you want to be functional and re-invent Maybe and Either at the very least -- I did. It's a trade-off between the homey functional paradigm and readability. If you use nulls, just be careful. Please, do not crash over them! And use documentation to make sure they're meaningful too. If I get null from a function, what does it mean? did the operation fail? or maybe it worked but retrieved nothing? (if both are possible and this information is important, just giving null isn't good enough. Make a class for the result). Is it okay to give your function a null? (is the argument optional?), if so, what will happen? Summary 