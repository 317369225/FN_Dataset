What does object-oriented programming do better than functional programming, and why is it the most popular paradigm when everybody seems to say functional programming is superior?
Neither of these terms are necessarily well-defined, at least in common usage. In fact, I'd argue that functional and object-oriented programming, done correctly, don't conflict. The problem with "object-oriented programming" isn't that it's a bad idea, but that over 90 percent of the people doing it have bastardized the concept. What is functional programming? The badly-done OOP that's popular in the business world has some 23 design patterns, and many more combinations thereof: Factories and Visitors and VibratorFactoryVisitors. Functional programming has two fundamental design patterns: noun and verb. For nouns, you have immutable data. For verbs, you have referentially transparent functions: that is, they return the same output per input. 99 percent of what you need to do, as a programer, is satisfied by these two constructs. If you can use immutable data, or a function, do so. What are its limitations? First, the world is mutable. In functional programming we refer to stateful effects as "side effects" and this is an unfortunate term, because some procedures are supposed to have effects, and main effect is a more appropriate term. At any rate, we write programs to do things. So, in addition to our two core concepts (noun and verb) we end up with a third one, the action: printing a character to the console, checking the time, or posting a picture of your cat to Twitter. Actions can be function/verb-like in that they actually do something (rather than just computing something) when executed, but it can be helpful (see Haskell's IO monad) to treat them like data (nouns) when building complex actions up out of simpler ones. Finally, while an ideal world (with infinite memory) would never require mutability or destructive change, you often need mutable references and collections for performance reasons. So, in practice, functional programming is about managing state, not eliminating it, because (a) many problems are inherently stateful and (b) the performance implications of eschewing mutability may be unacceptable. Real-world functional programmers don't avoid "dirty" constructs; we just know when we're using them. Why might "object-oriented" ideas be useful? Somewhere around a few thousand lines of code, you need organization. Adding functions and constant declarations to a global namespace isn't going to scale forever. You also find yourself writing repetitive code, if you're not careful. Let's say that you're working with linked lists, arrays, persistent vectors, and lazy streams, and you're doing a lot of map operations (like list comprehensions). At some point, you're going to get sick of having to differentiate between the List.map and Array.map and Vector.map functions. Writing repetitive code for various collection types isn't fun and it makes your code brittle. The root concept of an object is that functions can be locally interpreted, usually based on a trait (class) of the first argument. There are more flexible regimes for this (see: Clojure's multimethods) but this is the most common one. You also have, as codebases grow, an increasing need to deal with "the adjective problem". You've mastered nouns and verbs, but now you want your libraries to deal effectively with anything that has a map function: a Mappable (or, in Haskell, a Functor). At any rate, a function that will always be locally interpreted is often called a method. Finally, object-oriented programming offers encapsulation. This can be good or bad, depending on who is writing the code. Hiding implementation details can make use of a class simpler, and it can also prevent application programmers from entering an inconsistent state. Alan Kay's original vision for "object-oriented" programming was the biological cell. The cell is a complicated piece of machinery, but it interacts with the rest of the body through a simpler interface: chemical signals (hormones) and electrical impulses. Alan Kay (who seems to despise the bastardization of "object-oriented programming" that is now the rage in Java Shops) wasn't encouraging people to create monstrously complex objects. Rather, his vision of OOP was that it was something you want to do when complexity is inevitable: throw as much of that complex implementation behavior (that may change, for performance reasons) behind a much stabler, easier to use, and preferably self-documenting interface. That concept is still quite valuable if you're doing strict functional programming, and the good news is that all the modern FP languages offer it. 