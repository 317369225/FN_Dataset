In what ways are the major modern functional languages different from each other?... compare and contrast Haskell, OCaml, Clojure, Scala, Erlang, and F#, say, (or whatever subset you know about).
You can usually see these differences through a few categories: Type system; Expressiveness (tools for solving the expression problem); Safety (tools for controlling effects); Execution model; The type system spectrum goes from untyped (Erlang, Clojure, Scheme, Racket) to typed (Haskell, Scala, O'Caml, F#, Idris). Most functional programming languages are typed, and most of the research on functional languages can be somewhat related to type systems. But this is a quite large spectrum, with different features falling between the untyped and typed variants. Erlang, Clojure and Scheme have the most rudimentary facilities as far as types go. You could either say that none of those languages have types at all (by Pierce, types are a syntactic framework¹), or that those languages have only one type (by Harper, types are associated with an expression, and since in a dynamically typed language all compositions of expressions are valid, you must use one type to express that — and tag the values to differentiate them²). While the lack of static types mean that these languages can't enjoy lots and lots of nice properties of expressive type systems (hell, parametricity is one of the best things ever, and you can't have it in these languages!) and recent research on the area, it also means that they're free to model this concept of “type” however they want. It's a trade-off, and there are interesting points made about this³, by Felleisen, Tobin-Hochstadt, and others. As I said, untyped languages allow you to model different concepts of “type,” and there are some interesting ideas in it. Racket has higher-order contracts, that allows you to express in a simple way (in exchange for static checking and some performance overhead) complex invariants and conditions about your computations. For example, the following definition is impossible to express in Haskell, but easy to express in Racket: (define/contract sqrt ;; Makes sure the sqrt function always receives ;; a positive number as input, and returns a ;; positive number that's when multiplied by ;; itself results in a number that is equal to the ;; original input, with some small margin of error ((lambda (x) (>= x 0)) .->. (lambda (x) (lambda (res) (and (>= res 0) (<= (abs (- x (* res res))) 0.01))))) ...) Contracts are covered by some interesting research in Blame Calculus⁴ by Wadler, Felleisen, et al; and similar to the “well typed programs don't go wrong/get stuck” motto, Blame Calculus say “well typed programs can't be blamed”. Aside from contracts, you've got gradual type systems, and optional type systems. I've never seen an example of the latter for functional languages (they're mostly in OO languages like Newspeak and Dart), but gradual typing is a well researched topic, and Racket has it as the Typed Racket dialect, whereas Clojure got core.typed. You could say that gradual type systems gives you the best of untyped languages and typed languages, allowing you to write types only for the parts of your program you care about typing. The typed language spectrum is actually even larger! You've got languages that only support nominal typing (Haskell, ML, F#), languages that only support structural typing (O'Caml), languages that support both (Scala), languages that use subtyping (O'Caml), languages that use row polymorphism for structural typing (PureScript, Roy, MLPolyR), languages that have Hindley-Milner type systems (almost all of them), languages that don't have Hindley-Milner type systems (Scala), languages that have a kind system and support higher-kinded types (Haskell, PureScript, Scala), languages that don't support higher-kinded types (F#). Languages that support linear types (Rust). The type system may enforce totality (Idris, Agda), or not (most languages). And so on, and so forth. And then you get to even more expressive type systems: the dependent typed languages (Idris, Agda), and languages that use refinement types (Haskell + Liquid Haskell). There are probably a lot of other type systems, but my knowledge on the most advanced ones is somewhat limited right now. Now, let's move away from the type systems (else I'd have to write a whole 300-pages thesis as the answer) part and into tools for expressiveness that can be seen in these languages. These also vary quite a lot. There are two main tools for this: ML modules (ML, O'Caml), and type classes (Rust, Haskell, Clojure, Elixir, Scala — implicits + objects gives you first-class type classes, without global uniqueness of instances). Harper argues that ML modules are more general than type classes. I can not confirm that claim, but they both solve reasonably well the expression problems, despite some of the abstraction issues with ML functors. Most other languages will use some kind of objects for modules (F#, Scala), multi-methods (CLOS, Dylan, Clojure), or not solve this problem at all, giving you only higher-order functions for abstraction. Another area where functional languages diverge greatly is on the tools they provide for controlling effects. This is a particularly important part of functional languages, since you want your programs to not have side-effects at all, and you want to be able to abstract over and compose them in a neat way. Monads and monad transformers: Haskell requires all of your side-effecting computations to happen inside the I/O monad, although it provides unsafePerformIO that allows you to execute them anywhere (it's quite dangerous!). PureScript, Haste, Fay, Frege, Elm, and other languages derived from Haskell tend to follow the same pattern. The major problem in this is that monad transformers do not compose well. Anything you will: these languages don't care about controlling your effects at the language level, they only expect you to do so. Mostly, they'll give you things like immutable data structures and pure functions so you avoid mutability, but it's cool to have an arithmetic addition function that writes a file to your HDD. O'Caml, ML, Racket, Elixir, Erlang, Clojure, and pretty much every other language fits in this box. Effects system: Additionally, a dependently typed language can provide you a way of describing the effects of your program at the type level, and enforce that those effects are correct (for example, it can statically check if you've used a file handler correctly). Idris has this. Algebraic effect handlers: similar to Dylan conditions system, but far more general, they separate pure computations from effectful computations, and give you tools for abstracting over effects, and composing them. Together with an effects system in the type system, you can statically guarantee lots of things about your program, and they're far better to work with than Haskell's monads. Unfortunately, I only know research languages, like Eff, that have this. Just reify the effects on the types and compose them: this is similar (to a certain extent) to Java's checked exceptions, but far more general. Koka and PureScript have some of this.Languages like Mercury, Clean, and other languages based on logical frameworks probably provide a different way of handling effects, but I'm not too familiar with them to describe that. The way exceptional cases are handled also differs. Haskell has several different exception handling mechanisms, but the recommended approach is to reify them in the type system and either pattern match it, or provide a monad instance for the type. An historical accident made monads have a failure mechanism forever, which is quite unfortunate. Erlang and Elixir don't handle failures, they let the system crash and let a supervisor deal with what to do after that. Clojure and Scala use Java's exceptions. Racket has all sorts of ideas about everything. Dylan uses a condition system, which is more powerful and more general than Java's way of handling exceptions (you can go back to the call site and try different approaches to handling the error, for example, without unwinding the stack). O'Caml used to be all about pattern matching, and got some extensions later on to fix some of the issues with the wow this is so painfully explicit! effect. Lastly, you've got execution models. The major differences you'll see in the major languages is whether it uses strict evaluation (most functional languages), or lazy evaluation (Haskell). Another axis separates languages that are turing complete (most functional languages) from the ones that are total (Idris, Agda). Ideally, you wouldn't want your language to be turing complete, since that opens it up for all sorts of bugs, but we kind of always end up going for the languages where it's easy to make mistakes that are not perceived, anyway. ¹: Types and Programming Languages ²: Dynamic languages are static languages ³: http://existentialtype.wordpress..., http://existentialtype.wordpress... and On typed, untyped, and “uni-typed” languages ⁴: Blame and contracts 