Functional Programming: What is a functor?
I like to think of a functor as a generalization of a container. A regular container contains zero or more values of some type. A functor may or may not contain a value or values of some type -- and the values may be virtual, that is, not present at the time of interaction. They might, for instance have to be evaluated later. So what can you do with such a container? You might think that, at the minimum, you should be able to retrieve values. But each container has its own interface for accessing values. If you try to specify that interface, you're Balkanizing containers. You're splitting them into stacks, queues, smart pointers,  futures, etc. So value retrieval is too specific. It turns out that the most general way of interacting with a container is by modifying its contents using a function. This interface is well-defined: give me a function and I'll apply it to the contents of the container. (In Haskell it's called fmap.) In the simplest case, you have something like the C++ std::transform algorithm. But the mapping of a function over a functor/container is much more general. In particular, if the values don't exist yet, the functor may apply the function virtually (that is, store the function on the side and apply it later). This is the case of future values, the virtual results of running a thread. In C++, you can apply a function to a future by calling its method then. A lot of people have a problem stretching the container analogy to functions. A function doesn't contain values -- it calculates them. But it's still a functor. So how can you apply another function, h, to all the values that a given function f (treated here as a functor) may calculate in the future? You have to capture h and apply it to the output of f, when it's called. So a function is also a functor. A lot of functions can be memoized, effectively replacing them by a container that stores pre-computed values. So, conceptually, the distinction between a function and a container is not that sharp. The function that is applied to a functor may change the type of the contents. It's very important then that the same functor/container data structure be able to store values of different types (but not at the same time). So a functor is a polymorphic container whose contents may be modified by an arbitrary function, with the caveat that the contents doesn't have to physically exist at the time of the application of the function. There are also some pretty obvious functor laws that must be satisfied. One is that applying the identity function to a functor doesn't change its contents. The other is that if you apply two functions consecutively, the result should be the same as applying one composite function. The concept of a functor exists in all programming languages, but in some languages it can be expressed more clearly than in others. In Haskell, you can define a generic type class Functor that unifies all types of functors. In other languages you can only do it as a programming pattern. It doesn't help that in C++ the term "functor" is misused to denote a function object. Updated 3 Aug • View Upvotes