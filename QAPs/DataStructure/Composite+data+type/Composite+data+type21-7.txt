What are the growth stages of a programmer?Can someone share their journey and what clear stages you can identify over the years? e.g. learning your first programming language, first IT jobs, career decisions, understanding goals of corporate IT, etc?
I sold my first program when I was 14 -- a floppy-disk based catalog that tracked mold maintenance for a local manufacturing company. Then, for me, programming was a passionate hobby. I had skill and intuition and zero training. Over the years (lots of them), I have discovered and classified 3 key levels of competence in the field: Stage 1 - The Spec Monkey(as in, "Dance monkey! Dance!" -- 0 to 3 years experience) Software guys (I will use guys here to refer to either gender, as the distinction is unimportant) at this stage are passionate but naive. They will look at a story and implement it as written with no thought toward how the software may be used in the future. They will not think about general utility with a specific veneer to satisfy the special case outlined in the story. They will not think about the likely changes that will be demanded once it is released into the wild. Their motto is; "you asked for X here is X and it will never need to be anything other than X".Â  On the surface, this seems really cool and agile, but it is actually the tragic variation of agile that I dub fr-agile. Any change to the story spec and you are forced to re-write so much code that should have been generally useful. This makes you hate that harbinger of change; the Product Owner. They walk into the area and you are filled with anxiety and distrust because so much of what you wrote will need to be written again. These people should be your friends - they are there to make sure your software is needed and wanted and will be used. Stage 2 - The Meta-Engineer(years 3 to 5) Now you have learned your lesson -- your software should be able to withstand any minor changes to requirements and any major ones too! Those crappy business dudes with their crappy changing requirements can suck it, cuz the software you write now can do anything. Why, it's a veritable scripting language. You wanted the software equivalent to a dessert topping? We give you THIS - it is a tasty dessert topping, removes tarnish from silverware and is a handy floor wax. Now the only problem is that it took us 3 months to deliver a small part of the software, but the cool thing is, no matter what you want that software to do, it can be configured to do it. Never mind the fact that at this pace of achievement, it will take a decade to get the next release out. Also, please ignore the man behind the curtain, whose life as a coder is over because now he writes config files in JSON or XML in order to make this behemoth work. The important thing is - the feature you asked for is done along with a million other features you never asked for (and never will) all wrapped up in one extremely costly package. And the bugs? Shoot this thing is the gift that never stops giving... if you want bugs, that is. Stage 3 - The Craftsperson(years 5 and on) By now we have learned that we need architecture; sometimes heavy architecture, but most of what we do should be written to purpose as simply and quickly as possible. Some of your program needs careful engineering and time-consuming thought and testing to product something that can support and promote the business for the next 5 years, but most of it just needs to get done now. We have hopefully gained the wisdom to know the difference and we have gained, through practice and experience, the tools and skills we need to protect ourselves against changing requirements without writing our own operating system. We will encapsulate functions into modules and utilizes software tools correctly so that we can replace the awful and no-longer relevant bits without losing the whole thing. We refactor some portion of our product in every sprint and we constantly look to improve, not just the performance and the function of our software, but its composition. At this point, I think, we are at the top of our game. 