What are the novel ideas and profound insights in the design of the Haskell programming language?I am interested in the ideas and insights that have become prevelant in other programming languages, as well as the ideas and insights that did not gain traction elsewhere.
Haskell has quite a few very interesting features and insights. As befits a functional language, it has some very impressive features for parallelism and concurrency. Here's one example; I'll probably add more later: Parallelism Haskell has the notion of "strategies" for parallelism. This is a very special model for parallelism for two reasons: it's deterministic and it's decoupled from the actual code. What exactly does this mean? Determinism is easy to explain: the compiler guarantees that the parallel code retains the same behavior as the sequential code. It might not be faster, but it'll still work. Easy to explain, but, I think, incredible: no other language I know can offer a similar guarantee. The decoupling is a little bit more subtle. There are different ways to evaluate any given computation in parallel; currently, compilers cannot work out which one is best ahead of time. This means the programmer has to specify where and how to parallelize their code. In most languages, you can do this by using special functions (say parMap) or annotations ( #pragma omp ...). In both cases, you have to modify the original sequential code to parallelize it. In Haskell, you specify the "strategy" for how to parallelize code completely separate from the code itself! Here's a very simple example from Parallel and Concurrent Programming in Haskell[1]: map solve problems `using` parList rseq this tells Haskell to evaluate the list in parallel, evaluating each item of the list sequentially. The normal code remains unchanged; the parallelism is specified as the second argument to using. In fact, the input could look completely different: [solve problem | problem <- problems, someCondition problem] `using` parList rseq this still works even though you used a list comprehension and filtered. In fact, the computation to parallelize could even come from a different module, without needing to change that module at all! All that parList needs is that its argument is a list. It works on any list, however it's provided. And the type system ensures you can only use it with a list. There are a bunch of other strategies for different data types, and it's pretty easy to write your own. Moreover, it turns out that a strategy is just a normal function. This is also how parList takes another strategy as an argument--it's all just normal Haskell code. [1]: A truly wonderful book you can read for free online. Haskell has something of a tradition of high-quality, free books now, including Real World Haskell and Learn You a Haskell for Great Good. 