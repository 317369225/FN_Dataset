What is the integrity constraint in relational databases?Or a contraint in general? What types of constraints are there in relational databases?
I'm going to offer a rather simplistic and practical answer to this question and leave the more sophisticated academic details for others to expound upon. There are, roughly speaking, two sorts of integrity constraints that you'll encounter in common SQL RDBMS. The first, implicit constraint is on data type.  Every column has a type and the database management system rejects attempts to insert or update rows with invalid data in any column.  Your CREATE TABLE statements establish these constraints.  These can include NOT NULL and UNIQUE constraints to ensure that data is not only of the correct type, but that it's present and that there are no duplicates of any value within a given column. PRIMARY KEYS are implicitly UNIQUE and NOT NULL.  (Note it is also possible to have "composite" keys or impose composite UNIQUE constraints; this simply means that the constraint is imposed on multiple columns.  For example a UNIQUE constraint on (first_name, last_name, birth_date) would mean that not two entries could have the same combination of first+lastname and birth date -- but many entries could have the same birthday, the same first names, or even the same first and last names, etc). The second class of constraints related to "referential interity."  These have to do with the relations ... or references among tables.  For example if I have a table of authors, a table of publications, and a junction table relating publications to authors (a classic multi:multi association) ... then I would normally declare constraints on both columns in the junction table "REFERENCES author.id for one and REFERENCES publication.id for the other.  This arrangement would ensure that not entry in the junction table referred to a non-existent author nor to a non-existent publication. When you create a table using REFERENCES then these referential integrity constraints are implicitly enforced by the RDBMS. In addition to these implicit constraints it's possible, in most database management systems, add your own custom constraints ... which can require values in a certain range, require that values in one column NOT EXIST in some other column (UNIQUE only ensure that the value doesn't exists somewhere within the same column/table), and so on. These custom constraints could generally be categorized as being on data type/value or relating to referential integrity.  (Off hand I can't think of a single constraint would be in both categories; but I can't assert with any confidence that such a thing is not possible).  Certainly I might have multiple constraints  on a single column.  For example I might have one for mapping drivers licenses to persons which REFERENCES some sort of person.id while also having another which requires that person.age > 16, for example. In general the purpose of RDBMS integrity constraints is to ensure that bad data doesn't get into the system; by having the database system provide as much centralized  enforcement (referential integrity and business rules) as is possible/practical. The core assumption of an RDBMS is that the corpus of data stored there will be used by different applications concurrently and over time.  The intention is to be robust even in the face of possible application level defects so that the data and the relationships among the data retain their value. (This assumption is often in dynamic tension with how many applications' programmers view "the database."  To many applications developers "the database" is simply a fancy filesystem or data persistence engine, and one which imposes constraints on their code.  That view is not necessarily incorrect.  Many databases are created and maintained only for use by a single application or tightly couple suite of applications.  Also that view naturally leads to the Object-relational impedance mismatch and to the forces which gave rise to NoSQL). 