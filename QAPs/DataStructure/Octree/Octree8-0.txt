What are some fast and scalable algorithms to determine whether a given 3D point set has a (unique) geometrically-similar embedding into a 4D point set?
Without any special expertise in this class of algorithm, here's a crack at the problem. A straightforward approach is to pick points A, B, C, D in the needle; then try pinning them down recursively.  So for every X in the haystack, try A = X; which means for every Y, try B = Y; that fixes the scale and limits the rotation, so now C is constrained to a 2-dimensional sphere in 4D; for each point Z on that sphere, if any, try C = Z; then D is constrained to a circle in 4D, so do the same; then if we get this far, the whole needle is fixed, so check that the remaining points land on points of the haystack. That works.  The problem, of course, is that doing it naively could take k * n^4 time, if there are k points in the needle and n in the haystack.  (n^4 choices of X, Y, Z, W, k points to check for each one.)  So we need to do better. First, if your input is not truly pathological then there will be far fewer than n^4 choices of X, Y, Z, W that fit A, B, C, D, and indeed far fewer than n^3 that fit A, B, C.  So for each of n^2 choices of A, B you'll naively hunt through n possibilities for C, and that'll dominate the work, for n^3 time. Then with some reasonable geometric partitioning -- like an octree -- you should be able to search a sphere for C (and a circle for D, and a point for each remaining point of the needle) efficiently.  That should make it [math]\tilde{O}(n^2)[/math], i.e. n^2 times a factor that doesn't grow too fast. So much for the easy preliminaries. If "scalable" is a real issue, does that mean the 4D haystack may be very large, containing many points?  In that case, can you settle for finding the needle only if it is not blown up too big -- in particular, if it is not blown up so far that it cherry-picks a few points from an area that contains many more?  If you can, then that saves the day: n^2 becomes M*n, where M is the approximate number of neighboring points that may be skipped over by the needle.  For each X, take Y only from the nearest M or so points, e.g. from the neighboring few octree cells if you start by making a well-balanced octree. If you do need to be able to find giant blown-up needles, then perhaps a multi-level approach would do the job -- do one pass for small needles, then at a higher scale lump together nearby points (say all those under any small octree node).  I'd have to think harder to decide how well I think that would work.  It might depend on whether you want the points to match very precisely, or if e.g. you're fine with the points of a big needle matching at a correspondingly fuzzy scale, proportional to the size of the needle. Hope that helps.  Maybe an expert will come along and point you into the literature. 