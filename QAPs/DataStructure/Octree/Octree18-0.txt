Computer Graphics:Â How does the distance field ambient occlusion work in the Unreal Engine?
Thanks for the A2A Glyn. Signed distance fields are great! Basically, polygon meshes are stored as a bunch of points, and also a list of indices into those point, collected in triples, for defining triangles. This is great and the GPU can render them very quickly, but the problem is that you can't query the geometry easily. If you want to know how far a certain point it to the object, you have to test the distance to all the points and select the shortest distance. That's very expensive and sloooow. Or how about finding the closest distance between two meshes. For that, you have to check the distance of every point in mesh 1, with every point in mesh 2. Gyaa!! Of course, there are ways to speed up these tests. There are many spatial structures that allow for very fast geometric queries like this. Signed distance fields are one such technique. In addition to the mesh, a data structure that encodes the distance to the closest point on the surface of the object is stored. for points inside the object, the distance has a negative sign, and for points outside, it is positive. The cool thing is that these data structures can be stored in, and processed entirely on, the GPU. So when it comes to lighting a pixel, the shader can sample the local distance fields to work out how much light is being occluded by nearby objects. This also works well for soft shadows. Because for any point, tracing a ray to the light source, and sampling the geometry along the way, you can find out how close the ray came to being blocked. And if it grazed an object, you can attenuate the light reaching the point by the closest distance of the ray to an occluder. Stepping along a ray to find the closest approach can be done with a process called spheretracing. Basically, you start at the origin of the ray (P0) and sample the closest distance to the object. Now you know you are guaranteed to be able to step that far along the ray without intersecting the object. So step that far and repeat. Keep going until you reach your goal or intersect, and store the smallest distance. Signed distance fields can be stored on the GPU in octrees or kdtrees I hope that's clear enough. 