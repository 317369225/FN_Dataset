What is a hash table and how can I implement in C++?
A hash table (or hashmap) is essentially a map from one object to another. The most basic example of a hashmap is an Array, since an Array maps integers to data elements. The elements which are mapped from are termed as keys (in an array, the integer indices act as keys) and the elements that are mapped to are called values (in an array, the data elements are values). Generally, the keys need to be unique in a hashmap (else on quering a key, the language can’t determine which value to return, for instance mapping the index 0 of an array to 2 different objects). Let’s say I want to create a Hashmap of Strings -> Floating point values. Then, to do so in C++, either I can use the standard library’s implementation map which can be used as follows: #include <map> #include <iostream> #include <string> using namespace std;   int main() { //Map for Strings to Floats map<string, float> my_map; // Add some values my_map["First"] = 1.0; // Mapping "First" -> 1.0 my_map["Second"] = 3.141592; // Mapping "Second" -> 3.141592 my_map["Third"] = 0; // Mapping "Third" -> 0 //To get values, we can simply use the [] operator cout << my_map["First"] << " " << my_map["Second"] << endl; //Output: 1 3.141592 return 0; } As you can see, the syntax closely resembles a normal array, only the indices are strings instead of integers. Implementing a Hashmap An implementation of a hashmap requires us to have knowledge about “hashing”. If we have a good Hash function, then we can essentially create a hashmap using a normal array. An example below demonstrates the idea. Let’s say I have a function hash() that takes a string and returns an integer. If this hash function has a property that it returns a unique integer for each string it is passed, we are essentially mapping strings to integers. Now, let’s also say that we have a big enough array of floats, then, we can do the following to create a hashmap: // data_array is a very big float array // int hash(string) is a hash function   //To add "First" -> 1.0 to the hashmap data_array[hash("First")] = 1.0 //To add "Second" -> 3.141592 to the hashmap data_array[hash("Second")] = 3.141592 //To add "Third" -> 0 to the hashmap data_array[hash("Third")] = 0   //To retrieve, we do the same float a = data_array[hash("Third")] // a now has value 0 Did you see what we did here? We exploited 2 things: We have a hash() function (essentially an abstract hashmap) of Strings to integers We have a natural hashmap (an array) of integers to floats So, we joined the 2 hashmaps to create a composite hashmap. There are several details and assumptions here which might not hold (the hash function might not be always unique, the data_array might not be too big), we use several techniques like open-addressing, chaining etc. to address these. A general hashmap has the ability to map arbitrary data types (both for the keys and the values), so a user-defined hashmap can be generalised by using C++ templates 263 Views · 5 Upvotes