What is the difference between a symbol table and a hash table?
A symbol table and a hash table, though they sound similar, are quite different in implementation and application. For starters, the programmer has no control over the symbol table unless the machine is being designed by the programmer him/her-self. A hash table is a data structure that can be used by the programmer to store and retrieve things, often very quickly; owing to the properties of the hash table (See Vignesh Natarajan's answer to What is a hash table? for a little intro on how hash tables work). Unlike hash-tables symbol tables are data structures used by the compiler or an interpreter. As the name suggests they are used by the compiler/interpreter(will commonly refer to them as translators) to keep track of symbols that are used in a program written by the user. This helps the translator to efficiently handle the symbols (variable names, function names, #defines and many more language independent symbols) used in a program. Program are often translated using one or more passes -- each pass is nothing but the process through which the translator reads through the source code line by line. This process is called as assembling and I'll explain the use of symbol table using a two pass assembly system. Consider the sample source code below int scanned-element; cin<<scanned-element; int foo,bar; float foobar; foo = 2; bar = 4; foobar = (foo + bar + scanned_element ) * 1.0; During the first pass the translator allocates the required memory and stores memory locations according to the datatypes specified. They are identified using several methods which is beyond the scope of this answer. Every time the translator hits on a symbol that is not part of any predefined list it adds it to the symbol table - irrespective of whether or not it is a constant or a variable. In our sample code, foo and bar are constants while foobar and scanned_element are variables. All these names are added to the symbol table. The symbol table can be understood as being analogous to a check-list. The translator dumps everything that it cannot understand into the symbol table and whenever it encounters an input statement or a constant or an expression which would potentially give meaning to the symbol, it makes a note of it. The symbol table for our source code will be something like this after the first pass: After the second pass the translator would have figured out that scanned_element has an input statement and foobar has an expression to evaluate its value. So after the second pass the symbol table will look something like this. If there was any stray element that was declared but not defined, the translator will throw a warning after compilation. Something like warning on line 23: the variable test was declared but never used If there was any stray symbol that was never declared but used as a part of an expression, the compiler will throw an error. Something like error on line 23: the symbol test was never declared This is a symbol table's use which is of course a data structure but isn't like a hash-table which is customize-able  and can take values of any data type. To summarize, symbol table is a system software internal data structure which is used to keep track of symbols in a program and ensure they all have meanings assigned to them before the program is executed. Thank you for your feedback! Your response is private. Is this answer still relevant and up to date? YesNo 6.9k Views · 13 Upvotes