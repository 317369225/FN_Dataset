How would you find all the Pythagorean triplets in an array of n numbers?
I don't know a solution better than O(n^2), and that is easy to achieve. Here is a snippet of (Java) code that computes the number of triples in O(n^2) time, assuming there are no duplicates in the list and all the numbers are positive. Set<Integer> X = new HashSet<Integer>();for(int i=0; i<n; i++) {  X.add(A[i]*A[i]);}int ans = 0;for(int i=0; i<n; i++) {   for(int j=0; j<n; j++) {      if(X.contains(A[i]*A[i]+A[j]*A[j])) {        ans++;      }   }} The only non-trivial observation is that we can use a hash table to decide if a triple can be completed given the first two elements in O(1), which is how we beat the trivial O(n^3) algorithm. If there are duplicates, then you need to replace X with a structure that counts the number of occurrences of an element in an array. If your array contains "0", this snippet gives spurious answers (consider the array [0,1]), but no valid triplet without duplicates contains 0, so just ignore "triples" that contain 0. 