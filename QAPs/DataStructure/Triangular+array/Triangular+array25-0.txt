How would you find all the Pythagorean triplets in an array of n numbers?
Place all N numbers in a hash table. Denote the largest number in the set as L. Generate the tree of primitive Pythagorean triples as described in Tree of primitive Pythagorean triples until the smallest hypotenuse is larger than L (branches with hypotenuses greater than L can be pruned.)  For each triple, check whether its elements, or a scaled version of its elements, appear in the set. But what is the run time of this algorithm? The number of primitive Pythagorean triples is a constant fraction of L (as a limit) and each tree node visited produces a new primitive tuple, so enumerating them takes O(L) time.  (The limit is actually [math]{1 \over 2\pi}[/math] -- see the reference to Lehmer 1900 on Mathworld: http://mathworld.wolfram.com/Pyt...) We visit no more than 3L leaves which are too large. The problem here is that you asked for all Pythagorean triplets (not just primitive ones) so checking for the scaled versions takes additional time.  For (3,4,5) you must check L/5 additional triples, for (5,12,13) you must check L/13 additional triples, etc. A very hand-wavy bound for this amount of work is the harmonic number [math]H(n) = 1/1 + 1/2 + 1/3 + 1/4 + ... + 1/n [/math].  Now, it's hand-wavy because some hypotenuses do appear multiple times, but the limit result above says that the total number of tuples is still a (small) fraction so we should have some headroom.  So the running time of the algorithm is (probably) proportional to [math]L \cdot H(L)[/math]. Check: I didn't find an explicit estimate for the number of (non-primitive) Pythagorean triples with hypotenuse less than a bound, but A101930 - OEIS gives numbers up to [math]10^{12}[/math], and [math]L\log(L)[/math] is a good bound through that range.  The running time should be proportional to the number of Pythagorean triples, because we do not visit any given triple more than once, and require only constant work per triple (under the simplifying assumption that multiplication is constant-time.) Now, if the array of numbers is dense, that is, if N is [math]\Theta(L)[/math], then this algorithm could outperform the quadratic-time algorithms given.  But if N is not proportional to L, then the quadratic-time algorithm would almost certainly provide a better option. 