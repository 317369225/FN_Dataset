How do I find sum of xor of every pair of element in array in less than O(n^2)? Is there any linear time algorithm for this?
I don't know if this is exactly what you are looking for, but I'll try to give a few insights anyway. If you want to find the XOR of every pair of elements in an array [math]A[0] .. A[n - 1][/math], you are essentially looking to fill an [math]n \times n[/math] matrix [math]B[/math] where [math]B[i][j][/math] gives the xor of [math]A[i][/math] and [math]A[j][/math]. [math]B = \begin{bmatrix}a_0 \oplus a_0 & a_0 \oplus a_1 & a_0 \oplus a_2 & a_0 \oplus a_3 \\a_1 \oplus a_0 & a_1 \oplus a_1 & a_1 \oplus a_2 & a_1 \oplus a_3 \\a_2 \oplus a_0 & a_2 \oplus a_1 & a_2 \oplus a_2 & a_2 \oplus a_3 \\a_3 \oplus a_0 & a_3 \oplus a_1 & a_3 \oplus a_2 & a_3 \oplus a_3   \end{bmatrix}[/math] But you don't need to compute the xor for every element in this matrix, because you can take advantage of some of the properties of the xor operation. i) [math]B[i][i] = 0[/math] for all i, as [math]a \oplus a = 0[/math] ii) [math]B[i][j] = B[j][i][/math] as the xor operation is commutative. [math]a \oplus b = b \oplus a[/math] So effectively, we just need to compute the upper triangle (or equivalently, the lower triangle) of the matrix [math]B[/math] to know the xor values of all pairs of elements. And for computing [math]B[i][i][/math] we don't need xor operations, as they can just be initialized to zero. (Many programming languages will default-initialize all the elements to 0 anyway without any additional logic being needed). [math]B = \begin{bmatrix}0 & a_0 \oplus a_1 & a_0 \oplus a_2 & a_0 \oplus a_3 \\\cdots & 0 & a_1 \oplus a_2 & a_1 \oplus a_3 \\\cdots & \cdots & 0 & a_2 \oplus a_3 \\\cdots & \cdots  & \cdots & 0   \end{bmatrix}[/math] So how many xors do you need to compute? You need to compute all the elements of the upper triangular matrix, excluding the diagonal elements. That comes to exactly  [math]\frac{n(n-1)}{2}[/math] elements. Which is still [math]O(n^2)[/math]. Anyway, if you want to store all the elements, any algorithm will be [math]O(n^2)[/math], as you need to assign values to [math]O(n^2)[/math] elements. Now, with one more simple insight regarding the xor operator, I can think of how to do just n xor operations first, and then find the xor of any pair of elements using an additional xor operation. For simplicity, assume the array elements are [math]a, b, c, d, e[/math]. i) First compute [math]a \oplus b, a \oplus c, a \oplus d, a \oplus e[/math] and store the values in an array. That is, you first compute xors of all the other elements with a particular element [math]a[/math] (any other element can be used instead of [math]a[/math]). ii) Then, if you want the xor of any of the already computed pairs, you have it stored. But if you want to find [math]b \oplus c[/math], you compute [math](a \oplus b) \oplus (a \oplus c)[/math] (you have both these values stored, so just need to xor them together). iii) This will give the value that you need. How does this work? [math]\begin{eqnarray*}(a \oplus b) \oplus (a \oplus c) &= &(b \oplus a) \oplus (a \oplus c)  &(\text{by commutative property})\\&= &b \oplus  (a \oplus (a \oplus c))   &(\text{by associative property})\\&= &b \oplus  ((a \oplus a) \oplus c)   &(\text{by associative property})\\&= &b \oplus  (0 \oplus c) &(\text{as } a \oplus a = 0)\\&= &b \oplus c &(\text{as } 0 \oplus c = c)\end{eqnarray*}[/math] 