How can the task "Treasures" from Bulgarian OI be solved?
Here is a DP solution that works in O(n^2) time and uses O(n) space. Through the whole explanation I will refer to the squares as points. Let's take arbitrarily treasure A(x, y, p). The hole that we have to dig in order to take A has a form of an isosceles right triangle with sides |A.y| - 1,  |A.y| - 1,  2 * (|A.y| - 1). It's |A.y| - 1 because according to the problem statement y starts from -1. Let's define hole(A) as the isosceles right triangle that have to be dug to get treasure A. We want to find the number of points in hole(A) and since its a triangle with vertices that lay on points with integer coordinates we can use Pick's theorem. According to Pick's theorem: Area(hole(A)) = BoundaryPoints(hole(A)) / 2 + InternalPoints(hole(A)) - 1 The area of an isosceles right triangle can be calculated directly: Area(hole(A)) = 1 / 2 * (|A.y| - 1) * 2 * (|A.y| - 1) = (|A.y| - 1) ^ 2 The boundary points can also be calculated directly: BoundaryPoints(hole(A)) = 2 * (|A.y| - 1) + 2 * (|A.y| - 1) Now we can calculate the internal points using the equations above: InternalPoints(hole(A))     = Area(hole(A)) - BoundaryPoints(hole(A)) / 2 + 1     = (|A.y| - 1) ^ 2 - 2 * (|A.y| - 1) + 1     = A.y ^ 2 - 2 * |A.y| + 1 - 2 *| A.y| + 2 + 1     = A.y ^ 2 - 4 * |A.y| + 4 The cost to dig A: Cost(A) =     = BoundaryPoints(hole(A)) + InternalPoints(hole(A))     = 4 * |A.y| - 4 + A.y ^ 2 - 4 * |A.y| + 4     = A.y ^ 2 The profit of digging A: Profit(A) = A.p - Cost(A) Let's take another treasure B(x, y, p). There are 3 different cases for hole(A) and hole(B) that we need to review: 1. hole(B) doesn't share any points with hole(A). In this case we can calculate the profit from digging A and B independently. 2. hole(B) overlaps hole(A). Profit(hole(B)) += A.p 3. hole(B) intersects hole(A). Profit(hole(B)) = Profit(hole(A)) + Profit(hole(B)) +     SharedPoints(hole(A), hole(B)) Follows an explanation for SharedPoints(hole(A), hole(B)). Let l be the length of the shared segment from the bases of the triangular holes dug for treasures A and B. It can be calculated using the following formula: l = ((A.x - A. y) - (B.x + B.y) + 1) - 2 There are 3 different cases for l: 1. l <= 0 SharedPoints(hole(A), hole(B)) = 0 2. l is an odd number SharedPoints(hole(A), hole(B)) =     ((l + 1) / 2) ^ 2 = ((l + 1) ^ 2) / 4 3. l is an even number SharedPoints(hole(A), hole(B)) =     (l / 2 + 1) ^ 2 - (l / 2 + 1) = (l * (l + 2)) / 4 We have already understood how to calculate the profit for one or two treasures. Follows an explanation for more than two treasures. Let treasures[] be an array of n treasures, where each treasure is represented by (x, y, p). As we mentioned earlier in order to dig treasures[i] for any i from 1 to n we have to dig a hole with the form of an isosceles right triangle. The left side of one such triangle is a segment of a diagonal line, where the sum of the coordinates for each point is the same. We are going to sort treasures[] by the position of these diagonals - from left to right. This means that for any i, j (from 1 to n), treasures[i] < treasures[j] iff treasures[i].x + treasures[i].y < treasures[j].x + treasures[j].y Let's assume that for all i from 1 to n, maxProfit[i] consists of a single integer that represents the maximum profit achievable by digging treasures[i] and some subset of all treasures from 1 to i - 1, such that treasures[i] is not contained in the triangular hole of any treasure from the subset. We are going to compute maxProfit[i + 1]. To satisfy the rule that treasure[i + 1] is taken we will initialize maxProfit[i + 1] the following way: maxProfit[i + 1] = Profit(treasure[i + 1]) For each treasure j from 1 to i - 1 do the following: * If hole(treasures[j]) contains hole(treasures[i + 1]) then maxProfit[j] += treasure[i + 1].p To find whether hole(treasures[j]) contains hole(treasures[i + 1]) we need to check only if the right side of the triangle for j is the same or is after the right side of the triangle for i + 1. The left side of the triangle for i + 1 is after or the same as the left side of the triangle for j because that's how we sorted the treasures. Therefore: hole(treasures[j]) contains hole(treasures[i + 1]) iff treasures[i + 1].x - treasures[i + 1].y <= treasures[j].x - treasures[j].y * If hole(treasures[j]) and hole(treasures[i]) intersect then maxProfit[i + 1] = max(maxProfit[i + 1], maxProfit[j] + Profit(i + 1) + SharedPoints(treasures[j], treasures[i + 1])) Does this still work if hole(treasures[i + 1]) overlaps hole(treasures[j]) ? You might think that it wouldn't be correct to calculate it by crossing hole(treasures[i + 1]) with hole(treasures[j]) and we need to know with what hole(treasures[j]) has been crossed to get maxProfit[j]. Actually if hole(treasures[i + 1]) overlaps hole(treasures[j]) then the left sides of their triangles are segments of the same diagonal line. Therefore whatever crosses hole(treasures[j]) crosses hole(treasures[i + 1]) the same way. This means that SharedPoints(hole(treasures[j]), treasures[k]) = SharedPoints(hole(treasures[i+1], treasures[k]) for all k from 1 to j - 1. The maximum achievable profit is the maximum value of maxProfit[i] for all i from 1 to n. 