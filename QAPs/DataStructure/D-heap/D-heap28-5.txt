What are some time-saving tips that every Linux user should know?
People already mentioned C-R to search bash history. I find inserting below line into ~/.bashrc is really useful export HISTSIZE=32768 Bash history can contain 32768 items now.   UPDATE: I'm surprised many people are interested in this tip. Then here are some extra tips about managing bash history: tip 1 ==== Make your ~/.bash_history under git and back it up on github private repository. The commands you type in your life will never be lost. Before you commit the ~/.bash_history, you need unique it and clean the comands a little bit (for example, remove ones containing less than 5 characters). So insert below line into ~/.bashrc. Now you run command "cleanfile ~/.bash_history" to clean the history: function cleanfile () { if [ -z "$1" ]; then echo "Usage: remove duplicated lines without sortdt" echo " cleanfile ~/.bash_history" else local bkfile="$1.backup" # \+ does not work in OSX sed # delte short commands, delete git related commands sed 's/ *$//g;' $1 | sed '/^.\{1,4\}$/d' | sed '/^g[nlabcdusfp]\{1,5\} .*/d' | sed '/^git [nr] /d' | sed '/^rm /d' | sed '/^cgnb /d' | sed '/^touch /d' > $bkfile # @see Page on stack Overflow/questions/11532157/unix-removing-duplicate-lines-without-sorting cat $bkfile | awk ' !x[$0]++' > $1 rm $bkfile fi } Please note above script does NOT sort the history. Sorting the history is a bad idea in practice. Actually I use below command to get the job done: cleanfile ~/.bash_history;git add ~/.bash_history;git commit -m 'bash history' tip 2 ==== This is actually *NOT TO DO* tip. I turn off the time stamp string because time stamp is a distraction on screen when search history. So DONOT insert below line into your ~/.bashrc: export HISTTIMEFORMAT="%m-%d: " Thanks for Andrew Daviel reminding. You shouldn't follow my instruction blindly . I always works as a Linux developer. So I usually focus on how to re-use command line as quickly as possible. Anything unrelated to coding is regarded as noise and will be purged. System Administrators may have different views. Timestamp is  regarded as a critical part of system log for them. Please read my other tip with with critical thinking. tip 3 ===== C-R search from the latest commands. Sometimes I have vague memory about a command used months ago and I want to reuse that command. So I just type: history|grep "keyword"|grep "keyword2" The ID of that command is displayed, say it's "9899". Then just type following text to execute that command: !9899 Until now I've not revealed the tip yet! The trick is I seldom re-use the old command without editing. So insert below line into ~/.bashrc: shopt -s histverify then !9899 will insert the command into shell instead of execute it. tip 4 ==== history command is used so often by me so it's necessary to assign a alias for it in ~/.bashrc: alias h=history tip 5 ==== There could be better way to search, filter the history if you use percol from  mooz (Masafumi Oyamada). You could "h keyword" to find the command and place it into system clipboard. Steps to install percol: 1. download mooz/percol, that package you will find a directory named percol, put it in ~/bin/, there is also a python program named percol, rename it into percol.py and place it in ~/bin/ too. 2. insert below code into ~/.bashrc: [ $(uname -s | grep -c CYGWIN) -eq 1 ] && OS_NAME="CYGWIN" || OS_NAME=`uname -s`   function pclip() { if [ $OS_NAME == CYGWIN ]; then putclip $@; elif [ $OS_NAME == Darwin ]; then pbcopy $@; else if [ -x /usr/bin/xsel ]; then xsel -ib $@; else if [ -x /usr/bin/xclip ]; then xclip -selection c $@; else echo "Neither xsel or xclip is installed!" fi fi fi }   function h () { # reverse history, pick up one line, remove new line characters and put it into clipboard if [ -z "$1" ]; then history | sed '1!G;h;$!d' | ~/bin/percol.py | sed -n 's/^ *[0-9][0-9]* *\(.*\)$/\1/p'| tr -d '\n' | pclip else history | grep "$1" | sed '1!G;h;$!d' | ~/bin/percol.py | sed -n 's/^ *[0-9][0-9]* *\(.*\)$/\1/p'| tr -d '\n' | pclip fi } Here is the screen cast: For Bash 4 (OSX use bash3), use below setup is enough (C-r is rebinded), bind -x '"\C-R": READLINE_LINE=$(history | grep "${READLINE_LINE}" | tac | ~/bin/percol.py | sed "s/^ *[0-9]* *//g") READLINE_POINT=' tip 6 ==== Place below setup in ~/.bashrc, which will insert typed command into ~/.bash_history immediately after you execution of the command: PROMPT_COMMAND="history -a" # update histfile after every command See Page on stackoverflow.com, raychi's answer. tip 7 ==== percol.py gives you a second chance to filter the history. For example, bash cli "xrandr -s 1024x768" is used to switch to SVGA resolution. But you can also input "xrandr -s 1024x768 # switch resolution vga", the keywords after "#" will not be executed, but it will be recorded into ~/.bash_history, so when you search bash history, "switch" and "vga"  could be regarded as a TAG. since perlcol.py support wildcard search, you can use both keywords or either of them. It doesn't mean you need comment every cli on the spot, you can review and modify ~/.bash_history later. tip 8 ==== Commands containing relative path is not re-usable because they need be executed in certain directory. I exclude these command from ~/.bash_history Here is my setup in ~/.bashrc to ignore them: export HISTIGNORE="cd [a-zA-Z0-9_.*]*:mv [a-zA-Z0-9_.*]*" tip 9 ==== Merge several lines of commands into one liner because that's easy to search tip 10 ==== Focus on specific thing and keep improving it during a long time. As I have demostrated here for "bash history management". Make sure you reach the world class level. Then share it! The key point is, the quality of knowledge you share determines the quality you get back in return. Updated 22 Nov • View Upvotes