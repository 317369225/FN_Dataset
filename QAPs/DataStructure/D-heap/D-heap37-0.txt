How does a garbage collector work?
Garbage collector or shortly known as GC absolves the programmer from tracking memory usage and when to free a resource and it's associated memory. Before deep diving into this, I hope one is familiar with Object Oriented programming, Multi threading, Stack memory, Heap memory and reference variables. When a process is initialised, it is allotted with two kinds of memory - Stack Memory - Memory where all the program variables and objects created without using new or any version of malloc are present. These are allocated during the initiation of the process or when a new function or module is loaded. Heap Memory - Memory from heap is allocated dynamically. The decision on how much memory is required can be made during run time and is impossible to do the same in stack memory. //C++ language public int foo() { Person p1("John"); // p1 is a person object present in stack memory Person p2 = new Person("Katie"); //p2 is a person object present in heap memory } Stack memory is automatically managed or does not require to be managed because whenever a function or module returns to it's parent, the program counter is set to the next statement of the function call in the parent module and therefore, all the memory allocated for the called function is treated as released. But this is not the case with Heap memory as it is dynamically allotted. public int child() { Person p = new Person("John"); } public int parent() { child(); // If the GC has to run after the function call, it recognises that, the Person object which was dynamically allocated is not accessible anymore and therefore, releases it. } Certain helpful definitions Application Roots - Every application has a set of roots. It comprises ofÂ  CPU registers, a variable on some thread stack, global and static variables. Working of GC: When the application is started, the heap memory is empty and a pointer nextObjectPointer points to the beginning of the heap. Whenever an object is dynamically allotted, the nextObjectPointer gets incremented by the object size. The overhead involved in this allocation process is very minimal but has an assumption that infinite memory is available which is unfortunately, not. Every time a process is about to run out of memory, A Garbage collector checks whether an object(or resource in the form of an object for simplicity) in heap is no longer used by the application and if so, it releases that object. To do this, when it starts running, it makes an assumption that all the objects in the heap are garbage. In other words, it assumes that none of the application roots refer to the heap. Now, it starts walking through all the application roots and builds a graph of objects that can be reached in heap. Once all the roots have been checked, the GC knows which all objects can be accessed from the program. It then starts going through the heap memory in a continuous manner and pushes all non-garbage objects to one section of the memory. This would invalidate the application roots and any reference variables within the dynamically allocated objects. The GC is responsible for making sure that at all places the new memory address of the objects is used. Once all the non-garbage objects are pushed to one side, the nextObjectPointer is set right next to the last object in heap. FinalizationThis is an additional feature present in GC. During the entire garbage collection process, note that, GC is not aware of how to release a resource. It just claims the memory but it can so happen that the released object might be using some file descriptors or network resources and therefore should be taken care of when the object is reclaimed. Finalization allows objects to clean themselves up gracefully when it is being collected. public class Person { public Person() { } protected override void finalize() { // Perform resource cleanup code here... // Example: handle file descriptors or close network connection Console.WriteLine("In Finalize."); } } When the GC runs for an Person Object, it calls the finalize method for that object. "In Finalize" is printed to the console when the object is claimed. GenerationsThis is one feature which is present purely to increase the performance of GC. A generation GC works with the following assumptions - The newer an object is, the shorter its lifetime will be The older an object is, the longer its lifetime will be Compacting a portion of heap is faster than compacting entire heap Newer objects tend to have strong relationships with each other and are accessed around the same time.When the application starts, the heap memory contains no objects. Objects added to the heap are said to be in generation-0. When the heap gets full, GC runs. All garbage objects are claimed and non-garbage objects are compacted into one part of memory and are now considered to be generation-1. Now, if more objects are added to heap(objects are always added in generation-0), the heap fills and GC is run again. All non-garbage objects in generation-1 are promoted to generation-2 and all non-garbage objects in generation-0 are promoted to generation-1. To optimise even further, only one generation is claimed during the GC and if not enough memory is claimed then go for the next generation. Now, what happens when an object in generation-0 refers to an object in generation-2? or what happens when an object in generation-2 refers to an object in generation-0? How is performance addressed in such a scenario? This is beyond the scope of this answer. You might want to dig deep into this. In Conclusion, The motivation for garbage-collected environments is to simplify memory management for the developer. Of course, there is a lot of other things about GC that I did not mention here. This is a vast subject. For more information you can refer to this book here - Garbage Collection: Algorithms for Automatic Dynamic Memory Management: Richard Jones, Rafael D Lins: 9780471941484: Amazon.com: Books 