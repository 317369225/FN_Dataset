Sorting Algorithms: Can anyone give me the easiest code for heap sort?
Although I don't know what is going to be the easiest for you but this is what I used in my exam yesterday: [code] #include <stdio.h> void heapsort(int a[], int n); int shiftDown(int a[], int start, int end); void heapify(int a[], int n); void main(){   int i, a[20], n;   printf("Enter the number of inputs: ");   scanf("%d", &n);   for(i = 0; i < n; i++){     printf("Number %d: ", i);     scanf("%d", &a[i]);   }   //an unordered array a of length n is being passed to the function   heapsort(a, n);   printf("Sorted array: \n");   for(i = 0; i < n; i++){     printf("Number %d: %d\n", i, a[i]);   } } void heapsort(int a[], int n){   int end, temp;     //Build the heap in array a so that largest value is at the root   heapify(a, n);   end = n - 1;   /*   The following loop maintains the invariants that a[0:end] is a heap and every   element beyond end is greater than everything before it (so a[end:count] is in sorted   order   */   while (end > 0) {     /*     a[0] is the root and largest value. The swap moves it in front of the sorted elements.     */     temp = a[end];     a[end] = a[0];     a[0] = temp;         //the heap size is reduced by one     end = end - 1;     //the swap ruined the heap property, so restore it     shiftDown(a, 0, end);   } } void heapify(int a[], int n){   int start;   /*      start is assigned the index in 'a' of the last parent node         the last element in a 0-based array is at index count-1;     find the parent of that element   */   start = (n - 2)/2;   while (start >= 0){     //Shift down the node at index 'start' to the proper place such that all nodes below             //the start index are in heap order     shiftDown(a, start, n-1);     //go to the next parent node     start = start - 1;   } //after sifting down the root all nodes/elements are in heap order } int shiftDown(int a[], int start, int end){   int root = start, child, swap, temp;   //While the root has at least one child   while((root*2 + 1) <= end){     child = ( root * 2 ) + 1; //Left child     swap = root; //Keeps track of child to swap with     if (a[swap] < a[child]) {       swap = child;     }     //If there is a right child and that child is greater     if ((child + 1 <= end) && (a[child+1] > a[swap])) {       swap = child + 1;     }     if(swap == root){       //The root holds the largest element. Since we assume the heaps rooted at the                   //children are valid, this means that we are done.       return 0;     } else {       temp = a[swap];       a[swap] = a[root];       a[root] = temp;       root = swap;       //repeat to continue sifting down the child now     }   } } [/code] Help for the above algorithm has been taken from Heapsort | Wikiwand 