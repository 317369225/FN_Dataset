How can I quickly sort an array of elements that is already sorted except for a small number of elements (say, up to 1/4 of the total) whose positions are known?
None of these answers actually addressed how to identify a small number of out of order elements just given an array.  Supposing there are K elements out of order in our array of length N and K is much smaller than N then there are a couple ways to do this. The most obvious way is to use the standard longest increasing subsequence algorithm which will run in O(N log N).  The elements not in this sequence will be the out of order elements and we'll always end up with no more than K of them (and perhaps less!). However there's actually another approach.  Instead we can build an increasing subsequence of N-2K elements in O(N) time.  Do this by scanning over the elements in order maintaining an increasing subsequence of elements.  If an element is no smaller than the end of your subsequence append it to the subsequence.  Otherwise delete the end of the subsequence (and don't append to it).  Since each deletion operation must involve at least one of the out of order elements we must end up with at least N-2K elements in our subsequence at the end. Once we have identified 2K out of order elements we can do as Anders Kaseorg says and sort the out of order elements by themselves and then merge.  This gives the overall algorithm a complexity of O(N + K log K). In the description of your problem if only a really small number of elements are changing you might benefit by using a tree data structure that is going to allow you to update the position of a single element in O(log(N)) time so that your entire update operation can run in O(K log N) time, throwing out the linear term in N entirely. 