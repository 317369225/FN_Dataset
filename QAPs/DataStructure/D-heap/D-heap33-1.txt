Rust (programming language): What does Rust do best, and what are projects for someone new to the language that highlights these strengths?
Since Rust 1.0 has just been released yesterday, it is unclear what does it do "best", (whatever that means), so I will assume that the question is along the lines of "What does Rust do better than languages in the same category, such as C/C++?" Now, one of the main selling points of Rust is that it achieves memory-safety without a garbage collector. Consider the following C code: int calculate() { int *pi = (int*) malloc(sizeof(int)); *pi = 5; // do stuff with *pi } If you've never dealt with C before, you may be a little confused as to what exactly is going on here, so let me explain: int *pi = (int*) malloc(sizeof(int)); On this line, we are creating a new pointer to an integer variable and assigning to it (essentially), the memory address of an integer that we allocated memory for on the heap using malloc, (a pointer is a variable that holds the memory address of another object in memory), (the sizeof() function just ensures that we allocate enough space for whatever type we pass to it). So that pointer contains the memory address at which our data on the heap will be stored. *pi = 5; The above line dereferences the pointer, (accesses what is at the memory address, rather than the memory address itself) and stores the integer value 5 in that memory location. Now, at this point, everything may seem just fine - when actually it isn't! What went wrong? Well, if you look at this line: } - you may realize that the function finishes executing there, but pi is never free()`d, that is, we never actually signal that we don't need the memory space we claimed for pi anymore by calling the ` free()` function, like so: free(pi); Because we never release the reserved memory on the heap, we have a nasty memory leak on our hands, meaning that our application claims more memory for itself than it actually needs! Enough such leaks and our application will eventually crash, or may even bring down the whole system, (depending on the OS). "Ok, Ok, I get it, but how exactly does Rus* solve this problem?", I hear you asking: Well, consider this Rust code: fn calculate() { let pi = Box::new(5); // do stuff with pi } On the second line, we could have also written this: let pi: Box<i32> = Box::new(5i32); However, the above line produces exactly the same result as the one without the explicit type annotations, so spare yourself the trouble and take full advantage of the type inference, (and automatic pointer dereferencing), that we have in Rust. I think that it should be pretty clear at this point what the code does;  let pi introduces an immutable variable pi and assigns it a pointer to a boxed value 5 of type i32 on the heap. What's *really* interesting however is that, like in the C version, I haven't called anything akin to free(pi), (that would actually be drop(pi) in Rust, but the effect is the same), to release the allocated heap memory. Such an "omission" in Rust however does not cause a memory leak, as the compiler is able to track that pi *owns* the heap memory allocated to it and that when it goes out of scope, (once the block ends, in this case once the calculate() function returns), it should insert a silent drop(pi) call as the last think before }. Armed with this knowledge, we can now make sense of what happens inside our calculate() function: fn calculate() { let pi = Box::new(5); // allocate enough memory for an i32 on the heap and return a pointer to it, making pi the owner of that chunk of memory // do stuf } // pi goes out of scope here, so insert drop(pi) Because pi owns that chunk of memory, it is solely responsible for deallocating that chunk of memory as well, and because that happens implicitly when pi goes out of scope, the programmer can't forget it, like it's possible to do in C - Rust The concept of ownership is very important in Rust: fn add(n1: Box<i32>, n2: Box<i32>) -> i32 { *n1 + *n2 }   fn multiply(n1: Box<i32>, n2: Box<i32>) -> i32 { *n1 * *n2 }   fn main() { let num1 = Box::new(7i32); let num2 = Box::new(5i32); println!("{}", add(num1, num2)); // add() owns num1 and num2 println!("{}", multiply(num1, num2)); // multiply() cannot use them, because it does not own them! } The above code does not work, because the call to add() has transferred ownership of num1 and num2 to it, which means that multiply() cannot use them! Now, you're probably saying to yourself that it's all great, but kind of limiting - and you'll be right, that's why we have the concept of borrowing: fn add(n1: &i32, n2: &i32) -> i32 { *n1 + *n2 }   fn multiply(n1: &i32, n2: &i32) -> i32 { *n1 * *n2 }   fn main() { let num1 = Box::new(7i32); let num2 = Box::new(5i32); println!("{}", add(&num1, &num2)); println!("{}", multiply(&num1, &num2)); } Here, add() only borrows the arguments passed to it, instead of taking ownership. That means that main() still owns num1 and num2 and can therefore pass them to multiply() so it all works! 