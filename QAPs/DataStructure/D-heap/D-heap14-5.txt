What is the simplest intuitive proof of Dijkstraâ€™s shortest path algorithm?
Originally Answered: What is an intuitive explanation of Dijkstra's algorithm?Dijkstra's algorithm let's us find the shortest paths in a graph from a given node, like this one: The edges could represent roads between intersections, for example, and the labels could represent the distance of the road, the amount of time you spend on the road, the gas cost on the road, etc. Let's say it's time. We want to find the minimum amount of time it will take us to drive from A to any of the other nodes. To do this, we iteratively build up a set of nodes that we know the shortest path to. I'll skip the first few steps, and say we know the shortest paths from A to B and to F. Here, we have a "bubble" of A, B, and F. But being the explorers we are, we want to delve outside of our comfort zone. What's the shortest path outside of our bubble, from A? Here are all the edges leading outside of our bubble, marked in red: So, what's the shortest path outside our bubble? We could go A -> B -> C, which takes time 5. We could go A -> D, which takes time 3. We could take A -> F -> D, which takes time 2. Finally, we could take time A -> F -> E, which takes time 4. The shortest of those is A -> D, which takes time 3. But then this has to be the shortest path to D, since its the shortest path outside the bubble, and any path to D has to go outside the bubble at some point! So we can add D to our "known" set. Now we can continue. What's the shortest path outside our new, extended bubble? A quick glance shows that it is either A->D->C or A->D->E, each at cost 4. So now we know the shortest paths to C and E. Whee! Now we know how to get everywhere in the shortest time, from node A. This is how Dijkstra works conceptually, and the above explanation is pretty close to a proof of correctness. Note that there are some implementation details to actually implement this efficiently - keeping track of the minimum known distance to each node, using Priority queues to pick out nodes quickly, and so forth, but I won't go into that here. 