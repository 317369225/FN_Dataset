Data Structures: What is a list of data structures that a competitive programmer must know?
That depends on the problem you are trying to solve. If a problem is mapped to the most efficient data-structure which captures the essence of that problem, then it leads to an elegant solution of the problem. The "right" choice of data-structure would not only depend on the representation of the inputs, but the query it is supposed to be optimal for. E.g if asked to find a number among the list of number efficiently, then BST(Binary Search Tree) is a choice which would efficiently represent the input data for the set of all point search queries. If the query was for a range of numbers, and not just a single number, then  BST  is no longer the optimal choice but the data-structure to choose is maybe B+ Tree. For some kind of problems, it may be more efficient to choose even probablistic data-structures which offer an interesting trade-off between space, time, and correctness.  Example of such data-structures are to name a few among the popular ones, bloom filters, and hyperloglog. Such data-structures may allow false positives or false negatives (with some error probability) depending on their design. These are respectively used to provide efficient solutions for determining membership of an element in a cache, and approximate counting. In the case of cache, if you mispredict the presence of the element in the cache, no big harm done, you just fetch the element from the higher-up hierarchy. To prove the case in point, here's an extremely simple data-structure (recently developed, specifically to solve a particular problem) which solves a not so easy problem regarding palindromes in strings elegantly. Trying to fit known data-structures to the problem results in solutions which are difficult to understand and implement. What is the most efficient data structure to represent palindromes in a given string? What is the range of problems that can be solved by this data structure? To summarize, you would need to study a problem, understand what constitutes an efficient solution in its context (memory, time complexity, error probability)  and *google search* for the right data-structure (or creatively design it) to solve the problem elegantly. 