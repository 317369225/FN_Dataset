Rust (programming language): What does Rust do best, and what are projects for someone new to the language that highlights these strengths?
When you program with Rust you usually don't need manual memory management. In fact, Rust offers different low-level memory management concepts and artifacts than the ones by C, namely one of them is: The ownership model One of the big sources of crashes and exploitations of software written in C are dangling pointers. There are other problems with pointers, but let's focus on dangling pointers for now. In manual memory management one needs to free memory manually. It's a difficult problem. An example: You have a pointer p allocated. Of course if you don't need the memory for the whole time of your software running, you need to free it. This is important for long-running software like servers. This is usually not difficult. Just free p, when you are done with it. Or not? But what if you need to use the pointer at two different places in your program? Assign p to a struct member and return it from a function? This opens a can of worms. When the caller of the function frees the copy of p then the struct member becomes a dangling pointer. Of course the caller needs to know to set the struct member to NULL, but this gets often forgotten. And presto we have a new exploit. Rust solves this problem with the ownership model. Many C libraries already have a loose concept of ownership. The owner is responsible to free the pointer. An example in FFMPEG 2.7 here: AVPacket Struct Reference. This works okay, but if no compiler is enforcing the rules, stupid mistakes abound. After all, programmers are only human and make mistakes. The Rust compiler enforces some rules with the ownership model. For details please read the source given below. Here I only give a high level summary of the rationales of the ownership model as I have understood it as an experienced C programmer. I am not an experienced Rust programmer. It is said that programmers have to pay a price when they program with Rust. While they don't need to manage memory manually, they have to fight with the borrow checker of Rust. This can be frustrating, this fight, but when a program finally compiles without unsafe blocks, it is guaranteed not to have dangling pointers. And Rust does not need run-time checks. There are no performance penalties. All work is done in compile-time. This is the power of enforced compile-time rule checking. Please, again, read the source about what the borrow checker does exactly. Source: https://doc.rust-lang.org/book/o... Updated 2 Aug â€¢ View Upvotes