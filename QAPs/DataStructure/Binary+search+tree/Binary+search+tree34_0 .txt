How can you count all the duplicates in a binary search tree in O(n) time and O(1) space?If you have a binary search tree and you do an in-order traversal, you will essentially be iterating over a sorted list of your data values. Counting duplicates is a matter of counting the number of repeating values across consecutive elements. Clarification: The in-order traversal can be done in time and auxiliary space using the Morris Algorithm:  1 2 3 4 5 6 7 8 91011121314151617181920212223242526 public void inOrderMorris(BinaryNode root) {  BinaryNode current = root;  BinaryNode pre = null;  while (current != null) {  if (current.left == null) {  process(current);  current = current.right;  } else {  pre = current.left;  while (pre.right != null && pre.right != current) {  pre = pre.right;  }  if (pre.right == null) {  pre.right = current;  current = current.left;  } else {  pre.right = null;  process(current);  current = current.right;  }  }  } } Note: The Morris Algorithm modifies the tree as it goes and restores it by the time it finishes. What this means is that your binary tree must be mutable. The disadvantage of using the Morris algorithm is that it not thread-safe. 