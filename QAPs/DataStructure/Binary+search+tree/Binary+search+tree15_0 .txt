How can we find the largest binary search tree in a binary tree efficiently?Here "largest BST" means BST with maximum number of nodes. Largest BST may or may not include all of its descendants.You can solve this problem in O(N) time. To understand the algorithm let's first take a look at solving this problem where the BST must contain the root. If the root must be contained in the BST then if the left child is less then the root we should include the left child. This is because what we do to the left of the root cannot affect the right of the root and vice versa and we otherwise terminate the subtree. Therefore it is detrimental to not have a left/right child when one is possible. This same general argument applies as you recurse down the tree and you gain constraints on what range the tree node must be in if you can add it. Here's a sketch of an algorithm where the root must be included: 12345 int solve(node, min_possible, max_possible) {  if(node != NULL && min_possible <= node.value && node.value <= max_possible) {  return 1 + solve(node.left, min_possible, node.value) + solve(node.right, node.value, max_possible)  } } This algorithm runs in O(N) time. However your search tree might not be rooted at the root of your BST so you would need to do O(N^2) of these searches. However this comes down to O(N) using memoization. This is because for a given node there are only 3 possible states of (min_possible, max_possible) that could occur. For instance if the current node is a left child with parent p then the states are : {(-INF, +INF), (-INF, p.value), (g.value, p.value)} where g is the most recent ancestor that we're the opposite subtree of from our parent. 