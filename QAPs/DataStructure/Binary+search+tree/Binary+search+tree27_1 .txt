What is the fastest way to perform an inorder traversal of a perfectly balanced binary search tree containing n elements?Well, after much thinking, I am unable to come up with an O(n) solution. However, an O(n lg lg n) solution does exist, which I can describe here. 1. We have a complete BST with n nodes -> lg n levels. 2. For a subtree rooted an some internal node K, we can perform an inorder traversal of that subtree without ever leaving that node. Once we enter the node K and leave it, we will never enter it again. 3. We split the traversal into 2 parts:  [a] traversing nodes in the "upper tree", i.e. tree with nodes at level 0, 1, 2, 3, ... (lg n - lg lg n) (the root being at level 0)  [b] traversing nodes in the "lower trees", i.e. the trees with lg n nodes at the lower levels. 4. Once we reach node which is the root of a "lower tree", we cache that node and perform successor queries on that subtree in time O(lg lg n) per query. There are O(n/lg n) such trees, with each tree containing O(lg n) nodes. The total cost to perform successor queries in the lower trees is O(n/lg n * lg n * lg lg n) = O(n lg lg n). 5. For any node in the "upper tree", we perform successor queries in time O(lg n) per query. There are O(n/lg n) such nodes, and the cost to perform a successor query is O(lg n). The total cost here is thus O(n/lg n * lg n) = O(n). 6. The overall cost is thus O(n lg lg n). Similarly, by storing 2 nodes, one at level (lg n - lg lg n) and another at level (lg n - lg lg lg n), one can get a solution that costs O(n) + O(n/lg n * k lg lg k) + O(n/lg n * k lg lg k) [where k = lg n] = O(n) + O((n/lg n) * (lg n) * (lg lg lg n)) + O((n/lg n) * (lg n) * (lg lg lg n)) = O(n) + O(n) + O(n lg lg lg n) = O(n lg lg lg n) By using O(lg*n) space, we can get a running time of O(n lg*n), but I still don't see how to make it O(n) time with O(1) extra space. 