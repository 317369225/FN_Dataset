What is an uncomplicated way to understand an OBST (optimal binary search tree) algorithm?Binary Search Tree (BST) is a tree with each node 'n' - Values in its left sub tree are less than n - Values in its right sub tree are greater than or equal to n Example:-  8  / \  6 10  /\ /\  3 7 9 16 Problem:- Input 1/ N sorted keys {k1, k2, k3... kN}, where k1 < k2 < ... < kN 2/ Probability of each key {p1, p2, ..., pN}, such that p1+p2+...+pN=1 Output Create a BST where the average cost of looking up a key is minimized. Which means keys with high probability should be close to root (reduces search cost) This can be compared with Huffman trees[3] Optimal BST (OBST) example:- N = 2 Keys = {5, 8} Probability = {0.3, 0.7} Two ways to create BST:- #1 5  \  8 Avg look up cost = (#comparisons * probability) for each node Cost for key 5 = 1 * p1 = 1 * 0.3 = 0.3 Cost for key 8 = 2 * p2 = 2 * 0.7 = 1.4 Total cost = C5 +C8 = 0.3 + 1.4 = 1.7 #2  8 / 5 Cost for key 5 = 2 * p1 = 2 * 0.3 = 0.6 Cost for key 8 = 1 * p2 = 1 * 0.7 = 0.7 Total cost = C5 +C8 = 0.6 + 0.7 = 1.3 Compare order #1 and #2, choose the optimal one:- Ans = order 2 Here an OBST is a BST which has minimal expected cost. Same analysis can be done for N > 2 Recursive solution:- For N = 2, we tried both the node as root and selected 8 has root after calculating optimal cost. Same can be done for N = 3, try each node as root and then calculate which order gives the optimal solution. Generalization:- The idea is to try all nodes as root and recursively calculate optimal cost for remaining nodes. Say we have keys k1 k2, ..., kN and we select kR has root:- k1 <= kR <= kN We recursively calculate left OBST and right OBST for range (k1...kR-1) and (kR+1...kN) respectively [k1, k2, ... kR-1,] kR,[ kR+1, ...,kN-1, kN] Here's the formula:- External links:- [1] Page on software.ucv.ro [2] Dynamic Programming | Set 24 (Optimal Binary Search Tree) - GeeksforGeeks [3] Huffman coding Thanks for A2A 