Graph Theory: Given n nodes, how many labeled and unlabeled binary trees and binary search trees are possible?This is not a homework Problem. I am appearing for Competitive Exam where this question is asked many a times. Before posting question here, i have googled for the explanation,still couldn't understand it quite well.There are catalan number of Binary Search trees possible. Lets start with base cases. Say you've just 1 node or 0 nodes in your BST then number of possible BST is possibly just 1, since they are the only node. So base case if(n ==0 || n == 1)  return 1; Lets assume l denotes number of nodes in left subtree, r denotes number of nodes in right subtree. Say we've 2 nodes in our BST. For n=2 Possible BSTs now will be 1 root node and l = 0, r = 1possible arrangements = 1 l = 1, r = 0possible arragements = 1 So total possible arrangement = 2 For n=3 Number of valid nodes on left subtree can be 0,1,2 and 2,1,0 on right subtree respectively. Now, l = 0, r = 2 Here, for l = 0, there is 1 possible arrangement from base case (say left = 1) for r = 2, there is 2 possible arrangement, recall the scenario of n = 2. (say right = 2) So, total no possible arrangements = no of possible arrangements of left subtree * no of possible arrangements on right subtree. ie., ans = left * right ans = 2 * 1 = 2 l = 1, r =1Similarly for this case left = 1, right = 1, recall n = 1 scenario since here left and right are trees with 1 nodes. ans += left * right ans += 1*1 ans += 1 l = 2, r = 0now for l = 2, left = 2, n=2 scenario r = 0, right = 1, from base case ans += left * right ans += 2 * 1 ans += 2 Total possible trees = 2+1+2 = 5 If you had observed closely then the sequence goes like 1,1,2,5,14,.. which is catalan numbers. A simple recursion from the above logic in C is here, Int countTree(int N) { If(N==0 || N==1) Return 1; Int sum=0,left =0,right=0; For(int k=1;k<=N;k++) { Left = countTrees(k-1); Right = countTrees(n-k); Sum += left*right; } Return sum; } 