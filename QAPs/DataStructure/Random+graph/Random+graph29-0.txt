What are the practical applications of the quasipolynomial-time graph isomorphism algorithm?
First of all, the algorithm is a major breakthrough, but not because of its practical applications. It's the new ideas that matter. Practical applications, you say? In all likelihood, none at all, at least not directly. For all known instances the algorithm is outperformed (significantly!) by previously developed heuristic algorithms. Quoting Laci Babai himself (section 13.5 of the http://arxiv.org/abs/1512.03547v1 preprint): The purpose of the present paper is to give a guaranteed upper bound (worst-case analysis); it does not contribute to practical solutions. It seems, for all practical purposes, the Graph Isomorphism problem is solved; a suite of remarkably efficient programs is available (nauty, saucy, Bliss, conauto, Traces). The article by McKay and Piperno gives a detailed comparison of methods and performance. Piperno’s article gives a detailed description of Traces, possibly the most successful program for large, difficult graphs. These algorithms provide ingenious shortcuts in backtrack search. One of the most important questions facing the theorist in this area is to analyze these algorithms. While Miyazaki’s graphs provide hard cases for the early version of nauty, the recent update overcomes that difficulty. The question is, does there exist an infinite family of pairs of graphs on which these heuristic algorithms fail to perform efficiently? The search for such pairs might turn up interesting families of graphs. Alternatively, can one prove strong worst-case upper bounds on the performance of any of these algorithms? The comparison charts in [McKay and Piperno] seem to suggest that we lack true benchmarks – difficult classes of graphs on which to compare the algorithms. Encoding class-2 p-groups as graphs could provide quasipolynomially difficult examples, but right now we have no guarantee that the heuristics could not be tricked into much worse, (moderately?) exponential behavior. 