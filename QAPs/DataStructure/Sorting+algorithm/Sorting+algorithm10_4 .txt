Quicksort: What is the quick sort algorithm?Quicksort is a fascinating sorting algorithm. It belongs to the class of divide and conquer algorithms. It sorts in place, meaning it would not require any extra memory space to complete the sorting, unlike mergesort which would need space equal to the size of array you want to get sorted.Some terminology- Pivot- Since it is a divide and conquer algorithm so it should solve the problem by dividing it into subproblems and successively grouping the subproblems for the end result. But how do you divide your problem into subproblems?? Now, comes the role of pivot. Pivot is the element which you would use to divide/partition your array. One good start could be to select the first element as pivot always. But,choosing the pivot is very important for the algorithm to work efficiently. Partitioning- It is the process of dividing your original array into two sub-arrays using the pivot. After partitioning an array of size of 'n', you have two subproblems- such that the element which you used as pivot goes to its proper place as it would be in a sorted array, and all the elements smaller than the pivot element would be on left side of pivot and all other greater elements than the pivot, would be on right side of the pivot. So, effectively now you would have two subproblems, or sub-arrays which need to be sorted, one from start to the left of the pivot and other from next to the pivot to the last. Enough reading let's see it with an array- [50,45,23,67,88,32,66]. Although we have seen that quicksort does not need extra space, here i will use extra space to give you a feel of the partitioning more clearly. So, we keep an empty array of size 7 as our original array. [-,-,-,-,-,-,-]. Now we choose the first element 50 as pivot, start traversing the array, and keep the elements smaller than pivot to the left end of the empty array and bigger element to the right end of the array- So, it would be like, [45,-,-,-,-,-,-] [45,23,-,-,-,-,-] [45,23,-,-,-,-,67] [45,23,-,-,-,88,67] [45,23,32,-,-,88,67] [45,23,32,-,66,88,67]. See, the position for your pivot is now left and it is essentially the position where your pivot should be in the sorted array. Now you will put your pivot at this position to get [45,23,32,50,66,88,67]. You now have two subproblems, one to the left and other to the right of the pivot. You can then successively apply the algorithm first for left half and then for the right half till you get it all sorted. In-place partitioning could also be done. Let's say the first element was pivot, then you start from the second element, and scan the array. Initialise two pointers 'i' and 'j' to point at second element initially. Increment 'j' as you move on to next element. Compare the element at 'j' with element 'i', if element'j' is smaller then swap it with that at 'i'. Increment 'i' whenever such a swap happens. Now, after you complete the loop, swap the element at (i-1) with the pivot. This is all. 