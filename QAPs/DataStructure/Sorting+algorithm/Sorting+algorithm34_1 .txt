What is the fastest sorting algorithm with the least complexity?Which algorithm is the fastest in sorting number in array??Let's first try to understand the lower bound on sorting algorithms and the best they can do. Sorting is, given a set of elements, <a0, a1, a2, ... , an> arrange them such that it follows a specific configuration, usually ascending or descending order with numbers. It can be easily seen by combinatronics that a set of N items will have N! permutations in the worst case. ​ ​ The image shows 3 elements to be sorted it can be seen that there are 3!=6 possible permutation (=leaves of the decision tree). So if we build a decision tree we know that there are at least N! possible answers we can get, i.e. there are N! factorial leaves, since each leaf is a resulting permutation of the set of elements. Since the decision tree is binary (branching based on a YES or a NO) we know that the height of the tree can be found,   Height of the tree is at least lg(N!).  Using  Stirling's approximation of the factorial, http://en.wikipedia.org/wiki/Sti... ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ Hence the tree has height bounded by N lg(N) and that is the minimum time required for a comparison based sorting algorithm. Any algorithm that takes N lg(N) time is a good one. Merge sort and Heap sort are N lg(N) divide and conquer sorting algorithms. It depends on where you want to apply the sorting technique and what are the specific behavior that the system where it's to be applied exhibits. Depending on the input and various cases there maybe some algorithms that work more efficiently than others. There are other techniques that can break the bound of N lg(N) since they aren't based on comparing elements to sort the elements. Algorithms like Counting sort and Radix sort under specific conditions behave as linear time sorting algorithms and sort the elements in O(N) time. The above don't compare and only decide the position of the elements in the sorted list by just looking at the elements (and their frequency of appearance), hence the linear time.  It is to be seen that they work given that the range of the input is known. If the input data has elements varying over a large interval then the algorithm may not behave as a linear one. So comparison model based sorting requires at least O(N lg(N)) time while other sorting model techniques may push the bound to O(N). I suggest the better algorithm for sorting is Heapsort since it sorts in place, doesn't require auxiliary memory (unlike Merge sort) and does O(N lg(N)) work. The logic behind it is fairly simple and uses the properties of a Heap data structure.   