What are the best advice for problem setters in competitive programming?
I have little experience of problem setting and here are my advices: Try to reduce the amount of input / output. This will clearly eliminate the effect to fast IO method. There are a lot of ways to do it. Suppose you want to input an array with 10^6 elements. Instead of giving all 10^6 elements as input give only 2 or 3 seed integers (a, b, c) and then give a formula to generate other numbers like arr[i] = (arr[i - 1] * b + c) % 100 For short contest mask your problem using problem statement nicely. Person who knows the algorithm should be able to quickly start implementing it while the person who doesn't know the algorithm should struggle. Ask someone else to test your problems for you. If possible do not tell the tester anything about the problem. Let the tester figure out the solution Be careful with outputs that involve floating point values. A relative error of 10^-6 is good enough. Do not go beyond that. Write sub-optimal solution with constant-time optimisations and test your time limits. Make sure both iterative and recursive versions of an algorithm is accepted. Do not be too harsh with time-limit especially for slower languages. Ideally an optimal solution should take 1-3 secs while sub-optimal solution should take tens of second for the same set of test cases. Do not try to differentiate between O(NlogN) and O(N). LogN is should be considered as a constant for problem setting purpose except a very few cases. Google keywords and constants from your problem statement just in case. Do not get social engineered. Some contestants will browse the setter's solution history and then find a related problem. Make sure the setter's profile is clean. If your problem is inspired by some other problem, at least change the sample test cases ! Monitor the comment section regularly especially in long contests. Ideally the problem statement should be very clear and there shouldn't be any comments seeking further clarification Don't generate all the test cases randomly. Some smart contestants will try to exploit the randomness and get their sub-optimal solution accepted. There should be a mixture of corner cases, random test cases, overflow cases, etc. Use a proper technique to generate test cases for topics like graph. It's not just about generating a bunch of random numbers. Ensure all test cases obey the input constraints as specified in the problem statement. As far as the whole problem set is considered. Here is my rule of thumb : No one should be able to solve all problems. Each problem should be solved by at least 1 contestant 1 problem should be solved by > 80% of contestants The decisive factor between the top few teams should be number of problems solved and not the time. Applicable partially. There should be granularity in difficulty level. There should ad-hoc, easy, medium-hard and hard problems. 