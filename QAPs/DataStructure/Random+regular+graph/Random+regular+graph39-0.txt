What's a good "scripting" functional programming language?
I've been perfectly happy using Haskell for shell scripts and one-off tasks. Especially with some of the recent new features like deferred type errors and type holes, Haskell has become very interactive which makes it a solid choice for interactive development and prototyping. ScriptingRecently, I've been writing most of my shell scripts in Haskell. For example, here's a little pager script I wrote that has a few different command line options and calls out to emacsclient. It's actually quite nice: when I write something like git log in my Emacs shell, it just opens up a new buffer right in the same Emacs session which lets me easily move around the output, copy parts to other buffers or even save it somewhere. Unfortunately, Haskell is a bit verbose for common script tasks by default. But this isn't a fault of the language—it's just a library problem. And people have written libraries to make shell scripting much nicer, like Shelly. (There are code samples at the very bottom of the readme; it's a shame they're not more prominent.) One nice thing about using Haskell for scripting like this is that the various parts of Shelly are just normal Haskell values and functions, which makes it very easy to build up abstractions with them. For example, it's just one line of code to wrap up a common command in a function so that y ou don't have to copy and paste parts of it everywhere. TextHaskell also has some really great libraries for text wrangling. There's a parser library called Parsec which I've found far easier to use than regular expressions for everything beyond the really trivial. For things like HTML and XML, I've really enjoyed a lightweight library called tagsoup which makes simple tasks pretty concise. For example, here's a little snippet I just wrote for applying a function to every href attribute in an a tag: mapHrefs f = renderTags . map toUrls . parseTags  where toUrls (TagOpen "a" attrs) = TagOpen "a" $ map goHref attrs        toUrls tag                 = tag        goHref ("href", url)       = ("href", f url)        goHref attr                = attr The neat trick is that it all works by pattern matching. The toUrls function gets the attributes of an opening a tag and goHref only changes the "href" attribute. Note, also, that this is a String -> String function: it takes care of parsing and then printing the HTML to a string too! Pretty concise for the whole pipeline, I think. I bet this code could be even nicer with lenses, but it look like there's no active tagsoup-lens library. JSON is also very nice to work with. And this is an library for which you already can use lenses, which makes for really elegant traversals over JSON objects. Using aeson and lenses, we can write the Haskell equivalent of json[0].someObject.version[1] as json ^? nth 0 . key "someObject" . key "version" . nth 1 which also elegantly handles failure. I got this example from a great tutorial on using aeson with lenses. Traversals, another abstraction from the lens library, can make this sort of code even neater because they make looping over, say, every array item in the above code much easier. For example, you could bump the middle version number of every JSON object in an array (automatically parsing and then pretty-printing the JSON) like this: obj & values . key "someObject" . key "version" . nth 1 . _Number +~ 1 In this case, it handles errors by simply not modifying the malformed array entry. So if you had an object in the array without a version key, it would simply not be affected. And, in normal Haskell style, it's trivial to factor this out into a function. The most obvious way is like this: bump obj =  obj & values . key "someObject" . key "version" . nth 1 . _Number +~ 1 However, & is actually just inverse function application, so we can make this simpler and shorter by "cancelling out" obj: bump = values . key "someObject" . key "version" . nth 1. _Number +~ 1 This is one of the real strengths of Haskell as a quick scripting language: it's trivial, both syntactically and conceptually, to refactor things into functions. I say it's conceptually trivial because, since the expression can't have side-effects, there are no hidden dependencies to worry about; you know that just moving the expression into a function won't change a thing. I think this is a nice mini-demo of how lens can make for some very succinct code for common tasks like JSON munging. However, it's worth noting that lens does have some drawbacks, the main one being that it makes type error messages much harder to understand. Other TasksI've also used Haskell for a bunch of random scripts to automate otherwise tedious things. For example, I recently wrote a Quora answer about winning at connect-four which needed a whole bunch of diagrams like this one: It was very easy to hack together some code for quickly rendering these diagrams from a text file. And, thanks to Haskell's handy REPL, I actually ended up creating many of them interactively. Here's my code and here's a nice screenshot of it active in Emacs: It's not the prettiest code, but that's the point—I wrote it without worrying too much about maintainability since it was only going to be used once for that particular Quora answer. The actual diagrams were generated with the appropriately named diagrams library which is a really good fit for generating illustrations like this. I've actually done similar things for a few other Quora answers (like generating graphs to illustrate my points) and I've used Haskell for automating similar tasks in other places too. It's been uniformly useful. The point, ultimately, is that Haskell is a great scripting language. It takes a little while to learn it properly, but it's more than worth. And you only have to learn it once—but you'll benefit each time you write a script or, indeed, a serious program with it. Updated 85w ago • View Upvotes • Asked to answer by Anonymous