Why do Hash Tables need to store the Key of a record?Can't we just insert the Value (without the Key), after we calculate the hash for the table (using the Key)? I guess what I'm trying to get at is, what is the use of the Key after calculating the hash? We can just retrieve the record's Value if the requesting application knows the Key. Am I getting this wrong? Thanks.
The first problem is that you're not storing by the key, you're storing by the hash of the key. Your key could be a string, and we're going to figure out the hash of the string. Two strings can have the same hash, because there are more strings than there are integers. That means that if you don't store the keys, you can't tell the difference between hashtable["SomeString"] and hashtable["OtherStringThatUnfortunatelyHashesToTheSameValue"]. By storing the key, you can go to where you expect to find the first string and find the second string instead. You can skip that until youÂ  get the key you want. (I'm intentionally being a little hand-wavy: there are different methods to deal with collisions, including having a linked list of items that share the same spot and just storing the item in the next available spot.) The second problem is that when you create a hash table, it doesn't make an entry for every possible hash. Instead it creates buckets. The number of buckets it starts with is a little arbitrary, but you don't want all the buckets to be full. So you start with a number of buckets: let's say 100. You can choose a method of assigning a hash to a bucket (an easy one would be hash % numberOfBuckets). When more of your buckets start being full, you might decide you need to create more buckets. So you make more. Let's say you now have 200 buckets. You need to rebucket all the items that already in the hash table. At minimum, this means you not only need to store the value, but the hash too. (In practice you're going to store the key to avoid the collision issue, and you can just re-hash thekey.) 