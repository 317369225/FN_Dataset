What is the intuitive explanation for p∨q→r≡(p→r)∧(q→r)  p∨q→r≡(p→r)∧(q→r) ?I like to think of these things in more or less constructive terms. a→b  a→b means that, given a proof of a  a , we have a procedure to build a proof of b  b . a∨b  a∨b means we either have a proof of a  a or a proof of b  b . Crucially, we don't know which one: either would suffice. Putting these two together, we get a∨b→c  a∨b→c , meaning we have a way to build a proof for c  c given a proof of either a  a or b  b . Again: we don't know which one! Since we could be given either, we have to be ready for both. This means we have to have two procedures: one a→c  a→c and one b→c  b→c . Since we have both, we can  ∧  ∧ them together. Another way to look at this is through the Curry-Howard isomorphism, with proofs as programs and propositions as types. Here, implication (→  → ) corresponds to functions and disjunction (∨  ∨ ) to a sum type. In Haskell the most basic sum type is called Either: data Either a b = Left a | Right b The propositions we have corresponds to the type Either a b -> c. How would we write a function like this? We'd have to pattern match on the Either and handle both possible cases: case either of Left a -> ... Right b -> ... What are the two branches? Functions a -> c and b -> c respectively. To pattern match on a sum type, we have to provide functions for all the possible cases. To be more thorough, we can even write a function of the type (Either a b -> c) -> (a -> c, b -> c) to prove the relation you're asking about. (A tuple (a , b) corresponds to a∧b  a∧b .) The resulting function is actually pretty simple: foo :: (Either a b -> c) -> (a -> c, b -> c) foo f = (\ a -> f (Left a), \ b -> f (Right b)) That is, given a function f that corresponds to a proof of a∨b→c  a∨b→c , we get a tuple corresponding to a→b∧a→c  a→b∧a→c by producing two functions that, respectively, wrap an a or a b into Either a b and pass that into f, giving us a c both times. We can also go in the opposite direction. Given two functions a -> c and b -> c, we can get a single function Either a b -> c by, essentially, plugging both functions into a case statement: bar :: (a -> c, b -> c) -> (Either a b -> c) bar (f, g) = \ either -> case either of Left a -> f a Right b -> g b 3.4k Views · View Upvotes