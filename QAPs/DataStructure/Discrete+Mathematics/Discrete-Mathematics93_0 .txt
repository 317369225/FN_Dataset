How is Discrete Math related to cryptology?Ciphers and codes use many tools from abstract algebra, number theory. and linear algebra including: congruences, quadratic residue theory, field theory, matrices, non-commutative groups, various mathematical algorithms, hash functions, and quantum algorithms. All of these tools are part of discrete mathematics. An example is the famous RSA algorithm that enables a public-key encryption system, in which everyone knows how to encrypt but only someone with a special private key can decrypt. Here is how it works (very briefly): Two numbers are made public. Together these are called the public key. One of these numbers is a product pq of two prime numbers, and the other is a number we will call “e” that for technical reasons needs to be relatively prime to (p-1)*(q-1). That is, the greatest common divisor of e and (p-1)*(q-1) must be equal to 1. (The reason for this is very important, but I would distract you by explaining why right here.) For example, we can choose p = 5 and q = 11, and e = 21. Note that (5–1)*(11–1) = 40, and that the gcd(21, 40) = 1. To encrypt a message, first you convert to a sequence of integers. There are many ways to do this - some much better than others. Then, one by one, you encrypt the integers. To encrypt an integer x, you calculate x^e mod pq. The numbers pq and e are public so that anyone can encrypt any integer. For example, to encrypt the number 6 we calculate 6^21 mod 55 = 46. It is not obvious how to do this in one’s head but discrete math provides fast (efficient) algorithms for modular exponentiation. The cool part of this scheme, is that the obvious way to decrypt 46 is to brute force try all the possible values for x, raise them to the 9th power and mod by 55. This brute force idea is way too slow because when we use very large p and q, the resulting number of possible x’s is too large to manage efficiently. However, using some more discrete math (Fermat’s little Theorem, congruence theory, and Euclid’s extended algorithm), we can efficiently compute a magic decoding exponent d that will take 46 and turn it back to 6. The mathematics is to find d such that ed = 1 mod (p-1)(q-1). (Finding this magic decrypting exponent, and understanding why it works, is complicated. ) Once again, discrete math gives us an efficient algorithm to do this, providing we know what (p-1)(q-1) is. In our case, the magic decoding exponent happens coincidentally to also be 9 (it is not usually the same number), so to decrypt 46 we need to calculate 46^9 mod 55 = 6. Thus, the only thing preventing someone from decrypting a publicly encoded RSA message, is that they do not know (p-1)(q-1). And, the only way to find out that number is to get it from pq, which would require factoring pq, and nobody knows how to do that efficiently. Therefore, the only people who can decrypt publicly encoded RSA messages, are the people who created pq in the first place, because only they know p and q. That is the tip of the iceberg. There is much much more, but this single example should give you a feel for how discrete math is intrinsically connected with cryptology. 781 Views · View Upvotes · Answer requested by 1 person