How do I Implement a C program for a polynomial as an Abstract Data Type (ADT)?
Firstly, its important that any common reader has a general idea of what an Abstract Data Type  (ADT) is. Quoting from CS13002 Programming and Data Structures An abstract data type (ADT) is an object with a generic description independent of implementation details. This description includes a specification of the components from which the object is made and also the behavioral details of the object. Now, lets get back to the problem. Let [math]P[/math] [math]=[/math][math] a_{0}[/math] [math]+[/math] [math]a_{1}x^{1}[/math] [math]+[/math] .... [math]+[/math] [math]a_{n}x^{n}[/math] be a polynomial of degree [math]n[/math] (polynomial in multiple variables can be handled similarly). If we were to represent P using C language then the following ADT could be used: 1. Single Array: Let A be an n+1 sized array.  Set [math]A[0]=a_{0}, A[1]=a_{1}, ..., A[n]=a_{n}[/math]. Then, array A is an ADT for polynomial P. For example, if  [math]P=2+1x+4x^{2}[/math], then Now, if there are multiple polynomials with varying degrees then two things can be done: (a) Find the maximum degree of all the polynomials and use an array of that size. It is not very difficult to see that it is highly inefficient as any polynomial with degree less than the maximum degree will waste memory. For example, let the maximum degree = 5 and P = x, then (b) Get the degree of polynomial at runtime and dynamically allocate the required amount of memory to the array. Next, let us look at the tradeoff involved with using a single array as polynomial ADT. Pros: (i) Very easy to construct.  (ii) Polynomial addition and multiplication are easy. Cons: (i) Inefficient for sparse polynomials as visible in the previous example.  (ii) Modifying the ADT to represent a polynomial of higher degree is not possible. 2. Double Array: Let there be k non-zero coefficients in polynomial P. Let there be two one dimensional arrays A1 and A2, both of size k. Set [math]A1[i]=e_{i}, i=0,1,2...k-1[/math], where [math]e_{i}[/math] are exponents in increasing order with non-zero coefficients.  Set [math]A2[i]=a_{i}, i=0,1,2...k-1[/math], where [math]a_{i}[/math] is the coefficient corresponding to exponent [math]e_{i}[/math].   For example, let [math]P=5+3x+9x^{10}[/math], then [math]k=3[/math] and [math]e_{0}=0, e_{1}=1, e_{2}=10, a_{0}=5, a_{1}=3, a_{2}=9[/math]. Then Here, A1 and A2 together act as an ADT for the polynomial P. Now, let us look at the tradeoff: Pros: (i) Easy to construct. (ii) Space efficient even for sparse polynomials. Cons: (i) Addition and multiplication of polynomials become difficult. (ii) Modifying the ADT to represent a polynomial with any more non-zero coefficients is not possible. 3. Linked List: As in the previous case, let there be k non-zero coefficients in polynomial P. Let there be a (singly or doubly) linked list L with k nodes. Each node will store exponent value and the corresponding non-zero coefficient. It is wise to arrange the nodes in increasing/decreasing order of exponents they store. e.g. Let [math]P=5+3x+9x^{10}[/math], then [math]k=3[/math]. L will look like : In keeping with the tradition, here's the tradeoff: Pros: (i) Maintains a single data structure to store exponent and coefficients (unlike the clumsy double array). (ii) Easy to modify as insertion and deletion of nodes in a linked list is very convenient. Cons: (i) Not as easy to construct as arrays. (ii) Addition and Multiplication of polynomials become difficult. Now that you have three ADTs, this question naturally arises: Which one of them to use ? Well, I would like to act lazy and skip this part by saying," This is an excercise for the programmer". p.s: of course the choice of ADT depends on whether you are limited by memory or not :). 