Why are there no limits of single and double-precision numbers in Scheme?
In Scheme, numbers are divided into "exact" and "inexact" numbers. How each of these is implemented is implementation-defined. "Exact" numbers are basically arbitrary-precision rational numbers. "Inexact" numbers are what you normally think of as floating-point numbers, i.e. approximations of real numbers. Scheme tries to keep numbers exact as much as possible. When you write a regular number constant, you can specify whether it is exact or inexact, with the #e and #i prefixes; by default, integers constants are exact, whereas decimal constants or number constants in scientific notation are inexact. If you perform an "exact operation" on multiple exact numbers, the result is an exact number. Otherwise, it is inexact. Arithmetic operations that are closed over the rationals, like addition, subtraction, multiplication, division, etc. are exact operations. So, for example, if you divide two integer constants, you will get an exact number. But if you take the sine of a number, it will be an inexact number. There are functions exact? and inexact? to test whether a number is exact. There are also functions exact->inexact and inexact->exact to convert between exact and inexact numbers. Precisely how much precision inexact numbers have is not defined, but is probably single or double floating-point precision. However, chances are, when you asked this question, you were encountering an exact number, which is stored as a fraction type, so it is seemingly infinitely precise (well, it is "exact"). 