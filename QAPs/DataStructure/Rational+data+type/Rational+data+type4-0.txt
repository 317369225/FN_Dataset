Why doesn't Haskell have any killer app yet?
A "killer app" is, by definition, an application that makes a platform popular—and Haskell isn't really popular. (Yet?) It's little more than a post hoc rationalization of how something became popular—a process that's notoriously social, fickle and independent of quality. (An idea I've talked about before.) You can't have an app that made a language popular if that language has not been made popular. In my mind, the canonical "killer app" for a programming language is Ruby on Rails. It's a great example because Ruby is an unredeeming language that doesn't stand out from its close peers (Python, JavaScript, Lua, Perl… etc) and doesn't have a major commercial backer (37signals doesn't count much), so there are no obvious outside factors pushing it. Moreover, Rails  is only relevant for developers—users don't care that you used Rails instead of ASP or PHP. Does Haskell do anything like that? Are there any features that, after it finally gets popular (one day!), we can point to to build up a satisfying narrative? I think so. Perhaps the most cited concrete reason for functional programming is parallelism and concurrency. And this really is something that Haskell excels at. It offers one of the few successful implementations of software transactional memory and, through parallel strategies, fully deterministic parallel programming. Making your code parallel modularly and without changing its semantics sounds like a perfectly viable killer app in a world where parallelism is becoming more and more central to all programming. (Of course, it's not obvious that we actually live in such a world!) Or how about domain specific langauges (DSLs)? They're all the rage now! You could make a plausible case that Ruby got popular in large part by supporting and pushing a weird sort of DSL itself. Well, Haskell is just better at it. It's easy to write embedded DSLs thanks to the syntax, to laziness, to algebraic data types and to general expressiveness. And if you want to add an external syntax to your DSL, Haskell makes parsing easy. Or what about performance, for a high-level language? Haskell might not be as optimizeable as C or even Java, but provides an incredible set of building blocks for making high-level code faster. That's a big deal as more and more people have to program at larger and larger scales. Haskell not only has surprisingly good overall performance on benchmarks (despite how much less person-time has been put into GHC as compared to mainstream language implementations) but also boasts features that make it easier to provide high performance abstractions. Rewrite rules are a great example which effectively let you bundle compiler optimizations as libraries. Being able to write the high-level code you want without suffering abysmal performance is a perfectly reasonable "killer app"! But, of course, none of these really are killer apps—because Haskell isn't popular yet. But they're all plausible, as are many other things Haskell can do. Now we just have to wait on the actual social dynamics that can make the language popular to turn any one of these, or more, into a compelling "killer app" narrative. Updated 24w ago • View Upvotes • Asked to answer by Miguel Paraz and Sameer Gupta