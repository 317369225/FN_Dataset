What are some examples of when Haskell's type system is better than others?
Simple and illustrative example is Phantom Types. Suppose we want to work with different currencies and don't mess them up while storing as plain Doubles: {-# LANGUAGE EmptyDataDecls #-}data USDdata GBPdata EURnewtype Currency a = Currency Double deriving ShowaddAmounts :: Currency a -> Currency a -> Currency aaddAmounts (Currency a) (Currency b) = Currency $ a + bfiveDollars :: Currency USDfiveDollars = Currency 5.0fivePounds :: Currency GBPfivePounds = Currency 5.0main = do    print $ addAmounts fiveDollars fiveDollars -- Currency 10.0    --print $ addAmounts fiveDollars fivePounds -- won't compile Even in F# they have separate notion for this: Units of Measure. Similar thing is possible in C++ with more syntax as usual. There are more advanced examples. :) UPD. One of the most powerful and mind-blowing features of Haskell type system is type-level programming. (Frankly speaking you need GHC extensions to standard Haskell for this but everybody uses them anyway so practically they are standard. :)) Particularly, you can have type-level arithmetic which opens possibility for compile-time safe lists (vectors) i.e. their length is known (calculated) at compile-time hence calling head of empty list (vector) is compile-time error: {-# LANGUAGE GADTs #-}{-# LANGUAGE StandaloneDeriving #-}{-# LANGUAGE DataKinds, TypeFamilies, TypeOperators #-}{-# LANGUAGE UndecidableInstances #-}import Prelude hiding (tail, head)data Nat = Z | S Natinfixl 6 :+infixl 7 :*type family   (n :: Nat) :+ (m :: Nat) :: Nattype instance Z     :+ m = mtype instance (S n) :+ m = S (n :+ m)data Vector a n where  Nil  :: Vector a Z  (:-) :: a -> Vector a n -> Vector a (S n)infixr 5 :-deriving instance Eq a => Eq (Vector a n)toList :: Vector a n -> [a]toList Nil = []toList (x :- xs) = x : toList xsinstance Show a => Show (Vector a n) where  showsPrec d = showsPrec d . toListhead :: Vector a (S n) -> ahead (x :- _) = xtail :: Vector a (S n) -> Vector a ntail (_ :- xs) = xsmain :: IO ()main = do  print $ head (1 :- 2 :- Nil)  print $ tail (1 :- 2 :- Nil)  -- | Uncommenting the line below causes type error  -- print $ head Nil Code is from Part I: Dependent Types in Haskell which explains how it works. Again you can achive similar results in C++ but you do not want to. :) 