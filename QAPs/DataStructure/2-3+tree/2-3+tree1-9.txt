Is it okay for a beginner to take a lot of time to implement advanced data structures such as AVL trees or 2-3 trees? Frequently asked inRecently I tried to write a program involving AVL tree and I I took a lot of time. Though solved it eventually, I got frustrated because of time I took.
i feel this is a rhetorical question: the answer is obvious! the main reason I liked the question is/was because of the great answers the question has managed to garner ... from some of the best of the best. (I am following most of you now!) that said, I feel that the two best answers to your questions are these: Tony Li's answer to Is it okay for a beginner to take a lot of time to implement advanced data structures such as AVL trees or 2-3 trees? David Yang's answer to Is it okay for a beginner to take a lot of time to implement advanced data structures such as AVL trees or 2-3 trees? Why do I feel that? Because if you are in a data structures class, you may be required to implement it, or if you are wasting your time at a competitive programming contest place, then maybe you should know this by heart, but, if you are a real human programmer, solving real questions then I feel learning "data-structures by heart" is (and should be) the last thing on your mind. I feel that you should obviously know the commonly used data structures and algos and what makes one ds/algo better than the other, but, beyond that knowing them by "heart" is unnecessary. But seriously ... knowing the implementation by heart and implementing it at break-neck speeds is "unnecessary". Personally, I studied data structures and algos a million years ago. Then I worked in a field that required me to know and implement graph algorithms most of which I had NEVER studied in school. In fact, during my last few jobs, we worked on optimizing a few popular graph algorithms. Coming up with those optimizations took weeks. Our implementations (coding and dev tests) took weeks. Testing (system testing) in our labs took months after that. Testing at the service provider labs took even longer. The obvious question here: should we be concerned with speed of implementation or correctness of the algo? I would go with correctness of the algo. On a final note: yes, I studied AVL trees as part of my BS program. Thankfully, I never had to use them. At one time, much later in my career, someone asked me if my team would give them an implementation of the AVL tree. I asked them why they wanted it ... the answer was: because it would be "cool" to have our own AVL implementation! I just put an intern to finish the job! That code was never used in our code base ... not because it was not good, but because people never had a reason to use it. 