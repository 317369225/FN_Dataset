How do you write Java code for adding to a 2-3 tree? Frequently asked in
The method is pretty complicated but it covers pretty much all of the nuances of 2-3 tree insertion. Calls to insert will return when node is the terminal node of either a 3-node (2 elements, 3 children) or 2-node (1 element, 2 children). These are your base cases, but the method will only fully terminate when it reaches a 2 node case (assuming no exception is thrown). 2-Node Base Case: You have reached a terminal 2-node. All you do is turn that 2-node into a 3-node by attaching the given value. In this implementation, if the terminal node has a parent node, the parent node replaces its 2-node child with the newly created 3-node. Returns null. 3-Node Base Case: You have reached a terminal 3-node. The insert method terminates by returning the 3 element BST formed by the 2 elements of the 3-node and value (constructed by calling splitNode). After this, the method will start backtracking through the tree until it returns null. In the case that backtracking returns a new Tree, the add method will reassign the current 2-3 Tree to this return value. Recursive Case: There are actually multiple recursive cases but they can be generalized into same concept. The first step in all of these cases is making a comparison between value and the element(s) of the current node to find the proper branch to traverse. Perform a depth-first-traversal through the tree and everything will work out smoothly if you end on 2-node. But if you hit a 3-node, you run into complications due to the Node<T> result = insert(value, someNode); call when result points to something other than null. The main idea behind the non-null case is to attach the root value of the BST returned by the 3-Node Base Case and the node value of the previous recursive call, essentially reconstructing the 2-3 Tree through backtracking. Let's call these the reconstruction cases. Reconstruction Case 1: If the previous call referenced a 2-node as node, that node is turned into a 3-node formed by node and the BST root. The 3 children of the new node are properly assigned and the program terminates. Reconstruction Case 2: This is also a whole bunch of cases that can be generalized into one idea. If the previous call referenced a 3-node as node, splitNode is called on node and the root value of result, constructing a tree called returnValue. returnValue = splitNode(threeNode, result.val()); The children of the left and right branches of returnValue are then assigned children to their respective positions. Think of it as taking 3-Node Base Case and subsequently adding onto it to create a bigger tree. This process is continued (either Case 1 or 2) until the method returns null or reaches the top of the tree. Oh, and if value is a duplicate, the method throws an error. 