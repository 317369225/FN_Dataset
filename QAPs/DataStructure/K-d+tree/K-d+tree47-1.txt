Can someone provide side by side comparisons of a few operations done in functional programming vs imperative programming?
Here's a classic comparison. Quicksort implemented in C and Haskell. Here's the code in C: void qsort(int a[], int lo, int hi) {  int h, l, p, t;  if (lo < hi) {    l = lo;    h = hi;    p = a[hi];    do {      while ((l < h) && (a[l] <= p))           l = l+1;      while ((h > l) && (a[h] >= p))          h = h-1;      if (l < h) {          t = a[l];          a[l] = a[h];          a[h] = t;      }    } while (l < h);    a[hi] = a[l];    a[l] = p;    qsort( a, lo, l-1 );    qsort( a, l+1, hi );  }} And here's the code in Haskell: quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater)    where        lesser  = filter (< p) xs        greater = filter (>= p) xs And you can write it even more succinctly in Haskell as a list comprehension: qsort (p:xs) = qsort [x | x<-xs, x<p] ++ [p] ++ qsort [x | x<-xs, x>=p] Source: Introduction - HaskellWiki Learn more about functional algorithms: Pearls of Functional Algorithm Design ------------------------------------------------ Edit: Since there seems to be some controversy over the Quicksort example, here's a simple "Hello World" example with Java and Haskell. Java: public class HelloWorld {    public static void main(String[] args) {       System.out.println("Hello, World");   }} Haskell: module Main wheremain = print "Hello, World" In short, functional languages provide ways to write very succinct code. The downsides, some functional programming wizards write their code too succinctly, making it difficult to read. And, if loops aren't available, you'll likely have to use recursion and list comprehensions which require a bit of mathematical thinking to implement. Regarding performance, functional languages have been shown to perform as well as their C-based counterparts. Haskell and Erlang, in particular, were built with concurrency in mind[1][2]. And, in my own personal experience, I haven't had any performance issues with Haskell or OCaml. [1] Concurrency - HaskellWiki [2] Erlang -- Concurrent Programming Updated 109w ago • View Upvotes • Asked to answer by Doug Girard