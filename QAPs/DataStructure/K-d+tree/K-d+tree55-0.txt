How can you build a data structure on an array that returns kth order statistics on subarrays in logarithmic time?
Miguel Oliveira told me to post my comment as a separate answer, so here it is. Miguel's answer uses [math]O(n \log n)[/math] space and time preprocessing and [math]O(\log^2 n)[/math] time per query if you don't use fractional cascading. There is a simpler solution in the same space and time precomputation complexity and [math]O(\log n)[/math] time per query that does not require fractional cascading. We start by splitting the array around the median, and treating this as a normal K-th order statistic problem: # Given an array A, return the Kth smallest value in the range [L, R]Query(A, L, R, K):     if |A| == 1 return A[0]     Split the array A in 2 halves around the median         median = FindMedian(A)         A_low = array (v in A : v <= median)         A_high = array (v in A : v > median)         Associate each value with its position in the original array     p = # of values in A_low whose position is in [L, R]      if K <= p          return Query(A_low, L, R, K)     else                   return Query(A_high, L, R, K-p) This would be [math]O(\log n)[/math] if not for the need to binary search to calculate p, raising the complexity to [math]O(\log^2 n)[/math]. As p is the value we're ultimately interested in, let's keep a structure that helps us calculate p faster. This structure is a num_low array that will keep, for every position i in the array A, how many elements in [0, i] are smaller than median. This num_low array can be precomputed using a "reverse mergesort": start with the sorted array and use mergesort to sort the array by the original positions (i.e. unsort the array to its original state). This becomes our new query function: # Given an array A, return the Kth smallest value in the range [L, R]Query(A, L, R, K):     if |A| == 1 return A[0]     left = # of values in A_low whose position is in [0, L-1] = num_low[L-1]     right = # of values in A_low whose position is in [0, R] = num_low[R]     p = # of values in A_low whose position is in [L, R] = right - left      if K <= p          return Query(A_low, left+1, right, K)     else                   return Query(A_high, L-left, R-right, K-p) Some explanation about the recursive calls is probably in order: if you go to the low array, the "left" first elements are not in the interval, and the interval goes up to the "right" element, so that's why you call Query as Query(A_low, left+1, right, K). If you go to the high array, of the L elements not in the interval, "left" of those are in A_low, same thing for the upper bound of the interval. Taking into account that there are p values in the low array you're ignoring, you call Query as Query(A_high, L-left, R-right, K-p). A C++ implementation could be: struct elem {    int val, pos;    bool operator< (elem b) const {        return val<b.val;    }};int* tree[4*MAXN+10];elem temp[MAXN], arr[MAXN], sorted[MAXN];int* merge(int e, int d) {    int* num_left = (int*) malloc(sizeof(int) * (d - e + 1));    int left = e, right = (e+d)/2+1;    int i = 0, cnt = 0;    while (left <= (e+d)/2 && right <= d) {        if (arr[left].pos <= arr[right].pos) {            num_left[i] = ++cnt;            temp[i] = arr[left++];        }        else {            num_left[i] = cnt;            temp[i] = arr[right++];        }        i++;    }    while (left <= (e+d)/2) {        num_left[i] = ++cnt;        temp[i] = arr[left++];        i++;    }    while (right <= d) {        num_left[i] = cnt;        temp[i] = arr[right++];        i++;    }    for (int j = 0; j < (d-e+1); j++) {        arr[e+j]=temp[j];    }       return num_left;        }void create_tree (int i=1, int e=1, int d=N) {	if (e == d) return;	else {		create_tree(2*i, e, (e+d)/2);		create_tree(2*i+1, (e+d)/2 + 1, d);		tree[i] = merge(e-1, d-1);	}}int query(int p, int q, int k, int i=1, int st=1, int end=N) {      if (st == end) return sorted[st-1].val;    int left = (p!=1 ? tree[i][p-2] : 0);    int right = tree[i][q-1];    int diff = right - left;    if (diff >= k)         return query(left+1,right,k,2*i,st,st+(end-st)/2);    else         return query(p-left,q-right,k-diff,2*i+1,st+(end-st)/2+1,end);}int main() {	for (int i = 0; i < N; i++) {		scanf("%d", &sorted[i].val);		sorted[i].pos = i;	}    sort(sorted, sorted+N);    memcpy(arr,sorted,sizeof(sorted));    create_tree();} 