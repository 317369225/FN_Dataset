How can you build a data structure on an array that returns kth order statistics on subarrays in logarithmic time?
Edit: The original question asked for a sublinear-time algorithm, not one that is necessarily logarithmic time. My algorithm is only poly-log time. I will keep this answer here for now, though, since it may still be useful. I can offer an approach that provides [math]O(\log^3n)[/math] online worst-case query time after [math]O(n \log n)[/math] preprocessing using [math]O(n \log n)[/math] space. The approach is a mix of segment tree-like techniques and repeated applications of binary search. Pre-processing: for each positive integer [math]s[/math] such that [math]2^s \leq n[/math], store the sorted version of the subarray arr[[math]2^sm : 2^s(m+1)[/math]] for each [math]m[/math] that such subarray is in bounds.Â  Additionally, store a sorted version of the full array. Query: when you need to query for the [math]k[/math]-th order statistic of arr[[math]i[/math]:[math]j[/math]], the interval [math][i, j][/math] can be broken up into [math]O(\log n)[/math] intervals whose sorted versions were stored during the pre-processing. Now you have [math]O(\log n) [/math] sorted arrays in whose union you want to find the [math]k[/math]-th element. Note that you can find the order statistic for any given element in [math]O(\log^2 n)[/math] time: just binary search each of the [math]O(\log n)[/math] arrays for the element, and sum up across all the arrays the number of elements that preceded the searched element. Now that you have this [math]O(\log^2 n)[/math] method, note that the [math]k[/math]-th order statistic must be an element in the full array, and that furthermore, the order statistic of a number is a non-decreasing function. Therefore, you can binary search the sorted version of the full array for the answer. This binary search will issue [math]O(\log n)[/math] queries that run in [math]O(\log^2 n)[/math], giving an [math]O(\log^3 n)[/math] query time. I believe it should be possible to shave off at least one [math]O(\log n)[/math] factor. I will update this post if I determine how it can be done...in the meantime, up to others to find the answer! By the way, you probably should be careful to specify you want a solution that has a reasonable amount of pre-processing. Clearly, we can achieve [math]O(1)[/math] queries if we just cache every possible answer in advance using [math]O(n^3)[/math] pre-processing. 