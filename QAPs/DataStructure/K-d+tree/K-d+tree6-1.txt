What are the 10 algorithms one must know in order to solve most algorithm problems?
If you want specific algorithms, my top 10 would be: Dijkstra's - depending on the type of contest, you might see basic pathfinding problems, or you might see problems with non-obvious reductions to pathfinding problems. Whenever you have a cost minimization problem with a (reasonably small) finite number of states, an initial state a target state, you can look at it as a pathfinding problem. Bellman-Ford is useful for pathfinding when edges may have negative costs. For example if you're navigating a maze with potions which boost health and hazards which lower it, Bellman-Ford would be a great approach. Floyd-Warshall is useful for computing all paths. It is sometimes used in problems where you don't need all paths, because it's so easy to implement. It is slower than other pathfinding algorithms though, so whether Floyd-Warshall is an option depends on the graph size. Edmonds-Karp for max flow/min cut problems. One common application is bipartite matching problems. For example, given N people, M food items, and a list of each person's food allergies, how many people can you feed? The Hungarian algorithm for assignment problems. Similar to the above, but in these problems the edges have weights, and we're maximizing the total weight rather than just the number of matchings. The sweep line "algorithm" (more of a general approach really) is useful for various geometric problems, like the nearest pair problem. Also useful for a variety of intersection-related problems, like finding intersecting line segments, or conflicting calendar events. Graham scan or another convex hull algorithm, for problems such as building a minimal fence to enclose animals. An algorithm for finding strongly connected components, such as Tarjan's. Prim's algorithm for minimum spanning trees. Knuth-Morris-Pratt algorithm for string searching. Other concepts worth studying, which aren't in the above list because they aren't specific algorithms: Memoization/dynamic programming is quite useful. Some problems have obvious DP solutions, while others have very non-obvious ones which take practice to recognize. Binary search is useful in many optimization problems, so make sure you're very comfortable implementing it. Combinatorial game theory comes up now and then. I recommend Thomas Ferguson's introduction. Tries are useful in a variety of text-related problems. Updated 10 Apr â€¢ View Upvotes