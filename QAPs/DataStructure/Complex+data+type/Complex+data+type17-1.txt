What are the differences between Crunch and Cascading?
I’m unsure I’m the best person to answer this question as I’ve never used the Crunch API and really have only read the FlumeJava paper from google, which Crunch is an implementation of. Note I am the author of Cascading and the founder of Concurrent, the company behind Cascading. So I’m sure we all would rather see an independent developer weigh in on this. But I was asked to make a comment by the author of the question. I won’t belabor the most obvious point that Cascading is not a toy but a proven framework as evidenced in part by these case studies. Not to mention the companies using the layers on top of Cascading like the Bixo web mining framework and the Clojure based query language Cascalog. I do think that we may see certain classes of problems the FlumeJava model excels at representing. Overall I believe that applications and frameworks will be harder to develop and maintain with Crunch. In fact, the java-ness of Crunch will be such a burden, developers will begin to bolt on Cascading like functionality to compensate. A prevailing comment about Cascading (and Pig) has been that they use a Tuple model, vs arbitrary objects. This was called out specifically in the FlumeJava paper (Cascading is the first citation). The context presents this as a negative against Cascading/PIG. I see a number of benefits to using a Tuple model, in short: Support for dynamic language based DSLs Less overall developer code and supporting tests Fail fast dependency resolution, early error detection Ability to use complex types when necessary Without the Tuple model it would not be possible to build dynamic languages on top of Cascading. Since Cascading is Java, it can be driven from any JVM based scripting language (as Crunch can be) like Jython or JRuby. But since Cascading presents an optimized Tuple model, these dynamic languages can host child domain specific languages (DSLs) utilizing features of the host language to dynamically create fields and values at runtime. Cascalog is a great example of this. Yet the Tuple model does not prevent the use of arbitrary complex objects, which on occasion are quite useful. That is, you can stuff a Person type in a Tuple and pass it around, and write operations that know how to act on it. But the FlumeJava model requires types at every stage, so against a sufficiently modest problem, the FlumeJava model will result in an explosion of intermediate arbitrary types and tightly coupled operations that are not universally reusable. This results in more bug harboring code that must be tested. Cascading has a fail fast planner (it does not rely on the compiler, except in the arbitrary object case above). Every operation declares its expectations and results, and the planner resolves them. If they can’t be resolved, it fails before engaging the cluster. In this way, if we don’t need some values downstream, we just “project” them out of the stream. But if we do need a complex Person type, we can keep it localized, via SubAssemblies, reducing coupling in unrelated portions of the system. Because of the boilerplate overhead of creating intermediate types, Crunch developers will get clever and use maps and lists or create their own Tuple container. Cascading may use Fields and Tuples, but field values are never passed over the wire, they are part of the plan. Only values in Tuples pass between systems. A colleague of mine, formerly of Google and a FlumeJava user, has confirmed his team created their own Tuple types to overcome this issue. And were forced to touch values based on ordinal position, instead of a human readable field name. Here is an example he sent, dropAddresses = new MapFn<Tuple3<Name, Phone, Address>, Tuple2<Name, Phone>>() {    Tuple2<Name, Phone> map(Tuple3<Name, Phone, Address> input) {        return Tuple2.of(input.getFirst(), input.getSecond());    } } The prevailing justification for FlumeJava and Crunch is that they leverage types directly. But it turns out scaling the complexity of an application using Tuples is a natural solution to the issues introduced by types, and should therefore be first class in the underlying framework. Not a bolted on workaround to a proposed benefit. Alternatively in Cascading you would call, pipe = new Shape( pipe, new Fields("name","phone") ); or if you know the positions, and not field names pipe = new Shape( pipe, new Fields(0,1) ); One last point to address a prior answer. Internal Serialization is pluggable in Cascading (it even supports lazy deserialization during sorting).  This allows any serialization scheme to be used. See this blog post on the TupleProtocol, based on Thrift, from RapLeaf. Links from above: FlumeJava: http://scholar.google.com/schola... Cascading: http://www.cascading.org/ Concurrent: http://www.concurrentinc.com/ Case Studies: http://www.concurrentinc.com/cas... Bixo: http://openbixo.org/ Cascalog: https://github.com/nathanmarz/ca... SubAssemblies: http://www.cascading.org/1.2/use... TupleProtocol: http://blog.rapleaf.com/dev/2011... Updated 20 Oct 2011 • View Upvotes • Asked to answer by Christopher Lin