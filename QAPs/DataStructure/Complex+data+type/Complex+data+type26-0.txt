Why is Java a dominant programming language in open-sourced distributed systems?Hadoop, Hive, zookeeper, etc...
There are many reasons why Java has been so successful in distributed systems. Instead of answering this in the abstract, I'll answer it from my own personal experience as part of the team in 2001 that built Tangosol Coherence (now Oracle Coherence) -- a dynamically partitioned, dynamically scalable, highly available, self-organizing in-memory K/V store (what we refer to as a data grid) in Java, with native support for Java, C# and C++ applications. First, it's worth pointing out that there is little difference between Java and C# in respect to this question. Any technical advantage that Java has over other languages is almost certainly to be available in C# as well, with only rare exceptions -- and these exceptions tend to be temporary. The only real advantage that Java holds over C# in the area of distributed systems is the wealth (perhaps glut) of libraries available with which to build distributed systems; think of this as a Network effect (no pun intended). Second, to appease the language gods, it's important to point out that Smalltalk did all of these things first, many years ago, and in a manner much more elegant than any other language will ever be able to do it in the future. Now with that stuff out of the way, here are a few reasons why we found Java to be an excellent platform (i.e. language plus core libraries) for building distributed systems software on: Networking features are available in the core libraries. This includes support for TCP/IP, UDP/IP (including multicast), high-performance non-blocking I/O, HTTP / URx support, REST support, XML support, JSON support, and even security features like SSL. While this may seem obvious in 2012, it was not at all obvious when Java appeared in 1996, and it's one of the reasons why Java was so successful on the server. A rich set of data structures available in the core libraries. This one is less obvious at first, but building a distributed system requires a lot of different data structures, and Java has a healthy collection (no pun intended) of them to start with. We did end up creating quite a few custom data structures in order to achieve O(1) performance, but that's more a sign of Anal retentiveness than anything. To achieve consistent throughput in distributed systems, it's often necessary to use multi-threading, and Java is incredibly strong in this area. From day one, Java supported thread creation, locking primitives, wait/notify, multi-threaded data structures, and so on. As time went on, Java introduced support for atomics, advanced locking implementations, futures, rich reference types, and other capabilities that were essential for complex multi-threaded programming. Very early on (IIRC - either the original Java 1.0.2 in 1996 or Java 1.1 in 1997) Java supported serializing objects to bytes, and deserializing bytes to objects. I think it's obvious in retrospect, but having a portable way of sending complex data structures around a network is a Very Handy Thing (tm) when you're building a distributed system. The "portable" aspect is also quite important, since this functionality worked across different processor types, operating systems, multiple versions of the JVM, and even multiple versions of our own code. Java has quite a few well thought out APIs that are known and used quite widely in the industry, and we were able to leverage that knowledge and use by implementing those APIs in our product, i.e. by exposing our product's capabilities through well-known and already-used interfaces. As a little bit of an aside, this is an area in which Java is very open, and an area that we occasionally ran into wall when using C#. For example, in Java we could expose a K/V pair in a distributed system as a java.util.Map.Entry, an interface that is part of Java's "Map" (i.e. dictionary) data type. In C#, on the other hand, the Entry is actually a concrete class, and that concrete class is sealed, which means that you can neither implement it yourself, nor extend it! Considering all of the stuff that one asks it to handle, Java's performance is incredible! Concurrent multi-threading, garbage collection, massive network I/O loads, many concurrent disk I/Os, millions of weak/phantom/soft/etc. references, hundreds of millions of objects -- and it all just works! Yeah, there were a few bugs that we found in various JVM implementations and in the core libraries over the years, but very few and almost all work-aroundable. In the interest of full disclosure, I do work at Oracle, but the opinions and views expressed in this post are my own, and do notÂ  necessarily reflect the opinions or views of my employer. 