Why is use of pointers neccesary in C for swapping of two numbers through a function call?
Assumption: you have two variables holding some values in a built-in format (integer, float,...). You need to write a function that, after is called with the two variables as arguments, will have the two variables (say A and B) swap their content ( A now holds the initial value of B, B holds the initial value of A). There are two ways of sending parameters to a function in C-like languages: by value and by pointer. If you send by value, the function will operate on local copies of the variables sent as parameters; once the function returns, the copies are discarded and A and B will still have their initial values (as they have never been modified). To make sure that the changes that the function makes to its parameters propagate back into the variables sent to the function you need to pass them by pointer. So, this will not work: void swap(int x, int y) { int tmp = x; x = y; y = tmp; } ... int A=5, B = 10; swap(A, B); cout << A<<B; ... Will still print 5 and 10 as the memory locations for A and B haven't been modified after their initialisation. This, however, will work: void swap(int *x, int *y) { int tmp = *x; *x = *y; *y = tmp; } ... int A=5, B=10; swap(&A, &B); cout<<A<<B; ... As it will display 10 and then 5. Now the swap function doesn't operate on integer variables anymore, but on integer variable addresses (which is why you send &A to it - the address of A). Now when the function changes the content at that address (*x), it will actually modify the initial A. You may notice that the second variant above is however more complicated - you have added a bunch of & and *, and if you don't keep track of them correctly, if you add one where it doesn't belong or if you miss one where it was needed, chances are you'll only get an always-so-easy-to-ignore compiler warning, but the program will not work correctly. This is one case where the use of references helps a lot - in C, references are a kind of pointer-like variables that are however permanently bound to a single address and, syntactically, they are used like normal variables after they are declared. With references, all you have to change in the first code sample above is this line: void swap(int &x, int &y); The rest stays the same, including the way you call the function. The result would however be now correct - because the swap function now works with pointers to the initial variables. Supplemental reading: there are ways to do a swap function without pointers, of course, if the wording of the initial problem is slightly changed: - if you ignore the requirement that the function operates on its parameters, you can make it swap two global variables. Of course that makes it a very limited function, but, hey, it swaps two variables without pointers! (Just not any two variables) - if you ignore the requirement that the swap is done 'in place' (that is, you only need to call the function in order to swap the variables; no other code is needed by the caller), you can define a structure type with two values in it, receive by value an object of this type as parameter, then return it by value with the internal values swapped. It's not efficient (returning complex data types by value is generally frowned upon) and it's a major pain for the caller to keep packing and unpacking variables to the format required, but, again, it's valid C. 