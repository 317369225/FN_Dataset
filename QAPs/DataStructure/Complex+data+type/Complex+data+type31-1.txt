Why do stack variables contain garbage values? Is there any way we can assign our whole stack to NULL?Why do local, stack-based variables have garbage values by default?
Stack is an ADT (Abstract Data Type) In Abstract data type we are basically interested in operations and not on implementation, implementation details are hidden. i.e 'What it can do' rather than 'How it is done' So, initializing a stack will be unnecessary overhead(As per me) It can be implemented using Array, Structures, Linked List,etc Basically when we implement Stack using Array we keep extra variable top to point at the top of the stack. This is static Data Structure. As it is Array at its base(Remember ADT) we can easily initialize array to Null or Zero. In 'C' int array[MAX]={0} or you can use 'memset' for initializing a section of memory to some value int array[5]; memset(array, 0 , sizeof array); In C++, you can use an empty initializer list, causing the compiler to aggregate initialize all of the elements of the array: int array[100] = {}; As it is pretty simple using array, the same is opposite using structure, which we use to implement stack generally. Below is General method we use to declare structure of a stack and then we create a object of it; #define MAX 10 struct stack{ int data[MAX]; int top; }; struct stack s /*Here 's' is an object of struct stack*/   Basically as per C standards we can't Initialize members inside a structure so If you are going to do this : /*This is not allowed: Error*/ struct s { int i[MAX]={}; }; There is other way around ,If you want to initialize an instance. struct stack{ int data[MAX]; int top; } struct stack s = {{0},-1} or you can use Designated initializers(C99) struct stack{ int data[MAX]; int top; }s={.data = {0}}; But the above was particularly for an instance of stack, and 'Top' will also be set to 0(zero), you can do [code]{.data = {0}, .top = -1} , but it will be still for particular instance; if you have 100 objects then what? The above won't work won't work; to Initialize an array of stack to NULL, you can do the following: (The dirty Method and Lot of anomalies) typedef struct stack{ int data[MAX]; int top; }stack;   int main(){ ....   stack arr[100] = {{.data = {0}}} /*This will also set top to 0(zero)*/   ....   }   or you can do this : int main(){ ....   stack arr[100] = {{.data = {0}, .top = -1}} /*This will also set top of arr[0] to -1*/ /*The above will only set top of arr[0] to -1 other top in other array will be set to -1*/ /*This happens due to GCC standards: Basically, you have to open a new level of nested {} every time you "enter" another nested aggregate (a struct or an array). */   ....   }   As you see Initializing a stack to NULL is not an easy way and contains lot of overhead along with different anomalies. so letting stack variables contain garbage values is easy and friendly, secondly As Robert Love said : "It is undefined in most languages to read variables before they are assigned values." and we don't read variables in stack before they are assigned and we use 'TOP' to point at the Top of stack along with keeping track of variables which are assigned. P.S: I am still learning C/C++ and haven't implemented stack in other languages so, can't comment with respect to that and may be it easier to initialize stack in other languages. Thank You!!! 