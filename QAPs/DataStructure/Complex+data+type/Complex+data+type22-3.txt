What is C++ good at that cannot be achieved in Java?Follow up question: What are the types of applications that can be built in C++ but not in Java?
I spent about a dozen years in C++. Much of it was spent wishing I were programming in Java. But near the end, I developed techniques that I grew to depend on, and which are very difficult, if not impossible, to do in Java. Here are two: 1. Compile time const correctness. Java's reference-heavy architecture and lack of a const keyword make it difficult or impossible to express const-ness constraints. In C++, const is a great tool for conveying the intent of a function, i.e. void f(const Foo& foo) is a function that is contractually bound to use the foo object without modifying its state. The same rules can be applied to const member functions, i.e. "void f() const {}" as a member function conveys that f() will not logically change the enclosing class state. Now, like most C++ features, this can be abused with casting, and furthermore, even without abusive cases, the exact semantics of "const-ness" cannot be known except by convention. But in my case, I adhered to the "const references are guaranteed *logically* const, if not bitwise const, and as thread safe as immutable". In other words, if I declare a member function const, that function will not change the object's external state, but it may fiddle with bits internally. If it does modify the physical state, it will do so without affecting external state and (in a threaded environment) will preserve the typical multiple-reader-or-single-writer thread semantic. The latter case is typically useful for stuff like lazy initialization and reference counting, where bits change but the logical state remains the same; and such logically-const-but-physically-mutable cases must be properly synchronized. If you are diligent about declaring const-ness in your design, the compiler will catch subtle state errors for you. E.g., try to modify a member from a const member function, and you will get compile time errors. This is especially useful in multithreaded settings, where it is particularly important to know when an object will be modified (and would therefore require synchronization in a multithreaded client). In effect, the const keyword in C++ effectively allows for every class to have a dual interface, and can help prevent state creep, where objects are mutated as side effects when passed to a function (or, when data members are returned). To achieve compile-time const safety in a language like Java, the best you can do is create multiple interfaces for each class, i.e.: interface Foo {      //readonly members } interface MutableFoo extends Foo {     //read write members } Clumsy at best. 2. Complex value types and mutable value types -- Java did away with copy constructors, destructors, and even structure types and operator overloading, which means that emulating complex value types is difficult, especially mutable values. The language itself struggles with this in its String.equals() confusion: String is a value type but a == b is not guaranteed to succeed for equivalent strings (at least not in old versions of Java -- it may be different today). This reveals the weakness of an almost-pure reference approach. In C++, strings act in almost every way like a mutable value type, meaning aliasing (multiple referencing) of C++ strings happens only when you explicitly ask for it (i.e. using a pointer or reference to a string). In Java, aliasing is the *default*. This is also why Java String instances are immutable: because they realized early on that making a String mutable would cause aliasing nightmares. But there are complex types beyond String that would benefit from value semantics. For example, a coordinate Point class is usually thought of as a value, but in Java it has to be implemented as a reference. So if you want your point class to express mutable value semantics (i.e. it can change, but it's copied by default in function calls and assignments), you have to litter your code with point.clone(), which is clumsy and error prone. The alternative is to make all values immutable (the functional language approach), which solves the problem, but you have to emulate mutability with copies of the object (i.e. instead of the object-like "point.setX(1)", you have to write your code in the more functional "point = point.withX(1)"). Clumsy at best. There are other things I miss about C++ (i.e. object lifetime determinism), but these are the biggest for me. 