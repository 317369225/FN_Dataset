Why do complex data types compare by the address of their location while primitive types compare by their actual values?Why don't complex data types compare their values by default instead of having to invoke equals()?
It's a reason that Java, by hiding its pointers, doesn't really make clear to the person who just learns Java. It's mostly historical. It dates long before O-O programming, to the earliest LISP systems. LISP was traditionally data- or dynamic-typed. An S-expression, or SEXPR, could be any value. It could be an integer, or an atom, or a floating-point number, or a list, or a string, or an array. For every primitive type, the value was just stored in the word. This was a bit annoying, as you lost a couple of bits from your value, but it worked well enough. Simple comparisons for integers and identity used eq. There were a variety of other comparisons, using such functions as eql and equals (depending on the implementations) to do deep comparisons of lists for isomorphism. The machines they ran on were ridiculously slow, so a culture evolved to use eq as often as possible. In the mean time, C was gearing up to become useful. As a statically typed language, == was only used to compare the bits in the value. C had explicit pointers, and there was no mechanism for doing deep comparison. Most O-O languages, including Java, have historical roots to both. So the default for == is C-like or eq-like comparison. That's considered more basic and faster, so it's put in the syntax, even though modern computers are much more powerful. It is, of course, a different kind of equality (identity versus structure), and so a developer has to use both. But the default, and so in Java what is syntactic, is generally chosen to be what is considered the more basic. Some languages have tried other things. PHP, for example, has ===, which is more basic than ==, but this causes a lot of people to swear a lot. 