What is the best key-value store for generic usage?
First, there's a one big point I'd add to your assessment: Redis replication is not really in beta. The clustering support is currently in beta, but you can still run multiple redis hosts in a master-slave model and it should work fine for most use cases. We currently use both Redis and Riak in production and so hopefully I can help shed some light on when to use each on its own and when to use them together. To start with some major differences: Redis operates on data stored in memory, not on disk. It also deliberately uses a set of data structures such that you will rarely, unless you go out of your way to do it, perform an action that has a worst case time complexity greater than linear time. This allows for extremely fast operations over data stored in high level structures such as sets, hashes, lists, and sorted sets. However, because the server operates on data in memory you are limited in the amount of data you can reasonably store. Additionally, you risk losing some data in the event of a server outage. It is entirely possible to configure Redis to use a combination of an append only file and periodic dumps to disk to almost entirely avoid data loss, but at the end of the day you're still keeping all your data in memory. An often overlooked feature of Redis is its support for the execution of Lua scripts on the server, which is extremely useful for performing atomic, non trivial operations over data very quickly. Riak is a fully distributed key/value store written in Erlang that operates on data stored on disk. You have the option to choose the backend of your Riak cluster when you configure it, and this decision is hugely important to the performance and usage scenarios you hope to support. It's outside the scope of this question to dive into the differences between the backend systems Riak supports and there are plenty of good explanations on their differences on the Basho pages so I would highly recommend looking to those docs before making any decisions on whether or not to use Riak. For the rest of this answer I'm going to assume usage of the LevelDB backend, since that's the only one I've used in a production environment. Maybe somebody else with experience using the bitcask or memory backends can add some comments later. Since Riak operates on data stored primarily on disk you are not really limited in the amount of data you can store. In fact, performing complex queries against massive data sets is where Riak really shines. Optimizing your operating system to support an ideal Riak server environment is certainly more involved than setting up a Redis server, but depending on your hosting environment you may be able to avoid many of the hassles. AWS, for example, offers linux AMIs created by Basho that come with many of the OS level changes necessary to support general purpose Riak usage. However, I will say that setting up a production Riak cluster is several orders of magnitude more involved than setting up a set of Redis servers. Additionally, out of the box Riak supports Map/Reduce operations across the cluster. This is hugely useful for non trivial queries over massive data sets and you have the option to write your Map/Reduce operations in Erlang or JavaScript. If you use the LevelDB backend Riak also supports secondary indexes on your data. It also offers support for full text indexes via Solr indexes. The combination of secondary indexes, full text search, and Map/Reduce allows for pretty much any type of query over your data... except set operations. If you're coming from an RDBMS background you might be surprised to learn that doing a simple "select * from whatever where a = 'foo' and b = 'bar'" is actually not possible in a single query with Riak, unless you do the set intersection operations in your Map/Reduce operation. Additionally, querying against the secondary indexes will only return the keys of the values you need, and not the values themselves, unless you adapt the query to use Map/Reduce. However, this leads to another use case: a combination of Redis and Riak. To perform the above SQL query you need to perform one query against the secondary indexes for a = 'foo' and a second query against the secondary indexes for b = 'bar'. You'd then need to do a set intersection on the two key sets returned and feed the resulting set to a Map/Reduce operation to fetch the associated values. This may sound complex, because it is, but if you offload the generic set operations to Redis it is possible to create a more robust high level query interface on top of Riak that allows for an almost SQL-like API surface over your data, but with the added benefits of a fully distributed backend cluster, Map/Reduce, etc. Another huge difference between the two is the cost of hosting and maintaining each option. Riak is expensive to do right. Our current cluster is on 6 large EC2 CentOS VMs, and you can estimate the monthly cost from that. A minimal cluster configuration might be 5 medium VMs, but even that is pushing it. If you look at those resources and think "there's no way I need that much power" then you very likely don't need Riak at all and should consider a different key/value store. Despite the relatively high cost of memory space compared to disk space Redis still costs nowhere near the amount of time and money necessary to support a non trivial Riak cluster. Finally, I'd add that these two data stores are designed to support radically different use cases. I can't really think of a scenario in which their features would compete with each other. Riak is designed to support arbitrarily complex queries over massive, massive, long living data sets. Redis is designed for highly optimized queries on top of a select set of data structures over a data set capable of fitting entirely in memory. There's a ton of middle ground between the two and there are certainly key/value stores that fit somewhere between the two use cases Riak and Redis are designed to support. I would highly recommend looking into those options if these two extreme cases don't fit into your usage scenario. 