How can we create MySQL shards?
Relational database technology is showing its age and just can’t meet today’s requirements: a massive number of operations per second, a lot of open connections, huge amounts of data and a very high write ratio. As a result, almost every large website and SaaS solution uses sharding when writing to its relational database. How do you shard your application? The flow is actually quite simple, and consists of just four steps: 1.    Analyze your schema to find the best sharding configuration 2.    Start multiple database instances 3.    Split the data between the databases according to the sharding configuration 4.    Update your application code to support your sharding configuration Required Data To build a sharding configuration, you’ll need the following data: 1.    Table list and size – Big tables are great candidates for sharding, since many SQL commands are usually executed on them. 2.    List of foreign keys – Foreign keys can help you understand dependencies between tables. Tables that depend on one another must be divided in an intelligent way, otherwise, your data integrity will be lost. 3.    SQL query log – Some SQL operations are incredibly difficult to implement in a sharded environment, so you need the SQL log to understand whether you can implement sharding on some tables. The SQL log can also give a good indication of which tables are accessed heavily and which are not.   This section assumes that the database is well-defined and already contains data, which is the easiest course of action. If you have a new database and you’re not sure how many rows each table will contain, or what the SQL query log will show, you’ll have to make an educated guess. Table Policies Before you begin to implement sharding, it’s important to understand that not every table in the schema will be sharded. Since sharding limits your SQL capabilities (no join between sharded tables, uniqueness, auto-increment columns, etc.), you will enforce limits on your application that will be very difficult to overcome in code. Usually, only some tables will be sharded, and most tables will be replicated across all of the shards.  Deciding which Tables to Shard The algorithm for choosing which tables to shard is not a very complex one: 1.    Look at the biggest tables – Most schemas have several big tables, and the rest are very small. Table sizes are not divided evenly. 2.    Look at the SQL log – Are there joins between those tables?  a.    If yes, take the smaller table and make it a global table. b.    If not, those tables will serve as your shard environment. c.    Look at the SQL log:          i.    If the tables are not accessed frequently, make them global tables.            ii.    Look at the most accessed tables (especially those with many write commands) and mark them as sharded. Go to step 2 to make sure they can be sharded.  d.    The list of tables you get contains the best candidates for sharding.          Once you’ve decided which tables should be sharded, the choice of sharding keys is rather straightforward, as most will use the table primary key as the shard key. If multiple tables are sharded, and there is a foreign key relationship between these tables, then the foreign key will serve as the shard key for some tables.          As with database partitioning, there are multiple algorithms available for sharding: hash, list, or range. Usually you’ll use list and range for multi-tenancy, saving customer information across different databases and maybe even different data centers. Hash will probably give you the best results when it comes to sharding, as it statistically ensures that data is evenly distributed across all shards. What’s Next? If you have a new application, you can skip the next section and just wait for the next article. However, if you have an existing database, you’re stuck with huge amounts of data that you need to split. 1.    Have the database cloned in all shards – It can be done by cloning a VM, copying the physical files, or using mysqldump to export once and import to all shards. 2.    For each shard (on shard tables only): a.    Drop all indexes. b.    Delete the irrelevant data from the shard (by an automatic script). Note: This action creates a lot of fragmentation. You might consider creating a temporary table, inserting to it only the relevant rows, drop the original table and rename the temporary one to the real name. c.    Create all indexes. 