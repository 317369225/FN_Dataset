What is an algorithm to find a longest path in a unweighted directed acyclic graph?
Roman Dzhabarov is correct that we could apply the recurrence: dist(to_node) = max{dist(from_node) + 1} (For each directed edge from from_node to to_node) And then pick the maximum possible value from dist as the answer. However, just a note regarding implementation: If you do it top-down with memoization, there is actually no need to explicitly compute a topological sorting. For example, in Python, you may write something like this: memo = {}def get_longest(to_node):    if to_node in memo:        return memo[to_node]    best = 0    for from_node in from_nodes[to_node]:        best = max(best, get_longest(from_node) + 1)    memo[to_node] = best    return bestlength, node = max([(get_longest(to_node), to_node) for to_node in all_nodes])print 'Length of a longest path: length = %d, ending at %s' % (length, node) By adding some code in the for loop inside get_longest, you could easily backtrack to find one (or even all) longest path. 