Can the shortest path problem for cyclic graphs be solved by BFS, and WHY?
Yes it can, even the simplest implementation of BFS will work. It is easiest to see for this algorithm: BFS(start, end) {  List current = [start]  List next = []  while (true) {    for (Vertex v in current) {      if (v == end) { return } // path found!      next.addAll(v.neighbours())    }    current = next;    next = []  }} The list 'current' is initialised with a set of vertices that you can reach in 0 steps, which is the starting point. Every iteration, we go over 'current' and we make a new list 'next' that contains the direct neighbours of all vertices in current. Note that these neighbours must include all vertices that can be reached in 1 steps. Some vertices may appear in the list multiple times, but we don't even care about that, that will make the algorithm slower but it will still work. The list may also contain the starting vertex, but again, we don't care. As long as all the vertices that can be reachable in 1 step are in there. After the second iteration, the list contains all vertices that are reachable in 2 steps. And so on. If there are cycles, that means that vertices may get added to the list that were reached before. However that does not matter, these vertices do not help find the solution but they don't really get in the way either. If you understand why this algorithm works, then the next step is to simply concatenate the current and next lists, by using a queue. The algorithm will still do exactly the same: BFS(start, end) {  Queue Q = [start]  while (!Q.empty()) {    Vertex v = Q.shift()    if (v == end) { return } // path found!    next.addAll(v.neighbours())  }} So the Q in the code above is really the concatenation of the lists current and next. 