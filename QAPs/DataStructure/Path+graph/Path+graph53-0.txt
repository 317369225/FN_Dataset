What is the number of possible paths from a node [math]u[/math] to a node [math]v[/math] of length [math]k[/math] in an non-directed, un-weighted graph?
Dynamic programming: Let [math]N(s, h)[/math] be the number of paths of length [math]h[/math] from [math]u[/math] to the vertex [math]s[/math].  If we find [math]N(v, k)[/math], we'll have the answer. Observe that we can only reach the vertex [math]s[/math] if the second-to-last vertex on the path is one of its neighbors [math]t[/math], and to do this in [math]h[/math] steps, the path from [math]u[/math] to [math]t[/math] must have length [math]h - 1[/math].  There are [math]N(t, h - 1)[/math] ways to get to node [math]t[/math] in that many steps.  So we can write [math]N(s, h) = \sum_{t \in \mbox{neighbors}(s)} N(t, h - 1)[/math] Now in theory, we could find [math]N(v, k)[/math] recursively, by evaluating the function [math]N[/math] for each of [math]v[/math]'s neighbors, then evaluating it for each of its neighbors' neighbors, etc.  But this wastes a lot of effort, since recursive function calls may repeat work done by other function calls.  We'd like to save the results of "smaller" function calls, so we can look them up without having to redo the computation. One way to do this is by creating a table containing [math]N(s, h)[/math] for each vertex [math]s[/math] and each [math]h[/math] between [math]0[/math] and [math]k[/math].  Since column [math]h[/math] of the table only depends on entries in column [math]h - 1[/math], we can populate the entire table by first filling in the entries of column [math]0[/math], then using those to populate column [math]1[/math], until we get to column [math]k[/math] and can read off the value of [math]N(v, k)[/math], solving the problem. (There's only one way to get from vertex [math]u[/math] to itself in [math]0[/math] moves, and no way to get from [math]u[/math] to any other vertex, so column [math]0[/math] is entirely populated by 0's except for [math]N(u, 0) = 1[/math].) How long does this take? Finding the answers in one column takes [math]\Theta(|E| + |V|)[/math] time, because each vertex is looked at once, and each edge is looked at twice.  Since we look at [math]k[/math] columns, the procedure should run in [math]\Theta(k(|E| + |V|))[/math]. Except that the edges are given in the form of an adjacency matrix, which means we can't find the neighbors of a node without looking through a bunch of nodes that are not its neighbors.  In order to scan through the edges efficiently, we have to take [math]\Theta(|V|^2)[/math] time to rewrite the matrix as an adjacency list, which brings the runtime up to [math]\Theta(|V|^2 + k(|E| + |V|))[/math].  In the worst case, [math]|E| = \Theta(|V|)^2[/math], and this runs in [math]\Theta(k|V|^2)[/math]. You can also solve this problem by repeatedly squaring the adjacency matrix (as in Raziman's answer).  This would take [math]O(|V|^{\omega} \log k)[/math], where [math]|V|^{\omega}[/math] is (sort of) the time complexity of matrix multiplication.  ([math]\omega[/math] can't be less than [math]2[/math], and in a programming contest you would probably use an algorithm that multiplied matrices in [math]\Theta(|V|^3)[/math] ). Which algorithm is better depends on your values of [math]|E|[/math] and [math]k[/math]. 