How do I get the shortest path from the bottom to the top of a graph?
We can reduce this problem to the problem of finding the shortest path from a singleÂ  source vertex to a single target vertex. We can do this by adding a fake source vertex to the graph with edges to all the actual source vertices and adding a fake target vertex with edges to all the actual target vertices. Then perform Dijkstra's algorithm on the resulting graph. The below Python script finds the shortest path from the bottom to the top of the graph for any directed, weighted graph (your provided example is undirected and unweighted). This is what it outputs for your example problem (assuming that going right is increasing the first coordinate and going up is increasing the second coordinate): Shortest path (weight: 7) is: [(3, 1), (3, 2), (4, 2), (4, 3), (4, 4), (5, 4), (5, 5), (5, 6)]. import heapqdef main():    nodes = set([(1,1), (3,1),                 (1,2), (2,2), (3,2), (4,2),                 (1,3), (4,3),                 (2,4), (3,4), (4,4), (5,4),                 (2,5), (5,5),                 (2,6), (5,6)])    breadth = 6    pathWeight, shortestPath = getShortestPathBottomToTop(nodes, breadth)    if pathWeight == None:        print "No path across river."    else:        print "Shortest path (weight: " + \            str(pathWeight) + ") is: " + str(shortestPath) + "."## Return the shortest path from bottom to top given the rocks as# "nodes" and the "breadth" of the river.#def getShortestPathBottomToTop(nodes, breadth):    (sourceNodes, targetNodes) = getSourceTargetNodes(nodes, breadth)    if sourceNodes == None:        return (None, None)    nodeToEdges = createGraph(nodes)    newSourceNode = "fakeSource"    newTargetNode = "fakeTarget"    addFakeSourceTargetNodes(newSourceNode,                             newTargetNode,                             sourceNodes,                             targetNodes,                             nodeToEdges)    nodeToDistance = dict()    for node in nodeToEdges:        if node == newSourceNode:            nodeToDistance[node] = 0        else:            nodeToDistance[node] = float("inf")    heap = [newSourceNode]    nodeToPreviousNode = dict()    while len(heap) != 0:        currentNode = heapq.heappop(heap)        for neighborNode in nodeToEdges[currentNode]:            if neighborNode not in nodeToPreviousNode:                heapq.heappush(heap, neighborNode)            currentDistance = nodeToDistance[currentNode] + \                nodeToEdges[currentNode][neighborNode]            if currentDistance < nodeToDistance[neighborNode]:                nodeToDistance[neighborNode] = currentDistance                nodeToPreviousNode[neighborNode] = currentNode    currentNode = newTargetNode    distance = nodeToDistance[currentNode]    if distance == float("inf"):        return (None, None)    toReturn = list()    while currentNode not in sourceNodes:        currentNode = nodeToPreviousNode[currentNode]        toReturn.insert(0, currentNode)    return (distance, toReturn)## Given the "nodes" (rocks) and "breadth" of the river,# return the source nodes at the bottom of the graph# and the target nodes at the top of the graph.#def getSourceTargetNodes(nodes, breadth):    minYCoordinate = None    maxYCoordinate = None    for node in nodes:        yCoordinate = node[1]        if minYCoordinate == None or yCoordinate < minYCoordinate:            minYCoordinate = yCoordinate        if maxYCoordinate == None or yCoordinate > maxYCoordinate:            maxYCoordinate = yCoordinate    if maxYCoordinate - minYCoordinate != breadth:        return (None, None)    sourceNodes = set()    targetNodes = set()    for node in nodes:        yCoordinate = node[1]        if yCoordinate == minYCoordinate:            sourceNodes.add(node)        if yCoordinate == maxYCoordinate:            targetNodes.add(node)    return (sourceNodes, targetNodes)## Make a link from the "newSourceNode" to all the "sourceNodes"# and a link from the "newTargetNode" to all the "targetNodes".# The data structure that will be modified is "nodeToEdges".#def addFakeSourceTargetNodes(newSourceNode,                             newTargetNode,                             sourceNodes,                             targetNodes,                             nodeToEdges):    nodeToEdges[newSourceNode] = dict()    for sourceNode in sourceNodes:        nodeToEdges[newSourceNode][sourceNode] = 0        nodeToEdges[sourceNode][newSourceNode] = float("inf")    nodeToEdges[newTargetNode] = dict()    for targetNode in targetNodes:        nodeToEdges[newTargetNode][targetNode] = float("inf")        nodeToEdges[targetNode][newTargetNode] = 0## Given "nodes" in the graph, return a map "nodeToEdges".#def createGraph(nodes):    nodeToEdges = dict()    for node in nodes:        xCoordinate = node[0]        yCoordinate = node[1]        for moveHorizontal in range(-1, 2):            for moveVertical in range(-1, 2):                if abs(moveHorizontal + moveVertical) != 1:                    continue                adjacentNode = (xCoordinate + moveHorizontal,                                yCoordinate + moveVertical)                if adjacentNode in nodes:                    if node not in nodeToEdges:                        nodeToEdges[node] = dict()                    nodeToEdges[node][adjacentNode] = 1                    if adjacentNode not in nodeToEdges:                        nodeToEdges[adjacentNode] = dict()                    nodeToEdges[adjacentNode][node] = 1    return nodeToEdgesif __name__ == '__main__':    main() 