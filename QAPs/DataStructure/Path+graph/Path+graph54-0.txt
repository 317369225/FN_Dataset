If multiple shortest paths exists between 2 nodes in an undirected graph, is it possible to print all of them using Dijkstra's algorithm?
Yes, but with some adjustments to the algorithm. Dijkstra's algorithm finds the shortest path from the starting point to the ending point. For simplicity, let us say that the graph is a lattice of [math]M[/math] by [math]N[/math] nodes, with non-negative weighted edges between adjacent nodes, and the goal is to find the shortest path between the point [math](0,0)[/math] and [math](M, N)[/math] by traversing the edges. Let me first quote Dijkstra's algorithm [1] Assign to every node a tentative distance value: set it to zero for our initial node and to infinity for all other nodes. Mark all nodes unvisited. Set the initial node as current. Create a set of the unvisited nodes called the unvisited set consisting of all the nodes except the initial node. For the current node, consider all of its unvisited neighbors and calculate their tentative distances. For example, if the current node A is marked with a tentative distance of 6, and the edge connecting it with a neighbor B has length 2, then the distance to B (through A) will be 6+2=8. If this distance is less than the previously recorded tentative distance of B, then overwrite that distance. Even though a neighbor has been examined, it is not marked as "visited" at this time, and it remains in the unvisited set. When we are done considering all of the neighbors of the current node, mark the current node as visited and remove it from the unvisited set. If the destination node has been marked visited (when planning a route between two specific nodes) or if the smallest tentative distance among the nodes in the unvisited set is infinity (when planning a complete traversal), then stop. The algorithm has finished. Set the unvisited node marked with the smallest tentative distance as the next "current node" and go back to step 3. Suppose we store the cost of the shortest path to each node in an array [math]s[i][j][/math]. That is, we want to find the value of [math]s[M][N][/math]. In the original Dijkstra's algorithm, this value of shortest path to each point [math](i, j)[/math] is independent of the direction where it came from. In order to print out the shortest path between the starting and ending point, we need to store the information about the direction where it came from. That is, we need to add a new dimension to the array [math]s[i][j][/math], and make it [math]s[i][j][k][/math]. In this case, since each node has 4 neighbors, [math]k[/math] has 4 distinct values, say, [math]{0,1,2,3}[/math]. Thus, we store not only the lowest cost of arriving at that node [math](i,j)[/math], but we also the direction where it came from. (For instance, k = 0 means from above, k = 1 means from the right, k = 2 means from the left, k = 3 means from below). That is, at step 3, when finding the tentative distance to each neighbor, we will need to store it in the appropriate k for each of its neighbor. Then, when original Dijkstra's algorithm ends, this is when we retrieve the path information. We will need to backtrack from the point [math](M, N)[/math] recursively, looking at where is the direction which gave the smallest cost of reaching that node. We can do either a breadth first search or depth first search in order to achieve this. Once we hit [math](0,0)[/math] in the search, we know that we have a path that gives the shortest path, and we can print it out. We continue to do this until all the possible shortest paths have been backtracked. There are a few points to take note when coding this algorithm: The cost comparison at step 4 of Dijkstra's algorithm is more complicated. Instead of looking at [math]s[i][j][/math] for unvisited nodes, we need to look at the minimum for all the k's in [math]s[i][j][k][/math] in unvisited nodes. If, while exploring the tentative costs of reaching adjacent nodes of the current node, we find another way to reach a particular visited node, with the same cost as what it already has, then the cost matrix [math]s[i][j][k][/math] has to be changed to reflect that. That is, we have to make changes to the directions where we can reach a particular node, even if it is already visited. At the end of the original Dijkstra's algorithm, care must be taken not to terminate before ensuring that there are no further paths that produce the same cost as the shortest path to the node [math](M, N)[/math]. That is, [math]s[i][j][k][/math] for all the unvisited nodes must be larger than that of the minimum (for all the k's) for all the visited nodes. This algorithm can be easily generalized to an arbitrary graph. Suppose there are now P nodes in the whole graph. In this case, it might be easier to make an array [math]s[p][q][/math], where p refers to the node in the graph, and q refers to the node where the shortest path came from, and p and q run from 0 to P-1. The algorithm will then proceed similarly as described above. [1] Dijkstra's algorithm 