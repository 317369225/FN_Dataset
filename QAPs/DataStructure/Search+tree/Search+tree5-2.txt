How can you find successors and predecessors in a binary search tree in order?
node* nextInorderSuccessor(node* root, node* tofind) {	if (!root || !tofind) return;	//if a node has right child	//loop to the left most child (of the right child)	//if none, return right child	//if no right child (2 situations):	//if current node is left child of parent: return parent (parent is NULL for root)	//else if right child return grandparent    node* successor = NULL;	if (tofind->right){		successor = tofind->right;		while (successor->left) {			successor = successor->left;		}	}	else {		//this is a modified find on the "tofind" node		//where when the node to be found is smaller than		//it's parent node, the successor pointer is 		//updated to point to the parent		while (root) {			if (tofind->data < root->data) {				successor = root;				root = root->left;			}			else if (tofind->data > root->data) {				root = root->right;			}			else {				break;			}		}	}    return successor;} Reverse the logic for finding predecessor. 