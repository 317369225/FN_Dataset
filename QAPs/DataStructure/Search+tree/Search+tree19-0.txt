Are these two find methods for a binary search tree correct?
TYPE 2 is correct. TYPE 1 ANALYSIS: I'd first like to point out that your null check in Type 1 isn't incorrect, but its unnecessary. Node current = root; if(root == null){     return false;   } Since you first assign the value of root to Node current, you will never even enter the while loop if root was null.  Therefore, the "root==null" case will result in skipping the while loop and just returning false.  This means the null check is redundant/unnecessary. The conditional statement of your while loop "while(current != null)" is great.  Now let's consider the possibilities of how any "current" node you're inspecting in the while loop could compare to the value you're trying to find.  Clearly there are 3 possibilities: >, <, =.  Thus, the body of your while loop should match current.key with exactly ONE of these possibilities.  Instead, your code automatically assumes > if it's not <.  It then checks for equality.  What's the problem with this?  Consider what would happen if your root contained the value you were looking for.  Upon entering the while loop for the first time, you would execute the code in your else statement (current = current.left;) because the root does not fit the if conditional (current.key < key).  Now you just skipped to current.left, but current contained the value you were looking for!  Whoops Correct code inside your while loop would look like this: if(current.key < key){       current = current.right; } else if(current.key > key){       current = current.left; } else{       return false; } 