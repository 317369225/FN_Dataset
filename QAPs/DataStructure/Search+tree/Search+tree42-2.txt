How can we verify that a binary tree is a binary search tree in linear time and constant space?
You can solve this problem in O(n) time by using recursion. Here is the algorithm: In a BST, the root is greater than all nodes of the left sub tree. So root value forms an upper bound on left sub tree values. Similarly,  since the root is less than all the nodes of the right sub tree, root  value forms a lower bound on the right sub tree values. This can be used for checking if a binary tree is a binary search tree or not. 1. Initialize, low = MAX_VALUE, high = MIN_VALUE. 2. If root.data <= low || root.data >= high, return false. 3. Recursively check for left sub tree and right sub tree.    a. For left sub tree, pass high as root.data because for a BST, root forms an upper bound for left sub tree node values.    b. For right sub tree, pass low as root.data because for a BST, root forms a lower bound for right sub tree node values. Time complexity: O(n)     public boolean isBinarySearchTree() {        return isBinarySearchTree(root, Integer.MIN_VALUE, Integer.MAX_VALUE);    }     private boolean isBinarySearchTree(Node root, int low, int high) {        if(root == null) {            return true;        }        if(root.data <= low || root.data >= high) {            return false;        }        return isBinarySearchTree(root.left, low, root.data) &&               isBinarySearchTree(root.right, root.data, high);    } Source: Check if a binary tree is a binary search tree The algorithm visualization in the above link is very cool. Hope this helps. 