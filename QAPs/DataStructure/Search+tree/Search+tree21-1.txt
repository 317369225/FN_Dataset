What's the best analogy to explain binary search trees to a layman?
I have a random number, in the range of 1 to 25. You try to determine what's my number in the least number of guesses. Whenever you take a guess, I'll tell you if my number is higher or lower. The trick is always pick the number half way between the possible range. Example my number is 5. (0th step) 13 - lower (1th step) 6 - lower (2th step) 3 - higher (3rd step) 4 - higher (4th step) 5 - correct! Through this method, the maximum amount of steps you need to take to get to the answer is given by RoundDown( Log2(N) ). In this case N is 25 so Log2(25) = 4.64, rounding down gives 4 steps maximum. Given the Log function, the efficiency of this algorithm increases as N gets larger. Log2(1000) = 9.97 Log2(10000) = 13.29 (only 13 guesses needed to guess the correct answer!) Binary Search Trees works off the same logic, nodes are arranged such that smaller nodes are always to the left of the current node. Here we have a BST of with 15 nodes. Looking for 5; 5 < 8 go left 5 > 4 go right 5 < 6 go left Of course, this works for not just numbers, anything that can be sorted can be represented this way. 