Given a stream of n integers between 1 and n find one number that repeats in linear time using less than O(n) space and traversing the stream sequentially O(1) times?
Assuming that you consider an array to be a stream and that you have a loose definition of the word "sequentially," here we go: Explanation: Since we can't use [math]\Theta(n)[/math] additional space, I will explore the idea of using a constant amount of additional space since that will be probably lead to the least complicated solution.  If we're going to solve this problem with a constant amount of additional space, then we're going to need to "encode" all key information into the original input array itself.  One way to determine if numbers repeat in a list is to sort the list and check for duplicate values beside each other.  Suppose we could sort our array of numbers in-place in [math]O(n)[/math] time.  Then we could do one more [math]O(n)[/math] iteration over the numbers to verify that two consecutive numbers are not the same.  Typically, we would use something like Counting Sort to sort in [math]\Theta(n)[/math] time, but that has [math]\Theta(n)[/math] space complexity as well. Therefore, let's look at what we know about our data.  We know that it lies in the range [math]1 \le x \le n[/math].  We also know that if there are no repeats, then our numbers, when sorted, will make up the exact range of numbers from [math]1[/math] to [math]n[/math].  Suppose we know that there are no repeats.  How could we sort the array?  Simple: we could iterate over each number, [math]i[/math], in the array, and place it at index, [math]i - 1[/math].  So if we were at number [math]5[/math], we would put it at index [math]4[/math] (assuming indices start at 0).  Now, what happens if we try the same thing when there are duplicates in our array?  Then whenever we get to a duplicate number, the same number will already be in the expected index.  So what if we were to calculate the expected index for each number and place it there.  If a duplicate already occupies the slot we are trying to place the number into, then we have found a duplicate number!  If we can sort all of the numbers without placing two numbers into the same slot, then we know that there are no duplicates. I wrote some code below that implements the algorithm I described above.  Here's a brief overview: First, it checks for edge cases.  Then, it checks that every value in the input array is within the range [math]1 \le x \le n[/math].  It does this check with one [math]O(n)[/math] pass over the array. Then, we have an outer loop and an inner loop.  Clearly, the outer loop executes [math]O(n)[/math] times.  I will show that the inner loop executes [math]O(n)[/math] times across the entire outer loop's execution.  In order words, the inner/outer loop combination executes in [math]O(2n)[/math] time, which is [math]O(n)[/math] time. So... the outer loop iterates over every index, [math]i[/math], in the array.  The inner loop repeatedly moves the value at index [math]i[/math] to it's theoretical sorted index, [math]j[/math].  The inner loop stops when the theoretical index, [math]j[/math], for the value at index [math]i[/math] is [math]i[/math] (i.e., whenever the number at index [math]i[/math] is already at its theoretical sorted index).  Whenever we move the number at index [math]i[/math] to its theoretical index [math]j[/math], we swap it for whatever number was previously at index [math]j[/math].  However, if the number previously at index [math]j[/math] is the same as the number at index [math]i[/math], then we know we have a duplicate number, and we can return that number.  If not, then we can make at most [math]n[/math] swaps without repeats across the entire execution of the outer loop.  The reason being this: with every swap made by an iteration of the inner loop, one additional number gets placed into its sorted position.  We cannot place more than [math]n[/math] numbers into sorted order.  Therefore, the inner loop cannot execute more than [math]O(n)[/math] times across the execution of the outer loop. This solution uses [math]O(1)[/math] additional space.  It runs in [math]O(n)[/math] time, which means that it traverses the entire stream [math]O(1)[/math] times (it traverses the stream no more than 3 times). Code: public class RepeatingNumberIn1ToN {    public static void main(String[] args) {        test(new int[] { 5, 1, 3, 4, 1 });        test(new int[] { 5, 5, 4, 4, 3 });        test(new int[] { 4, 5, 4, 3, 5 });        test(new int[] { 1, 1, 1, 1, 1 });        test(new int[] { 1, 2, 3, 4, 5 });        test(new int[] { 5, 4, 3, 2, 1 });        test(new int[] { 3, 2, 4, 5, 1 });        test(new int[] { 2 });        test(new int[] {});        test(null);    }    public static Integer repeatingNumberIn1ToN(int[] list) {        if (list == null) {            return null;        }        final int MIN = 1;        final int N = list.length;        if (N <= 1) {            return null;        }        for (int i = 0; i < N; i++) {            if (list[i] < MIN || list[i] > N) {                return null;            }        }        for (int i = 0; i < N; i++) {            int temp = list[i];            int j = temp - MIN;            while (i != j) {                if (temp == list[j]) {                    return temp;                }                list[i] = list[j];                list[j] = temp;                temp = list[i];                j = temp - MIN;            }        }        return null;    }    public static void test(int[] list) {        printList(list);        Integer repeatingNum = repeatingNumberIn1ToN(list);        if (repeatingNum != null) {            System.out.println(" => The number " + repeatingNum + " repeats.");        } else {            System.out.println(" => No numbers repeat.");        }    }    public static void printList(int[] list) {        if (list == null) {            System.out.print("(null)");            return;        }        final int N = list.length;        System.out.print("[ ");        for (int i = 0; i < N; i++) {            String next = (i == N - 1) ? " " : ", ";            System.out.print(list[i] + next);        }        System.out.print("]");    }} Output: [ 5, 1, 3, 4, 1 ] => The number 1 repeats.[ 5, 5, 4, 4, 3 ] => The number 4 repeats.[ 4, 5, 4, 3, 5 ] => The number 4 repeats.[ 1, 1, 1, 1, 1 ] => The number 1 repeats.[ 1, 2, 3, 4, 5 ] => No numbers repeat.[ 5, 4, 3, 2, 1 ] => No numbers repeat.[ 3, 2, 4, 5, 1 ] => No numbers repeat.[ 2 ] => No numbers repeat.[ ] => No numbers repeat.(null) => No numbers repeat. Updated 117w ago • View Upvotes