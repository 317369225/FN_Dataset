What log-structured/journaling key-value stores are there?
Do you mean at individual data store layer (e.g., just the store), or full system (a full distributed system)? At the individual data store layer: BerkeleyDB Java Edition is a log structured B+Tree (uses both copying and threading, copying triggered by a utilization ratio). Might be an over-kill for "key/value" (it's fully ACID compliant), but it's fast and allows the transactional guarantees to be turned off. http://www.oracle.com/technetwor... It's the most commonly used storage engine for Project Voldemort and (in that configuration, with full disk persistance) easily capable of 10,000-20,000 queries/second when hot portion of the data fits into memory. It can handle a data-to-memory ratio of 5x-10x fairly gracefully (unlike some other stores, which tend to immediately degrade upon hitting disk). Only issue I'd keep an eye out for is garbage collection and competition with the operating system page cache. In production, we've been using an 18gb JVM heap with 10gb of it going to BDB cache. This is with the CMS (Concurrent Mark and Sweep) collector. Experimentally, I've been able to use BerkleyDB (inside Voldemort) with a 30gb heap, 20gb going to BDB cache (using CMS in 1.6_u20 and G1 with OpenJDK7). It should be possible to use JNA (no JNI needed) to make a Posix call to mlock() all of BerkeleyDB's cache in memory (avoiding the issue of page cache fighting with BerkeleyDB cache -- which, honestly, hasn't been a problem for us in production *yet*), but I haven't experimented with that so far. The BerkeleyDB JE team is *very* responsive, friendly (including to non-paying customers) and works closely with their customers (who are developers). Bitcask is effectively "log structured linear hashing" and is used by Riak (another Dynamo-like key/value store). It uses the operating system page cache rather than a built in cache, thus being friendly to garbage collection in Erlang (language that Riak is implemented in): http://bitbucket.org/basho/bitcask Krati is a similar concept to Bitcask (again, append-only linear hashing), but is implemented on the JVM and available as a storage engine for Voldemort: http://sna-projects.com/krati/ Cassandra ("key/value+" store with a BigTable data model with Dynamo distribution model) uses an implementation of LSM trees (with each Super Column Family in at least one separate file and a Bloom Filter to determine which file to look in). It may be possible to extract the LSM tree implementation out of Cassandra, but I am not familiar enough with the code base to say so. HBase is another excellent log-structured columnar store, which writes out the LSM trees onto HDFS and provides strong consistency and excellent integration into the Hadoop ecosystem. EDIT: Google has now open sourced LevelDB, an implementation of LSM trees (memtable SS/Table, modified from BigTable to be useable inside Chrome): http://code.google.com/p/leveldb/ Updated 214w ago â€¢ View Upvotes