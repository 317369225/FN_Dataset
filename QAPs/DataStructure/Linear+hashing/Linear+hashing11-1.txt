How do I implement a C-code to remove duplicate elements from an array and what will be the complexity of such an algorithm?
1. O(n ln n) Method : First sort the array using quicksort (qsort function in stdlib.h) and then traverse the array to remove duplicates. #include <stdio.h>#include <stdlib.h>#define len 10int cmpfunc (const void * a, const void * b){   return ( *(int*)a - *(int*)b );}int main(void) {	int arr[len]={4,6,5,4,3,3,5,8,2,10};	int n;	qsort(arr, len, sizeof(int), cmpfunc);	int res[len];	int k=0;	for(n=0;n<len;n++)    	printf("%d ",arr[n]);    printf("\n");    for( n = 0 ; n < len; n++ )    {    	if(k==0)    		res[k++]=arr[n];    	else    	{    		if(arr[n]==res[k-1])    			continue;    		else    			res[k++]=arr[n];    	}    }    for(n=0;n<k;n++)    	printf("%d ",res[n]);	return 0;} Code : Ideone.com 2. O (n^2) Method : void rmdup(int *array, int length){     int *current , *end = array + length - 1;    for ( current = array + 1; array < end; array++, current = array + 1 )    {         while ( current <= end )        {             if ( *current == *array )             {                 *current = *end--;            }            else            {                current++;            }        }    } } std::unique in C++ STL uses this approach. unique - C++ Reference 3. O(n^3) Method : for (i = 0; i < size; i++) {      for (j = i + 1; j < size;) {         if (arr[j] == arr[i]) {            for (k = j; k < size; k++) {               arr[k] = arr[k + 1];            }            size--;         } else            j++;      }   } Thanks for A2A Swati Setia. 