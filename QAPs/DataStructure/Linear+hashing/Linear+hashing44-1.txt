Given a stream of n integers between 1 and n find one number that repeats in linear time using less than O(n) space and traversing the stream sequentially O(1) times?
Here is my solution: 1.) Split the numbers from 1 to n in sqrt(n) ranges so that range i corresponds to [sqrt(n) * i .. sqrt(n) * (i + 1)). 2.)Do one pass through the stream of numbers and figure out how many numbers fall in each of the ranges. 3.) At least one of the ranges will contain more than sqrt(n) elements. Do another pass and process just those elements in the oversubscribed range. 4.)Using a hash table to keep frequencies, you’ll find a repeated element. 5.)This is O(sqrt(n)) memory and 2 sequential passes through the stream. [/code] class Solution {public:    int repeatedNumber(const vector<int> &V) {        if (V.size() <= 1) return -1;        int valueRange = V.size() - 1; // 1 to N when the size is N+1.        int range = sqrt(valueRange);        if (range * range < valueRange) range++;        int count[range + 1];        memset(count, 0, sizeof(count));        for (int i = 0; i < V.size(); i++) {        count[(V[i] - 1) / range]++;        }             int repeatingRange = -1;        int numRanges = ((valueRange - 1) / range) + 1;        for (int i = 0; i < numRanges && repeatingRange == -1; i++) {            if (i < numRanges - 1 || valueRange % range == 0) {                if (count[i] > range) repeatingRange = i;            } else {                if (count[i] > valueRange % range) repeatingRange = i;            }        }        if (repeatingRange == -1) return -1;        memset(count, 0, sizeof(count));        for (int i = 0; i < V.size(); i++) {            if ((V[i] - 1) / range == repeatingRange) count[(V[i] - 1) % range]++;        }        for (int i = 0; i < range; i++) {            if (count[i] > 1) {                return repeatingRange * range + i + 1;            }        }        return -1;    }}; [/code] Updated 7w ago • View Upvotes