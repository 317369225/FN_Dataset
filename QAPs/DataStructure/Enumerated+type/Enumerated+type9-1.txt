If C++ is a strongly typed language, then why does it allow these type of implicit conversions?
Strong type discipline doesn't equal monomorphic behavior. Code can and, for a useful programming language, must perform different actions given arguments of different types. The type of the expression 3.3f is strictly the type float. The type of the object a is strictly int. The behavior of copy-initialization and compound assignment is explicitly, and differently, defined for the arguments of type float, int, or, e.g. enumeration type. The second example has an error (undefined behavior): the standard explicitly states, in 5.7[expr.add]/6, "a pointer to a base class cannot be used for pointer arithmetic when the array contains objects of a derived class type"Â  (and indexed access through pointer is defined in terms of pointer arithmetic) I would say most type safety violations explicitly render the C++ programs that attempt them undefined (same goes for C to a large degree, consider something like printf("%f", 10)). The strictness of the type system is subverted by the difficulty of its enforcement, which is the trade-off we sometimes make for having zero-cost abstractions, although static analysis tools and language and library features with fewer opportunities for undefined behavior are usually available. (to counter printf, we have std::cout << 10 and a plethora of third-party type-safe I/O libraries) 