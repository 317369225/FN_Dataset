Software Engineering: What are good ways to avoid bugs while programming?
For me, there are two related ideas working together: simplicity and modularity. These two core concepts are supported by certain tools, most notably static types and functional programming. These particular tools and the whole programming philosophy are at their best in languages like Haskell. The underlying principles, however, are applicable to all programming even if it's staunchly untyped and imperative. Simplicity Simplicity is a particular idea too many people mistake for "easiness". Rich Hickey's talk "Simple Made Easy" illustrates this distinction particularly well. If you do not want to watch the talk, just remember that "simple" is not the same as "easy". Basically, simple code does not do too much. It does not have extra internal structure: things are directly related to only a handful of other things, rather than depending on everything. As much as possible, everything serves one concrete purpose. A good example of something needlessly complicated would be the C-like  x = i++—this code is both modifying i and passing its value to x, two tasks which should not be intertwined. And you just have to look at the confusion people have between ++i and i++ and the hideous morass of C's sequence point rules to see why this is a bad idea. You could make this even worse by using this inside an if or while condition, doing three things at once! While in an abstract sense simplicity is objective, in practice it's a matter of judgement and taste. I try to make sure that it's always easy to tell all of what a given bit of code is doing and that the flow of dependencies is straightforward and easy to navigate. Functional programming helps here, but more on that later. Modularity Deeply related to simplicity, modularity is the idea to separate code into self-contained, independent pieces with well-defined interfaces. These different pieces only depend on each other in clear, prescribed ways—they don't know about each others' internals. I say that simplicity and modularity are related because more modular code is simpler and simpler code is more modular. Remember how simplicity is about having a simple internal structure? Modularity is this concept reified at scale. Why does this happen? It's because complexity increases superlinearly with the number of "things" you have. I think of it as a graph where the parts of my code are nodes, and their relationships are edges. If you just let everything depend on everything else, you will obviously get a lot of edges! As a side-note, I'm starting to really like GraphViz! On the other hand, if you manage to break this into two pieces and restrict the way parts depend between the pieces, you can reduce the complexity significantly while still keeping all the same parts. I generated these graphs with a one-off Haskell script, which just shows that Haskell is actually great as a hacky scripting language. It's not just for code where correctness matters! Modularity and simplicity go hand-in-hand. They both make it much easier to work with code! Types and Functional ProgrammingSimplicity and modularity are goals to strive for, not actionable techniques. I've told you what you want, not how to get it. This is where my two favorite tools step in: static types and functional programming. Both types and functional programming help prevent bugs in a host of  different ways. Types rule out whole categories of mistakes like null-pointer errors or incompatible argument values. Functional programming makes concurrency and parallelism safer. They both make refactoring much nicer.  But, despite these advantages, the biggest improvement by far was that they make writing simpler, more modular code more natural. Types Types are, in some sense, the very essence of modularity. After all, the idea is to have explicit interfaces between different pieces of your program, and types are just that—explicit interfaces. They make it easier to fit pieces together. Think of typed program like a jigsaw puzzle where each piece has a distinct shape; if you try combining pieces that aren't supposed to go together, they simply won't fit. Types make modularity a first-class part of the language. You have fine control over how different things interact. Types help document your code, and, since they're checked automatically, they can't ever go stale or out of date. Types help ensure that the internal details of code are actually hidden and that code that claims to be generic actually is. Using an abstract (ie existential) type ensures that others cannot use any information about how the type is implemented—this directly reduces edges on the complexity graph. Using a polymorphic (ie universal) type ensures that code that's supposed to be generic doesn't accidentally assume more about its arguments than it should¹. So I heavily advocate types not just as a way to prevent common errors but as an incredible tool for making your code more modular. Functional Programming Functional programming is another set of techniques that I've found very effective for both simplicity and modularity. On the simplicity front, functional programming makes all the dependencies between different areas of your program explicit. Dependencies—and therefore complexity—can't sneak in through the backdoor of mutable state or side-effects. You still can use state or side-effects if you want, you just have to be explicit about it using the type system. Since dependencies are explicit, you naturally tend to limit them as you program. There's less need to constantly think about making your code simpler because it comes out simpler in the first place. Functional programming, especially lazy functional programming, also helps with modularity. All of the things that make your code simpler in a functional language? They also make it more modular. It's much easier to move code around because order doesn't matter. Functions only interact by what's in scope or parameters that are passed in explicitly; if you want to move code from one scope to another, you will just have to take the dependencies you need and turn them into function arguments. As I alluded earlier, laziness also makes code more modular. In particular, it decouples definition from evaluation. You can define something at one part of the code, and different users can evaluate different parts of it. Hughes wrote a great article about this called "Why Functional Programming Matters". footnotes ¹ This is actually a very interesting property called parametricity. Basically, since polymorphic code can't assume anything about the parametric type, you get a lot of nice properties for free. Here's an article that about the idea that looks good: parametricity. Updated 27 Oct • View Upvotes • Asked to answer by Miguel Paraz