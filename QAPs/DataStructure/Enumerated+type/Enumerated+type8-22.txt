Software Engineering: What are good ways to avoid bugs while programming?
A low-tech thought: Each piece of your program should be comprehensible at a glance, or at least fit in your brain’s working memory. I believe that bugs become geometrically more likely the moment the piece you are working on—regardless of whether it’s an expression, a function, a class, or a module—spills out of your brain’s working memory and starts paging. If you’re looking at a function, and it is sufficiently simple enough that you can keep it all in your head at the same time, it is relatively easy to catch bugs by inspection. The moment it is too long or too complicated to do this, you have to start using more or less mechanical methods to break it into manageable pieces—even if that ‘mechanical’ method is nothing more than mentally separating it into chunks. But they are arbitrary chunks, and if they reside in the same logical chunk of code, dependency paths in time or [memory] space may arbitrarily cross it. So don’t do that. Keep each chunk small enough, whenever you can, that inspection is feasible. This does not mean that inspection is sufficient. I’m not here to criticise strong static typing, static analysis, TDD, or anything else. But if the program flow is obvious, you are much less likely to create bugs in the first place, as well as less likely to sneak bugs past your safety lines. Of course, it’s a pretty vague guideline. In particular, it depends a great deal on who’s reading the code—after all, you’re often not the sole maintainer, and it’s no good if it’s only obvious to one guy on a team of a dozen. But I find that things I do in order to support my ideal of “comprehensible at a glance” include good function names that make it clear what my code is doing; utterly consistent formatting, to make visual noise go away and code appearance reflect program semantics; keeping functions short. I want my functions to fit on one screen. It’s less a matter of lines or columns, and more a matter of physically fitting the content on the working area of the editor/IDE/whatever—obviously, the smallest one in use by any project participant (and obviously with additional, reasonable restrictions: excessively long lines are easily readable to nobody). I believe that, although mental ‘paging’ is harmful, it’s much more harmful when you cannot take in the whole of a function at one visual glance and trace flow with your eyes if not your mind.The last bullet in particular favours expressive, high level languages. If your language of choice is not particularly expressive, you will probably have a tendency to write functions that are too long to fit in your head or on your screen, and as a result, you will have diminished your ability to trace and anticipate its path and possible problems. 