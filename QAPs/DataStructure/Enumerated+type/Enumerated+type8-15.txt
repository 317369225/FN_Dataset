Software Engineering: What are good ways to avoid bugs while programming?
You avoid bugs by covering yourself against them. Most bugs are caused by programmers who think they can avoid bugs. The other name for "avoiding bugs" is Ego-Driven-Development. The antidote for it is called "Test-Driven-Development". The problem often starts with the first person on the team. "I have the entire blueprint in my head," he thinks, "I'd know how not to let bugs in". He builds the house and forgets about it. A few months later someone asks him "can you build this new feature?" Of course he can. He builds the feature, checks it in, and a little bug creeps into the old code without him noticing. Users complain of a bug in production. The marketing team tells the first developer to fix the bug. He does, and along the process creates two other bugs. The stakeholders decide he needs help, and hire another developer to only fix bugs. The second developer not only has to understand what's wrong, he also needs to understand what's not wrong -- a task ten times more difficult without tests. Everywhere he steps, he lets more bugs in. The whole team comes to an embarrassing halt in front of the customer. They decide enough is enough. Let's write tests before we write code! Write a failing test for your expected outcome first. Then write the code to make the test not fail. Once it doesn't fail, you have "avoided bugs". If passing all tests is a required step in your deployment process, you're guaranteed to not introduce bugs that you've tested for. Repeat the process until you have 100% code coverage. Code coverage doesn't keep out all bugs, but it minimizes human error when adding code and opening the door to all kinds of regression nastiness. TDD has the upside of reducing the cost of system maintenance to near constant O(1). But on the downside, it front-loads overhead time for every code commit, because you need to run all your tests first. Small teams avoid the downside, and when they get larger, pay a huge price for gaining back the upside, often at the cost of months of total halt to development. Without TDD, no matter how modular your system, how succinct your programming language and how frequent your pair-programming, your changes shake the house of cards. The cost of change will still be at least linear O(n) depending on your "n" lines of code. If the code is non-modular and difficult to read, the order of cost can reach exponential O(n^2) because every two lines may interact with each other in unexpected ways. Other agile practices rely on TDD fundamentally. Unnoticed bugs compound in a team environment. The cost of a system without TDD rises with four factors fueling it: n lines of code, n ways that a line interacts with other lines, b existing bugs and t people on the team: O(b * t * n^2). Super-human effort cannot undo the wreck that human neglect can accumulate. Ants attract other ants. And soon, if you're not doing TDD to prevent bugs, you'll declare technical bankruptcy. And don't get me started on Second-System-Effect. Starting from scratch often takes twice as long to completion. Get it right the first time. Do not try to avoid bugs. Expect them. And put a screen in every window you build. Then, when you see a new bug in your house, look for holes. Updated 28 Oct â€¢ View Upvotes