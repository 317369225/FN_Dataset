Given an array of positive integers, how can we convert it into a sorted array with minimum cost using the decrement and deletion operations (Decrement operator cost = 1, Deletion operator cost = value of the element)?For example: Consider the array 4,3,5,6 . We can sort it by decrementing 4 and thus sorted array will be 3, 3, 5, 6. Minimum cost is 1 for sorting in this case. Consider the array 10,3,11,12. We can sort it by deleting 3 and thus sorted array will be 10, 11, 12. Minimum cost is 3 for this case.I strongly suspect that this problem can be solve in O(N) or O(N log N), however I haven't worked out all of the details. However, I will detail a simple O(N^2) solution that I think can be made faster with a few transformations. Consider the smallest element in the array. We will never decrement anything below that so the only decision we need to make with it is whether we delete it or not. If we delete the smallest element we recurse on the one-smaller array. If we choose not to delete the element then we will decrement everything prior to it to match its value. There is no reason to try anything else. Therefore we can describe our state with two values. 1) What suffix of the array we are working with. 2) What is the index of the minimum value that hasn't been deleted. Which leads to O(N^2) states. In order to compute the recurrence relation in O(1) time we'll need some data structures to help us find the minimum indexed value for a suffix of the array, the next larger element for some suffix of the array, and the partial sum of elements larger than each array element. Since we're going for an O(N^2) solution these data structures are trivial to implement (just precompute everything for each suffix). 