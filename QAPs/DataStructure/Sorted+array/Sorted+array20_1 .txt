How can I fix my program about finding the k-th smallest element in the union of two sorted arrays, for time O(k)?该网页不存在附加信息...a+ b + 2 == kThis check is wrong. It should be a + b + 1 == k. Once you do that, your corner case for the first element will automatically come inside the loop. a = 0, b = 0 // at the starting point a++; // increment a when it is actually the current position if(a+b+2 == k) return A[a]; // returning the next element instead of the actual kth element. You are starting at the first element of the combined array and yet you return the value after incrementing a and b, which means that you are returning the (k+1)th element instead of kth element. However, your (wrong) check for a+b+2 == k was helping you out in certain cases and gave an illusion that the code works in certain case, even though it was quite wrong. Essentially, after the above adjustments, your code will look like  1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829 private static int find(int[] A, int[] B, int k) {  int a = 0; //pointer of array A  int b = 0; //pointer of array B  if(A.length + B.length < k)  return -1;  while(a < A.length && b < B.length){ //start traversing both arrays  if(A[a] < B[b]){ //if the current element from A is smaller than the current element from B, increment a  if(a+b+1 == k) //+2, since the enumeration in the arrays in Java starts from 0  return A[a];  a++;  } else { //do the same as before, but for the case when A[a]>=B[b]  if(a+b+1 == k)  return B[b];  b++;  }  }  if(a == A.length) { //if we have traversed the whole array A, but there are some elements from B left  while(a+b+1<k)  b++;  return B[b];  } else { //if we have traversed the whole array B, but there are some elements from A left  while(a+b+1<k)  a++;  return A[a];  } } This should work as expected, although I haven't tested it. However, you can write it somewhat compactly as:  1 2 3 4 5 6 7 8 910111213141516 private static int find(int[] A, int[] B, int k) {  if (A.length + B.length < k || k < 1)  throw new IllegalArgumentException("k should be between 1 and " + (A.length + B.length));  for (int a = 0, b = 0; a + b < A.length + B.length; ) {  int currValue = -1;  if (a < A.length && b < B.length)  currValue = (A[a] < B[b]) ? A[a++] : B[b++];  else  currValue = (a == A.length) ? B[b++] : A[a++];   if (a + b == k)  return currValue;  }  throw new IllegalStateException("Indicates code bug! Contact developer immediately!"); } 