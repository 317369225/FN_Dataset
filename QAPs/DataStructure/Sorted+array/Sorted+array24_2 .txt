Given two sorted lists of size m and n, what is the fastest algorithm for computing the kth smallest element in the union of the two lists?What's the solution to the generalized problem: Given m sorted arrays each of size n, what is the fastest algorithm to find the kth smallest element in the union of the m arrays? (I can think of a m log m + k log k algo if k<m andÂ  m log k / log (m/m-1) (generalizing Cosmin's approach) otherwise.)Clearly, only the first k elements of each list (M and N) are relevant, so the remaining elements can be ignored. From this point, the problem can be solved with a modified form of binary search, with a big-O of log(k). For each element , we look up of list M, we look up , . Here is a python implementation:  1 2 3 4 5 6 7 8 9101112131415161718192021222324 def ksmallest(M,N,k):  min_poss = max(0,k-len(N)-1)  max_poss = min(k-1,len(M)-1)  r = 0  if k==1:  return min(M[0],N[0])  if k==len(N)+len(M):  return max(M[-1],N[-1])  while max_poss-min_poss > 0:  d = max_poss-min_poss  l = min_poss + (d+1)//2  print (l,k-(l+1))  a = M[l]  b = N[k-(l+1)]  print (l,d,a,b)  if a==b:  break  if a<b:  min_poss = l  else:  max_poss = l-1  if l<len(M)-1:  return min(a,b)  return max(a,N[k-(l+1)-1]) 