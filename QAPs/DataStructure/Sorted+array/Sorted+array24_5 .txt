Given two sorted lists of size m and n, what is the fastest algorithm for computing the kth smallest element in the union of the two lists?What's the solution to the generalized problem: Given m sorted arrays each of size n, what is the fastest algorithm to find the kth smallest element in the union of the m arrays? (I can think of a m log m + k log k algo if k<m andÂ  m log k / log (m/m-1) (generalizing Cosmin's approach) otherwise.)This is my first answer to any question on Quora. Lets gather all the possible solutions for this problem . ->first take all the elements in an array and sort them and return the k the elment from the array.O(n*mlog(n*m)) -> improvement you can build a minheap by collecting all the elements and that takes O(n*m) time and you can easily find the k smallest element in this heap by repeatingly removing the element and that takes k log(n*m) .so complexity O(n*m) +O(klog(m*n)) Can we do better than lets check it -> do you observe something in the previous solutions that these solution are going to work even we have not given sorted arrays but here is a catch that the given arrays are sorted so we can use this to improve the complexity . Suppose we have a min heap first take out m elements one from each of the m arrays( obviously choose the first one :P) now put them in the heap right now take out the minimum element from the heap and check which array elements it is that you can check in constant time by maintaining a hash or something. now increase the pointer of that array and then take out the next element from that array and put that in the min heap . Again take out the minimum element from the heap and proceed in the similar you will end up finding the kth smallest element in the merge of these arrays. have we improved from the previous solutions?? time complexity of this solution O(m+k)log(m) verify this on your own. space complexity O(m) for the min heap  complex one with bad complexity : As we are allowed to submit solution with any complexity on an online judge here i am going to submit one . we can use this method we can find the range of all element in O(m) suppose it is from something to something . then we will use binary search technique like we select mid of this range and find the number of elements less than this element in every array and if the count is less than that of k we can move to the right side and if count i more we can move in the left half else we end up finding this element. There may be problems with the solution as i know some problems in last solution but i request all of you to visualise it on your own or do comment here :p . I would like to if someone has some better algorithms for this then please post it here. Learn and Let Learn :D 