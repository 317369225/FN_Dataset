How can we find the k-th smallest element in the union of two sorted arrays in O(log m + log n) time?Let A and B be the arrays. To make explanation easier, we shall assume all elements are distinct. The motivation of the algorithm is that we want to find some (x_ans,y_ans) such that x_ans + y_ans = k and max(A[x_ans],B[y_ans]) is the kth smallest element. And since the arrays A and B are sorted, there exists some monovariance that we can exploit. Thus, we think of binary search to find x_ans and y_ans. The rest of the algorithm is just reasoning to determine what we should do when a scenario arises. We initialise x = k/2 and y = k/2 (we shall assume that A.length() <= k/2 and B.length() <= k/2. If the length of the array is too short, just take the whole length) In all explanation below, we shall assume WLOG that A[x] > B[y] Case 1: x + y = k If B[y+1] > A[x], A[x] is the answer. Otherwise, there are still many elements B[z], z > y, such that B[z] < A[x]. Therefore we increase y Case 2: x + y > k Since the sum exceeds k, we know that A[x] is an overestimate. So we decrease x Case 3: x + y < k If B[y+1] < A[x], this means there are many elements B[z], z > y, such that B[z] < A[x] that we have not accounted for. Therefore we increase y to account for them. Otherwise we increase x Note that when I mean increase/decrease, I mean changing the value by k/4, k/8, k/16 etc after each iteration on each array. To illustrate this, suppose that you updated x 3 times and updated y 2 times. If you need to update x during the current iteration, you change x by k/16. If you need to update y during the current iteration, you change y by k/8. 