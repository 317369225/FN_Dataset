Given a sorted array, output all triplets <a,b,c> such that a-b = c. Expected time is O(n^2) notÂ  O(n^2 logn)?Assuming all numbers are positive and distinct. Without loss of generality, the question can be converted to 'find (a,b,c) such that a+b=c.' Assume, arr = given sorted array Now fix a = arr[0] : for b, Scan array arr[1]..to...arr[n-1]. Now if b = arr[1], then c can only be after index 1, right? (light bulb!) So, start and keep scanning from index 2 with your middle finger preferably, while your middle finger points to some value which is less than a+b. (Please remember the place where your middle finger is pointing to) Now if the number next to your middle finger is equal to a+b, add this triplet to your answer. (but don't move your middle finger ) Else don't do anything. Now move to next element for b, that is, arr[2]. Now check whether what your middle finger points to is less than a+b or not. If yes then move middle finger to next number and check again and so on while it keeps pointing to a value which is less than a+b; likewise do this for b = arr[3] to arr[n-1]. So, for a particular a (which arr[0]) in this case, we scanned the array for different value of b (starting from arr[1] and so on) only once. And also our middle finger always went right and hence it also scanned the whole array once (yes yes only once, you can verify by taking a small example ). So, overall complexity is O(n) for arr[0]. Do this for all the possible value of a. (i.e. arr[1] ...to ...arr[n-1]). So, the total complexity becomes O(n*n); P.S:Negative number can also included with slight modification in the algo, where your middle finger goes left instead of right or something like that. 