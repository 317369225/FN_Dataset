Given an array of positive integers, how can we convert it into a sorted array with minimum cost using the decrement and deletion operations (Decrement operator cost = 1, Deletion operator cost = value of the element)?For example: Consider the array 4,3,5,6 . We can sort it by decrementing 4 and thus sorted array will be 3, 3, 5, 6. Minimum cost is 1 for sorting in this case. Consider the array 10,3,11,12. We can sort it by deleting 3 and thus sorted array will be 10, 11, 12. Minimum cost is 3 for this case.This could be solved in with a dynamic programming approach. (Edited, cc Mark Gordon, Nick Wu) Idea: Let be the given array. Let's be the elements of all 's when sorted in an increasing order. Let's ignore the deletion operation for now. Based on intuition, you will never try to change into a number which is not some . (Proof: Exercise) Define a DP state to be the minimum cost which changes the subarray into an increasing subarray , s.t., . It should be clear that all can be computed in time. Improving runtime to O(n^2): Let be the optimal cost to modify into an increasing subarray , s.t., , for some . Then, we have: Now, we could easily compute each with the recurrence: Finally, allowing also element deletion should be pretty straightforward.  Embed Quote Updated 7 Sep, 2013. 385 views.Suggestions Pending Nick Wu suggested edits to this answer: This could be solved in with a dynamic programming approach. (Edited, cc Mark Gordon (links to: /Mark-Gordon-6), Nick Wu (links to: /Nick-Wu-4)). Idea: Let be the given array. Let's be the elements of all 's when sorted in an increasing order. Let's ignore the deletion operation for now. Based on intuition, you will never try to change into a number which is not some . (Proof: Exercise) Define a DP state to be the minimum cost which changes the subarray into an increasing subarray , s.t., . It should be clear that all can be computed in time. Improving runtime to O(n^2): Let be the optimal cost to modify into an increasing subarray , s.t., , for some . Then, we have: Now, we could easily compute each with the recurrence: Finally, allowing also element deletion should be pretty straightforward.Edit Suggestion Suggest edits to the author of this answer: B I U H     @    This could be solved in [math]O(n^2)[/math] with a dynamic programming approach. Idea: Let [math]a_1, a_2, ..., a_n[/math] be the given array. Let's [math]c_1, c_2, ..., c_n[/math] be the elements of all [math]a_i[/math]'s when sorted in an increasing order. Let's ignore the deletion operation for now. Based on intuition, you will never try to change [math]a_i[/math] into a number which is not some [math]c_j[/math]. (Proof: Exercise) Define a DP state [math]f(i, j)[/math] to be the minimum cost which changes the subarray [math]a_1, a_2, ..., a_i[/math] into an increasing subarray [math]b_1, b_2, ..., b_i[/math], s.t., [math]b_i = c_j[/math]. It should be clear that all [math]f(i, j)[/math] can be computed in [math]O(n^3)[/math] time. Improving runtime to O(n^2): Let [math]g(i, j)[/math] be the optimal cost to modify [math]a_1, a_2, ..., a_i[/math] into an increasing subarray [math]b_1, b_2, ..., b_i[/math], s.t., [math]b_i = c_{j'}[/math], for some [math]j' \le j[/math]. Then, we have: [math]g(i, j) = min\{f(i, 0), f(i, 1), ... f(i, j)\}[/math] Now, we could easily compute each [math]f(i, j)[/math] with the recurrence: [math]f(i, j) = g(i-1, j) + |c_j - a_i|[/math] Finally, allowing also element deletion should be pretty straightforward. Update ://T Drop an image here Drag an image here, or... Explain Your Suggestion Explain Your Suggestion: Update ://T CancelSuggest Edits CloseDiscard