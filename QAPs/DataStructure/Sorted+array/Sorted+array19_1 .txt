How would you square each element in a sorted array of ascending integers while still maintaining the order?Given n is any element in the sorted array: 32_BIT_INT_MIN <= n <= n + 1 <= 32_BIT_INT_MAX Additionally, what is the fastest possible time complexity of this algorithm and how could that be implemented?Well, since you need to square every element, that alone says the best you can do is O(n), so let's shoot for that. My solution is going to require an extra O(n) of space. I imagine there may be a way to do this in-place, but since you didn't specify a space constraint, I'll file that under premature optimization. The high level idea is this: we'll maintain two pointers, one starting at the beginning of the sorted input array, and one starting at the end of the array. The key insight is that elements are guaranteed to get smaller (or at least, not increase) as we move from the outside of the array inwards. For example: Input: { -7, -5, -4, -2, 0, 1, 3, 3, 5 } Squared: { 49, 25, 16, 4, 0, 1, 9, 9, 25 } The procedure itself will look something like this: Square every element in the input array. Allocate an output array of size n. Let head be an int that points to the beginning of the input, and let tail be an int that points to the end of the input. Let i be the number of elements we've placed into output (initially 0). If input[head] > input[tail] then assign output[n - i - 1] = input[head] and increment head. Else assign output[n - i - 1] = input[tail] and decrement tail. Increment i. Repeat 4 until head > tail. If all that sounded familiar, that's because it's essentially the "merge" step in Merge Sort. 