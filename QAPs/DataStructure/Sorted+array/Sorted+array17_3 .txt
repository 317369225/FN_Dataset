Given a sorted array, what are some good ways to find all its subsets whose sum is equal to a given value k in O(n)?Bit mask technique won't work.As Michal Forišek and Aditya Kadam point out, you cannot do in in O(n) ...unless... Disclaimer: this is a highly impractical solution with impossible demands on parallel computing resources for all but the tiniest values of n. It is not meant to be a proposed solution, but rather I bring it up just for its academic value. ...unless you have access to a network of parallel processors. For an array of 30 numbers, you would need 1073741824 parallel processors. Each processor would be assigned an ID from    to   , and would receive a broadcast of the array and the k value. It would then pull out only the elements with indices that correspond to the nonzero bits in the binary representation of its ID. Processor number 0 would not have to look at the array at all, and just return a result based on whether or not k=0. As it won't be very busy, we can assign processor 0 the task of broadcasting the array and k value, and collecting the results (true or false) and storing the IDs of the processors reporting "true". Processor number would potentially have to sum all n elements (it could stop early if, for example the array is sorted in ascending, the current value is positive, and the current sum exceeds k), so the overall time would be , with parallel processors. Note that with that many processors, you would run into a lot of other problems, such as how to deal with processors that do not report a result in the expected time (processors can be distributed on many computers over a large network - if network has issues some processors may be out of communication intermittently or permanently).   