What are some of the algorithms in computer science that you like more than the others?
My favorite algorithm is forward differencing. It's useful anytime you want to evaluate a polynomial function many times at evenly spaced values [math](0.1, 0.2, 0.3, ...)[/math]. It is used for tesselating Bézier patches and Bézier curves, and by extension can be used for tesselating NURBS surfaces, subdivision surfaces, and T-Spline surfaces. Here's an example. Let's take the polynomial: [math]f(x)=x^2-3x+5[/math] Now, evaluate it at a few positions: [math]x=\{ 1, 2, 3, 4, 5, ... \}[/math] gives [math]f(x)=\{ 3, 3, 5, 9, 15, ... \}[/math] Next, we take the difference between adjacent terms, giving: [math]\{ (3-3), (5-3), (9-5), (15-9), ... \} = \{ 0, 2, 4, 6, ... \}[/math] Now we do that again, taking the differences of items from the second list. This time it's [math]\{ (2-0), (4-2), (6-4), ... \} = \{ 2, 2, 2, ... \}[/math] Here's the cool bit: it is always going to be 2, forever. Even cooler, every polynomial will eventually do this, and the number of times you have to take the difference to get down to the repeating constant is equal to the degree of the polynomial. So why is it called forward differencing? Because I know that the next term in my last sequence will be a 2 forever, I can now run the differencing algorithm in reverse to figure out what the next terms will be on up the chain. So I can now find the next number in the original sequence without doing any multiplication at all! For example: [math]6+2=8, 15+8=23[/math] And sure enough, the next value is [math]f(6)=23[/math], which we discovered with only two addition operations! What's next? [math]8+2=10, 23+10=33, f(7)=33[/math] Note that you shouldn't do more than a few thousand steps with this algorithm; you'll run into numeric stability issues. Still, for any polynomial you might have, this is a blazing fast way to generate a series of equally spaced points. Updated 37w ago • View Upvotes • Asked to answer by Nischal Samji