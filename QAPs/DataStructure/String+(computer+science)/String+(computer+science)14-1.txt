What is the worst mistake ever made in computer science and programming that proved to be painful for programmers for years?
This one has an easy answer :-). Remember the string manipulation function like strcpy from the standard C library? This function has the following prototype/API:- char * strcpy ( char * destination, const char * source )   Here, you specify the 'source' string that will be copied into the 'destination'. Notice something missing? A crucial information is required for the operation to complete correctly... It is the length of the source string. Well, then how does the computer know the length of the source string? It calculates that by using the fact that the C-style strings are terminated by '\0'.   Well, its all well and good until you consider the following situation where:-   char destination[10]; char source[200]= "I am a bad and malicious string hell bent on spoiling your software release party" strcpy(destination, source);   Notice what is wrong here? This is a write Access violation. Generally, the source is not hardcoded in the program and it comes from a user as input to the program. If such strcpy are not properly guarded, it can be easily exploited by any attacker to trigger various bad things like Remote code execution e.t.c. Is there any safeguard we can put inside strcpy against such attacks? The answer is NO because the API just does not have any way of passing enough information to the function. The crucial parameter of destination length is missing! The only answer is to look for all such instances of strcpy in the code and then make sure that it cannot end up in being exploitable. If it can be exploited, then use proper checks to ensure the validity of the parameters to strcpy. The most probable reason why strcpy does not have this crucial information is that the C-standard library was designed lonngggg time ago. When security considerations were not such a big issue. You must be wondering if such a security issue exists with strcpy, then why not put the checks in place when you are writing the code initially. I can think of these possible reasons:- 1.) The code is a legacy code. It was written "in a galaxy far, far away where security considerations were not really important" 2.) Sometimes, developers assume that the input "source" cannot be controlled by a user. This assumption might be wrong from the beginning itself. Or, it might become wrong due to numerous changes to the program during development and its release life-cycle 3.) Some inexperienced developer might not be aware of such problems with strcpy (like back in college I never knew these things) 4.) Simply a human error. Developers are human too. If you have a deadline to meet, you just go berserk with your keyboard without worrying about the consequences!!!!!   Wouldn't it be wonderful if the string manipulation functions like strcpy, strcat were designed to ensure that such problems did not occur. Well, software community realized these problems and corrected them by designing new platform -specific APIs like StringCchCopy function. This function requires the length of destination buffer to be passed to it and performs the necessary validation before it performs the copy.   EDIT: For the sake of completeness, here is a clarification:- "Char destination[10]" is a local variable and the buffer overrun is on the stack. Thus, you can overwrite the return address to a function and make the Instruction pointer jump to an addess where you have stored malicious code. Happy to help . Go through this as a tutorial:- Writing buffer overflow exploits - a tutorial for beginners 