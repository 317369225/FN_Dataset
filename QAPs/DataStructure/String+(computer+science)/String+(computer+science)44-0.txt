What are some of the algorithms in computer science that you like more than the others?
Perhaps broadening the definition of "algorithm" a bit, my favorite is a compiler optimization: inlining. It has to have one of the best power to weight ratio of any optimization: conceptually, it's quite simple but, combined with a handful of other basic optimizations, lets the compiler seemingly do magic. The idea behind inlining is to insert the body of a function into the code in place of a normal function call. This avoids the extra indirection and overhead of calling a function and, perhaps more importantly, opens up the body of the function to be optimized in the context of its call. This lets the programmer express more complex logic in functions without necessarily incurring any performance penalties. The real power of inlining is that it acts as the glue to combine other simple optimizations into a coherent, more complex whole. It lets the rest of the optimizations performed by the compiler stay local and simple while still being extremely useful. Think about it this way: inling lets local optimizations affect distant parts of the code... by simply bringing them together physically before optimizing further. The compiler can intelligently optimize uses of your libraries functions without knowing anything about them or having to do complicated analysis at their use site because those functions get converted into inline code. Once the rest of the optimizations see it, there's no function call at all, so the whole thing gets optimized properly. Similarly, this lets higher-order functions have performance characteristics similar to loops because the body of the function passed in can be inserted right in the same place, just like the body of a loop would be by default. Of course, while the idea is simple, doing it efficiently is not. Inlining inherently increases the size of your generated binary: after all, the compiler is essentially copying and pasting your function all over the place! Moreover, if your function is too large, inlining it might use the instruction cache less effectively and lead to worse performance. Practical compilers have carefully tuned heuristics for figuring out whether or not to inline and still sometimes need a programmer to manually specify whether a function should be inlined. But, with that in mind, I still think it's one of the coolest algorithms around, just because of how simple and yet powerful it can be. 