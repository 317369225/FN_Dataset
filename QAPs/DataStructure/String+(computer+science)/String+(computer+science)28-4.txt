What are some interesting puzzles asked in computer science programming technical interviews?
1. Write regexp matching strings having only letters a, but only of length which is composite number. (example: aa -> True, aaaa -> False (not composite), aab -> False (not only a's)) 2. BFS algorithm: what is memory complexity of BFS? I mean, what is the maximum size of queue during execution for graph of n vertices and m edges. Why? 3. Find smallest positive decimal number containing only digits 0 and 1 which is divisible by N. (example: 7 -> 1001) 4. You have sequence A containing N numbers. Sequence B is obtained by taking multiplies of any pair of numbers from A (so you get exactly N^2 pairs [we count (A*B and B*A as different pair]). Find K-th smallest number in sequence B. 5. Implement queue using two stacks. 6. Find in linear time if array of length N containing integers from range [1; N] has duplicate using constant additional memory (not counting input array - you can write on it). 7. You have string containing only letters A and B. Find longest substring where A occurs twice as much as B. (example of good substring: ABAABA) 8. Is it possible to create data structure providing operations Insert(x), Erase(x), FindMin() where each operation is o(log n)? Why not or how to do that? Note that x can be real number and assume you can compare in constant time. 9. You are given sequence of parentheses S and bunch of queries in form: Is S[i..j] correct? (example: S = ()(()))(, query: (i = 3, j = 6)  => substring = (())  => answer Yes) Provide an algorithm which can answer many queries (thousands) for large sequence (thousands of characters). 10. Binary search. You have N cells of sorted array. You want to find value x. However cost of reading value T[i] is i. Provide algorithm which is optimal in worst case. (if there is way to always find x using queries of cost at most p in any case and your algorithm has greater cost - it is wrong) 11. (very interesting) You have K similar eggs and you want to determine their durability. Each egg has the same durability p (which you have to find). If egg is dropped from height <= p it will not break down, if it is dropped from height > p it will. You know that p is integer number and it is <= N. Find algorithm which determines p using smallest number of drops (in worst case) if: (a) N = 100, K = 10 (very easy) (b) N = 100, K = 1 (very easy) (c) N = 100, K = 2 (challenging) (d) N = 1000, K = 5 (very challenging) (e) N = 10^9, K = 15 (more than hard) What is good about this problem: all of these five points (a) - (e) have different solutions. 