Why is the time complexity of the Knuth-Morris-Pratt algorithm O(n)?
Wikipedia articles can be long winded and difficult to understand, especially when related to computer science. In this case it is helpful to look at some actual source code: http://ideone.com/A69NK9. This code, which is fairly standard if you look at how KMP is implemented in competitive programming, is elegant in that the table building step is analogous to the string matching step. int pref = 0;for (int i = 0; i < str.size(); i++) {    while (pref != -1 && str[i] != target[pref]) {        pref = lookup[pref];    }    pref++;    if (pref == target.size()) {        return true;    }}return false; This is code for the string matching step. In the code, pref is the longest matching prefix, and str[i] is the current character. Every iteration of the while loop, pref decreases until it hits -1 or until it matches. After that, it is incremented by one. Therefore, in the worst case, pref can only be decreased up to n times and increased up to n times, and the algorithm is linear. Updated 81w ago • View Upvotes • Asked to answer by Akshay Arora