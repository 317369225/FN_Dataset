How does one become a great coder?
First I'm going to give kudos to Michael O. Church for defining what a "great coder" is in a more rigorous fashion. I agree with him on most of his points and think his model has promise as an HR tool (he will probably hate me for saying this). Programming is like any other human activity - there are going to be child prodigies on the extreme right of the bell curve, there are going to be people of average ability, and there are going to be people on the far left. I believe the only people who are unable to reach a level of programming competency are those with mental handicaps, which prevent them from competency in most kinds of human intellectual activity. So, assuming you have average cognitive abilities, can you become a great coder? An obvious necessary requirement to becoming great at something is to first acquire basic competency. Jeff Schaffzin has a very good observation about having a background in logic. The core activity of computer programming involves having mental models of your programming language and of the problem you are trying to solve. This is why Seymour Papert was so successful in applying Piaget's constructivism theory of learning to teaching children how to code: help children construct mental models by having them build and tinker with computer programs (http://en.wikipedia.org/wiki/Con...). IMO, this is why most CS programs that start out teaching Java or C++ fail. Those programming languages are useless for tinkering and exploration. The only students that pass the course are those that come in already having mental models that are related to programming. The other students don't get a chance to develop those mental models and are told they don't "get" programming. Two other prominent programs in the constructivist programming learning camp are those run by Alan Kay, and the PLT TeachScheme! project (now known as ProgramByDesign). My first real introduction to programming (aside from keying in some BASIC programs without knowing what I was doing as a child) was through a high school introductory CS class that was part of the TeachScheme! project (Mike Zamansky's class at Stuyvesant). By the end of it I could write computer programs that solved basic problems. However, I had no interest in programming, and would not develop an interest for several years. This is where the journey to greatness starts: with motivation. My motivation came when I discovered SICP and learned that programming can be logically simple and beautiful. I'm not going to claim to be a great coder, or even an excellent one, but I will explain the tactics I am using in my plan to get there. Since we are talking about ways to do something, having a good process for doing things helps. I recommend reading George Leonard's book Mastery. I found the most important points of the book to be: 1. To become great at doing something, you need to practice at doing that thing. 2. Practice is most effective if done regularly and consistently. 3. Fundamentals are everything. The greatest achievers are ones that pay the most attention to perfecting the fundamentals. 4. A great practitioner never stops learning. As soon as you become complacent with your present competency, you have slid into mediocrity. Years after starting out on the path to becoming a great coder, I lost my motivation to improve. I thought I was good enough and there wasn't any point in trying to get better. I found other interests in business and psychology. I even decided to try to pursue a career in business and enrolled in an MBA program. That's when I discovered Leonard's book and realized I had failed. I dropped out of business school this May with a renewed motivation to become great and a very different perspective on things. I evaluated my approach to see which things I had done wrong and which things I had done right: Things I did wrong: 1. Not paying attention to regular and consistent practice 2. Thinking I was good enough at the fundamentals 3. Not being competitive enough 4. Not learning enough mathematics To address point 1, I am employing the "Seinfeld technique" - I try to do at least one task related to any of the Free Software projects I am involved in every day. I find that the best way to do that is to employ the "Hemingway technique" - leave a task or subtrask unfinished at the end of the day. That way it's easier to make a contribution tomorrow. Point 2 I am addressing by going back and re-learning fundamental data structures and the algorithms on them, by taking my time to read introductory materials that should be "too basic" for me, by re-learning the basics of areas of CS that I don't specialize in. I am also simplifying my programming style. Everyone agrees that simple is good, but now whenever I encounter the need to make a decision about the design of my code, I ask myself (taking a cue from Mastery): what is the stupidest thing I can do? I find myself being too clever when I'm trying to be simple. Force yourself to be stupid and you can only come up with simple solutions. The pretending-to-be-stupid exercise has also lead me to abandon any vestiges of ties to programming paradigms or proscriptions. I now more than ever write code that by popular "wisdom" and dogma should be terrible, but ends up being simpler to understand. I used to think functional programming was better than object-oriented programming. I now think they're both terrible. Point 3 is something new for me, but should have been obvious. After all, the whole idea of "great coder" is relative - you can only be out X sigmas on the bell curve if there are other people to compare yourself to. I've never been particularly interested in programming contests before - I've only ever done two, the last one for the 2007 International Lisp Conference. Right now I'm planning to start doing TopCoder competitions once I have cleared some of the other planned tasks. I'm not sure how long it's going to take me to get good, but I think I'll be ok (my ILC07 entry dominated with the highest score and lowest runtime). Point 4 should be obvious. One of my bachelor degrees is in pure mathematics, and I think there are only two things I did not do enough of in college: sex and mathematics. Things I did and continue to do right: 1. Learn from the best materials 2. Learn from the most materials 3. Taking time to do ambitious projects 1. Niels Abel has said that the key to his progress was to study "the masters, not their pupils." I am a big fan of the MIT computer science cirriculum. I think the three best books in CS are Abelson and Sussman and Sussman's Structure and Interpretation of Computer Programs, Cormen, Leiserson, Rivest and Stein's Introduction to Algorithms, and Saltzer and Kaashoek's Principles of Computer System Design. The great computer science books, papers, and dissertations from the 1950s, 60s, 70s, and 80s are full of insight that is not and will never be outdated. During college, I made it a point to read CS books mostly published before 1990. One of the tasks of the current plan is to read all four volumes of TAOCP in their entirety. 2. This might seem to contradict the above point, but once you understand what is important and what is not, you learn how to evaluate any material that comes your way and either discard it or learn something from it. Unfortunately not every topic is exhaustively covered by masterful exposition. 3. This is very important. If you want to do a project and someone tells you it will be too difficult, you should do that project. If you do great projects, by definition you will become known as a great coder. Don't bother making small, simple projects your priority - in the course of doing a large project you will have to deal with enough small, simple projects that are blocking your progress that you won't need anything else. Doing a difficult and ambitious project means the possibility of failure. One very common way to fail is to run out of time. You can remove this possibility by working on long-term Free Software projects. I literally take years for my Free Software projects. On a long enough time scale, major life changes and shifting priorities don't get in the way. If I run into a technical problem that I don't see a good solution to, I can walk away for months, and come back when a satisfactory solution has occured to me. This way, the only reason to abandon a project is that it is not important enough to spend time on. A side-benefit to Free Software projects is that the small, simple projects blocking your progress tend to be other Free Software projects. You get to make public contributions that benefit a lot of other people, all the while doing something you love that will make you known as a great coder. I can't say for certain that this will work, or if it's the best approach. If you have ideas, please feel free to share. Updated 132w ago â€¢ View Upvotes