Why are programmers in the software engineering job interviews tested on skills similar to a Topcoder contest irrespective of the fact that the skills required in the industry are entirely different?
I see this question, in one form or another, relatively often, and today I feel like adding my own answer. I'm going to go against what seems to be the popular opinion on the Web, and defend the use of algorithm problems in interviewing candidates. (Yes, I'm biased. Let the reader beware.) First: because it works. As far as I can see, all of the most successful tech companies in the world do it. After Microsoft started doing it, pretty much everyone else decided to follow suit. Second: no, they're not. It is true that in industry you will almost never have a 30 minute time limit to implement something out of CLRS. It is false, and an entirely different thing, to claim that there is no overlap between the skill set required to perform well in an algorithmic interview and the skill set required to perform well in a software engineering position. Okay, so, this might be true if your job consists entirely of writing HTML+CSS, perhaps. However, here are a few things that a good engineer should generally be able to do, that are testable in algorithmic interviews: Reason about correctness. It seems quite obvious to me that a candidate who can explain that their binary search implementation must be correct because it satisfies a loop invariant will be much better at writing bug-free code than one who cannot. (I will admit, though, that I failed at writing binary search the one time that I was asked to during an interview.) Reason about efficiency. I know some people try to pretend that this doesn't matter in the real world, but I think that is quite a ridiculous position to take. How are you going to be successful if you can't scale? How can you scale without having algorithms that scale well? And honestly, nobody cares if you know that the running time of Strassen's algorithm is [math]O(n^{2.807})[/math]. But you had better know that hash tables have expected constant time per operation, because they're used everywhere. Determine the right tools for the right job. Third: because it's a filter for talent, in general. As Joel Spolsky says, Youâ€™re looking for people who are Smart, and Get things done.If you could somehow evaluate the candidate's past work, that would be much better than asking algorithm questions. But there are already not enough talented engineers to fill all the demand for them in the tech industry, and refusing to consider candidates because you can't easily evaluate their past work would simply leave you with too few candidates; you'd be missing out on a lot of good people. For example, you can't just hire people who have built widely used, highly scalable open source applications, though it is obvious that the small number of people who have done so are almost certainly excellent software engineers. So what do you do instead? You ask candidates questions that are most likely to reveal insight into how smart they are. Rather than asking algorithm questions, you could ask domain-specific questions---and many companies do. But you shouldn't ask only domain-specific questions, unless you intend to restrict yourself to hiring candidates who already have extensive experience in the domain. (This would be an especially bad way to interview candidates for internships.) Fourth, I'd like to point out that interview problems are not intended to filter out people who don't do contests. Rather, if you are serious about contests, it's simply a nice side effect that your algorithmic problem-solving skills are probably far above the level of most interview questions. Most interview problems aren't intended to be as hard as TopCoder problems. It is true that many interview problems have optimal solutions that use structures like segment trees you will only encounter in contests and practically never at most companies, but you don't have to find the optimal solution in order to get the job. Your thought process is important too, and allows the interviewer to evaluate your intelligence. The best interview problems are the ones that can be approached in many ways and give the candidate a lot of flexibility and room to talk about their solution and how it can be improved, even if they don't manage to see the solution that runs in one second for N = 100,000. They should be hard enough to differentiate between smart and less smart candidates, while not being so hard that only a competitive programmer could make any reasonable headway. 