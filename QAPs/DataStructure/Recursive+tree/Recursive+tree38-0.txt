What is the logic behind finding ancestors of a node of a binary tree non-recursively?
I haven't gone through the post here. here are my thoughts though. It uses two stacks. current node = root 1. Push current node to stack A 2. Pop current node from stack A 3. Push it to stack B 4. If node pushed in step #3 has left/right child, push left child followed by right child 5. Repeat steps #2-#4 until stack A is not empty 6. Pop nodes from stack B one by one until you find Node X whose ancestors need to be found 7. Once X is found, start popping nodes from stack B one by one until its not empty. Now, here comes the tricky part on how to know if it is the ancestor of node X. We would basically backtrack the tree in down to top vertical tree hierarchy and see if current node is the parent of previous printed node in ancestor hierarchy. Makes sense? Don't worry. let us understand with an example: Lets say input tree is         1       /  \     2     3    / \  4    5       /     6 Lets say Node 6 ancestors need to be found: 1. Push 1 to stack A 2. Pop 1 from stack A. Push it to stack B 3. Push 2 and 3 to A 4. Pop 3 from A and push it to B 5. Since 3->left and 3->right doesn't exist, its a noop 6. Pop 2 from A. Push it to B 7. Push 4 and 5 to A 8. Pop 5 from A and push it to B 9. Push 6 to A 10. Pop 6 from A and push it to B 11. Since we found the node whose ancestor need to found, we stop ops from A 12. Contents of stack B are: 6, 5, 2, 3, 1 13. Pop 6. Print 6 14. Pop 5. Its the parent of 6. So, print 5 15. Pop 2. Its the parent of last printed node 5. print 2 16. Pop 3. Its not the parent of last printed node 2. Skip printing 3 17. Pop 1. Its the parent of last printed node 2. Print 1 As you must have seen, we have printed ancestors(including node 6) as 6, 5, 2, 1 Hope it makes you understand 