What is memoization?
Memoization is about saving the results of a function into a cache that is local to the function and looking it up from the cache instead of recomputing it when arguments are identical to a previous call to the function. One of my frequently used performance optimization techniques. Obviously, it only makes sense when your function body has no side-effects. Here's fully working code for a single argument memoization in Racket/Scheme. You use it like this: (define-cached (memo-fac n)    (if (= n 0) 1 (* n (memo-fac (- n 1))))) Here are the definitions: (define-syntax (define-cached x)  (syntax-case x ()    [(_ (fn arg) body ...)     #'(define fn (cache-lambda (arg) body ...))]))(define-syntax (cache-lambda x)  (syntax-case x ()    [(_ (arg) body ...)     #'(let ([cache (make-hash)]             [fail-value (gensym)])         (Î» (arg)           (let ([res (dict-ref cache arg fail-value)])             (if (eq? res fail-value)                 (let ([v (begin body ...)])                   (dict-set! cache arg v)                   v)                 res))))])) If you have multiple arguments, simply curry the function. 