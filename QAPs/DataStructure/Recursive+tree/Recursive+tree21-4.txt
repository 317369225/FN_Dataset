What is tail recursion? Why is it so bad?
Consider the problem of computing factorial of a number. A straightforward approach would be: factorial(n):    if n==0 then 1    else n*factorial(n-1) Suppose you call [math]factorial(4)[/math]. The recursion tree would be:          factorial(4)           /       \         4    factorial(3)        /             \      3          factorial(2)     /                   \   2                factorial(1)  /                         \1                       factorial(0)                                \                                 1    The maximum recursion depth in the above case is [math]O(n)[/math]. However, consider the following example: factAux(m,n):    if n==0     then m;    else            factAux(m*n,n-1);factTail(n):    return factAux(1,n); Recursion tree for [math]factTail(4)[/math] would be: factTail(4)       |factAux(1,4)       |factAux(4,3)       |factAux(12,2)       |factAux(24,1)       |factAux(24,0)       |      24 Here also, maximum recursion depth is [math]O(n)[/math] but none of the calls adds any extra variable to the stack. Hence the compiler can do away with stack. A tail recursion is a recursive function in which no computation is done after the return of recursive call. Many compilers optimize to change a recursive call to a tail recursive or an iterative call. 