What is memoization?
Let's say you have a recursive function f If f calls itself recursively in such a way that you might find have f called with the same argument more than once: def f(*args):  # do stuff  f(...)  # do stuff  return stuff Then you can store return values for f in a dictionary so it never computes the same results twice. memo = dict()def f(*args):  if args in memo:    return memo[args]  # do stuff  f(...)  # do stuff  return stuff Memoization is only really useful if you'll end up solving the same subproblem more than once so for example, it's nice to memoize the recursive fibonacci sequence. def f(n):  if n == 0 or n == 1:    return 1  return f(n-1) + f(n-2) into memo = dict()def f(n):  if n in memo:    return memo[n]  if n == 0 or n == 1:    return 1  result = f(n-1) + f(n-2)  memo[n] = result  return result Notice how f(3) needs f(1) but f(2) will also call f(1). It's completely useless to memoize something that'll only be called for a certain value once, like: def f(n):  if n == 0:    return 1  return 1 + f(n-1) You'd just be adding space overhead in the form of the dictionary to in addition to the stack space you're already using up. Note that some languages can optimize the stack for tail recursion. Some languages like Python will let you wrap up most general memoization into a decorator and make it really easy to use - PythonDecoratorLibrary - Python Wiki. In a nutshell, that's memoization, it's simply storing results of recursive subproblems so you don't recursively compute them. It's useful in top-down Dynamic Programming when it's easier to think recursively rather than iteratively. 