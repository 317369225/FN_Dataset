What is an intuitive explanation of Prim's algorithm?
The intuition to most minimum spanning tree (MST) algorithms is the cut property [1]. Let me illustrate that with an example. Understanding the Cut Property Let us consider a connected weighted graph G, with N vertices and E edges. Suppose we divide its vertices into two parts such that one part has N-1 vertices and the other exactly one. Now, any of the edges from that one vertex to the other (N-1) vertices can be used to connect the two parts of the graph. Since a minimum spanning tree covers all vertices by definition, that implies that it should also cover our lone vertex. Then, it is easy to see that any MST for G should necessarily include the edge with minimum weight between the lone vertex and the other (N-1) vertices. See why? Because if it does not, then we can easily replace that edge with the minimum cost edge and obtain a lower cost spanning tree. Once, we have this intuitive understanding, it is easy to extend it to any partition of the graph G. Say one part of the graph contains k nodes and the other, (N-k). Then, using the same argument as above, we can claim that an MST of the graph must connect these two components of the graph and do it in minimum cost, so the lowest cost edge will surely be in the MST. Designing the Algorithm Different algorithms for an MST can be designed based on the cut property.  The Prim algorithm, essentially, works by creating two components of the graph at each iteration and finding the minimum cost edge between them, knowing that such an edge has to be in the MST. This ensures that all the edges added using Prim's algorithm are edges of a valid MST of the graph. Prim's Algorithm: Choose an arbitrary node n. Initialize two sets, U={n} and V=G \ {n}.   Repeat for (N-1) steps: Choose the minimum cost edge (a,b) between U and V such that a belongs to U and b belongs to V. Remove b from V and add b to U. It still remains to be shown that the tree thus constructed is a spanning tree. Spanning: At each iteration, the algorithm adds a new node to the current tree  (which has 1 node initially), and we run the algorithm for N-1 steps.  Thus, N unique nodes get added to the tree. Tree: One intuitive way to see that the final graph is a tree is through induction. Consider the graph containing the first node; that is a tree of one node trivially. Then at each iteration, we add a new edge connecting the current tree to a new node. Each new edge consists of a new node, so there can be no cycles. [1] A cut (Cut (graph theory)) of a connected graph is a set of edges that divides it into two disconnected components. That's why the name. 