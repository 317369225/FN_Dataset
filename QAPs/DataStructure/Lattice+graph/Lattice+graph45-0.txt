How does one become good at solving algorithm/programming problems?
If you consider Bloom's Taxonomy in the Cognitive domain, you'll realize that deriving algorithms requires "synthesis."  Synthesis is the second highest level in the taxonomy, which means that it naturally comes after everything before it: Knowledge, Comprehension, Application, and Analysis. Right now, you seem to be good at attaining knowledge and gaining comprehension.  You seem to be able to apply what you learn.  However, you still have two levels of even higher learning in order to solve algorithm/programming problems.  You have to use analysis and then work towards synthesis. What does analysis include?  According to Wikipedia, it requires that you start to "break information into parts by by identifying motives or causes."  Have you done that with merge sort?  Do you know why we repeatedly break the original list into two parts?  Have you considered why the actions of merge sort lead to an [math]O(n \lg n)[/math] run-time?  Do you understand why you have to merge each sub-list together in groups of two?  Have you analyzed what properties hold true at each point in the algorithm?  Do you know why those properties must hold true?  Wikipedia says that with analysis you should consider elements, relationships, and organizational principles.  Once you've analyzed something, you will be better prepared to synthesize. You will be better prepared to synthesize because you will understand why John von Neumann designed merge sort the way he did.  Once you understand his design motivations, you will be better equipped to modify the algorithm to fulfill changing requirements. And that is the key to solving algorithm problems.  You first acquire knowledge of things like data structures / algorithms / paradigms / run-time analysis / proofs / etc.  Then you spend time comprehending how they work / what their advantages are / what their uses are / how they were derived / etc.  Once you've done that, you solidify your understanding by applying what you've learned.  Maybe you code a hash table up from scratch.  Maybe you implement an efficient solution to the maximum gap problem that you read about online.  Hopefully, you will spend time analyzing the things you've learned next.  Break them down into their parts.  Really understand them.  Understand the why in addition to the how.  Make them your own, as if they were your own inventions.  Know them inside and out. So then when you've acquired all of this information, you go back to the merge sort problem.  After you analyze it, you will understand that the power of the merge sort lies in the fact that you can merge lists by comparing two elements at a time in a linear fashion.  With the change in requirements, you can no longer compare two elements at a time in linear fashion.  Instead, you have to compare [math]k[/math] elements at a time.  Then you ask yourself, how can I find the minimum of [math]k[/math] elements in linear or near-linear time?  Good thing you learned last month that minimum binary heaps can do exactly what you need.  Then you ask, what do I need the minimum value of?  The first element in each of the [math]k[/math] lists.  So if we store the first value from each list in a minimum binary heap, we can just pop the minimum.  Then we think back to what the two-way merge sort did after it found the minimum.  It inserted it into a list and then moved the pointer along in the list from which the minimum value came.  How does that translate for us?  We can add the minimum to a result array.  We know which sub-list we extracted the minimum from, but what does advancing the pointer in that list mean?  It means a new number is now at the front of the list, which means a new number should be in our minimum heap.  So we put the next number in the heap and repeat.  That basic idea seems like it will work, and each time we do a [math]k[/math]-way merge of a list of [math]n[/math] items, it takes [math]O(n \lg k)[/math] time. As you can see, once you have a large corpus of domain knowledge, you will be prepared to synthesize.  Your mind will make connections between different algorithms and data structures that you know.  You will begin to connect constraints and patterns and paradigms.  Rarely does someone produce a masterful work without learning from the greats before him.  Look up to the great minds of the generation before us.  Read the writings of Knuth, Dijkstra, Rabin, etc.  Appreciate what they've done for the field... and then become inspired. Finally, a huge component of learning to solve algorithms is believing in yourself.  Really.  Take a look at You and Your Research. Good luck! Edit: I'm not implying that you must go through every stage in Bloom's Taxonomy before you can reach synthesis.  However, it is a natural progression and should make your job easier.  You can get lucky sometimes.  But it is better to be methodological. 