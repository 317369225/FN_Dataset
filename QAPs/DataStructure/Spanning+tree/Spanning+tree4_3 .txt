How do I get a second minimum spanning tree?Details with Example?If you're using Kruskall's algorithm, the second MST has only one edge different of the first MST (take one edge out of the first and add a new edge). You need to find which edge to replace to get the least amount of increase. Something like (pseudocode): Build first MST L = list of edges in the first mst, sorted by weight second_best_cost = INF for (i=0; i<L.size; i++) {  try to build a mst without using edge L[i]  if it's possible and its cost is < second_best_cost {  second_mst = the new found mst  second_best_cost = its cost  } } Since the first MST has at most V-1 edges and you'll create a mst (O(E)) again at each step, this runs in O(V*E). Notice that: 1) there may not be a second MST (in case the graph it's already its MST) 2) the 2nd mst may have the same cost of the 1st (in case you can remove an edge, but use another one with the same cost that wasn't being used before). If you need to have a second mst which cost is strictly more then the first, compute the first before, than on the "if it's possible" check, add a condition that it also needs to have cost > cost of the first mst. (Again, it may not be possible to find one). [Edits] I said Prim first, it's Kruskall. First answer was wrong as pointed in the comments, you need to iterate all the edges of the first MST, I was breaking after finding the first possible one. 