Why use ternary search tree instead of replacing every node of Trie to a BST tree?
The short answer is that sometimes constants do matter. From an asymptotical point of view, all trie variations have approximately the same performance: the amount of space consumed is linear in the total length of stored words, and the time needed to insert / look up a word is linear in its length. However, there is also one other parameter that sometimes matters: the size of your alphabet. Even though the alphabet size is often a constant, there is a difference between the constants 2 (your characters are 0 and 1), 4 (CGAT), and 95 (printable 7-bit ASCII). Additionally, there are some very specific situations where alphabet size is actually proportional to the total length of the input. Hence, it makes sense to consider the alphabet size (sigma) as a second variable when analyzing the time and space complexity of tries. For example, in your basic trie lookup time does not depend on the alphabet size, but space complexity does: it is actually the total length of all words times the alphabet size, because each node stores O(sigma) pointers. Many uses of tries are in environments where memory consumption is the bottleneck. The lookup is fast enough by a wide margin, so you can go for a trade-off: slow down the lookup slightly but save a lot of memory. In some cases (e.g., when this helps to fit your entire trie into your RAM) this trade-off may even lead to a better practical performance. Probably the most extreme way of doing this trade-off is the left child / right sibling (LCRS) representation. In this trie, each node only stores two outgoing edges instead of sigma. E.g., if your vanilla trie contains a node A with children B, C, D, E, in this representation A's left child pointer points to B, B's right sibling pointer points to C, C's right sibling is D, and so on. In these trees, lookup slows down to O(sigma * word length), but space complexity no longer depends on sigma. The ternary search tries are further along this trade-off spectrum: they can be slightly faster, but their memory consumption is slightly greater. (More precisely, space complexity still does not depend on sigma, worst case for lookup is the same as in LCRS tries, but the average case for lookup is O(log sigma * word length) if the words were inserted in random order, and this can even be made into a worst case if the trie is static.) Your proposal is to store a balanced BST of child links in each node of the trie. This is even further down along the line. Your memory consumption still does not depend on sigma but you are wasting more memory than in the previous solutions -- the constant factor is worse because each BST has a bunch of additional NULL pointers. Lookups will be good, roughly as fast as in an optimally-constructed ternary search trie, but insertions can actually be slower in practice: the overhead of balancing a node can easily be more than the time needed to find and modify the right place by simply following a few pointers and then changing them locally in constant time. I cannot really imagine a situation when this particular implementation would be desirable. Additionally, for most usages of tries the order of child nodes actually doesn't matter, and you are better off using a small hash table instead of the BST. Anyways, the purpose of all these variations is to have a choice. Analyze your situation, discover what the bottlenecks are, and choose accordingly. 