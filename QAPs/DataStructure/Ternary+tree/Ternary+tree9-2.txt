What is meant by the complexity of O (log n) in this case? (picture related in question detail)
Here is how I was taught big-O notation in university. Imagine that we have some magic function that can tell us exactly how long a particular algorithm is going to run. We'll call it [math]T(n)[/math] (T for Time), where [math]n[/math] tells us some useful thing about how much work the algorithm has to do (in this example, it's the number of elements in the binary tree). In practice, T is usually a very complicated function, and is going to vary by the clock rate of the CPU, the speed of the memory, and so on. None of that is usually relevant to algorithm design, and it complicates discussion, so Big-O notation was invented. It refers to the "order" of the time function, meaning it's class or type. Formally, to claim that a particular time function is [math]O(f(n))[/math], then there must exist some constant value [math]k[/math] such that the following relationship is always true: [math]T(n) ≤ kO(f(n))[/math] Now if you think about this a bit, it might strike you as a bit odd. Couldn't we just set k=one-zillion years and claim that our function is therefore [math]O(1)[/math]? But in fact you can't do this; because the execution time grows with the value of [math]n[/math], we can eventually find a value of [math]n[/math] large enough to prove that our search cannot be [math]O(1)[/math]. To address your specific question, the search time of a binary tree is logarithmic because the height of the tree is logarithmic on the number of elements in the tree. So with the right constant factor, you'll have a reasonable upper bound on the search time for the tree. This algorithm is also bound by [math]O(n)[/math] and [math]O(n^2)[/math], but these functions are not a tight bound on the execution time, so it's less useful to say this. If the tree is unbalanced, then it is possible to arrange all your elements in a long line, for example by filling out only down the right side, and leaving all left children empty. In this case, searching the tree is only bound by [math]O(n)[/math], which is much worse! Writing balanced binary tree algorithms is a pain, but is usually considered worth it because of the improved running time. It's worth noting that Big-O notation is more of a theoretical idea, because in practice computers have limited memory and there is a true upper bound on the input data size they can handle. The whole concept makes a great deal more sense if you think in terms of Turing machines, which have infinite memory (and crappy I/O). Updated 36w ago • Asked to answer by Anonymous