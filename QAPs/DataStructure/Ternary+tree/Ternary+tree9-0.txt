What is meant by the complexity of O (log n) in this case? (picture related in question detail)
Your notation is a bit wrong. Log is relevant to the specific base. I.e. in your sample you're using a binary tree - i.e. base 2. If it was a ternary tree it would be base 3, and so on. But let's stick with binary since it's easier to grasp, and exactly what the example calls for. That would mean the tree's height is a function of how many items are inside it. So the formula is actually: [math]\log _{2}(N)[/math] In your drawn example there are 15 items in total, so N=15, base=2. And as drawn the tree's height being 4 (i.e. 4 levels of the tree). Now let's do the math: [math]\log _{2}(15)=3.906891\approx 4[/math] Usually you tend to take the upper limit to the closest integer, since a real fractional number for "count" makes llittle sense - you can't have 3.9 items, you can only have 3 or 4. So the function is rather more precisely: [math]\lceil \log _{2}(15) \rceil = \lceil 3.906891 \rceil = 4[/math] BTW: Your drawn tree is not correct if it's supposed to be a BST. E.g. node 66 is in the wrong place or has the wrong value. It's greater than node 60 so shouldn't be on the left branch from there. Edit: Note though ... when working with Big-O notation for algorithms and data structures, you tend to ignore the detail. Especially since you seldom know the N before hand it doesn't help that much to make it too precise. And the purpose of BigO isn't to calculate the exact time / space needed (that can much more easily be done through a test). Rather it's meant as a means to compare one alternative to another using a broad measure. Thus even if you use a different base the bigO would still read O(log N). Think of it as reading: To the order of log N, not as log N times. Also as commonly used bigO tends to show the average instead of the worst case. E.g. in the sample given the "average" height is somewhere between 3 and 4. So calculating such exact doesn't really help that much. 