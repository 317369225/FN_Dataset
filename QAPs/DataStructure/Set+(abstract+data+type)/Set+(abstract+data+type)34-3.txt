What should every programmer know about functional programming?
Everyone should know the immensity of development and (especially) debugging time and effort saved in programming in a declarative style, i.e. one that minimizes side-effects. In my professional experience (as a software developer), I'd estimate that as much as 80-90% of my time has been spent analyzing and debugging stateful programs, and I don't imagine that it's much different for Joe Random Programmer. That means that so very much of my life has been spent doing the following sort of work: Let's say we're maintaining some gigantic pile (I think that's probably the most accurate word) of enterprise software, and a customer has filed a bug about some list of foo being backward. The product is gigantic, and therefore it makes use of horrifyingly complex data structures -- most of them likely excellent ideas to begin with but which have been kludged into solving problems they weren't meant to because it's easier to write hacks than to refactor. Anywho, the process which generates the list of foo consists of roughly a dozen phases which massage some internal dataset of foo into several intermediary forms before producing the final output to be exposed to the client. These phases are controlled by dozens of control variables which are set, cleared, modified, and interpreted in different ways in different logical branches in each phase. So we need to track down why the list of foo is coming out backward. We discover that the order of foo is influenced by control variables bar and baz. So now we get to look backward through the entire process to learn why bar and baz have the values they do, and try to determine at what point it's best and/or safe to expect that they have values which would put foo in the correct order. Turns out bar is influenced by control variables qux and quux, and baz is influenced by the same qux, as well as corge and grault. We find at least three places where we could make the right checks to set bar and baz, but one of them requires qux to be two different things simultaneously, one of them forces corge to be in a state the program won't be ready for for at least 3 phases down the road, and the last one has a comment like "I know this is a hack, but everything breaks if quux is not ([[{},{}],[qux*10,MAXINT],true,true,false]) here" which you quickly verify to be painfully accurate. You describe your findings to one of your superiors, but of course he hasn't looked at that code for at least a year, so all he can give you a sympathetic shrug and ask you to do what you can. You decide that the only feasible way to address the issue without rewriting 40% of the multi-million line codebase is to introduce another control variable, garply, which has semantics you never document anywhere outside your brain even though you totally meant to when you started making your changes. You think garply is only needed in two of the twelve phases, but you turn out to be wrong and have to write garply into about four more, each time making tiny refinements to its semantics, and you begin to lose track of which assumptions you were still using in each of the places you decided to involve garply. You run into several extremely delicately-composed conditional statements which you can't adjust in the slightest without breaking everything, so you work around them. Your changes need a handful of statements to be in a different order, but find out the hard way that another developer's changes depended quite strongly on having that particular ordering, so you have to work around that, too (perhaps changing garply's semantics a bit more and/or necessitating the addition of another control variable, waldo). You need to run some functions on grault, but they turn out to be destructive, so now you add a snapshot of the original value of grault somewhere in garply and scatter a couple dozen extra lines throughout the codebase that transform it in the same way whenever grault is. This "trivial" ordering bug has now taken you about 4 weeks of staring in bewildered, impotent rage at state dumps (a printed snapshot of all the control variables), and its result (or side-effect, if you will) besides fixing the problem (outside of several hundred edge cases) was to compound on the problem with your own horrifying complexity which you and the rest of the development team will have to take even more special care to work with (or around). This is what you subject yourself to in the long run by allowing your program flow be dictated by state. This does not happen when you or the language you use encourages you to use a declarative style, which many functional languages do. You will never have problems arising from pesky control variables, statement ordering, destructive functions, or functions with unexpected side-effects. In my hobbyist and professional experience, debugging functional programs is several orders of magnitude more straight-forward and less sanity-eroding. And that translates into time and energy savings to you, freeing you to put your brainpower to more meaningful use. And for bonus points, writing in a declarative style makes the program much easier to parallelize in the future, since there is no state to pass around, synchronize, or share. Updated 116w ago â€¢ View Upvotes