What do C/C++ programmers know that Haskell programmers don't?
Disclosure: The lion's share of my experience is C++. I apologize to any Haskell programmers for any mistakes I make about Haskell. Freedom. No, not 'Murica Freedom or Lisp macro magic freedom. I mean the scary anarchist wet dream freedom. There are things we do as low level programmers that would give other languages the heebie jeebies. Haskell's strong type system, for example, does a lot to prevent the programmer from making mistakes and allows programs to be built from first principles. Of course, these ironclad principles can be overcome through Monads (or Macros, if you're a LISPer), a typical Haskell programmer won't unless it must be done. This allows the programmer to reason about their programs before writing them. It's important to remember that C begain it's life as a universal assembly language. Much of it's design is informed by how theoretical processors and memory works. For example, we can circumvent the entire type system and convert one type to another with an explicit cast. "Why would you do that?!" I hear you. It sounds dangerous and stupid, but as low level programmers we think in terms of memory and how it's laid out. This allows me to build systems with some memory layout constraints that I can peek into to discover the contents. Binary file headers a great example of this style of memory mapping. Another great example of flogging the type system is the Fast inverse square root found deep in the Quake III code. It manipulates the raw bits and requires a deep understanding of how each variable's memory is laid out. The Union keyword is specifically designed to allow the same memory space to be used by two or more different types. It's used when we need to look at the memory in various different ways depending on a problem space. I've used this concept to build 3D matrix information. I would have one large array for the whole matrix, two arrays for accessing the coordinates and orientation, and another set of arrays for easily SIMD access. Same memory, different ways to access the data. In embedded systems, we don't have the luxury of the OS or other software, so we must be able to read and write to raw memory addresses. Think about a portable game system, like the original Game Boy. It had a raw memory space that put pixels on the display, buttons were hardware ON/OFF switches that mapped to memory points, and of course there was the small memory space for your game to run from. All these things existed as raw memory locations we could address and read/write. To see if a button is pressed, we needed to ask the hardware memory what value they have stored. Speaking of memory, most Haskell programmers don't have to worry about their program size. In many applications, especially console video games and embedded hardware, memory is precious and must be carefully maintained so we don't go over the system's limit. If we did, then (at best) the whole program crashes or (at worst) it may break the hardware! Haskell's immutable types rely on an abundance of memory to make their transformations and copies. This is a good thing, since we don't like thinking about memory, but this makes it very hard to control how much and where your memory is used. This freedom with memory allows many clever tricks. Many large game studios have a libraries that allows them to replace the default memory allocation in C++ to a custom management module. This allows for controlling how much memory is allocated, where it's allocated, when to change out memory and hook debug tools. Yes this is pretty standard GC stuff, but when you need to pry out as much performance and visual detail that modern gamers demand, then you need the fine grain control of how your GC works. It's also a publishing requirement. If your game goes over the limit, Microsoft, Sony, and Nintendo WILL prevent your game from being published. Oh yeah, if you are working cross-platform, you better believe you need to switch how your GC runs to be performant on the target system. Throw in computers and you have four different memory restraints, thus need four different GCs. These are specific examples of why you would use some seemingly crazy features of C/C++ that Haskell programmers likely won't need to see. All of these come at a cost of complexity, program length, and difficult code. Most people don't need that kind of raw freedom. I don't think is means X programmers are more grizzled/knowledgeable/serious/heroic than Y programmers. Writing code with intentional side effects in Haskell, like writing to a database, is convoluted magic sometimes. Other times you can reason about your program incorrectly, making your entire application bunk. We might have different scarring because of our exposure to different problems (e.g. C++ and manual memory management), but it doesn't make them better or worse. Only different. 