Object-Oriented Programming:Â In layman's terms, what is the difference between abstraction, encapsulation and information hiding?
In OOP terms, abstraction takes place in the messages that are passed between objects. More concretely, this is established through creating interfaces. What I find with some of the other answers is they conflate an interface with encapsulation. I think that's the wrong way to look at it. An interface represents a consistent system of behavior, but it does not go with a particular kind of object. The powerful concept of OO is to think of objects like they're computers, with the principle that any computer can emulate any other computer. Interfaces are like data protocols between computers, with the expectation that if Object A uses an interface to communicate with Object B, which uses interface C, Object A should be able to expect the same behavior, as far as it's concerned, using the C interface with B as it would using the C interface with another Object D (assuming D implements C as well). To use Jack Menendez's example, if you have an interface that features methods for Open and Close, we could generalize the concept to "Portal," or something like that. This way a Door object could implement Portal, but so could Refrigerator, a CarDoor, or even a Manhole, but Portal is understood to be an interface, representing a consistent system of behavior to which classes can subscribe. Each class provides its own implementation of that interface. Re. encapsulation and information hiding I guess there is a distinction between them, but again, I see it differently from the other answers. I think encapsulation means that you never, never, never expose implementation to other objects. Information hiding means that the behavior of the implementation of the interface is consistent. You do not want an object that's using another object to have to worry about the state of the other object. This means it shouldn't have to think about how the object it's using is going to behave differently depending on what state it's in (that's information that should be hidden). This ties in intimately with the goal of abstraction. With encapsulation, implementation details can be shared within a class hierarchy (from base class to subclass(es)), but never with objects not associated with the same class hierarchy. With information hiding, if you notice that there's a necessary behavior change in a class, once an object instance reaches a certain state, that should indicate to you that the class needs to deliver a reference to an object with a new interface that reflects the new behavior, when behavior needs to change. Interestingly, the "new object" that's delivered may be of the same class type, or maybe even the same instance, just with a different interface (this is where encapsulation is important, since you're hiding the implementation of how the new interface is delivered). The point is the programmer understands, through this interface change, that behavior is changing. I want to clarify with information hiding, and consistent behavior, that this does not mean that the implementation has to be exactly the same across classes for the same interface. What it means is the behavior that an object using an interface expects needs to be the same. If implementation of the interface, in a class, is exposed, or a state change in an object instance changes its behavior, the whole purpose of the abstraction is defeated. The consequence of this is that objects using the interface to communicate with other objects cannot count on consistent behavior with it, and so objects will have to test for the types of objects they're holding, and they'll have to either test an object's state before proceeding, or they will have to make assumptions, based on an object's type, whether an object's behavior is going to change. They'll have to say, "Even though I know this object has X interface, I need to know if it's really an A object, or a B object." That's what you want to avoid. I may be getting ahead of what you were asking, but in OOP there is this important idea of "programming to an interface." A best practice I've heard of for enforcing this in popular languages is to use what's called a "static factory method" in conjunction with what's called a "private constructor" in a class. I'm thinking of C++, C#, and Java for this. Ruby programmers may have a different way of doing this. The factory method is a public static method that returns an appropriate interface type, and calls a constructor in the same class that is private, to create an instance of itself. This way, any programmer that uses the class is forced to use the appropriate interface type, instead of the class type, when declaring a reference/pointer to a new instance. 