What should I do/learn next?
Here is your checklist: 1. Test-driven programming. Design the code, write the tests, implement the code to meet the tests. 2. Unit and Integrated Testing. Test every component and collection of components to make sure they behave correctly (ie: don't crash or give false answers) for valid, invalid and extreme data values. 3. Learn functional OR stack programming, it doesn't matter which. 4. Learn about Abstract State Machines, Abstract Data Types and either Algebraic Petri Nets or Coloured Petri Nets. 5. Learn about futexes, mutexes, semaphores, channels, spinlocks, barriers and deadlock prevention. 6. Using 3, 4 and 5, develop a parallel program spanning multiple processes to simulate the individual components of some non-linear piece of machinery. One piece of hardware runs on one process. Transmission of energy and momentum via channels. One-way channels should be client-side. Two-way channels should be peer-to-peer. Everything must be kept synchronized, as it would be in the real object. Behaviour should remain absolutely consistent no matter how individual processes are prioritized or optimized. Submit this as a prototype for review on github or one of the gforge forks. 7. Learn the CERT guidelines for secure programming in C. 8. Take any existing small security-oriented open source project and test against CERT first, then perform unit and Integrated testing as before. Fix identified security issues and create patches. One issue, one patch. Document why it is an issue and why the patch fixes it. Submit the individual patches for code review/installation by the maintainer. 9. A real-time program is guaranteed to run at a precise time for a precise amount of time. Because the windows are typically very short, lots of setting up and tearing down state isn't possible. You want to get the most done in very little time. Real-time programs are often found on embedded systems where memory is limited and crashes are bad. Write a program that handles its own state, uses no heap memory, can recover gracefully from errors, can run with no user intervention for prolonged periods (ie: no cumulative errors) and can do something that is non-trivial. It doesn't matter what. 10. Test your embedded skills by writing an Android/Kindle app that requires least privileges, runs reliably on a range of devices when switched to/from, closed in unorthodox ways, and also left running for a week, which is non-trivial, which is highly responsive (though not necessarily real-time) and which is resistant to misbehaving hardware from less reputable vendors. Publish it on Amazon Store and Google Store. Once you've completed this checklist, you will know formal methods, functional/stack programming, parallel programming, client/server architecture, peer-to-peer architecture, real-time systems, software testing and one form of extreme programming. You will also be on the credits of two projects (your own and the one you sent bug fixes to). You will know when to go in heavy and when a lighter touch will do. You may have learned one or more style guides. That's the bulk of the first two years of a software engineering degree, if not to the same depth then to the depth that's useful in practice and perhaps greater depth in important areas like getting the code to work right. With that under your belt, particularly the established credit, you've currency on the market. To use the metaphor of belts, most who complete a university degree have only basic understanding. They're ready to move on from being a white belt, but a BSc/BS degree is too lightweight. Complete these ten steps and you will have proven your ability to apply that knowledge three times, which is nominally green belt status. However, it's a little better than that. Multi-paradigm thinking is tough, multi-domain thinking is no easier, and it takes a lot to understand formal methods. Programmers are usually lousy at testing and following programming protocols. I think it would not be unreasonable to suggest that a novice who has accomplished all this has merited the red belt, although one could argue that it takes a lot more practice than indicated here. Google is known to hire the best, but I doubt they've more than a handful of black-belt coders. Even for such companies, green to red is sufficient. However, a ten step thinking course isn't going to get you into the giants. You will need academic qualifications (which you should sail through after this) and maybe a research masters (MPhil in the UK). At that point, you've credibility in the programmer world, credibility in the academic world and a lot of very useful skills. 