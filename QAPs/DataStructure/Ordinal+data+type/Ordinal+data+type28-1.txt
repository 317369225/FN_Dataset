Can you explain to a beginner what object-oriented programming is?
I'll try this out. The way I usually explain it is that you have the data grouped in memory and the methods are really just functions that the compiler enforces restrictions on usage. The best way to think about methods is that the data is passed in the first parameter and the reference is usually called 'this'. That isn't a simple answer as it assumes you understand what a structure or what data grouped in memory is usually called. I think I like using C for explaining object-oriented programming. Mostly for the enjoyment at annoying pedantic, "But, that ignores almost everything about object-oriented programming," Yes, yes it does. Structures If you don't know C or what a struct or structure is, then it usually looks like the snippet below. type Example struct {    X float32    Y float32    Z float32} Example now defines a group of floats named X, Y and Z. These technically have no relevance except to the programmer. The compiler will replace the named reference with the offsets to the position in memory. The compiler (or programmer) will allocate memory of 12 bytes. So each Example in memory will be at least 12 bytes. Cool. You can then say that there is little difference between the below snippet and the above structure. public class Example {    public float X = 0.0;    public float Y = 0.0;    public float Z = 0.0;} Methods Methods in object-oriented programming languages usually means that you are creating a function that is restricted to the class. I'm going to switch to Swift for the following examples. struct Coordinates {    var X : Float = 0.0    var Y : Float = 0.0    var Z : Float = 0.0}func display(coords : Coordinates) {    print("(\(coords.X), \(coords.Y), \(coords.Z))")} Is equivalent to the below struct Coordinates {    var X : Float = 0.0    var Y : Float = 0.0    var Z : Float = 0.0    func display() {        print("(\(self.X), \(self.Y), \(self.Z))")    }} The compiler in most cases will output object code like the first method example. If we are talking about languages which allow for overriding methods, which to be honest is all of them, you will have a pointer in the structure pointing to another structure containing function pointers to all of the functions in memory. If you were implementing this in C, then you would either have the function pointers in the same structure or a separate structure with the function pointers. Doing this, you can replace the functions or methods when other classes extend another class and override the parent class's method(s). Some languages might simply update the reference to the other method that was override instead of using the original reference. This prevents the need for storing a virtual table. Interfaces Interfaces are entirely a language construct to further restrict class details and provide a way to specify a contract for methods that accept just an interface. So that you can say that if a class implements an interface, that it can be passed to any method or function (if those are allowed) in the language. You can even say that properties or attributes can be an interface instead of an class. This in a way loosens the reference to a specific class throughout the code allowing programmers to pass new classes that implement an interface. This prevents having to modify the original class. Objects Objects are references to groups of data or structures or classes in memory. Object-Oriented Programming The meat of OOP is the relationships between objects. Separating out the processes to their reusable parts. Using patterns to develop smart coupling and cohesion between classes. If you do this correctly, then the library just flows and parts of libraries can be reused outside of the rest of the library. The hardest part is programming the coupling between components and having proper cohesion for components. It is too easy to call outside a component to another component in the library and start using another component's classes, instead of switching to an interface and providing another class to communicate between components. Beyond what objects are, the hardest part of learning OOP is how to properly define the relationships and developing classes correctly, so that they are reusable. 