In reality, which is better: one size fits all database or polyglot persistence?
I think it's important to note that "polyglot persistence" is not about having multiple homogenous storage/datbase backend systems (sharding, for example) ... but rather about having different types of backend for different types of data. For example eschewing the use of BLOBs in an SQL/RDBMS for storing pictures, videos or binaries ... using the DBMS only to store keys which lead to the primary store for such data. The phrase seems to have arisen from Martin Fowler's extension of a colleague's term "polyglot programming" ... applying the concept to data storage/management, in contrast to source code and programming language usage within an enterprise. So the question here basically boils down to: "Does it ever make sense to store different sorts of data in different backend systems, in a large enterprise?" And the fact is that most attempts to store *everything* in any one type of system pose serious challenges.  The most obvious examples relate to BLOBs ... but also to artifacts of the source code management and development process.  I don't know of anyone who seriously tries to maintain source code revisions as part of their SQL data corpus.  Practically every enterprise uses various different source code revision control suites for various legacy projects (CVS, SCCS, Perforce, git, BitKeeper, and so on). As you point out such polyglot policies inevitably lead to integration issues --- certain types of data cannot be represented as a "query" (suitable for one backend system) or even as a "map-reduce job" (suitable for one cluster) ... but have to be expressed, maintained, and executed as complex procedures involving multiple different back end systems. Attempting to audit or recreate any results in any such system is even more complicated as all logging and updates to them happen both asynchronously and generally without any sort of comprehensive co-ordination. Updated 113w ago