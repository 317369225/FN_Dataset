How would you design a perfect Computer Science bachelor's degree?
I'll design an over specified and overly general degree, but a rather complete one to produce a well rounded computer scientist.  Since computer science is currently the amalgam of the mathematics of codata, programming, and computer engineering, every semester should have at least one theory, one systems/programming class, and one math/apps/ece class. This will also be a language agnostic course - I don't want to play favorite languages (although I will play favorite paradigms).  I'm also designing this around a semester system and not a quarter system, since this is what every school I've been to has had. Freshman Fall: Get some prerequisites out of the way. Physics w/ E&M:  this is necessary and helpfull towards learning (really learning) any ece, graphics, physical simulation, and even some aspects of computer vision. Linear Algebra: The linear algebra should be about proofs.  You don't have to multiply matrixes by hand, but linear algebra comes up over and over in pretty much all aspects of everything.  Its also good to get used to proofs early. Intro to Discrete Math & Theorem Proving: required to begin the theory track.  most people don't even know that this is a subject until they take it, thus it needs to be taken early. Functional Programming Language of Choice (haskell, ml, lisp, python?, prolog?, ruby?, javascript?): It has been shown that people learn functional declarative languages better if they are taught them as first languages.  These languages also tend to have great libraries for creating things. Communication for Computer Science Majors: I don't mean how to write technical papers here - I mean how to say things in general in a beautiful fashion.  Freshman Spring: now prepare for research or first internship. Algorithms & Data Structures: the next step after discrete math.  This should cover an assortment of data-structures that have proven useful time and again, as well as how to create algorithms using them and how to analyze runtime of algorithms.  Systems Programming Language of Choice (fortran, c, c++, basic, assembly?): This is a computer science track.  If you can't handle the system, don't be a cs major. Theoretical Computer Science Survey: complexity theory, computability theory, automata theory, graph theory, number theory, programming language theory, group theory, computational geometry, formal languages, combinatorics.  It should spend a short amount of time on each.  Introduction to Computer Engineering:  circuitry, a bit of materials science, tabled logic, organization and archetecture of a computer, organization and architecture of a chip. Creative Writing: It's often been said that programming and writing are very similar pursuits.  It follows that strengthening one will benefit the other.  Also, this is great stress relief during such a difficult semester. Sophomore Fall:  Start getting some specifics. Intro to Computer Systems: anything which gets you to be able to read and write x86 assembly, and write in low level C.  A perfect version of this would also introduce Verilog and thus mix in a little computer engineering. Combinatorics:  You can't really be good at analyzing algorithms if you don't know a bit more than the basics in combinatorics. Programming Languages & Software Engineering: A class in languages like Java, Scala, C++, Fortran, and Haskell designed to get you to write maintainable code in languages designed for giant projects.  At the same time it should introduce you to concepts like frp, mvc, visitors, oop, actors, refactoring, separation of concerns, reflection, and encapsulation. Management, Leadership & Entrepreneurship: Again, a class in communicating with the world.  What use will it be if when you leave the degree, you can not talk to humans.  Pretty much all successful people end up at some point or another being tasked with managing other people on a project (you can't even escape this in academia).  It will also help you when you are looking for job. Sophomore Spring:  Things get difficult. Complexity Theory: This is a good theory class to have early on.  Taken write, it puts you in the perfect problem solving mentality for solving interview questions. Distributed Systems, Networking: The internet is not escapable as a computer scientist.  It is both invading theory and industry. Programming Language Theory: Haskell, ML, Prolog, Lisp.  This should teach about proving properties of languages by recursion, about logic programming, and about functional programming with patterns. Economics:  Its really a shame if you get into the world and don't know a thing about why you are getting paid what. Junior Fall: Winding up. Data Mining/Databases: there is a very high chance that at any software job you'll end up querying a database.  Computational Geometry: ties in well with data mining. Probability & Statistics for CS majors: while you're doing some linear algebra, why not also do some other continuous math. Computer Security:  Crackers are actually everywhere.  At some point somebody is going to try to break into your servers.  Keeping them out could save you millions.  20th Century History:  Ideally one that focuses on technology.  I'm honestly not much of a fan of history, but it's nice not to offend professors or bosses with faulty facts. Junior Spring:  Some depth is needed. Abstract Algebra & Number theory for CS majors:  the relationship between these subjects and automata theory & cryptography & each other. Operating Systems:  This doesn't need to be writing a kernel.  It would be good if you came out of this class having written at least 2000 lines of C & assembly with a partner & learned how to write a driver. Machine Learning & AI: Again, an extremely useful and prevalent subfield of computer science. Computational Finance: Every free and working person in a capitalistic country should know some finance.  Its just a perk that finance can be made computational for computer scientists. Senior Fall: Winding down. Computer Graphics & Interface Design:  I see no non historical reason these should be separate classes.  Eventually you're going to encounter a user.  And eventually you will have to display something Automata & Recursion Theory: This stuff is just cool.  Computer Algebra/Automated Theorem Proving:  One of these might save your life.  The first is a great refresher for linear algebra and multivariable calculus, the second is a great refresher for programming language theory.  Psychology: You can't trick a person if you don't know how they think.  This will benefit your front end facing programs, as well as your ability to interact in the work place, as well as your home life. Senior Spring:  Partying. Compiler Design: Again, this doesn't have to be an overly difficult class.  It's often useful to know what you need to optimize in your code and what you don't, even if you never write a compiler.  Its a good idea to learn how to take advantage of garbage collector. Natural Language Processing: this subject can be used from essay analysis to search engine statistics. Graph Theory/Game Theory/Set Theory/Category Theory: These subjects translate well to other fields and are mostly very interesting. Philosophy: Take this last so you aren't tempted to switch majors. 