How would you design a perfect Computer Science bachelor's degree?
Although this is a pretty skewed question, since it was A2A'ed by a friend to whom I've quite frequently complained about the curriculum, it is really a moral obligation for me to answer this question. Nevertheless it is important to note that the design of a curriculum is more or less a personal decision, or should be one, guided by self-interests and aspirations. It would be a wrong thing for anyone to force a particular form of academic syllabi over someone who might have his own ideas and purposes for education. So my answer more or less only reflects what I would suggest an aspiring CS Major to opt for among the various courses he can take. Nevertheless, as a matter of personal taste, it could be possible that my answer looks biased towards theory, but that is so because I would promote the teaching of principles and insights above training in tools, since it is my belief that education should deal with more permanent ideas. Also, I'll probably be more traditional in modelling courses around major texts, rather than online resources et al. First Semester : 1) Discrete Mathematics Foundations (Sets and relations), Combinatorics, Graph Theory, and Style of Mathematical Thought (proofs et al.) are some of the most basic requirements to work in any technical field as mathematically oriented as computer science. Some balance between portions of Discrete Mathematics and Its Applications (Kenneth Rosen) and Discrete Mathematics (Richard Johnsonbaugh), would be sufficient content, with the addition of problem solving material form various sources. Also I would suggest an approach where Well-founded induction and consequences are discussed in detail, since its not quite an understatement that "Proving in computer science is equivalent to applying induction". 2) Unix Way of Doing Things Familiarization with Linux shell, and the Unix Philosophy. No matter how many different varieties of UI spring up, it is essential for all computer programmers to look at things from the view of a true hacker. Important aspects like Shell programming and Posix systems, are not only are important as features, but their use itself offers a perspective quite deep and revealing about computation and system organization. 3) The Art of Computer Programming I would personally go all out in the Knuth way of introducing everyone to programming and the algorithmic way of thought. But surely flexibility in the model of thought has to be exercised, for the aim of TAOCP is not to teach how to program in assembly like code, but is to teach the modelling of solutions by breaking down of problems. 4) Digital Logic and Processors When George Boole came up with "The Laws of Thought", it might have sounded an exaggeration of sorts, but in hindsight all forms of computing devices that have been made or will ever be made in near future will work on Boolean algebra only at a fundamental level. The study of Combinational Logic circuits, Sequential Logic circuits and design of digital processors is an extremely important aspect of CS education since it helps understand the very atoms of digital design. I personally find Digital Logic & Computer Design by Morris Mano a good text, but there could exist various alternatives. 5) Discrete Dynamics Since all computation is part of a process, and since the concept of process precedes that of algorithm (an algorithm is merely a process whose outcome can be read in some meaningful way), it is important to understand processes in a logically consistent and flexible way. Various mathematical concepts such as invariants, monovariants, and fixed-points are central to computer sicence and can be well understood by Iterations and their dynamics. In fact much of computer programming, thanks to denotational semantics, can be brought down to fixed-point operators. But also this can help understand discrete dynamics in a way where various properties, such as share memories, or realtime input, etc can be well modelled. Second Semester : 1) Data Structures A course in data structures is essential in moving to advanced topics in computer science. Also it has recently been a trend to incline the data structures course naturally towards concurrent data structures, which is something that is good for a learning programmer. 2) Computer System Organization This is a standard CS course, usually discussing ARM or MIPS architectures, and although a lot of alternatives can be proposed, there wouldn't be much of a difference in the content as long as important concepts such as Pipelines, Cache, etc. are discussed. 3) Number Theory and Algebra A typical Abstract Algebra course, with a lot of Algebraic Number Theory done too. Concrete Mathematics (Knuth), any standard textbook in algebra like Abstract Algebra: Theory and Applications or Algebra (Michael Artin), along with a good problem source (such as those of Putnam) would be excellent content for course, even if only the basics are covered. 4) Software Foundations/Structure and Interpretation of Computer Programs It is extremely important for a CS student to know how to program, and that does not mean so much to learn a lot of languages and tools as much it means to have a decent understand of programmatic structures and paradigms. I personally believe that Structure and Interpretation of Computer Programs can offer a very good introduction, if complemented with introduction languages mentioned by Norvig, quoted here. 5) Formal Methods and Theory of Computation Automata Theory, in pure classical way. Doing automata theory after having being introduced to State diagrams in Digital Logic, is the logical next step, and automatons should be introduced in a way largely free of complexity theory developments et al. In more or less the form Auotmata was known to Kleene or Turing. Introduction to Automata Theory, Languages, and Computation could do great if only done judiciously. Automatons offer an implementation-agnostic view of computational processes, in a way that behavior of the machine can be analyzed tractably. Third Semester : 1) Algorithms and Theory of Computation A survey on the techniques in the Design and Analysis of Algorithms, is obviously a must. I personally believe, that although any content can be covered here, what remains essential is the principles of design of algorithms and problem-solving that remains the focus. 2) Symbolic and Higher-Order Computation This probably the only course where I'm forced to keep language-agnoticism aside, since Lisp happens to be the only language that allows to think in unthinkable ways about recursion and software design. Meta-circularity, code as data, etc. are some concepts that are easily manageable with Lisp. The course should largely explore the works in symbolic systems, such as those done by AI hackers of the MIT AI Lab days. And it should be sufficiently good introduction to writing good software and understanding symbolic computation. 3) Real Analysis A basic course in Analysis is a must for any STEM undergraduate, and especially for Computer Scientists, a course on calculus and real analysis is essential to stay in touch with the world of continuum, away for discreteness. 4) Philosophical and Theoretical Foundations of Computation How Knowledge and Observation form some of the foundations of Computation, Cryptography, and Physics. Probably part of the course could cover Quantum Computing since Democritus (Scott Aaronson), with the rest of the course could discuss works of Russell, Whitehead, Smullyan, etc. Things like Turing's Ordinal Logic, to Godel's Incompleteness Theorem, and Tarski's Undefinability Theorem, should be discussed. And part of the focus should also be at how the philosophy of information lies at the center of fields like Quantum Mechanics. 5) Data Representation and Query Languages Basics of Relational calculus, relational algebra, and SQL can be taught to give a general view idea of set-theoretic computation and the power of logic in design of queries. Foundations of Databases can be used to introduce the theory around expressive powers of data representation or query languages. Once the Core is done, a lot of electives should be offered, which can ordered in the curriculum as per the convenience. Some of the electives that must be available are : Foundations of Artificial Intelligence: Reasoning (First-Order, under Uncertainity, etc.) and survey of Knowledge Representation; Formal Ontology; Search Heuristics and Games Advanced Algorithms and Data Structures: Advanced Data Structures; Randomized Algorithms; Approximation Algorithms Operating Systems: Concurrency Theory, automated threading and process scheduling; Memory management and virtual memory; File systems; Message passing and process communication; Fault Tolerance Compilers: more or less Compilers: Principles, Techniques, and Tools, the Dragon Book Complexity Theory: more or less Computational Complexity: A Modern Approach. Time Complexity, Boolean Circuit Complexity, Space Complexity, Arithmetic Complexity, et al. But maybe Scott Aaronson's recent work in quantum complexity can also be included. Principles of Programming Languages: Practical Foundations for Programming Languages + Types and Programming Languages / Lambda Calcluls; Type Systems; Meta-circular compilers; Introduction to category theory and Haskell; Lambda the Ultimate papers Database Systems: Foundations of Databases + The Complete Book Cryptography and Information Security: mostly Foundations of Cryptography + Introduction to Modern Cryptography + Quantum Cryptography + Information Flow Control Automated Theorem Proving: Type Theories; Category Theory; Proof Theory; Homotopy Type Theory; Coq, Agda, LF, etc. Parallel and Distributed Programming: mostly The Art of Multiprocessor Programming + maybe some Concurrency theory per se. Quantum Information Theory: Quantum Computer Science: An Introduction And various other such as Computational Geometry, Machine Learning, Computational Linguistics, Data mining, Computer graphics, et al. along with other courses like Optimization Theory, Advanced Number Theory, Algebraic Topology, Philosophy of Metaphor and Analogy, etc. Updated 106w ago • View Upvotes • Asked to answer by Anhad Jai Singh