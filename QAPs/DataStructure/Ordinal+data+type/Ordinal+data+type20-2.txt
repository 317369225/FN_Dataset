What are the steps taken when designing a relational database or JSON objects? Besides ID, primary key, and timestamps, are there any other must have fields?
Designing a database is a process that has been split into multiple disciplines now.  Generally, there are 2 major difference, which is the OLTP 3rd normal form and OLAP's dimensional modelling.  The last group of mix and matches include Big Data and NoSQL like languages. My experience is heavily towards OLAP, with some experience in OLTP so I will comment on these two for now, but the PROCESS for designing Big Data and NoSQLs are similar. You are most likely looking to design something on the OLTP side.  These DBs are used as back-end data storage for applications and games.  The main focus is to design something that is fast and accurate and easily reproducible.  If the DB is small (tens of thousands to hundreds of thousands of rows max) and not likely to increase, you don't really have to worry about redundancy.  Proper indexing should get you all you need for the speed. The other two factors will come from your ER (Entity Relational) modelling.  To explain this to programmers, I compare this with Object-Oriented Programming concepts.  I sum up OOP to be basically 3 things , objects, interactions and environment.  You can pretty model the entire universe (even made up ones) with these 3.  You have objects like people, plants; interactions like eat, plant, water; and environmental variables like speed of light, gravitational constant, etc. Entity in DB modelling is the Object in OOP, Relation is the Interactions.  The mind set though is different, because interactions in OOP is explicit.   You HAVE TO program the interactions in code, or else the two objects cannot interact.  Relations however, exists purely because two entities have a key attribute that overlaps.  For example, we have Iphone table and Sales table.  Each Iphone has a unique number called inum(so that when it is lost, you can shut down that specific phone completely) and the Sales table also has an inum, this dictates that Sales is Related to Iphone.  This thought process may not seem like much, but when you start querying your DB, it becomes much more profound in the sense that SQL will always be running in a O(n) "loop". To simplify things even more, you'd only have 2 kinds of things in the transactional DB, and this is borrowed from Dimension modelling from OLAP.  You have a Masters table to record object states, like Iphone Master, which describes each individual phone and all its attributes.  And you would have a Transactions table to record events, such as Sales, Payments that describe which object, did what to which objects at what time.  Lastly a reference table if needed for many to many relationships.  Generally 1 to many relationships, you'd keep the key from the 1 table and keep that in the many table.  If an iphone can be sold multiple times (i.e. sold, returned and resold), then the iphone's inum is in the Sales table, not the sales_id in the Iphone table.  But if multiple iphones are sold in the same Sales transactions, how can one row hold multiple inums?  You create a reference table in this case. Once you determine the normalization of the tables, you'd be done.   To determine how much normalization to do is purely up to you and experience.  In general, my rule is when things can change and often, and you can categorize it, normalize it.  Systems like SAP, PeopleSoft or most large enterprise ERP systems are super normalized.  There are 4500 tables in SAP, in these systems, you may have a iphone table, an inum table and a reference table.  Overkill in my opinion! The difficulty in designing a DB is not in how to structure the table, or what fields to put in there; the difficulty lies in predicting all possible ways business transactions CAN happen now and in the future, and coming up with a design that handles these possibilities.  Most architects don't anticipate business scenarios, so the DB ends up having a lot of work arounds throughout its lifetime that it looks like a terrible design; but if you walk through each design release and the justifications behind it, you won't find anything wrong at any point in time.  You have to look at the entire thing holistically throughout time. Happy designing. 