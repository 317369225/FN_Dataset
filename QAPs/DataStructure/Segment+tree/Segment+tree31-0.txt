How do I solve this problem using segment trees?
The question is essentially this: Given an array a[1…N], find the number of pairs of positions (i,j) such that i<j and the number of times a[i] appears in a[1…i] is greater than the number of times a[j] appears in a[j…N]. The natural thing to do would be to: For every position i, find b[i] = number of times a[i] appears in a[1…i] Similarly, for every position i, find c[i] = number of times a[i] appears in a[i…N] Find the  number of pairs of indices (i,j) such that i<j and b[i]>c[j] Step 1 can be easily achieved by sorting. Sort the (value,position) pairs in the array in lexicographic order. Positions with the same value will end up contiguous, and b and c can be calculated using the positions within the contiguous pieces. For step 3, we can use a segment tree which allows point update of values and query sums of intervals. To be precise, the segment tree must support the two operations: Given a position i, increment the value at node i by 1 Given a position i, return the sum of values at nodes [i…N] Initially, all segment tree nodes have value 0. Sort all elements of arrays b and c (along with their positions and b/c type) together in the ascending order of value. Break ties by placing the b elements before c elements, it does not matter how ties are broken among b (or c) elements of same value. Traverse this sorted array. When you encounter c[i], increment the value at node i of the segment tree. When you encounter b[i], note that all c-elements with a lower  value have already been updated. This means that the number of nodes among [i+1…N] which have been set to 1 are exactly those with j>i and c[j]<c[i]. Their number is just the sum of values at nodes [i+1…N], which can be found from the segment tree. Accumulate the sums for all b[i] values, and you get the required answer. 