Sphere Online Judge (SPOJ): How do I use a persistent segment tree to solve a problem?
Preprocessing : Build a segment tree such that each segment [math]S[i..j][/math]contains sorted array of elements in the range [math][i..j][/math]. This can easily be done in [math]O(n log(n))[/math], build the two sub-segments [math][i .. (i+j)/2][/math] and [math][(i+j)/2+1 .. j][/math] first and then merge them to get sorted list for [math][i..j][/math]. Query Answering : Now, for each query [math]Q(i, j, k)[/math] (semantics as mentioned in the question link), the range [math][i..j][/math] can be written as disjoint union of segments from the tree. E.g., in this segtree, the range [3..8] is union of segments [3..4], [5..7] and [8..8]. Observe that there will be [math]O(log(n))[/math] such segments. Now what remains is finding kth number from the numbers from these ranges, ie, the number at kth position if we merged these sorted arrays. How to do that efficiently? Binary Search! Let [math]m[/math] be the minimum and [math]M[/math] be the maximum element among the ranges. Binary search over [math][m..M][/math] to find the number which has [math]k-1[/math] numbers smaller than it in these ranges. How to find that? To get rank of number [math]e[/math], do a binary search over each of these ranges to find number of elements less than [math]e[/math]. Sum them to get the rank of [math]e[/math]. Obtain (by the outer binary search) the number that has [math]k-1[/math] number smaller than it, that will be the answer. In case of repetitions, you will need to count two things in the inner binary search : number of elements less than [math]e[/math] (call it [math]N1[/math])and number of elements less than or equal to [math]e[/math] (call it [math]N2[/math]). [math]e[/math] will be the answer if [math]N1<k<=N2[/math]. Complexity? Preprocessing in [math]O(n log(n))[/math]. Then for each query, finding the segments will need [math]O(log(n))[/math]. The binary search over [math][m..M][/math] will be [math]O(log(R))[/math], where [math]R[/math] is the range of elements in the array, and each binary search will take [math]O(log(n))[/math] for binary search in [math]O(log(n))[/math] intervals. So total complexity is [math]O(n log(n) + Q log(R) {log^{2}(n)})[/math], where [math]Q[/math] is the number of queries. Hope it helps! :) Updated 96w ago • View Upvotes • Asked to answer by Orchid Majumder