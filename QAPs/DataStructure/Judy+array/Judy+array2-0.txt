What are some good project ideas to be a kickass algorithmist?
This is an entirely different sort of answer from the topcoder one. I'm going to tell you how I became a kickass practical algorithmist. First order of business: learn everything you can. Master complexity analysis. Master contention analysis. Take that second one seriously, concurrency is quickly becoming as critical as order of algorithmic complexity. Learn all of the common algorithms for search, sort, partition, join, etc. I like Sedgewick's "Algorithms in *" books. The Dragon Book remains relevant. Wikipedia can be a good starting point. Learn some linear algebra. Know what a Jacobian transform is, how it works, and why it's useful. Learn some domain specific approaches, for things like compression, cryptography and noise filtering. Learn some computational methods. You should know what the Runga Kutta technique is. All of this gives you the fertile ground you need to really grow. It isn't enough to know basic algorithms, though. You need to develop a feel for what works, when, and (critically) why. Are you in a data space small enough that O(n^2) isn't that big a deal? A fixed n can be treated as a coefficient, and there are cases where the net coefficient of a less desirable (in theory) algorithm is small enough that it blows a more complex algorithm out of the water. I've seen such a case in an implementation of Unicode collation rules. The data space was bounded, and the function itself was called with very high frequency in an O(n log n) operation with an unbounded n, and the poorly scaling algorithm proved to be the winner. It fit into a single cache line on most target architectures. Which leads to the next point. Context matters, and general purpose algorithms aren't always the best answer in specific use cases. Learn a few hardware platforms... and maybe a couple of kernels. Windows and Linux aren't necessarily going to do the same thing when you call a system function that blocks, or do something that allocates memory. This doesn't sound algorithmic on the surface, but... take a look at the Judy array for an example of its applicability. 