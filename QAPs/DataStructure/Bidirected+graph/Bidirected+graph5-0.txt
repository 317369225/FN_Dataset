How does one solve the problem "Caprica Cities" (CAPRICA) on SPOJ?
Thanks you for A2A. After a long time I opened my SPOJ account and solved a problem. I tried this for 3 hrs in the night in my single room. That's how horrible I am. Finally I found that there was an implementation fault and got that AC. Enough of extraaaa shots!! Theory: The prerequisite of this problem is that you should know basic implementation of graph as well as Dijkstra's algorithm. Provided you know that, we come to the actual problem. We are given a weighted bidirected graph G having 2 non empty disjoint set of vertices X and Y. We basically have to find x in X and y in Y such that distanc-e between x and y is the least. The first idea that comes to our mind is to take any of the 2 sets say X and then find shortest distance of each x in X from all other verticies. And then find the minimum distance of each vertex y in Y.And then find least of all minimum distances for each x in X. But that may lead to TLE (Although I didn't try). A careful observation shows that: "There is no need to find the minimum distance between vertices of the same set because if x1 and x2 are 2 vertices in set X and y be some vertex in set Y then the path of minimum distance x1 to y or x2 to y will never be of the form x1 -> x2 ->y or x2->x1->y. " So the problem boils down to taking a vertex in set X (or Y) and find the minimum distance to all other vertices that are not part of X(or Y). To do this we apply Dijkstra's algorithm and carefully ignore the vertices of  same set thereby reducing the operations. Implementation: I used implementation of Dijkstra using stl sets. This implementation is similar to implementation if Prim's algorithm. Only slight change is required (see this Jaskaran Virdi's answer to How can we implement prim's algorithm quickly in programming contests? )  I then created an array hash such that hash[i]=1 if i is element of X hash[i]=0 if i is  element of set Y and -1 otherwise. Then I inserted all the elements of set X in a priority queue( STL set used as priority queue here) and then with few modifications in Dijkstra I got that AC. See my code for details. Sorry if you find my code unclear, but I am sure you will be able to read it. /*1.Controlling complexity is the essence of programming cuz computers are good at following instructions but not reading your mind. 2.Programmers are the guys that make variables constant, make the root at top of the tree, write a=a+5,say String and threads are not same, let red parents have black children and yes say that 1.1s is too slow and .99s is really fast. 3. Code not to get placed. Code cuz coding is fun. 4. If you do not find yourself passionate about competitive programming, leave it and then find your passion.*/ #include <bits/stdc++.h> using namespace std; //typedefinitions typedef long long int li; typedef vector<li> vi; typedef vector<string> vs; typedef vector<vi> vvi; typedef pair<li,li> pi; typedef vector<pi> vpi; //macros #define F for #define W while #define R(i,a,b) for(i=a;i<=b;i++) #define rR(i,b,a) for(i=b;i>=a;--i) #define si(x) scanf("%d",&x) #define sl(x) scanf("%I64d",&x); #define P printf #define cc continue #define bb break #define rr return #define pb push_back #define mp make_pair #define fir first #define sec second #define db(x) cout<<#x<<"="<<x<<endl #define ppp cout<<"fine here"<<endl #define P_vec(vec) F(i=0;i<vec.size();++i){ write(vec[i]); P(" ");} P("\n"); #define INF 99999 //templates template < class T > void read(T &x) { char c, mi = 0; while(c = getchar(), c <= 32); if(c == '-') mi = 1, x = 0; else if(c < 48 || c > 57) return void(x = c); else x = c - 48; while(c = getchar(), c > 32) x = 10 * x + c - 48; if(mi == 1) x = -x; } template < class T > void read(T &x, T &y) { read(x); read(y); } template < class T > void read(T &x, T &y, T &z) { read(x, y); read(z); } template < class T > void reada(T *a, int n) { for(int i = 0; i < n; ++i) read(a[i]); } template < class T > void write(T x) { static char s[20]; char pt = 0, mi = (x < 0); if(mi == 1) x = -x; while(!pt || x > 0) { s[++pt] = (char)(x % 10 + '0'); x /= 10; } if(mi == 1) putchar('-'); while(pt > 0) putchar(s[pt--]); } template < class T > void write(T x, T y) { write(x); putchar(' '); write(y); } template < class T > void write(T x, T y, T z) { write(x, y); putchar(' '); write(z); } template < class T > void writeln(T x) { write(x); puts(""); } template < class T > void writea(T *a, int n) { for(int i = 0; i < n; ++i) { write(a[i]); putchar(i + 1 == n ? '\n' : ' '); } } //main code int main() { pi z; li i,N,M,A,B,x,p,q,r,w; set<pi> Q; vi::iterator it1;vpi ::iterator it2; W(1) { read(N,M,A); read(B); if(!N&&!M&&!A&&!B) rr 0; vpi graph[N+1]; vi hash(N+1,-1),AA,BB,dist(N+1,INF); R(i,1,A) { read(x); hash[x]=1; AA.pb(x); } R(i,1,B) { read(x); hash[x]=0; BB.pb(x); } R(i,1,M) { read(p,q,r);graph[p].pb(mp(q,r)),graph[q].pb(mp(p,r)); } Q.clear(); F(it1=AA.begin();it1!=AA.end();++it1) Q.insert(mp(INF,*it1)); W(!Q.empty()) { r=Q.begin()->first; p=Q.begin()->second; if(hash[p]==1) r=0; Q.erase(Q.begin()); F(it2=graph[p].begin();it2!=graph[p].end();++it2) { q=it2->first; w=it2->second; if(hash[q]==1) cc; if(dist[q]>r+w) { if(Q.find(mp(dist[q],q))!=Q.end()) Q.erase(Q.find(mp(dist[q],q))); dist[q]=r+w; z=mp(dist[q],q); Q.insert(z); } } } w=INF; R(i,1,N) if(hash[i]==0) w=min(w,dist[i]); write(w);cout<<endl; } rr 0; } see Ideone.com for test case. 