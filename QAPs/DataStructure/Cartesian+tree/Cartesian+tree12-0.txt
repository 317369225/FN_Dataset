Can we use maps for hashing, sets for trees and other things without actually implementing them for competitive programming?
Sometimes you can, sometimes you can't. Lot of things are implemented in STL. Some of them aren't well-known for most of competitive programmers (like rope - check Implicit cartesian tree in GNU C++ STL. - Codeforces); lot of them are well-known and widely used. Can you find k-th element of a set fast using std::set? Does map help you to write some 1-liner instead of implementing Rabin-Karp algorithm with all these primes, modules, multiplications, partial sums?.. These things are instruments, but not an ultimate solution. Nowadays I can't imagine solving problems without them - implementing red-black by myself sounds sad (and yes, there are much simpler alternatives). I am not sure that I'll be able to write bugless quicksort now - simply because I am using std::sort instead for last five years. Sometimes even if you can use set to implement something - it turns out to be a bad idea because of large hidden constant. Very simple example - Dijkstra's algorithm with priority queue usually is much faster than implementation with set. Another simple example - if you want to map set of numbers into [1..N] range - you'd better add them to a vector, sort this vector and process it in a single run, instead of making a set, inserting all elements there and running over it with iterator. 