What is the most interesting problem solving technique or trick in programming contest?
Edit: Changed to a different test case which more clearly demonstrates the process, and added some extra details to the story which Aditya's comment reminded me of. My favourite technique is really quite simple. I'll give an example of a problem that can use it: ACM-ICPC Live Archive When I first read this problem my immediate thought was the obvious brute force with an O(n!) solution - try all combinations of cutting off one required piece at a time. This is obviously much too slow, with 15! = 1.3e12, and I wasn't even convinced that it would give the right answer. I then realised that if you combine pieces A and B, and then that with C, you have the same sub-problem as if you had combined pieces A with C, and then that with B, or B with C and that with A. So I thought about adding memoisation to the solution (a dynamic programming approach), but couldn't immediately think of a way to identify each sub-problem (there will be at most 2^15 of them, I realise now I could easily use a bitmask). Â Then a friend I was competing against who had solved it gave me a single word as a hint: "backwards" (it was only a practice round). If you want to try solving this problem with just that hint, stop reading now. With just that one word I instantly saw the solution, and how simple it is. You start with the required pieces and reassemble them into the single start piece - always combine the shortest two pieces from the current set. So for example, for the case of cutting 32 into 3, 3, 5, 5, 16, you start by combining the two 3s, for a cost of 6, to give 5, 5, 6, 16. Next you combine the the two 5s, for a cost of 10, to give 6, 10, 16. Next you combine the 6 and the 10, for a cost of 16, to give 16, 16. Finally you combine the two 16s, for a cost of 32, to give 32. The total cost is 6 + 10 + 16 = 32. Now whenever I see a seemingly simple problem with no obvious efficient solution, I try solving it backwards. 