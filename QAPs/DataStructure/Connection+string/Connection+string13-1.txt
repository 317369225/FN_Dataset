How does Java overload operator "+" connect two strings? How does that invisible part work?
Vinay's example suffers from the fact that the compiler is going to optimize out the calls that it generates, so we can't see what it's really doing.  Here's a slightly different example that won't get optimized out and lets us see what's really happening. Here's the code: public class Test { public static String dummy (int x, int y) { return x + " + " + y + " = " + (x + y); }   public static void main (String[] args) { System.out.println( dummy (1, 2) ); } } And here's the disassembly of the class file generated (I've only quoted the "dummy" method as that's where we need to look: public static java.lang.String dummy(int, int); Code: 0: new #16 // class java/lang/StringBuffer 3: dup 4: iload_0 5: invokestatic #18 // Method java/lang/String.valueOf:(I)Ljava/lang/String; 8: invokespecial #24 // Method java/lang/StringBuffer."<init>":(Ljava/lang/String;)V 11: ldc #27 // String + 13: invokevirtual #29 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer; 16: iload_1 17: invokevirtual #33 // Method java/lang/StringBuffer.append:(I)Ljava/lang/StringBuffer; 20: ldc #36 // String = 22: invokevirtual #29 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer; 25: iload_0 26: iload_1 27: iadd 28: invokevirtual #33 // Method java/lang/StringBuffer.append:(I)Ljava/lang/StringBuffer; 31: invokevirtual #38 // Method java/lang/StringBuffer.toString:()Ljava/lang/String; 34: areturn Decompiled, this is roughly: return new StringBuffer(String.valueOf(x)) .append(" + ") .append(y) .append(" = ") .append(x+y) .toString(); The compiler, internally, uses the java.lang.StringBuffer class to implement string concatenation, and may use any of several different methods in that class along the way to do so. 