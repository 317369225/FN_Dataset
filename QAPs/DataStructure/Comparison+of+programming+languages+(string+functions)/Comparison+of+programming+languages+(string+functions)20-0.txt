Functional Programming: How does F# compare to OCaml?
Interestingly, we just published the first in a series of articles detailing the similarities and differences between OCaml and F# in the F# Journal: F# vs OCaml part 1: syntax and types In terms of syntax, F# allows overloading of both operations (+, -, * etc.) and some functions (sin, cos, sqrt etc.) whereas OCaml has separate functions (+, +., +/, +|) to operate on different types. Overloading also applied to the indexing syntax where xs.[i] to index a string and xs.(i) to index an array in OCaml is replaced uniformly with xs.[i] to index anything in F# (including Map). F# is indentation sensitive by default in order to do away with "in" and "begin..end" from OCaml. Some features that were available as third-party macros in OCaml (pa_monad, LWT, view patterns) are built into the F# language (computation expressions, async and active patterns, respectively). OCaml has an integrated full-blown macro system in the form of Camlp4 whereas F# does not have macros and, in fact, has been deliberately closed off in order to discourage people from creating products that compete with Visual Studio. In OCaml, collections parameterized over functions like comparison and hashing (e.g. Set, Map, Hashtbl) use the higher-order module system. Hashtbl provides a default module with structural hashing which is nice when it works but breaks horribly if you try to use it with an abstract type because the hash and equality functions look at the internals of the data representation with no regard for semantic meaning. In F# there is no higher-order module system but there are per-type equality, comparison and hashing functions and collections use them which solves almost all real problems much more elegantly than a higher-order module system. In terms of paradigms, the main things that have changed in my approach to development since moving from OCaml to F# are GUI programming (extremely tedious in OCaml but almost trivial in F#, now every other program I write has its own GUI), Intellisense in Visual Studio (much faster to explore libraries in F# than OCaml), easy interop with lots of .NET libraries (quick to solve many practical problems and I've never needed native interop but much of .NET is badly written) and multithreading (OCaml impedes parallelism whereas F# makes it easy). As for numeric capabilities, vanilla OCaml only supports bools, 8-bit chars (no unicode without a 3rd party library), natively 31- or 63-bit ints (32- and 64-bit ints can be emulated but are ~32x slower than necessary, see Archives of the Caml mailing list > Message from Jon Harrop) and double precision 64-bit floats (but not single precision 32-bit floats). F# supports the full variety of .NET types including unicode chars, signed/unsigned 8/16/32/64-bit ints, 32/64-bit floats. F# also supports value types so it can handle unboxed complex numbers and low-dimensional vectors and matrices. Although OCaml has a much faster (albeit single-threaded) garbage collector, it is unable to compensate for unnecessary boxing caused by its internal data representation, e.g. FFT over complex numbers is 5.5x faster in F# than OCaml (using Complex.t). This is due to value types and reified generics in .NET vs Lisp-style uniform data representation in OCaml which actually completely changes the internals of some core collections like hash tables which are usually at least 4x faster in F# than OCaml (see F# vs OCaml vs Haskell: hash table performance). Writing multicore programs in OCaml is horribly painful compared to F# due to the single-threaded run-time. OCaml also suffers from 16MB limits on string and array sizes on 32-bit OSs. Jane St are probably the world's largest OCaml users today but Citrix acquired one of the world's largest OCaml code bases from XenSource and continue to develop it heavily. I discussed F# with Yaron Minsky (of Jane St) who said that he was concerned about the symbolic performance of F# so I think they do a lot of symbolics as well as numerics. Updated 26 Aug 2013 â€¢ View Upvotes