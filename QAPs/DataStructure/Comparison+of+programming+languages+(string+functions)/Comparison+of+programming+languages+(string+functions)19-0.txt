What bad programming/architecture habits can a self-taught PHP coder develop?..and how to get rid of them?
I agree with Syd that that you can write bad code in any language. That said, there are some very specific things programmers who start off using PHP as their first language are vulnerable to, and I'll try to enumerate them as follows: Not understanding how memory allocation works, how garbage collection comes with performance drawbacks and how it can be extremely problematic to use in certain problem domains. Assuming that all memory is free, since they are insulated from manual memory management. Not understanding the internal representation of types that are used, and consequences there of. ( For example a switch statement on strings might appear to be the same as a switch on integers, though at the core the map to different things internally.) The same goes for using strings as enums. Not understanding that how doing certain operations across requests in a webserver are extremely expensive as compared to a server which keeps client state in memory. It can be done in PHP with APC, but naively speaking some users will likely write code that might do expensive state setup for every single request. Not understanding the advantages of serialization in binary formats vs. PHP serialization, particularly the performance benefits. PHP can train people to reach for @error suppression instead of actually writing error handling code. Not understanding the difference between arrays and associative arrays, what operations are cheap for each class of structures and which ones are cheap. Not understanding the implementation of the array_* functions, and assuming they are cheap. Not understanding that deferencing null fields is a bad thing to do. I.e. in PHP you can check ( isset(x->y->z)), and it will work fine if y isn't set and simply behave as if x->y->z was null. In C it will crash if y is null. Not understanding the difference between deep copies and shallow copies. Not understanding concurrency, particularly at the hardware level. Users of the language are never exposed to more refined forms of concurrency such as epoll style event driven asynchronous IO. Developing a mindset that presentation and logic is for output is a very bad thing. Not understanding why file_put_contents isn't suitable more demanding instances of file/IO. Developing the mindset that it is okay to evaluate things such as function names to execute at run time based on a string by the use of variable variables. I've seen code that actually stored callback function names for a certain data structure be written out persistently. The worst programming habit you can develop using PHP: "If it didn't work right, I'll just change something and hit reload" - that is hacking, not engineering. 