In comparison to Ruby, what is the role of object-oriented programming in JavaScript?Hope this makes sense. I'm looking to understand how JavaScript uses Object Oriented principles. Any insights would be appreciated....
OO is a style of programming, not just a language construct At it's core, object-oriented programming is about representing related bits of data and functionality into named chunks called objects, and then writing your code in such a way that it's easy for humans to interact with it.  It's a way of organizing your code so that future developers can make  sense of things easily, and hence it keeps the cost of development low. Certain programming languages such as Ruby, Java and JavaScript have language constructs that make it possible for you to write code in an object-oriented fashion, some more easily than others.  Other languages, like Haskell make it more difficult to write (and in some cases impossible) to write code in an OO fashion. So you can write functional-style programs in both languages, or OO-style programs in both languages. Objects and methods To start, Ruby and JavaScript both share the concept of there being Objects, and being able to call methods on those objects.  Syntactically both use the dot notation (`object.method`) to call methods on objects, so it might seem like they are more similar than they actually are. In Ruby methods truly do belong to objects, and can only be called on those objects.  In JavaScript "methods" are really just short-hand for looking up the correct function to call, and passing in the object as `this`.  So the following two calls are identical in JavaScript: var person = { fullName: function(){ return [this.firstName, this.lastName].join(' '); }; }   person.fullName(); // is the same as... person.fullName.call(person); So in Ruby you have to invoke a method on an object.  In JavaScript you just have functions, and if you call a function on an object it will afford you some benefits. Inheritance Inheritance deals, in part, with method lookup.  Ruby and JavaScript both have built-in support for calling methods up-the-chain, so to speak, but they implement it very differently. Take the following Ruby: class Person attr_reader :first_name, :last_name def initialize(first_name, last_name) @first_name = first_name @last_name = last_name end   def full_name "#{first_name} #{last_name}" end end   Person.new('Jeff', 'Dean').full_name When you call the `full_name` method on your new Person instance, it looks at itself, at Person and then at any class Person inherits from (in this case Object, Kernel, BasicObject etc...).  This is what you'd call an "is-a" relationship - your object is a Person.  The `full_name` function can only be called on a person, or another object that's a subclass of Person. In JavaScript, a reasonable approximation of this would be: var Person = function(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; };   Person.prototype.fullName = function(){ return [this.firstName, this.lastName].join(' '); };   new Person('Jeff', 'Dean') But rather than creating an "is-a" relationships, when you use the `new` keyword, it effectively does this: var person = {} // plain old javascript object Person.call(person, 'Jeff', 'Dean') // call the Person function, passing in our new object as `this` person.prototype = Person // (pseudo-code) - point our `person` object to another Object where functions might be defined return person; Note that what comes out of `new Person()` is just a plain old JavaScript object - but it has one special property set - the `prototype` property.  So when you call `person.fullName()` it looks at itself first, then goes to its prototype, then its prototype's prototype etc...  JavaScript uses prototypes to find the right function to call, then it uses the fact that `object.foo()` is the same as `object.foo.call(object)` to make it appear as if it's doing the same thing that Ruby is doing. So method lookup can feel similar in both languages, even though their exact details are quite different. Super Ruby has proper support for `super` - that is, when you override a method, you can internally call your super-class's method with the same name.  JavaScript does not have a built-in concept of super, although you can create your own fairly trivially (see Invoking Super Methods in JavaScript). This is one of the biggest differences in the two. Encapsulation Ruby has the concept (although a bit strange) of hiding methods and instance variables.  Ruby has a concept of public, protected and private methods, with the latter two being a little harder to call on objects.  It also has the concept of instance variables which should, in theory, only be accessed by methods on that class.  As with everything in Ruby, there are ways to get around it, but Ruby clearly supports the intent of the developer to make things hidden from the outside world. In JavaScript there are no built-in concepts of private functions or private attributes that you can use in a declarative way (like `public :foo`), so many people think you can't encapsulate data, but it does allow you to hide data well if you know how (Private Members in JavaScript). Polymorphism Both Ruby and JavaScript have types, but don't enforce them.  For example you can't make either language enforce that you pass a string to a method.  So in both languages you can rely on duck-typing - basically writing methods such that if an object has the right methods / properties your code will work ("if it walks like a duck and quacks like a duck"...) This makes polymorphism super easy, and you won't notice much of a change for most parts of your program if you are actually using polymorphism well.  However, Ruby allows you to ask an object for its type (`person.is_a?(Person)`) whereas JavaScript's typeof will always return "object" for your "instances".  So if you rely heavily on that kind of asking you'll have to hand-roll it in JavaScript. 