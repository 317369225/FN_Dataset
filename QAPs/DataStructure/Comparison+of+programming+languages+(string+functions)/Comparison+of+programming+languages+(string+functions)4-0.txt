What does a program written in a programming language without lexical scoping look like?Please include actual code examples.
The tricky thing is that it can look exactly the same—it'll just behave differently! In fact, in the intro CS course I took, we looked at versions of Scheme with both sorts of scoping. A good way to understand how dynamic scoping works it to take a program and figure out how it behaves under both scoping regimes. But that's probably not what you meant. The interesting question, I suppose, is how a program would take advantage of dynamic scoping. It's had to find examples because, on the whole, dynamic scoping is not a great idea. It makes writing a lot of programs harder and doesn't buy you much. If you have a piece of code that expects a dynamically scoped variable, you can always rewrite it as a function with an argument in a lexically scoped system: all you're doing is making the implicit explicit. That said, I have used dynamic scoping in the past. One place it comes up is elisp, which only got support for lexical scoping within the last couple of years. Honestly, it's actually pretty neat in that specific application: we can just refer to a variable and, if it needs to be changed in a specific buffer or mode, everything else sees the change but only in that buffer or mode. Another language that comes to mind is Perl. Perl started out with dynamic scope and still dynamically scopes variables by default, although best practice is to almost always use lexically scoped variables these days. One place I remember seeing it was in the higher-order sort function which expected two variables, $a and $b to compare. I might be getting some of the details wrong (I haven't used Perl since high school!), but it looked something like this: @sorted = sort { substr($a, 0, 3) cmp substr($b, 0, 3) } @whatever; This would sort the list only comparing the first three letters of each string. If you're not familiar with Perl syntax, the { ... } block is an anonymous subroutine (i.e. lambda) taking no arguments. Note how we never declared $a or $b—they're not arguments to our comparison function. Instead, they're defined in the sort module and dynamically scoped so we can access them. And hey, this works. It's even a bit neat. But the problems are soon apparent. The first is that, just looking at the code, we have no idea where $a and $b came from. You'd have to look inside the definition of sort to know what they were. This might be okay for a common library function everybody knows and uses, but it won't fly for anything else. On top of this, what happens if you define $a and $b lexically scoped before calling sort? That's going to be a mess! The perldocs for sort put it succinctly: Note that in the latter case [dynamically scoped sort], it is usually highly counter-productive to declare $a and $b as lexicals.So now, if you use sort this way and anyone declares $a or $b lexically in your scope, you'll have a mysterious bug pop up. This is a potential dangerous interaction between parts of your code that should not be related at all. Ultimately, that captures the problem with dynamic scoping into a single idea: dynamic scoping is anti-modular. It lets distant, distinct parts of your code interfere with each other, which means you can't think about your problem in small pieces any more. You always have to keep the whole program in your head. That just doesn't work. 