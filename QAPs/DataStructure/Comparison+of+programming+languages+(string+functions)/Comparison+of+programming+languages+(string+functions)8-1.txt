Programming Languages: Which are the most used programming paradigms? Which are good coding examples?
Hello, I read your post, I really like this question. I began programming at the age of 13, and have programmed in about a dozen languages. I really love study of programming languages, and I love to code even more. Your question could probably be statistically analyzed based on all the code that has been contributed to open-source and closed source projects, but for that to happen there would have to be a lot of cooperation across many corporations, organizations, foundations, distributions, and projects; which will probably never happen. But with that said I will expound on what I can deduce from the knowledge of paradigms. The following list, is a list of the lineage of programming paradigms. Each indentation represents a level of hierarchy. Meaning that a paradigm was spawned as a subset of a another paradigm or it spawned as a subset of a paradigm, and was used in that fashion with in another paradigm altogether, for example: Structured > Object-Oriented . Programming Paradigms: Action Agent-oriented Array-oriented Automata-based Concurrent computing Relativistic programming Data-driven Declarative (contrast: Imperative) Constraint Constraint logic Concurrent constraint logic Dataflow Flow-based Cell-oriented (spreadsheets) Reactive Functional Functional logic Purely functional Logic Abductive logic Answer set Concurrent logic Functional logic Inductive logic End-user programming Event-driven Service-oriented Time-driven Expression-oriented Feature-oriented Function-level (contrast: Value-level) Generic Imperative (contrast: Declarative) Literate Procedural Inductive programming Language-oriented Natural language programming Discipline-specific Domain-specific Grammar-oriented Dialecting Intentional Metaprogramming Automatic Reflective Attribute-oriented Homoiconic Template Policy-based Non-structured (contrast: Structured) Array Nondeterministic Parallel computing Process-oriented Point-free style Concatenative Semantic Structured (contrast: Non-structured) Block-structured Modular (contrast: Monolithic) Object-oriented (OOP) Class-based Concurrent Prototype-based By separation of concerns: Aspect-oriented Role-oriented Subject-oriented Recursive Value-level (contrast: Function-level) Probabilistic Concept Since I have listed all the programing paradigms, I will point out to you, and other readers of this post, that many programming languages are multi-paradigm languages. Meaning that a language can incorporate more than one 'style' of programming into its foundation. For example, Java is a multi-paradigm programming language, exhibiting the following 'styles': Object-Oriented, Structured, Imperative, Generic, Reflective, and Concurrent. The C programming language is also a multi-paradigm language, but differs from Java in terms of paradigms. The C programming language exhibits the following 'styles': Imperative, Procedural, and Structural. Now that I have made the statements in the previous paragraph, I should point out that many languages of one type of paradigm, we also be designed by 'its' creators to incorporate another common paradigm. For instance, just about every language that is considered to be an Object Oriented language, that language will also be an Imperative language. The reason why almost all O.O. languages are also Imperative, has to do with the characteristics of the Imperative paradigm, which are: iteration and variable assignment. Continuing in discussion of O.O. and Imperative: from a programmers perspective when choosing an Object-Oriented language, would anyone want to use an Object-Oriented programming language that doesn't allow the  programmer to iterate? The answer would be no! If an Object-Oriented language like that does exist, the language would be terribly in-efficient to program in. Programmers would have spend 100's of times more (at least) creating statements over and over just to replicate the efficiency of an iteration (e.g. For loop or While loop). With everything that has been stated thus far, and with our knowledge of systems programming and language popularity, it is safe to say to say that the most used paradigms are as follows: 1) OBJECT-ORIENTED 2) IMPERATIVE 3) STRUCTURAL There might be some proponents to my rankings, but it is quite logical why I have ranked them in this order. If we consider the top 10 most used languages in academia and industry, 9 out of the 10 are Object-Oriented languages; and remember every Object-Oriented language is also an Imperative language. Therefore, O.O. and Imperative are ranked first and second. Structural is ranked third, because the kernel of ever major, mass distributed operating system in the world, was coded in C (or a combination of C with assembly and/or C++). The following is the 2015 language rankings, in terms of development, that were posted in July 2015, on the IEEE website: LANGUAGE: I hope this answered your question! If you'd like code examples I message me and will code you some. *********************************************************************** Editing this now after reading the comment: Imperative programming: //***************** // This theGladiator.cpp class is created to answer a post on the Quora website // The program uses the gladiator method to find the largest (greatest) // number entered. This program also tracks the number of occurences of // the highest entered number. // This program was compiled and tested on MacOSx, using g++ version 4.2.1 // author:GeoWade //**************** #include <iostream>   using namespace std;   int main() {   int count = 0;   int largestNum = 0;   int entry;   // an integer variable to increment the number of occurences int j = 1;   // output a greeting statement to the user cout << "Please enter 10 digits. Input the digit followed by return\n";   while(count < 10) {   cin >> entry;     // set the condition for defeat if ( entry >= largestNum ) {   if ( largestNum == entry ) { j++; } else { // if a new gladiator is crowned, reset the occurences to 1 j = 1; } largestNum = entry;   } else {   largestNum = largestNum;   } count++; }   // output a statement to the user followed by the largest number cout << "\nThe largest integer entered is: " << largestNum << " and the value occurred " << j << " times." << endl;   return 0; } The above program is created to demonstrate the Imperative paradigm. Notice the assignment operator, the equals (=) sign, in the statements of: int largestNum = 0; int j = 1; In the followed by the re-assignment of both those variable to new a value. The value location of the variable itself was stored in memory and the value of the variable was changed later in the program multiple times. Also the notice the use of the while loop, to iterate and/or cycle through the statements that are to be computed, with in the body of the loop. Object Oriented Paradigm: //***************************************** // This wordCaps.cpp C++ class has been created to capitalize all the words // from the WordList.txt file, and output them into TheList.txt file. // author:GeoWade //***************************************** #include <iostream> #include <fstream> #include <string> #include <cstdlib> #include <locale> using namespace std;   int main() { // create ifstream and ofstream objects from the include of fstream library ifstream in_file("/home/oops/ProjectOfWords/WordList.txt"); ofstream out_file("/home/oops/ProjectOfWords/TheList.txt");   // create a string variable to store each line of text from the input file string line; // create an integer variable to find index position of each string // and where that string should be cleaved int index;   if (in_file.is_open()){   cout<<"The file opened successfully!\n"<<endl;   while ( getline( in_file, line ) ) {   if ( ! line.empty() ) {   index = line.find(':'); string holdWorld = line.substr(0, index);   // iterate through each index position of the string for (int i = 0; i < holdWorld.size(); i++) { holdWorld[i] = toupper(holdWorld[i]); } out_file << holdWorld << '\n'; } } } else { cout<<"OOPS! SOMETHING WICKED HAPPENED!!"<<endl; } cout<<"The operation compeleted successfully!"<<endl;   // close the in_file object in_file.close(); // close the out_file object out_file.close();   } In the C++ program, the Object Oriented paradigm is visible, with the creation of the ifstream and ofstream objects. Object Oriented Paradigm: /** @author: Geo,Wade */ import javax.swing.JOptionPane;   public class JptionTest { public static void main(String[] args) { String input = JOptionPane.showInputDialog("Enter course number"); int cno = Integer.parseInt(input);   // abstract the Jopton class and create the spook object Jopton spook = new Jopton(cno); spook.getion(); System.exit(0); } }   class Jption { private int hello;   public Jption(int cno) { hello = cno; }   public void getion() { JOptionPane.showMessageDialog(null, "The course number: " + hello); } System.exit(0);     } The above Java example is an excerpt of code from previous application that I had coded. The code above demonstrates class abstraction and object creation. The program also demonstrates the assignment of variables. Structured, Imperative, and Object-Oriented: /** * This RobotTester java class is created to run and execute the Robot * java class, which is designed to direct the robot based on a users input and * calculate the position of the robot in comparison to a starting coordinate. * author@Geo,Wade */ import java.util.Scanner;   public class RobotTester { public static void main(String []args) { // part 1: open a scanner Scanner scan = new Scanner(System.in);   // part 2: Abstract the Robot class Robot rTwoD = new Robot();   // part 3: prompt the user to enter a direction and move the robot boolean finished = true; while (!finished) { System.out.println("Enter 1 to turn Right, Enter 2 to turn Left, Enter 3 to move, Enter Q to quit "); int turn = scan.nextInt();   if (turn == 1) { rTwoD.turnRight(turn); }   else if (turn == 2) { rTwoD.turnLeft(turn); } else if (turn == 3) { String facing = rTwoD.getDirection(); System.out.println("The Robot is facing: " + facing); } else finished = false;   }   // part 4: close the scanner scan.close(); System.exit(0);   }   } The above Java program demonstrates, Object Creation, Class Abstraction, Method/Functional Abstraction, Control Structures, Block Structures, Conditional Statements, Iteration and Assignment; which are all characteristics of three paradigms that are listed (in bold) as header to the program. I hope this helps! 