Why was Lisp the language of choice for AI research?
Here is a piece of a little book on Lisp  (found at: www.civilized.com/files/lispbook.pdf)  on what Lisp is good for.  (Sorry about the line-breaks - i don't how to get quora to re-justify.) 24      What is LISP Good For? The quick answer to the question “what is LISP good for?” is (1) ideas, and (2) experimental programs. The algorithmic ideas which LISP inspires are often powerful and elegant. Even if LISP is not the target programming language, thinking about how to tackle a programming job using LISP can pay worthwhile dividends in ideas for data structures, for the use of recursion, and for functional programming approaches. The use of Algol-like languages or FORTRAN tend to limit a program- mers’ imagination, and both applications programmmers and systems programmers can benefit by remembering LISP. LISP is useful for building and trying-out programs to solve predominantly non-numeric problems such as natural language parsing or dialog processing, symbolic formula manipulation, retrieval in a LISP-encoded database, backtrack searching (e.g. game playing) and pattern recognition programs. Most versions of LISP have been extended with arrays, strings, a FORTRAN-like statement-based programming facility via the so-called PROG special form, and many other features. Indeed, the enthusiasm for extending LISP is perennially high. Many extensions take the form of control structures and data structures for managing abstract search. As LISP is extended, however, it seems to lose its sparse pure elegance and uniform view of data. The added features are sometimes baroquely complex, and the programmers’ mental burden is correspondingly increased. Moreover at some point it is legitimate to ask why not extend FORTRAN or C to contain LISP features, rather than conversely? And indeed this has also been done.     Exercise 24.1: Define an extension to LISP to handle the class of strings of characters as a     datatype. In particular, let strings of characters be a class of legal LISP values, just as num-     bers, functions, and S-expressions are. What about a typecode for strings? Explain how strings     might be stored. (Hint: use self-referential ordinary atoms.) How are constant strings written?     Define the functions which provide for string manipulation. Include (CAT a b), (STRLEN a), and     (SUBSTR a i j ). Would STR, where v[(STR x)] = the string of v[x], be useful? What about intro-     ducing an inverse to STR? Define (READSTR) in a useful way. How will PRINT and PRINTCR handle     strings? Can READ be redefined to optionally apply to a string? Are there other potentially-useful     new functions and extensions of old functions which are of interest? Strike a synthetic balance     between utility and complexity. Often features are added to LISP to increase its speed. The standard accessing strategy in LISP is, in essence, linear searching, and many attempts have been made to circumvent this. LISP with extensions, then, is likely to be a curious amalgam of considerable complexity, sometimes with the possibility of constructing faster programs as a compensating factor. (Although, if a program is perceived to be fast enough by its users, then it is fast enough, no matter what language it is written in.) Not only does LISP perform slowly in comparison to conventional loop-based programs; it is de- signed as a self-contained programming system. Thus, like APL, it may be difficult to employ and/or control computer system resources, access files, and handle interrrupts in a general and convenient manner. In short, without suitable extensions, LISP is not a systems programming tool, and insofar as a program must deal with such environmental issues, LISP is generally in- adequate to the challenge. Since most programs with a long half-life have systems programming aspects, LISP is generally not the tool of choice for building a robust, efficient system for long-term use. Note, however, system programming extensions can be added to LISP by introducing suit- able “hooks” to the operating system; the well-known emacs text-editor is written in an extended version of LISP. Minor details also mitigate against LISP. Format control for terminal input and output is often lacking for example, and this can be frustrating in many applications. Moreover, although LISP list notation is adequate for short functions (indeed, it encourages them), it is cumbersome compared to Algol notation, and the lack of traditional mathematical notation is a severe handicap in many cases. Notational extensions have been proposed, but again, simplicity is sacrificed. On the other hand, LISP is an excellent tool for experimentation. A pattern-matching idea may be able to be programmed and tested in a preliminary way more easily and quickly in LISP than in Pascal for example. The lack of a variety of constrained data types, and the absence of declarations and multiple statement forms often gives an advantage to LISP as long as we banish efficiency con- siderations from our minds. Moreover there are certain applications, notably formula manipulation tasks, where S-expressions and recursion are so well suited for the job that LISP matches the utility of any other language. Unfortunately many versions of LISP do not gracefully cohabit with programs written in other programming languages, so a system can’t generally be easily constructed which employs LISP just for selected subtasks. However, a special embeddable LISP interpreter could be relatively-easily constructed as a C or FORTRAN callable subroutine package which would allow the use of LISP for specialized purposes within a larger non-LISP system. (Indeed, you could modify the LISP interpreter program given later to read its input from a memory array rather than a file or the keyboard, and thereby achieve such a “LISP subroutine”.) We shall consider several classical applications of LISP below. 