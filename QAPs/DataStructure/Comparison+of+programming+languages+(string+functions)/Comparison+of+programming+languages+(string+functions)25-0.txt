Why are Java 8 lambda expressions regarded as a big change in the Java programming language?
Firstly it removes a lot boilerplate code in java and let's you write more concisely, concentrating more on the functionality of your method : Consider the example String[] atp = {"Rafael Nadal", "Novak Djokovic", "Stanislas Wawrinka", "David Ferrer", "Roger Federer", "Andy Murray", "Tomas Berdych", "Juan Martin Del Potro"}; List<String> players = Arrays.asList(atp); //for loop for printing all players for (String player : players){ System.out.println("Player" :+player); So now we are going to use lambda expressions do achieve the same result. players.forEach((player) -> System.out.print(player + "; ")); So the code looks more concise great. We don't need to spell out every detail in our program. But there is another advantage of lambda expressions : you can use them in GUI programming. So consider you want to add a Button to your GUI and do some stuff it some action is performed on the Button (like a click.) In old java you would need to implement an anonymous class. So let's look at the code : JButton testButton = new JButton("Test Button"); testButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent ae){ System.out.println("Click Detected "); } }); So the ActionListener is an anonymous class with an actionPerformed Button. You could have done this with another named class and called the class, but the rationale of an anonymous inner class is : when you need a class only once it's better to do it with an anonymous class because they enable you to declare and instantiate a class at the same time. So before I move on and convert this method using lambda expressions I want to have a quick look at the ActionListener Interface : It's an interface with a method void actionPerformed(ActionEvent e) As you can see it has only one method. Interfaces with only one method are called Functional Interfaces in Java 8. It turns out that if you are using a functional interface, you can convert the anonymous inner class to a lambda expression : JButton testButton = new JButton("Test Button"); testButton.addActionListener(e -> System.out.println("Click Detected ")); So what's going on here? Since the ActionListener has only one method called void actionPerformed(ActionEvent e). So the compiler will know that e in the code will be of type ActionEvent and will do exactly the same as done with the anonymous inner class. You may say, that this converting is only applicable to functional interfaces. Well yes, but a lot of interfaces are actually functional. (Like runnable interface, comparable interface and a lot more) . So that's the reason you can do stuff like : [code]new Thread(() -> System.out.println("New thread")).start();[/code] Wait I said that comparable is a functional interface. So you can use lambda expressions for Comparing two things. So you could use it to sort things : So instead of : Collections.sort(humans, new Comparator<Human>() { @Override public int compare(Human h1, Human h2) { return h1.getName().compareTo(h2.getName()); } }); You can do stuff like this : humans.sort((h1, h2) -> h1.getName().compareTo(h2.getName())); You can also do other cool stuff while sorting : for more example see here Java 8 - Comparison with Lambdas | Baeldung Now I will demonstrate another cool thing about lambda expressions. Consider the example public int sumAll(List<Integer> numbers) { int total = 0; for (int number : numbers) { total += number; } return total; } So great it sums all Integers in a list. Now imagine that the requirements change, and you also have to provide a function which only sums even integers. Great you think, you can make another method. So maybe you will do something like this: public int sumAllEven(List<Integer> numbers) { int total = 0; for (int number : numbers) { if (number % 2 == 0) { total += number; } } return total; } Okay you copy pasted the code and tweaked it a little bit. Not an issue now you say. Now the requirements change again and you need to sum numbers greater than 3. You may add another method called sumAllGreaterThan3. You need to basically copy paste your code once again. But you remember the rule, that if you have to copy paste 3 or more times it's time for refactoring. So you think and maybe you get the idea : What if you make a method sum(List<Integer> numbers, filter) so that the filter automatically filters out the numbers you need to sum. In this case you only would have to write one method. Great now you can use lambda expressions. You will need a Predicate<Integer> argument for your method, so the signature would be : public int sumAll(List<Integer> numbers, Predicate<Integer> p). A predicate defines a behaviour how to use the List of Integers. Here's the documentation of the predicate : Predicate (Java Platform SE 8 ) We want to use the test method of the predicate. So our code will look like this. public int sumAll(List<Integer> numbers, Predicate<Integer> p) { int total = 0; for (int number : numbers) { if (p.test(number)) { total += number; } } return total; } So we can call the function like this : sumAll(numbers, n -> true); sumAll(numbers, n -> n % 2 == 0); sumAll(numbers, n -> n > 3); So you see the lambda expression in our method call. In our method sumAll method the function call p.test(number) tests if the predicate is true for every number it encounters. So these were for me the most important features of adding lambda expressions to Java and as you can see they do quite add some value to the language. 