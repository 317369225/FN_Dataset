As a starting Python programmer I see a lot of praise for the Python language (and so far I can only agree). Isn't there anything bad to say about it? What is a real con?
While the good outweigh the bad for most cases, there are definitely some bad parts about Python: - It's slow. That is both dynamically typed and interpreted means that performance takes a hit. - The Global Interpreter Lock (GIL) makes it hard to do advanced operations with asynchronous programming. - `print()` doesn't require parentheses, which is inconsistent with the rest of the language. - Though everything is an object, there are a number of builtin functions which make the language inconsistent. For example `[1, 2, 3].len` would be more consistent than `len([1, 2, 3])`. Ruby is not inconsistent in this way. - {'a': 1, 'b': 2} is how you define a dictionary. {1, 2} is how you define a set. What does {} mean? (A dictionary. Dictionary notation came first.) - (1, 2,) defines a tuple. (1, 2) defines a tuple. (1,) defines a tuple. (1) is just 1. (,) is a syntax error. () defines a tuple. -  ({} == []) != (bool({}) == bool([])) - Since False == 0 and since Python is dynamically typed, you can do nonsensical operations like [1, 2, 3] * False (which equals []). In a sane typed language, that would probably throw an error. - There is no good way to add infix operators. - Python sets hard limits on the stack height, which can be a problem if you are doing anything recursive in nature. Technically, you can rewrite recursive algorithms in an iterative form to get around this issue, but this is impractical for complex functions like the Ackermann function. - Guido dislikes reduce (a higher level function) and its use is discouraged. Unfortunately, this means that anytime you have a function which could benefit from being abstracted, you cannot abstract it. This is basically a forced design pattern. - There is no way to express a `do-while` statement, which leads to design patterns. - Python's packaging system is extremely complicated. For starters, you need to install pip yourself using easy_install. Distribution is simple enough to get started with, but if you need to do anything complex you will need to study the history of the various options (distutils, setuptools, etc). - Certain libraries in the standard library are showing their age, but there is nothing in the documentation that makes that clear. For example, imaplib fails to intelligently parse responses in the IMAP protocol, meaning that you sometimes need to construct data structures from strings represented lists. (imaplib was written in 1997, before Python 1.5 was released.) - List comprehensions leak scope. For example, `[x for x in xs]` will put `x` ins scope. This can be dangerous if you had previously defined `x`. - Python relies heavily on idioms. To the master this is no problem, but to the novice you have to discover the idioms. For example, to repeat a block `n` times you want to know the idiom `for _ in range(n):`. - Multi-line `if` statements are hard to read. Consider: if (collResv.repeatability is None or     collResv.somethingElse):    collResv.rejected = True    collResv.rejectCompletely() - Subclass relations aren't transitive. [1] - When using byte strings and Unicode strings, Python does implicit conversions which can be confusing if you don't know what's happening. For example, >>> "Hello " + u"World"u'Hello World'>>> "Hello\xff " + u"World"Traceback (most recent call last):    ...UnicodeDecodeError: 'ascii' codec can't decode byte 0xff in position 5: ordinal not in range(128) Also: >>> "foo" == u"foo" True>>> "foo\xff" == u"foo\xff"__main__:1: UnicodeWarning: Unicode equal comparison failed to convert both arguments to Unicode - interpreting them as being unequal False [1]: Python Subclass Relationships Aren't Transitive Updated 66w ago • View Upvotes