If I was interviewing for a SWE position in Python, and you were the interviewer, what are the top 5 things about the language that would disappoint you if I did not know them?
As Mitchell Peabody said the answer depends on the domain of software development for which I was interviewing.  In my case that would usually be "devops" (site reliability engineering); but I might be asked to interview candidates for other groups. As Paul Bissex said the "top 5" is arbitrary. Most importantly the things that disappoint me most when interviewing prospective programmers have nothing to do with the choice or programming language (nor with their spoken/natural language).  The fact is that there are far too many people with allegedly extensive programming experience and education on their résumés who are terrible at some of the most rudimentary interview programming tasks. These days, for our devops positions, we're using CoderPad and I now routinely paste in the following to each new CoderPad interview when it's scheduled for me: ## Jeff Atwood: ## To familiarize  yourself with this environment and prepare for our ## interview please implement the following code: ## FizzBuzz: ##    For each integer in the range 1 to 100 (inclusive) ##    Print a line such that: ##    If it's evenly divisible by 3  print "Fizz" ##    If it's evenly divisible by 5  print "Buzz" ##    If it's evenly divisible by 15 print "FizzBuzz" ##    Otherwise: print the number itself. ## (Feel free to change to another scripting or programming language ## if you prefer) ## Be prepared to talk about testing methodology, refactoring, ## code maintenance or design considerations (as if this weren't ## a "toy" problem) as well. (Where I replace "Jeff Atwood's " name with that of the candidate) I've done this about a dozen times over the last couple of months.  So far no one has gotten a perfect score on it and only one person has gotten a correct bit of code on the first try.  (Notice that I'm directing them to pick any language of their choice; I'm setting the default to Python (2.x) because most of the code we'd be having them work with is Python and because of my own biases). Note that this is the classic "FizzBuzz" problem statement.  (If you actually read Jeff's 'blog entry he describes it as only an example of the class of problems he presents to prospective coders). Here's a working solution: for i in range(1,101):     if i % 15 == 0:         print 'FizzBuzz'     elif i % 5 == 0:         print 'Buzz'     elif i % 3 == 0:         print 'Fizz'     else:         print i That's by no means perfect.  But it precisely implements the specified functionality.  Less than one in ten people who have been scheduled for phone screening as programmers (devops) does this well at this problem (in my experience). What would a perfect response look like (to me)?  Well, it would start by moving this code into a function (one extra line).  It would actually implement one function for output and another for the data handling (refactoring for testability).  It would parameterize the range ... or take a sequence/generator object as an argument (for future flexibility; but also for testing).  It would include a test suite. Notice that nothing in this personal vision of "perfection" is even remotely specific to Python? All of those extra "features" are silly for a whiteboard interview example; and they might seem silly for a CoderPad exercise.  But keep in mind ... I post this to the CoderPad URL reserved for the candidate as soon as I get it.  They have days to look it over and post in whatever they like.  They have the opportunity to impress me with their diligence, meticulousness, and eagerness. The solution shown here should take any competent Python programmer less than five minutes ... and require almost no thought ... just some typing time.  A good programmer will be asking some questions like: why 1 through 100?  What if we wanted other factors?  Is it coincidental that 15: FizzBuzz == 3*5: "Fizz"+"Buzz"? ... or should that relationship be part of the specification? None of us, who bill ourselves as programmers, should be proud that we can implement "FizzBuzz."  Anyone who can't do this easily in each programming language they list on their resume should be ashamed.  (More importantly they should learn how to program). I know this may already seem like it's devolved into a rant.  It's hard to answer a real world question about programming interviews without being frustrated by the state of the real world. You asked specifically about language specific deficiencies which I would find disappointing in a candidate.  The stop of the stack, for me, is whether or not they can handle the simplest possible coding tasks: looping over some range of numbers or sequence of "things" ... checking for simple conditions and doing things based on those conditions.  That's FizzBuzz.  We shouldn't even have to list it in this sort of discussion and I only do so because I've actually encountered that specific disappointment more often than not. I'll grant that some of my disappointments have been on much on some finer details.  Did they catch the edge cases?  Leave off 100?  Include zero?  Did they check each of the factors and output lines for each matching factor (separate if statements rather than one if ... elif ... else structure)?  Did they notice the sequencing dependency (the need to check 15 before 5 or 3)?  Did they leave off the "else" clause. Each of those is a minor disappointment (and I've seen each in practice).  I'll happily consider a candidate who misses any of those ... but they aren't being meticulous if they miss them. My disappointment is compounded when a candidate misses those sorts of details in their code and doesn't have any test suite.  (If you have a test suite  ... and it's wrong as well as your code then it's simply a misunderstanding of the requirements; I'll chalk that up to stress and natural language issues.  But the lack of any attempt to write tests when combined with the error (or possible misunderstanding) is double trouble. (To be clear, if your code correctly implements the spec and you have no test suite than I'm satisfied with your proficiency and merely not as impressed with your diligence or enthusiasm.  It's just when you get your code wrong and lack tests that it's really disappointing). As for more language specific details and questions ... I posted a list of over sixty of them here: Jim Dennis' answer to What are some great questions testing knowledge for someone new to Python? Can I extract five themes from those?  Let's try. Semantics Misconceptions Batteries Community Idioms Semantics matter more than syntax! Generally I care less about syntax and far more about semantics.  I'm especially attuned to those semantic differences which commonly confuse people who've been proficient in some other language. I care less about specific terminology and jargon (for example the differences between "names" or "identifiers" and "variables" or the distinction between "assignment" and "binding" and the differences between statements and expressions).  These are cultural (that is in the sense of different online communities) and the majority of the people I've been interviewing over the last year speak (American) English as a second language. I care about some of the concepts underlying these terminological differences. For example, do you understand that Python's semantics, as a "late binding dynamically typed" language, are significantly different than those normally associated with C, C++ and Java ... and even those in Perl, PHP and Javascript? What we casually call a "variable" in Python should be called a "name."  In most programming languages declaring or defining a variable allocates a bit of memory and associates its location with some identifier.  In Python identifiers are all references to objects.  You can have a name refer to an integer on one line and a string or dictionary (hash, associative array, mapping, table) in another line.  The binding (association between name and object) was changed rather than the contents at location in memory *after* dereferencing a variable.  This distinction shows up in surprising ways and places for people shifting to Python from most other languages. Do you understand immutability and its implications? (This is the heart of a question like: "is Python pass-by-value or pass-by-reference?"  The typical example is this "trick" question: Given the following: def foo(item, bar=list()):     bar.append(item)     return bar What happens if I call foo(1); foo(2); foo(3)? What happens if I call baz=[]; foo(1); foo(2, baz); foo(3)? The answers to these questions involve both the handling of arguments and the semantics of immutability.  If you recognize that the parameters in a def statement are evaluated at the time you're defining the function while the arguments are handled during each invocation then you're way ahead of the game.  If you further understand that this distinction is mostly relevant when dealing with mutable objects (lists, dictionaries, sets) that's good, too. If you recognize that this form of function definition creates a closure of the function over the object to which "bar" is bound by default ... and you're sufficiently precise in your explanation to have put it in those terms ... I want you to come work with me. Here's another example of tricky semantics: number_names = {     "1": "one",    "2": "two",    3.0: "three",    } number_names["3.0"] ... what happens and why?  What about if I try to reference number_names[3]? If you understand that Python's dictionary semantics are different than those of most other languages ... that most types of immutable objects are distinct keys in a dictionary such that 1 and "1" are different ... then you're doing much better than most.  If you understand that integers and equivalent real numbers will map to the same value I'm impressed.  If you know that number_names[decimal.Decimal(3.0)] maps to the same key as 3 and 3.0 then I'm actually astounded. If you get the syntax wrong your code won't run.  But getting semantics wrong can bite you in the worst ways ... bugs which only show up under specific and sometimes very rare combinations of circumstances. Misconceptions can be counter-productive If you come in to an interview with me and express disdain for it as a language ... then you better know what you're talking about.  It's fine to have valid criticisms; but it's also easy to take some criticism from off the 'net, spew it at me and expose that you don't understand the underlying concepts. Mostly I see this with complaints about performance and scalability of threading.  (Python is slow because of the GIL, etc).  But I've also seen generalizations to suggest that Python can't be used for "large" projects and that Python code is not maintainable beyond some modest number of lines and that Python is "weakly typed." Expressing those criticisms can be tempting ... as a way of showing off your deep knowledge of programming and diversity of knowledge about systems other than Python.  But picking out those which are misconceptions is very disappointing. Have you ever compared how easy it is to scale a problem in Python using the multiprocessing  module?  Have you ever written multi-threaded code in Perl, Ruby or C?  Testing the performance of the former two cases?  Debugged issues in the latter case? Do you know anything about the distinctions between multi-threading, multi-processing, and non-blocking event driven "co-operative" programming techniques and models? (Twisted being the most prominent example of the last among these; there's also asyncoro and probably others). (One of my expressions of disdain for Python was someone who said that Python was useless for him because strings are immutable.  This was not in an interview, so it's only an aside here.  But Python does include an array module, support bytearray objects (built-in, since 2.6), and one could always use an mmap object as a mutable byte array (since before 2.5)). This not to say that there aren't valid criticisms of Python to be made. Managing virtual environments is messy and only slightly better than just leaving whatever version of Python your OS shipped with alone and writing your code to a "least common denominator" of your intended deployment targets. Python's scoping rules are just strange compared to those of almost all other programming languages. (Here's a good thread on that: Short Description of Python Scoping Rules; but it's not so short).  For comparison to a few other languages consider: Scope (computer science) on Wikipedia.  (No post of mine on Quora seems complete without at least on link to StackOverflow and one to Wikipedia). The transition to Python3 involves some deep changes to the semantics for strings vs. bytes which are subtle and pervasive enough to keep programmers busy for the next decade (both in adjusting their expectations and porting or fixing code). (Here's Thoughts on Python 3 which mostly focus on these string vs. bytes issues). Tail recursion elimination is a wart ... more cosmetic than anything.  But it does require some code refactoring for some forms of code which can be quite elegant in their recursive form. I have some peeves of my own (for example import should allow one to provide a string, path, or file object without having to jump through __import__ and other hoops; and options for dealing with foreign function interfaces (ctypes) and refactoring Python code into compiled modules (Cython, et al) are a bit of hairy when you do it a real performance bottleneck). Also the syntax for single element and empty tuples is ugly --- and there are some quirks when using tuples with the string % (interpolation) operator ... and the .split() vs. .join() quirk (see below). There are warts and critiques: PythonWarts - Python Wiki, Unfortunate Python, YourLanguageSucks - Theory.org Wiki (mostly nits, really), Five things I hate about teaching Python. Did you know the batteries were included? One of my peeves in programming interviews is when the candidate either doesn't know that Python has standard libraries or chooses to ignore them.  It's one thing if I pose a problem and specify that you should write the code because I want to review your lower level coding skills; but even then you can say: "That would be just the list's .sort() method, of course ..." and then go into the implementation. I'll give an example.  One of our simpler programming "challenges" calls for you to write code to implement the "top K selection" from a very large list of numbers.  (Where "very large" means more than you can fit in memory and enough that you might run out of disk space, too; alternatively you can think of it as an unbounded stream where I want to be able to query for the "top K" (some arbitrary but relatively small number of the largest items encountered thus far).  The follow-up question is to characterize the performance of your solution. A trivial solution for the simple case (it all fits in memory) is to sort the list and take a slice.  It's great to mention that as a preface to any coding solution; and the efficiency would be O(n*log(n)) ... the same as any good, general purpose sort. A solution to a degenerate subset of the problem would be consider what we do if K==1 ... we just keep track of the maximum item.  That's a simple O(n) ... linear approach.  It's worth verbalizing this, in an interview. A good coder will realize that we want some of heap or other data structure ... even just a bounded list. Here's my point for this bullet: don't just jump into a bunch of code to implement a heap or bounded list data structure. If the first thing that occurs to you is to use a list then describe that: "If I maintain it as a simple list then I need to either keep the list sorted or scan through it every time I change it ... keeping track of the smallest item among the top K that I've currently found.  I also have to write some special case code to handle the list bounding ... for example I grab the first K items from the list then have a different loop or function handle every item thereafter.  In that main loop I just check if the current item is bigger than the smallest of those that I currently have, if so I replace it and then scan the list for the new smallest item.  (It's easy to forget that this new item might be larger than the old smallest but also larger than some other items as well)." So, using a list involved either a (small) linear scan or sort every time I change the list.  The overall performance for relatively small K vs. large N is linear.  Keep track of 10 or even 1000 items out of millions or billions amortizes quickly. That code, in Python is pretty simple. What about if you want to gild the lily?  You can use a binary tree.  But I'll be disappointed if you start writing the code for that when I'm conducting an interview that's explicitly focused on Python.  I'd be happy if you say: "There's probably already a library to handle this in Python."  I'll be delighted if you write code using the bisect module and ecstatic if you oppose the idea of using the heapq's .heappushpop() method. (Trick, you have to invert the sign of each item to get this right ... but that's a quibble). Now I don't expect people to have memorized all of the modules available in the Python standard libraries.  But it's nice if you can, at the very least, speculate on what's probably available. One of the main reasons to use Python is to avoid having to re-work the wheel ... to use the "batteries" which are included. (BTW: when answering a question like this "top K selection" example, it's also good to comment on how the problem appears out in the real world and on any approaches that are already in use.  For example the whole Apache Kafka / Storm ecosystem is mostly used to keep track of "top K" or "what's hot."  This isn't an acceptable answer for the interview question; but recognizing that the question is essentially a statement of the same problem ... and saying so ... is worth lots of points in an interview). Community The obvious extension to that is to think about the code that's freely available for Python beyond the standard libraries.  If a problem sounds like data analytics then you might mention that Numpy and SciPy are likely to be of use.  If it sounds like a "big data" then mentioning Python's support for Hadoop and Spark makes sense. If it has anything to do with ReSTful automation then perhaps Requests is worth bringing up.  For any sort of web scraping one might want to mention BeautifulSoup, or Scrapy. If it sounds like a operations question that might involve automating some sort of terminal interaction then consider a reference to  Pexpect version 3.3 ... and for anything involving ssh you might talk about paramiko or Fabric. Those last examples expose my tendency to be interviewing for operations oriented positions.  But the point is that you want be familiar with the modules, libraries, frameworks and packages that are specific to your field of interest. Like said in my first comment ... this depends on what you're actually trying to write programs to do. Idioms That this is last on my list is intentional.  I'm only a tiny bit disappointed when a candidate doesn't know (or choose to ignore) some common Python idioms.  Failing to use if __name__ == '__main__': or #!/usr/bin/env python are nitpicks.  But, if all other things were equal, I would prefer the candidate who is familiar with these idioms over one who wasn't. Updated 18 Oct • View Upvotes • Asked to answer by Sricharan Chiruvolu