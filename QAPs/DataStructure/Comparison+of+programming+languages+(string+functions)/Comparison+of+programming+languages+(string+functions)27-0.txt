Why can't binary be reversed to source code exactly as it was before compilation?
Because computer languages are symbolic. A compiler converts the symbols into code. Take this short program: main(int argc, char *argv[]) {    for(i=0;i<10;i++) {       printf("Quora rules!");    } } Almost everything there is a symbol. The constants (10, and "Quora Rules!") are data. The "for" symbol tells the compiler to start a type of loop which uses the symbol i and the constant 10 to determine when to exit the loop. The open and close brackets symbolize the code to execute during each iteration of the loop. The printf tells the compiler (because it is not a keyword or accepted language punctuation) to make a subroutine call that is defined elsewhere. The compiler actually outputs this text file: .file "ss.c" .section .rodata .LC0: .string "Quora rules!" .text .globl main .type main, @function main: leal 4(%esp), %ecx andl $-16, %esp pushl -4(%ecx) pushl %ebp movl %esp, %ebp pushl %ecx subl $20, %esp movl $0, -8(%ebp) jmp .L2 .L3: movl $.LC0, (%esp) call printf addl $1, -8(%ebp) .L2: cmpl $9, -8(%ebp) jle .L3 addl $20, %esp popl %ecx popl %ebp leal -4(%ecx), %esp ret .size main, .-main .ident "GCC: (GNU) 4.1.2 20080704 (Red Hat 4.1.2-52)" .section .note.GNU-stack,"",@progbits Let's just look at a few things here. First, not that the string "Quroa rules!" appears at the top as a string (.string) on line 3. In the far left is a label ".LC0" that will resolve to an address at run time. Remember that. Now look at line 17. This is a jmp instruction that says move execution to ".L2" is a label at line 22. Execution will actually move to line 23 the first line after the label. This is a compare instruction that is comparing something "-8(%ebp)" to $9 which is hex for 10-1, the original loop invariant in the code - 1 since the compiler uses "less than or equal to".  That sets some flags internal to the CPU core and goes to the next instruction which is "jle" jump-less-than-or-equal. So if the previous comparison was less than or equal to 10-1 ($9) it moves execution to the label ".L3" on line 18. %ebp is a register and -8 is an offset added to the register. That is the program stack where local variables are stored. That means that our variable "i" in the C code actually lives in the stack and is referenced only as an offset from the top of the stack (8 bytes back). There is no reference to a variable name, it is simply an address in memory which is computed by adding -8 to the value in the register %ebp. This would be the same if we had used the variable name "times" instead of "i" in the source code -- it was only a symbol the compiler has converted to an address (which happens to be relative to another address). You see at line 16 this was set to zero because we initialized to 0 in the for loop. So we do take the jump to label ".L3". At line 19 the address of .LC0 is moved into the register %esp. Recall .LC0 is the string we wanted to print. The the call to printf but "printf" is a stub for the linker. The code for printf which is contained in a library will be added to the program (static) or linked at run time (dynamic). Then at line 21 we add one to the -8(%ebp) which, as you'll recall, was the variable "i". Then we go to the comparison we started with. When the the comparison at line 23 is greater than .L3 at line 24 it will go to line 25 which exists the program by cleaning up the stack and restoring some registers before returning. That is the code for the for loop. So, if you just had the assembly file we just examined how would you know the variable name i? You wouldn't. But how do you know that was a "for" loop instead of a "do" loop or a "while" loop as the compiler will make them all look the same. Again, you don't. The symbols are converted into relative address, absolute addresses, and linker stubs. We haven't even got to the optimizer yet which will make the above code look even different before it is assembled. The question is, can you tell what language it was originally written in even? You can't. As you can see without putting some information in the assembly code, like comments that hold original variable names, there is no way to convert from pure assembly back to the source code, if even you could look at the assembly and determine what language it was even written in or what compiler compiled it, two things you must known to even begin to go backwards. Updated 8 Jul • View Upvotes