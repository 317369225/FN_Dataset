Why do many software engineers not like Java?
Well, I guess I'm kind of biased, since my bread-and-butter (these days anyway) is gotten by writing tons of (hopefully) well-documented and functional Java code.  I can't say it's my favorite language (I REALLY liked assembly language ...., and Forth had me buzzing for years).  So, maybe I'm really weird....  But, let me start with some (very) personal observations: 1. Java vs. C++:  don't get me started on trying to debug template operator overload bugs in my code derived from the STL...  Most of the time with Java I don't even need a debugger -- put in some relevant logging (or just System.out print statements), recompile/rebuild in a few seconds and try again.  2. Java vs. C: How about the heap corruption bugs I was trying to track down ALL THE TIME with C that have never occurred, not even once, in Java. 3. Java vs. anything else that I want to run the same on Linux, Mac, Windows, ...: Wouldn't even try.... 4. Java vs. ???: Trying to write code to interface with sound cards, MIDI, graphics libraries, encryption, web services ... It may not be that pretty in Java (see answers above), but it JUST WORKS, and lets me concentrate on the system design and the business logic, without worrying about whether I can actually find some libraries (or might have to write my own) to do XYZ. Now, having said all that (which, by the way) were major reasons I CHOSE Java for my current project, there are things I don't like. 1. Everything is a class (well, except primitive types).... So, even things that shouldn't be a class have to be a class.  Why can't I just write a callback function ....  Or a utility method.... Why should I have to make a "Utilities" class, and call everything like "Utilities.doThis()"? 2. Speaking of which:  why does every little piece of code I want to run in the background have to be a "new Runnable(...)"? 3. Names like "AbstractRegionPainter.PaintContext.CacheMode"... Need I say more? 4. Until Java 7 you HAD to write stuff like this:     private static Map<String, Future<FileOutputStream>> futuresMap = new ConcurrentHashMap<String, Future<FileOutputStream>>(threadPoolSize); UGH!  Now it can be written like this:     private static Map<String, Future<FileOutputStream>> futuresMap = new ConcurrentHashMap<>(threadPoolSize); GREAT IMPROVEMENT, NO?! So, kind of a mixed bag.  But, overall, I'd say I've been more productive (in terms of amount of functionality implemented per time) in Java than anything else I've ever used, but .... sometimes .... 