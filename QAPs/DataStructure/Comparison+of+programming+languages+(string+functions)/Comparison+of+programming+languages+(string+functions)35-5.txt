Why do many software engineers not like Java?
A lot of people have written a lot about it, but I think the problem is much more fundamental than most of what they've written about (or probably even believe/realize). The basic nature of computer programming is one of investing a lot of time and effort up front (i.e., designing and writing the program) with the expectation of a massive long-term pay-off (automating boring tasks out of existence entirely). Of all languages in reasonably current use, Java runs the most directly contrary to that basic philosophy. From the very beginning, Java sold as a simplified, easier to learn language than C++. Nowadays, people might compare it to other languages (e.g., Haskell) instead, but the basic idea remains the same: to use Haskell (well) you need to invest a lot up-front in learning non-trivial concepts. The notorious phrase about "a monad is just a monoid in the category of endofunctors. What's the problem?" fairly springs to mind. Languages that are favored by software engineers are the ones that fit the basic mindset of software engineering: being willing to invest a great deal up-front in order to automate entire classes of problems out of existence in the long term. Java does nearly the opposite: simplify the language to reduce the work up-front required to learn the language, but in exchange for that, leave it to its users to manually re-implement the same basic concepts hundreds upon thousands upon millions of times over. Some have attempted to cite the Java standard library (and especially its size) as indicating that this is basically wrong. In reality, it is (again) still more evidence of my point. Let's consider a concrete example. Here's an implementation of RSA encryption from the ground up in C++: template <class T> T mul_mod(T a, T b, T m) { if (m == 0) return a * b;   T r = T();   while (a > 0) { if (a & 1) if ((r += b) > m) r %= m; a >>= 1; if ((b <<= 1) > m) b %= m; } return r; }   template <class T> T pow_mod(T a, T n, T m) { T r = 1;   while (n > 0) { if (n & 1) r = mul_mod(r, a, m); a = mul_mod(a, a, m); n >>= 1; } return r; }   struct crypt : std::binary_function<num, num, num> { num operator()(num input, num key) const { return pow_mod(input, key, n); } }; If you instantiate it over something like `int`, this will be a toy--but if you instantiate it over an arbitrary integer type, it can do real RSA encryption that really will be difficult for somebody to break. Basic point though: the sole real difficulty here is understanding RSA itself--how it works, how to implement it, and so on. Now let's consider how RSA looks using the Java standard library: /** * Encrypt the plain text using public key. * * @param text * : original plain text * @param key * :The public key * @return Encrypted text * @throws java.lang.Exception */ public static byte[] encrypt(String text, PublicKey key) { byte[] cipherText = null; try { // get an RSA cipher object and print the provider final Cipher cipher = Cipher.getInstance(ALGORITHM); // encrypt the plain text using the public key cipher.init(Cipher.ENCRYPT_MODE, key); cipherText = cipher.doFinal(text.getBytes()); } catch (Exception e) { e.printStackTrace(); } return cipherText; }   /** * Decrypt text using private key. * * @param text * :encrypted text * @param key * :The private key * @return plain text * @throws java.lang.Exception */ public static String decrypt(byte[] text, PrivateKey key) { byte[] dectyptedText = null; try { // get an RSA cipher object and print the provider final Cipher cipher = Cipher.getInstance(ALGORITHM);   // decrypt the text using the private key cipher.init(Cipher.DECRYPT_MODE, key); dectyptedText = cipher.doFinal(text);   } catch (Exception ex) { ex.printStackTrace(); }   return new String(dectyptedText); } [This example taken from: RSA Encryption Example] I hasten to point out that this isn't an entirely apples-to-apples comparison. The C++ code actually *implements* RSA itself. The Java code uses the RSA implementation in the standard library. Despite this, the Java code is considerably longer than the C++ code. Worse, the Java code is actually incomplete--we'd need a few more lines of code to define things like "ALGORITHM" before this code would actually compile. Much more important, however, is a fundamental difference between the Java code and the C++ code. The C++ code There are two points to note though: although it doesn't implement RSA at all, the Java code is still several times larger than the C++ code. Worse, especially  when it comes to the encryption proper, the Java code is all about memorization, not understanding. There's virtually nothing there that can actually be understood--it's pretty much a collection of arbitrary names. Along with lack of understanding, they haven't even had the courtesy to make the names consistent. For example, in the encrypt/decrypt functions, we have an `init` and a `doFinal`. If we're going to throw in a gratuitous "do" why not at least do so consistently, and name them doInit and doFinal? So here again, we have more of the same: C++ is about investing up-front in understanding, while Java is about memorizing more arbitrary "stuff" with essentially no relationship to the actual task. Software engineers don't like Java because the basic premise of Java runs directly contrary to the basic premise of software engineering. Updated 23 Aug • View Upvotes