Why is C++ so complicated?
C++ complexity stems from three very different sources. First, you have the fundamental tenet of C++ design philosophy: You never pay for what you don't use. This means that, in every case, the default behavior should avoid non-obvious hidden costs, and that obvious "hidden" costs (things that give C programmers conniptions, like invoking destructors and conversion operators) should be avoidable if desired. Things that have runtime penalties are deliberately less trivial to invoke (leaving aside things like pass-by-value, which falls under the second source of complexity that I will address next) and this means that some constructs that are for programmers, but terrible for programs, in other languages are going to be difficult to utilize, or outright unavailable, in C++. Second, you have a legacy of backward compatibility, both with earlier versions of C++ and with C. Some of these have been sources of highly unfortunate constructs in C++. C-style includes are a bane, and until modules make it into C++, we're stuck with the consequences. Preprocessor macros are unfortunately unconstrained and capable of terrible pollution. This, too, is an unfortunate legacy that cannot be trivially removed. And the legacy extends to obsolete idioms that are still prevalent in codebases around the world. C++ is not a young language, and the legacy of its early years, when lessons were learned that other languages benefitted from, will never completely go away. And third, you have a discovery both serendipitous and unfortunate, that the template language originally intended to supplant C's preprocessor macros was a Turing complete functional language that executed at compile time. Because this was not its designed purpose (unlike later languages like D, or what is being developed for Rust) the syntax is complex, and often unwieldy. As much as C++11, 14, and 17 have improved this, the old syntax remains in place - that second point again - and while it might not be the idiomatically preferred approach, if you're dealing with template metaprogramming - and only library developers should really deal with this layer - you need to know the old stuff just to read legacy code you will inevitably stumble across. As a bonus fourth, the C++ standard library is lean, and adding to it is a conservative process, so sometimes you need to go outside of the standard library for what you need, and that means dealing with either your own libraries, or third party libraries of inconsistent style, quality, and complexity. Updated 14 Sep • View Upvotes • Asked to answer by Pravasi Meet