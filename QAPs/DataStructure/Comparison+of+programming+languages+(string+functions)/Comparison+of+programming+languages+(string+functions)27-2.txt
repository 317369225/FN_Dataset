Why can't binary be reversed to source code exactly as it was before compilation?
There are a number of issues with decompilation. - When source code is compiled a single programming languageÂ  keyword or function is compiled into multiple assembly instructions. Given these assembly instructions its hard to know which ones map back to which keywords in the programming language. In some cases given a group of assembly instructions there could be many ways to map it back to source code. - There is no way to know what programming language was used to compile the raw assembly instructions. You could make an assumption given some of the patterns in the assembly but given raw assembly instructions there is nothing saying what language was used. - The processor doesn't care about things like variable names and function names it only cares about memory locations and because of this function names and variable names are missing. - Compilers have a ton of optimizations that they do when compiling. This could mean moving around code, removing chunks and completely changing code. As compilers are getting better and better the source code you would get if you could decompile would be drastically different then the source that was written and in a lot of cases the optimized code might be very difficult to read and understand. ** Some languages emit more meta data into the end assembly then others. For example in technologies that use a JIT like .NET and Java there is a large amount of meta data which does describe a lot about the source. This is very useful for doing on the fly optimizations during run time as well as debugging but it makes these languages much easier to decompile back to their source. 