Does Swift overcome the limitations of Objective-C?Syntax and readability aside. Instead: how it compiles and performs.
There are many areas in which Swift is superior than Objective-C. Memory safety This translates into a couple of features (and other): • optional types (with the help of generics) • constructor & initialisation rules • safe type casting Optional types represent a polymorphic type that encapsulates two cases: the original value or a none value. They are used to treat the case of nothingness (nil/null/etc.). Optional types are fairly common in functional languages and Swift has special syntax sugar to deal with them. In Haskell, the optional type looks like this: data Maybe a = Nothing | Just a In Swift, it looks like this: enum Optional<T> { case None case Some(T) } But this is generally written as T? and is initialised with either a value or nil. Optional types apply to any type in Swift because the enum is generic. So why is this useful? When you define a variable of type Int like var a:String you have a guarantee that the variable a can get values only in the possible range of values of String. It cannot be nil. That's valid for all Swift types (Int, Float, Double, Array, etc and custom types). So the code above will rise an error if the variable is used before being initialised - the compiler will always complain about uninitialised variables or constants before use. So what happens if you don't know the value of some variable? Or you really want to express nothingness. Optionals come into play here. Let's say you have a variable var a:Int? This variable doesn't have to be initialised before usage, but instead, the compiler will force you to check if a is nil or not: if let unwrapped = a { // use unwrapped Int } else { // a is nil } If a function takes an Int and you pass a as an Int?, you will get a type mismatch error. This model works really well to guarantee memory safety. In Objective-C all reference types can be nil but the compiler doesn't make you type each and every reference type before use (because that would be really annoying). In Swift you only sometimes have to model nothingness. With type casting you get the same behaviour: the compiler makes you check if the casting succeed or not. Of course, there are some workarounds for these compiler enforcements, but they are usually not encouraged and used only because of some limitations, edge cases or cases when the programmer really knows what he's doing. Constructor and initialisation rules refer to the same principle. You cannot construct an object without carefully initialising the object. Non optional types need to be properly initialised. Also, when subclassing, some special rules come into play. Please refer to the Swift official book for more information. There can also be failing constructors that return nil if they failed initialising the object (let's say a file on a disk that's missing) or T? if the file succeed. In any case, you have to check if the initialisation succeed. • Tony Hoare - There is a famous story related to the null reference issues called Tony Hoare's 1 billion dollar mistake. • Nullability and Objective-C - Swift Blog This year (2015) at WWDC, Apple announced they added some keywords to the Objective-C language like nullable and nonnull to aid the transition to Swift. Static typing This is a feature in my opinion. Having the compiler aid you from doing mistakes is always nice. The compiler will always warn you when something may be ambiguous or type-wise incorrect. Information is key. Being explicit when you write code makes your code less error prone. GenericsHaving more type information at compile time gives you more safety, expressiveness, code reusability and performance. In Objective-C you had NSArray in which you can push anything, not knowing for sure what you'll get back when you wanna pop something back from the array. In Swift, the generics are implemented using Reification and not Type erasure like Java. you can read more about this: • Comparison of C Sharp and Java. This year (2015) at WWDC, Apple announced they added support for lightweight generics in Objective-C in order to aid the transition to Swift. Switch statement The swift switch statement is way more powerful than in Objective-C (and many other languages). You can switch on Ints, Strings, Ranges, Tuples, and any other type that can work with the ~= operator. You can also overload the ~= operator so you can pattern match over your custom types. The swift switch statement is also exhaustive and warns you if you don't treat every possible case. You can also use the default case for large possible values sets like Int, String, etc, but this is especially useful for enums. As from what I recall, this is one of Chris Lattner's (the main language designer) favourite features. More about the switch statement: • Swift: The Good Switch of the East Enums The enums in Swift are super cool. If I remember correctly, in a discussion on the developer forums, Chris Lattner said that enums are his most favourite feature of the language. They have value semantics, can conform to protocols, can be extended, can use raw values to be initialised (Int, String, etc.), can be generic, can can have static and instance methods, can be self recurring, and can have associated values. For example: enum Result<T> { case Success(T) // generic associated type case Error(String)   func errorMessage() -> String? { switch (self) { case .Success(_): return nil case .Error(let message): return message } } }   func doRequest() -> Result<JSON> { if (success) { return .Success(responseJSON) } else { return .Error(errorMessage) } } Recursive enumeration: enum ArithmeticExpression { case Number(Int) indirect case Addition(ArithmeticExpression, ArithmeticExpression) indirect case Multiplication(ArithmeticExpression, ArithmeticExpression) } Value and reference types In Swift you can have both value and reference types. structs, enums, tuples follow value semantics (class instances follow reference semantics). This means that they follow pass-by-value semantics. This also means that you have a guarantee that you won't have several references pointing to the same object. Passing by value can also produce more optimised code and aid programming for parallelised applications without the need of using synchronisation mechanisms. There is an interesting talk by Andy Matuschak (former Apple UIKit employee): • Controlling Complexity in Swift by Andy Matuschak (Video) Mutability/Immutability In swift you can declare something to be mutable by using the var keyword and immutable by using the let keyword. If you use a let over a reference type, you cannot change the reference to that instance, but you can change the instance. On the other hand, if you use a let on a struct or enum, that value is immutable and you can't call mutating methods on those values. If we use var both references and values can change. Value types have methods marked with the keyword mutating if they change the value. This feature brigs safety and performance optimisations opportunities for the compiler. Extending structs and enums You can easily extend an existing struct or enum (even if it was not defined by you). For example: extension CGRect { func rectByOffsetting(dx: CGFloat, dy: CGFloat) -> CGRect { /* ... */ } mutating func offset(dx: CGFloat, dy: CGFloat) { /* ... */ } } Less code, less files. As you mentioned, the syntax is much lighter and you need only one file (.swift) without the .m/.h jumping around. Protocols with default implementation The one major shortcoming of protocols, both in Swift and Objective-C, is the lack of a built-in way to provide default implementations for methods, as one might accomplish in other languages with mixins or traits. For example: struct PackagingOptions : OptionSetType { let rawValue: Int init(rawValue: Int) { self.rawValue = rawValue }   static let Box = PackagingOptions(rawValue: 1) static let Carton = PackagingOptions(rawValue: 2) static let Bag = PackagingOptions(rawValue: 4) static let Satchel = PackagingOptions(rawValue: 8) static let BoxOrBag: PackagingOptions = [Box, Bag] static let BoxOrCartonOrBag: PackagingOptions = [Box, Carton, Bag] } With only adopting the protocol with a little bit of code gives you a large set of free operations implemented by default in the protocol like: isSubsetOf, isSupersetOf, isDisjointWith, subtract, isEmpty, isStrictSupersetOf, isStrictSubsetOf, etc. More about protocol oriented programming: • Protocol-Oriented Programming in Swift • Why Apple emphasis protocol oriented development in Swift? Java has supported interface for a long time, what is so special to use protocol? Swift playgrounds You can use the Swift playgrounds to test out pieces of code very fast without the need of recompiling every time a full project. You can see live changes in real time. This is particularly useful for transitioning from Objective-C. It aids rapid prototyping and also helps beginners to approach the language. Here's Chris Lattner presenting the playgrounds: Open Source At WWDC 2015, Apple announced the Swift will be made open source by the end of the year. This will guarantee more transparency, more community support, inside insight, etc. The language will also be available for Linux (and maybe Windows in the future). This will make the language be used for full stack development. Imagine writing a web API, a mobile application, and desktop applications all in Swift. Static or Dynamic dispatch Like many other languages, Swift allows a class to override methods and properties declared in its superclasses. This means that the program has to determine at runtime which method or property is being referred to and then perform an indirect call or indirect access. This technique, called dynamic dispatch, increases language expressivity at the cost of a constant amount of runtime overhead for each indirect usage. In performance sensitive code such overhead is often undesirable. There are ways that can improve performance by eliminating such dynamism: the final keyword, the private access specifier, and Whole Module Optimisation. More about this: • Increasing Performance by Reducing Dynamic Dispatch - Swift Blog • Profiling in Depth - minute 29:22 Multiple return types You can use tuples to return multiple results from a function: func foobar() -> (Int, String) { return (5, "foobar") } Support for try-catch error handling mechanism TODO Operator overloading This is the most controversial feature of Swift. It adds a lot of power in the hands of the programmer. You can overload a lot of operators for good use (like adding two CGRect structs, or implementing the equality operator in order to conform to the Equatable protocol) or for bad use. This is a feature that has to be treated with a lot of responsibility. For example: struct Vector2D { var x = 0.0, y = 0.0 }   func + (left: Vector2D, right: Vector2D) -> Vector2D { return Vector2D(x: left.x + right.x, y: left.y + right.y) } Type inference This feature is more of a convenience. The compiler knows how to infer the type of an expression in the majority of cases. Where it has trouble it will warn you. let a = 4 // this will be automatically inferred as Int Easier block syntax The block syntax is much nicer. No more need for How Do I Declare A Block in Objective-C? as a reference. There is still Closures in Swift but I think it's just not needed. Nested types You can define new types inside other types. Curried functions The concept of currying is that instead of accepting multiple arguments, a function accepts only one, and returns a function which acepts the remaining arguments. The returned function will also accept only one argument, and returns another function. This process continues until all arguments are exhausted and we are left only with a single return value. This is useful when you don't have all the arguments of the function at once. Availability syntax In Swift 2.0 there is a new syntax for checking API compatibility. There are a set of APIs that are annotated with the minimum deployment target required. The compiler will warn you when you try to call APIs marked with availability annotations. You will first need to check the minimum deployment target in order to use the APIs. Example: if #available(iOS 9, *) { // use UIStackView } else { // :( use "Auto"layout } Access control There are the public, internal and private keyword used to specify access control for code. willSet and didSet In order to observer proprieties, there is a nice syntax that allows you to do that without the need to completely override setters/getters. class StepCounter { var totalSteps: Int = 0 { willSet(newTotalSteps) { println("About to set totalSteps to \(newTotalSteps)") } didSet { if totalSteps > oldValue { println("Added \(totalSteps - oldValue) steps") } } } } 