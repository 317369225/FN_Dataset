Haskell (programming language): What are type classes and how are they useful?
You could think of type classes as an analogue of interfaces in object-oriented languages. It's a way of making polymorphic functions which don't care which type is used so long as it is capable of some small set of generic things. Let's say you implement a really awesome sorting algorithm. It combines two or more different sorting algorithms and chooses intelligently between them based on the list's size. Your use case was to sort a list of integers, so that's how you wrote it: superSort :: [Int] -> [Int] As you produce more code, you decide you would do well to sort a potentially giant list of strings, and you realize that the superSort function you wrote would be perfect for it. Since superSort is only for integers, you copy/paste the function definition but specify the types as strings, instead: superStringSort :: [String] -> [String] As you develop further, you find that you could really benefit from a sort on a type you created. So you copy/paste again and then modify superSort to make the proper comparisons between two values of your type. You miss one and forget an argument somewhere else, but then fix those bugs in a few minutes of debugging. superFooSort :: [Foo] -> [Foo] Then it happens that you need to sort a list of Foo by a different property of Foo than your current superFooSort does. You are sick of copy/pasting and making minor modifications to the same function, so you consider other possibilities, and that's when inspiration strikes. You realize that instead of hard-coding the proper comparisons into the superSort function, you could specify it when you call superSort to begin with. You realize further that this will now allow you to sort any type by any criteria so long as you can provide the comparator to use! So you write this: data Comparison = Less | Equal | Greater genericSuperSort :: (a -> a -> Comparison) -> [a] -> [a] This works wonderfully for a while. Then you start getting tired of having to write the same comparator functions over and over. So you define each comparator you use one time and refer to it. You were used to giving superSort one argument, so you periodically leave out the comparator when calling genericSuperSort, but that's a minor annoyance. You daydream for a bit about how convenient it'd be if data types somehow knew how to compare themselves, as part of their definitions. And then you get to a point where you have a list of Foo and need to find the maximum for a criteria you already have a comparator for. So you whip out this bad boy: let biggestFoo = foldl1 (\biggest f -> case compareFoo f biggest of | Greater -> f | _ -> biggest) foos That's annoying to write and annoying to read, and you have to do it a few more times in your code. So you consider writing something like this: genericMax :: (a -> a -> Comparison) -> [a] -> a genericMin :: (a -> a -> Comparison) -> [a] -> a Then you need to insert a Foo into an already-sorted list of foo. Ugh, here we go again: genericInsert :: (a -> a -> Comparison) -> a -> [a] -> [a] One day, genericInsert stops inserting things correctly. It takes you a day of debugging and second-guessing yourself to realize that you used a different comparator in genericInsert than you did to sort the list. Bloody hell. There has to be an easier way. Let's talk about Ord. Ord is a type class. If a type is a member of the Ord type class, that means the type knows how to order itself relative to other values of the same type. That means that all of the (a -> a -> Comparison) argument in all of the above functions are now implicit; it's always the comparator for the type you're sorting, inserting, or finding the min or max of. If you look at the sort function in Data.List, you'll see that its signature looks like this: sort :: Ord a => [a] -> [a] The type class specification Ord a => means that this function is effectively saying, "I don't care what type you give me, so long as it knows how to compare itself with itself." There are also functions: insert :: Ord a => a -> [a] -> [a] maximum :: Ord a => [a] -> a minimum :: Ord a => [a] -> a ...and more, scattered in other libraries, including third-party libraries you may end up using. So the benefit with Ord is this: once you make the type an instance of the Ord type class (i.e. you teach it how to order itself), you can use it with any function you find forevermore which is defined for members of the Ord type class, without any extra work or glue code on your part. Another good example is the Show type class, which allows you to use this little guy: show :: Show a => a -> string If you make your type an instance of the Show type class, you avoid a problem OCaml has with redundancy: string_of_int : int -> string string_of_float : float -> string string_of_bool : bool -> string string_of_your_type_here : your_type_here -> string 