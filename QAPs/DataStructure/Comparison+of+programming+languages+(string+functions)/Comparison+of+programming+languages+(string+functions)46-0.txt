Should code efficiency be favored over code simplicity in a software project involving several team members?Should code efficiency (e.g. x>>1, (x&1) ==0) be favored over code simplicity (e.g. x/2, (x%2) ==0) in a software project involving several team members?
I'm one of the guys who makes most "optimizations" like the one in the question details worthless.  The majority of my professional life to date has been spent on optimizing programs and writing compiler optimizations and backends. To answer the primary question: there is no general answer to the efficiency versus simplicity across all domains.  However, as several answers have said, pre-optimization is bad and by default, implementations should favor clarity, robustness, and simplicity.  Write clean, clear code, and the compiler will take care of 99% of the easy and useful optimizations.  Try to get "clever" and you're more likely to shoot yourself in the foot. Optimizations that are worth the effort are almost never a one-line change, but rather a major algorithm rewrite or hardcore assembly programming. One application was really lousy on both instruction and data caches.  In one situation, we rewrote the program to compress instruction info into data and built an interpreter for it, dramatically reducing instruction cache and L2 cache misses.  In another, we compressed and decompressed program data on the fly so that it'd all fit in memory: the extra processing was a lot cheaper than spilling to disk. If an app spends the vast majority of time on a small piece of code, rewriting it in assembly to suit a particular processor pipeline and cache structure and data pattern can yield tens of percent in performance increases, and sometimes that's worth the pain for future modifications. This situation rarely comes up these days, but I did it for one startup a few years back, and a friend was doing it for his high frequency trading firm around the same time. 