What could be an efficient way to find the length of the longest possible substring having distinct characters?
This problem can be solved with a time complexity of O(N) using dynamic programming. We will do this by keeping an array to store the "last seen" location for each letter - call it prev[]. Scan the string S[1…N] from left to right. For each position i, we will find best[i] = the smallest value of j such that S[j…i] has distinct characters. Clearly, we have the base case best[i]=1. While processing a new value of i, there are 2 possibilities : If prev[S[i]] ≥ best[i-1], there exists another copy of S[i] somewhere within the best substring we found ending at S[i-1]. Then the longest substring ending at i with distinct characters is S[prev[S[i]]+1…i]. That is, best[i] = prev[S[i]]+1. On the other hand, if prev[S[i]] < best[i], the duplicate character does not exist in the best substring for i-1, and we can just append S[i] to it to obtain best[i] = best[i-1]. Considering these two cases, we have the recurrence for best. Note that since best[i] depends only on best[i-1], we can use a single variable instead of an array. Pseudocode: def longestdistinct(S[N])  prev[]={0}  ret=0  best=1  for i = 1 to N    best=max(best,prev[S[i]]+1)    ret=max(ret,i-best+1)    prev[S[i]]=i  end  return retend 