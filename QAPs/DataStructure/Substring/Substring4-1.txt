What is the algorithmic approach to solve hackerrank problem Substring Diff?
Besides the O(N^2) solution mentioned by Raziman , we can also have a O(N^2 log N) solution using binary search. To find the maximum value of L, we binary search on it. This works because if there exists for particular L some i,j such that M(i,j,L)<=K, then obviously for all l<L, there also exists i,j such that M(i,j,l)<=K. So we have             int low = 0,high = l,mid;            while(low < high){                mid = (low + high + 1) >> 1;                if(solve(mid)) low = mid;                else high = mid - 1;            } Now solve(x) function will return true if we there exist some i,j such that M(i,j,x) <= K. This can be implemented in O(N^2) time using some pre-computation. We can keep an array count[i][j] which will tell us the number of mismatches between the strings [i-min(i,j) ... i] and [j-min(i,j) ... j]. Using this for any i,j, M(i,j,x) can be calculated as count[i+x-1][j+x-1]-count[i-1][j-1]. Hence the solve(x) function becomes something like this : solve(int mid){       for(int i = mid;i <= l;i++){            for(int j = mid;j <= l;j++){                int tmp = count[i][j] - count[i-mid][j-mid];                if(tmp <= K) return true;            }        }        return false;} Finally a simple dynamic programming to calculate count[][] in O(N^2)             l = P.length();            for(int i = 0;i < l;i++){                for(int j = 0;j < l;j++){                    count[i+1][j+1] = ((P.charAt(i) == Q.charAt(j))?0:1) + count[i][j];                }            } 