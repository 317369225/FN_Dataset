What is the best way to find the longest common palindromic substring between 2 strings?
We can do this in O(N^2) using DP and suffix arrays and improve it to O(NlogN) by using Segment Trees + Manacher's Algorithm in place of DP. O(N^2) Algorithm: First using DP we can easily find what is the longest palindromic sub-string in each sub-string starting from position 'i' and ending at position 'j' for all (1 <= i <= j <= n) in string A and store it in a 2D array dp[i][j] in O(N^2) time like this, First we define another 2D array pos[][] where pos[i][j] stores a bool value if the sub-string A[i....j] is a palindrome, this array can be recursively calculated as pos[i][j] = (A[i] == A[j]) && (pos[i+1][j-1]). Second we define the recursive relation to calculate dp[i][j] as if pos[i][j] == true : then dp[i][j] = j - i + 1, else : dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]). This is because if A[i....j] is palindrome then it will be the longest palindromic substring of A[i....j] else we take the maximum of the dp[i+1][j], dp[i][j-1] because the longest palindromic sub-string of A[i....j] now could only contain  either A[i] or A[j] but not both. Now we make a new string C = A + "$" + B (here '+' represent concatenation of strings), and calculate the suffix array for it in O(N logN) and calculate the LCP array (longest common prefixes for each adjacent suffix) in O(N). In the string C, the indices of the characters of string A lie in the range (0 to N - 1), Nth character will be '$' and indices characters of B lie in the range (N + 1, N + N). Now if we consider suffix starting from an index less than N (say 'i') and another suffix which starts from index greater than N (say 'j') the LCP of these two suffixes will not be more than max(N-i+1, N+N-j+1), in simple terms the longest common prefix of these two suffixes doesn't include the '$' character. Now all we need to do is for each pair of adjacent suffixes in the sorted suffix array if one is less than N (say i') and other is greater than N (say 'j') and let the LCP be 'k', then the respective sub-string we need to consider in string A will be P = "A[i]A[i + 1]....A[i+k-1]" and the respective sub-tring in B will be Q = "B[j]B[j + 1]....B[j+k-1]". As P == Q here, we just update the answer with max(current answer, dp[i][i + k -1]). The total complexity is O(N^2) = O(N^2) for dp + O(NlogN) for suffix sort + O(N)  for lcp respectively. Here the slowest part is the DP part of O(N^2). So if we can improve this to something faster then we can improve the whole solution. O(N logN) Algorithm : Now after creating the suffix array and finding LCP, all we got is some ranges (i, i+k-1) and asked us to find what is the longest palindromic sub-string in this range, i.e, simply for each index 'j' (i <= j <= i+k-1) we need to find the longest palindromic sub-string centered at 'j' and which can start after 'i' and end before 'i'+'k'-1. We might have maximum of 2*N such queries. I am only considering odd length palindromes in this solution, even length can also be found by making simple modifications. Here what we can do is for every index 'j' we can store the right most index at which the palindrome can end and the left most index at which the palindrome can start if the center is at 'j'. Now in each query if we see only the starting points will change for j such that (i <= j < i+k/2) and ending points will change for j such that (i+k/2 <= j < i+k). So we need to update the starting and ending points for respective 'j's'. This can be done using segment tree in O(logN) per each query. Now we have for each center 'j' the left most starting and right most ending points, and we can find the longest palindromic sub-string centered at each position in O(N) using Manacher's Algorithm. So our final answer can be calculated by calculating the largest palindromic sub-string centered at each 'j' which can be possible, i.e, by considering the left most starting points and right most ending points. Suggestions are most welcomed :) Updated 71w ago • View Upvotes