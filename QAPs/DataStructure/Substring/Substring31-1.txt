Given a string, find the length of longest substring where no character repeats twice?
This problem can be stated in other words as "longestÂ  substring without repeating characters ". It can be solved in O(n) time complexity and O(n) space complexity. A sliding window approach can be used. Keep track of the characters which are visited in current temporary string(sliding window) by using a visited array. Let maxlen denotes the current maximum length of the substring required. Once a repeating character is found,stop there, find the length of the temporary string(enclosed in current sliding window). If it is greater than maxlen, update maxlen. Also notedown the starting and ending index of the current longest substring without repeating characters. Now slide back to the next index of the previous instance of the repeated character.Also update the visited array with respect to the new sliding window and carry on with same steps mentioned above. Here is the code with detailed comments. #define REP(i,n) for(int i=0; i<n; i++)#define FOR(i,st,end) for(int i=st;i<end;i++)#define db(x) cout << (#x) << " = " << x << endl;#define mp make_pair#define pb push_backtypedef long long int ll;string longestsubstr(string str){	int n=str.size();	int i=0,j=0;	int longstart=0,longend=0;//start and end pointer of the longestsubstring	bool visited[300]={0};//have a visited array to check if the character is already visited	int maxlen=-999;//current maximum length  substring without repeating characters.	//i is the start pointer of the temporary substring and j is the end pointer of the temporary substring	//traverse the string till you encounter a character that repeats	while(j<n){		if(visited[str[j]]){//if the character is visited already			if(j-i>maxlen){// if j-i is greater than maxlen till now 			maxlen=j-i;// make j-i as 			longstart=i;			longend=j-1;			}			//This is very important part of the algorithm which makes this logic linear in time			//if repeated character is encountered at j it means that the same character is encountered somewhere 			//have an iteration with i as index variable and iterate till the character str[j] is encountered. This will be found at an index < j			while(str[i]!=str[j]){				visited[str[i]]=false;				i++;			}			//if you think intuitively you will know that all substrings that start before or at 			//so continue searching for longest substring by pointing head at i+1			// since we have processed till index j now. increment j.			i++;			j++;		}		else{//if the character is not visited yet			visited[str[j]]=true;			j++;		}	}	//This part is important as well. When j reaches n and the loop breaks the substring with length n-i is another candidate for 	//longest substring	if(n-i>maxlen){			maxlen=n-i;			longstart=i;			longend=n-1;	}		return str.substr(longstart,maxlen);}int main(){	int t;	string s;	scanf("%d",&t);	while(t--){	cin>>s;	cout<<longestsubstr(s)<<endl;	}}		 