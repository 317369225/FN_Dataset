How can I replace all occurrences of a substring from a string with a smaller substring, in-place?
This can be solved in a quite simple maner in two steps: replace every occurence of your pattern by the shorter replacement and fill the remaining characters with something like '\0' collapse every occurence of your padding charactere '\0' to get a string without "holes" In C++ the first function would look like: void find_replace(    const std::string& pattern,    const std::string& rep,    std::string& str){    size_t match_start = 0;    while (match_start <= (str.size() - pattern.size()))    {        // Try to find a new match        match_start = str.find(pattern, match_start);        if (match_start == std::string::npos)            break;        // Replace `pattern` by `rep` and fill the remaining        // space with '\0' character.        for (size_t j = 0; j < pattern.size(); ++j)        {            str[match_start + j] = j < rep.size() ? rep[j] : '\0';        }    }} And the second one would be simpler: void collapse(std::string& str, char rep){    unsigned shift = 0;    for (unsigned i = 0; i < str.size(); ++i)    {        // Swap the current caracter backward of `shift` characters        str[i - shift] = str[i];        // If we see a '\0', increase the shift        if (str[i] == rep)            ++shift;    }    // Resize the resulting string    str.resize(str.size() - shift);} You could then use it like it: int main(){    std::string pattern{"toto"};    std::string rep{"ta"};    std::string str{"Hello toto, Hey totototo!"};    std::cout << str << std::endl;    find_replace(pattern, rep, str);    std::cout << str << std::endl;    collapse(str, '\0');    std::cout << str << std::endl;} I hope it helps. 