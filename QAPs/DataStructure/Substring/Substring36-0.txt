How can we find the longest substring with at most two different characters of a given string in O(n)?
Better than the other algorithms presented here, there is an algorithm that uses [math]O(log(\Sigma)+log(N))[/math] memory (Anonymous' solution actually uses [math]O(\Sigma)[/math]) and runs in non-amortized linear time (Anonymous' solution is amortized and may not be suitable for real-time streaming applications (ok, theoretically the increments of lastA/lastB are amortized with worst case [math]O(log(N))[/math] but of course this is a non-issue for practical implementations)). All that you need to solve this problem is to scan the string and keep track of: 1) Which are the two most recent characters 2) When was the last time the characters appeared in the string 3) The longest two-character substring ending at ch (charA, lastA) = (0, 0)(charB, lastB) = (0, 0)length = 0for ch in theString:    if ch == charA:        (lastA, lastB) = (0, lastB + 1)    elif ch == charB:        (lastA, lastB) = (lastA + 1, 0)    elif lastA < lastB:        (length, charB, lastB, lastA) = (lastB, ch, 0, lastA + 1)    else:        (length, charA, lastA, lastB) = (lastA, ch, 0, lastB + 1)    length += 1 At the end of each iteration length will contain the maximal length of the substring ending in ch that is two-character.Â  The longest substring overall will then be the maximum value of length over the execution of this algorithm. 