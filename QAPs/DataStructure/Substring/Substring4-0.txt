What is the algorithmic approach to solve hackerrank problem Substring Diff?
Use the two pointers/sliding window method. Note that the O(N³) solution is pretty straightforward. For every (i,j) pair, find the largest value of L such that M(i,j,L) ≤ k. Since there are O(N²) such pairs and you need O(N) operations to calculate maximum L for each pair (You only need one operation to calculate M(i,j,L+1) when you have M(i,j,L) calculated already), the entire algorithm takes O(N³) time. def getbest(k)  best=0  for i=1 to N    for j=1 to N      bad=0      for l=0 to N        if i+l>N or j+l>N          best=max(best,l)          break        end        if p[i+l]!=q[j+l]          bad=bad+1        end        if bad>k          best=max(best,l)          break        end      end    end  end  return bestend Now, how can you improve the complexity from O(N³) to O(N²)? Suppose that you have found the longest L which gives M(i,j,L) ≤ k for given (i,j). Let us assume that we didn't stop at L because we reached the end of the string but because next characters mismatched and took our mismatch count above k. This means that M(i,j,L) = k and M(i,j,L+1) = k+1. The key observation now is that we don't need to calculate M(i+1,j+1,l) for l < L-1. M(i+1,j+1,L-1) is going to be either k or k-1, depending on whether p(i) and q(j) are equal or not. We can just start at this value and try to increase l from L-1 to see how much higher it can go. Since we increment the index of the left or right limit of the interval we are looking at in each step, the algorithm takes O(N) time for each value of i-j. Since there are only 2N-1 values of i-j, the overall complexity is O(N²). #This function starts at (i,j) and uses two pointers to find maximum l#  which gives M(i',j',l)<=k among all (i',j') such that i'>=i and i'-j'=i-j#So we only need to use this with at least one of i,j being 1def getbest(i,j,k):  best=0,bad=0  i'=i,j'=j,l=0  while 1    if i'+l>N or j'+l>N      best=max(best,l)      break    end    if p[i'+l]!=q[j'+l]      bad=bad+1    end    if bad>k      best=max(best,l)      while p[i']==q[j']        i'=i'+1,j'=j'+1,l=l-1      end      bad=bad-1      i'=i'+1,j'=j'+1    else      l=l+1    end  end  return bestend#Here is the function which does the full jobdef getbest(k)  best=0  for i=1 to N    best=max(best,getbest(1,i,k),getbest(i,1,k))  end  return bestend 