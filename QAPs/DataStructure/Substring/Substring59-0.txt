How can I understand this code to find the number of balanced substrings in C++?
The main idea behind this logic is [ a xor a ]=0. Similarly , d xor a xor b xor b xor a  xor c = d xor c Now, what is xor? Here is the link by stack overflow that explains about xor. @What does bitwise XOR (exclusive OR) mean? Now,  #include <bits/stdc++.h> using namespace std; int dp[100005]; int main() {       int t,n;      long long ans;       string s;       map <int,long long> m;      cin >> t;      while ( t-- )     {              cin >> s;             n = (int)s.size();//calculates length of string              assert(n<=100000);//checks if n<=100000              m.clear();              dp[0] = 0;             ans = 0;              for ( int i = 1; i <= n; i++ )                      dp[i] = dp[i-1]^(1<<(s[i-1]-97));              m[dp[0]]++;              for ( int i = 1; i <= n; i++ )             {                     ans += m[dp[i]];                    m[dp[i]]++;             }            cout << ans << endl;      }      return 0;} Line 9, Maps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order, in short,it acts as a dictionary. For example,                 If these are the values stored in our dp array, 0 1 2 1 2 1 0 then m would contain { 0:2 , 1:3 , 2:2 } so it basically updates and stores the frequency of the numbers in dp array. Line 20, We calculate the xor and store it in dp array. 1<<x is simply [math]2^x[/math] . So if our string is aabb , dp[0]=0 dp[1]=0 xor [math]2^0[/math]=1 dp[2]=1 xor [math]2^0[/math]=0 dp[3]=0 xor [math]2^1[/math]=2 dp[4]=2 xor [math]2^1[/math]=0 Line 22,  i                    m                ans 1                  {0:1,1:1}        0 2                {0:2,1:1}         0+1 3             {0:2,1:1,2:1}       0+1+0 4              {0:3,1:1,2:1}       0+1+0+2 Since,0 turns out to be at index 2 and 4 which means that there are three substrings of the original string that are balanced strings ["aa","bb","aabb"]. So,3 is the answer. Note,that the value of dp[2] and dp[4] would be equal to the value of dp[0]. If dp[0] would be equal to 1 then dp[2]=dp[4]=1. Here is the link for geeksforgeeks solution to the two non-repeating elements in an array of repeating elements. @Find the two non-repeating elements in an array of repeating elements - GeeksforGeeks It might be useful. 