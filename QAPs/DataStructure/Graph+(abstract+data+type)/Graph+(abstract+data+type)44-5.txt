What does one mean by 'elegant' code?I have heard some programmers, especially those who are fond of functional programming, state that it is easier to write 'elegant' code in Haskell than in Python or Java. What do they exactly mean when they tell that? Examples would help me a lot because I am relatively a newbie to the world of functional programming.
I can't improve on Tikhon Jarvis excellent answer, but perhaps I can explain it in different terms.  When one analyses a problem looking at various designs for the solution, one often starts with a rough idea of the solution but, at that point, the details are sketchy.  You want a vehicle for transport.  You decide that wheels are in order, some kind of motive power, and the capacity to carry a passenger.  Then you get into details.  How many passengers?  How fast?  what kind of power?  Will it need fuel?  How much fuel?  How much will it weigh?  How many wheels?  The broad, general solution begins to sound like a truck.  Trucks are large and configurable.  As soon as you are adding details on the base idea of truck you are in a vast field of incommensurate ideas, from garbage truck to SUV.  You're now stuck on truck, not transport.  The original problem was transport. Furthermore, the generality of the idea of truck is limited.  You are confined to fairly large vehicles with big engines and lots of fuel capacity that depend on a whole infrastructure of roads and refueling stations.  Maybe treads or bipedal locomotion would be better for rough ground.  Maybe backpack portability would be better for urban commuting.  Should it be a truck? A great designer breaks down the concept of transport into abstractions, such as suitability for the terrain, length of trip, cost to purchase, cost to use, storage, compatibility with existing transport modes, etc.  There is a landscape of possibilities here of which "truck" is but one subset.  Bicycle, monocycle,  and scooter are other subsets.  Suppose we have self-balancing scooters, each carrying one individual and a grocery bag or two.  Is this a reasonable way to solve the transport problem for many people, vs. a single large yellow bus?  Well, the bus is faster, better in bad weather, but the speed may be irrelevant if you have to wait for it to pick up and drop off many people.  So you arrive at the abstraction of "last mile transport".  Then you contemplate the traffic situation with lots of individual vehicles competing with trucks or pedestrians on a single pathway.  Does this solve the transport issue or just misuse and abuse a transport system made for trucks or pedestrians?  Now you are looking at another abstraction, the transport network, and you realize that there is no separating the vehicle from the transport network.  How much of the solution needs to go into the network as opposed to the vehicle?  What are the abstract minimum requirements for each, so you can narrow the design space?  By this process you arrive at a set of abstraction on a higher level than simply the original idea of a truck of some kind.  Taking those non-material requirements, you work you way down to an instance with sufficient details to see if it is practical and acceptable to the users.  It is not the only solution, but it uses the same abstract principles you derived earlier.  It may be a bicycle with an small electric engine that you can charge from a standard AC outlet, or it may be self-balancing tandem wheeled device that folds up into a backpack with a carrying handle.  Both are viable.  Both are simple.  Both are elegant.  Maybe the ideal situation is ziplines between the upper stories of tall buildings, and the vehicle has a mechanism to transfer from a ground path to a motorized zipline.  Maybe the cost of real estate for adding yet another lane to a California freeway is far more than the cost of adding cinder paths threaded among the residential areas. The necessary mental trip is from the problem set to the abstraction to the instantiation.  In the process, you make the minimum generic but necessary inventions and apply them in clever and practical ways, as opposed to inventing a large number of unique parts.  There are as few basic functional parts with general utility as possible, like lego blocks if that can be achieved.  The cruft, as we often call it, is gone.  There aren't any unnecessary components.  The costs reflect the utility as directly as possible.  If the abstractions are perceived as OBJECTS, described with nouns, and if these objects are chosen such that they are independently definable (orthogonal elements of a set), then you have a good object-oriented design.  In the final instantiation, your objects will have an obvious and clear relationship to the solution and to each other, and any revisions or further implementation details can concentrate only on the directly affected objects as oppose to shaking up the whole program. These are the characteristics of an elegant solution. 