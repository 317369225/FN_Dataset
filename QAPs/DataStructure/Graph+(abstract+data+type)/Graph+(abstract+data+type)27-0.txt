What API for web development do you think is useful, but hasn't been invented yet?
Well, it can't be useful now if it hasn't been invented yet. However, I'll have a crack at this. Web technologies evolve. This is a good thing, but it means pages break when old technologies and standards die off and fail to ever display properly when rolling standards (such as HTML5) develop concepts that never get deployed sufficiently for browsers to implement and test those concepts uniformly. HTML is increasingly used for more complex media, such as books, but it simply lacks the kind of power needed to typeset and typesetting is useless for web pages. HTML is also proving stubbornly difficult for semantic concepts. I would therefore expect a meta-format to develop, where the markup directly and reliably converts to absolutely any existing markup language or combination of markup languages and can readily be converted into any future standard, making use of new features in that standard. This means the meta-format must be Turing-Complete, otherwise there will exist a future markup language it cannot translate into. If you want a language that can support HTML 5, CSS 3, LaTeX 3, Java Swing, Flash, VRML, OWL 2, GDML, GML, UML and anything else you can think of, it has to be a bit more sophisticated than what's currently out there in metalanguage land. But you wanted an API, not a ML. The API needed to programmatically access all this functionality isn't nearly as bad as you might expect. An object, be it a book, a page or anything on it, etc, has structure. Atomic objects must have content, which may be across one or more attributes. All other objects must have relationships with other objects (atomic or compound) where the relationship type is described by the relationship. A reasoner must be capable of determining any other required information from this structure. The graph must not describe how things are done or how things should look. That should all be derived by the reasoner and source-source compiler. Only the abstract structure of the document(s) and the abstract specification of graphical concepts should be given. So the API needs to have something along these lines: New(Compound Object Class, Abstract template) Associate(Object, Object) Bind(Association, Attributes of relationship) New(Atomic Object Class, Properties of atomic object) Compile(Object) You don't want attributes in compound objects. They should always be in objects that are linked in. This way, you decouple generalities and specifics. You won't be able to get this wholly generalized, otherwise. The structure is not hierarchical, it is a directed graph with explicit and implicit arcs between the nodes. Implicit arcs mean that what you mean is not always what you say. Graphs create much more interesting flows and can therefore encode programmatic concepts, recursive relationships and other ideas that are very helpful if you're trying to describe the algorithm without implementing it. If enforced sequence is required, atomic classes formulating a coloured Petri Net will suffice. You don't need to talk implementation. You don't care about inefficiencies, this won't be used to deliver content but to turn raw information into specific sorts of information. The template can take care of what the content means, the flows say how things relate to each other, so that all takes care of the basics. It's sufficient for everything except dynamic content and I/O. For this, the API needs extending: New(Source object type, URI of source) New(Data object type, URI of data) New(Abstract specification type, Abstract specification) New(Channel type, Channel) These would create objects which could be linked in as before. You can now define specific inputs as conforming to specific grammars, compiled according to an abstract data type, collectively validated and transformed by Z, then posted to a database. The compiler can turn that into whatever it wants, you don't care, all that matters is that it's guaranteed to generate what you meant, regardless of the technology of the day. Inefficient? Yes. Very. Complex? Definitely, but no worse than the ghastly mash-up of modern standards and it's maintainable. There is no reference to HTTP, partly because it's an inefficient standard and partly because web pages should not care about delivery protocols beyond saying how they get data. And even then, it would be better to use a Content Addressable format than a URI, but there's no accepted standard across sources for that at this time. 