How can I improve search functionality in tables with a many-to-many relationship?
I built a solution twice, in an open source RDBMS and a paid licence platform.  aka Oracle and Postgres.  It was for a company that offered the solution via a PaaS or sold it to companies as a stand alone product deployed on their infrastructure. The solution managed information about Users and performed all sorts of services like mobile contact management as well as directory search by things like skills as well as other information (geography, org etc). The company I worked for at that time had over 300k employees and provided a lot of great information to test with.  Especially since the profile of employee skills was very wide, disparate and volatile. We also found value to having a tree hierarchy to the data.  There are some skills like programmer that have a child , like back end developer, middle tier developer, font end developer, mobile developer, main frame etc.  Each one of those may have different or same skill in each branch.  For instance we had developers who knew java that only did middle tier work with Java, and only used PHP on the front end.  We had some developers that only did Java in the middle tier and did Objective-C in the mobile space.  Meaning they never built a web app with Java.   Being able to distinguish this kind of information provided value.  I wont bore with details on all the different non-programming trees... It was interesting to be able to search for a skill regardless of branch or search when considering a specific branch. Since branches could go N deep and Users had N number of skills I implemented a recursive hierarchical model. The model was in two tables logically and went something like User Attribute Detail primary key  (aka child key) master key (aka parent key ) attribute foreign key  (fk to Attribute Table) value char value num value date Attribute Table primary key attribute name data type (this was also a fk to another table but shorting for brevity ) The attribute table had an attribute named SYSTEM USER GUID The root node to every tree was the SYSTEM USER GUID. We ended up having a few hundred unique attributes On average a user shared less than 20 attributes with any other user. We stored things other than skills like Organization Hierarchies and who reported to who. The Detail table ended up with about 15 million rows in it.  About 50 attributes per user.  The average depth was about 5.  Max depth I recall was 13. In Oracle the Bitmap index provided a little extra value because of the cardinality ratios. Oracle's partitioning implementation made the PaaS of this easy to extend.  This implies that reporting across partitions was not intended to be done at the app level.  Only internal reporting ever crossed partitions and that was very limited  Total number of partitions.  Avg number of rows per partition.  Total rows etc.  I do not enjoy partitioning in Postgres. Both RDBMS platforms support a solid implementation of Ansi 99 recursive SQL.  Oracle's unique recursive SQL was a little faster and had a smaller footprint.  The difference was not huge and if there was no PaaS need there was no real justification for Oracle. Both programming abstraction layers made dynamically programming the recursive SQL very easy.  Getting results for different combinations of attributes was easily managed.  A series of thoughtful meta driven API's fulfilled most application requests for data.  There was little change required to the model or the supporting DB code after initial set up.  The front end development evolved quite a bit. The interesting thing about this model is there are only two indexes that had to be maintained every time you added a value.  So when a new attribute for a user was added to the detail table it was immediately available for query.  Inserts had very little overhead.   I wanted to do more testing around putting just the indexes in separate table spaces that were on SSD.  I suspect that would have made things even faster.   Response time on all tactical queries were sub second.  Find this user with this combination of attributes.   Get this list of USERS with these attributes. What organization has the most developers with X skill. More strategic queries were usually fast enough for reporting.   When they were not fast enough a pre-aggregation solved any reporting problem.  Since our strategic questions did not have near real time needs that was fine.  The thing I was least pleased with had to do with visualizing trees.  I am still looking for a good way to solve that.  Visualizing graph type data in general is still not fun as far as I can tell.  That is not my area of expertise so I do not think about it too much. A fine critique of this implementation is that it is initially non-trivial from a technical point of view.   One might argue that your standard DB developer may not be able to support it without training.   Against such critiques I have no defense.  The best I got is, everything was written with clean coding in mind.  All db abstractions are very small and modular.  It was easy for me to train relatively in-experienced people to support and even extend it.  I am not afraid of such things.  I recognize that not everyone has my faith in humanity. 