How did Quora implement its topic/tagging architecture?Does it scale?
Disclaimer: Most of this stuff was implemented before I joined, save some enhancements here and there. I'm just reporting on what I see today. It was implemented with good product decisions, engineering abstractions, and performant design. Data Store At a high-level, it isn't too different from how one would imagine it be done.  You could think of us having a topic table, with unique identifiers we call topic ids, or tids and some columns to store data associated with each topic (e.g. name, topic followers, questions in those topics, parent/child topics, photos and FAQ stuff). In reality, we actually split this table out into many smaller and separate tables, still keyed on tids for modularity, and faster reads and writes. Reads and Writes Topic ids and their names are stored in a separate in-memory index written in C++ for fast searches (see How does Quora's topic tag autocomplete work?). Creating new topics is also a very lightweight process, and can be done right from the topic tagger as searches are being done to see if a topic exists.  This involves some good design to allow for a single-use UI element that can function for both searches and adds (see How does the Quora search box work?). Moderation Just like other key aspects of Quora, topic changes (adding a new topic or modifying existing ones, or adding an overly broad topic to questions) are moderated by Quora admins and reviewers.  This ensures topic quality is high as well. Performance Almost all the topic data is cached in memcached for faster reads, since it's used pretty prevalently across the site (see How does Quora calculate the number of topic followers so quickly and accurately?). Some Hard Design Challenges Some design thought went into topics, to solve hard problems with normalization and dealing with merges. These were done very early in the product by Adam D'Angelo and Kevin Der, and the following design notes were pulled straight from the comments in our code as a rough idea of what they are: 1. Canonical naming and aliasing An NAE is a named aliasable entity. Topics are NAEs, and have the following properties: they have a type. they have an id, unique within the type. they have a name. they have a set of aliases. the same alias can point to multiple NAEs of the same type only one NAE of a given type can have a specific name. 2. Merging A UAE is a unifiable associable entity. Topics are UAEs, and each: has a type has an id, unique within the type has a set of questions associated with it has a set of users associated with it can be merged with other UAEs of the same type, which causes the following:  - all users associated with either UAE are merged - all questions associated with either UAE are merged - the merge can be reverted. - you can only perform a merge from A -> B if B is not merged   into anything else, and nothing is merged into A (no chains   can go more than one hop) Speed notes: - merges and unmerges are O(1) - from_question and from_user are O(# of UAEs associated) Overall I would say that this overall system scales pretty well in both the engineering and product perspectives.  But there are still some areas we could improve, I think: Topic ontologies could be organized better and made more useful Faster tagging of questions with related topics (maybe we could auto-suggest a few based on the content or existing topics - and make them one-click to add) Maybe better visualization of topic ontologies, that allow for more interactive browsing (e.g. maybe something in HTML5/CSS3) like how graphs really should look like: A large "connected components subgraph" of topics, circa June 2011, when I was trying to look at how well-organized topics were for fun. That maybe allowed zooming in the browser to particular clusters: The topic ontology cluster for Quora topics. 