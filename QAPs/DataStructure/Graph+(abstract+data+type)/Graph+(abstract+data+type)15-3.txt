What are the differences between a Graph database and a Triple store ?
Graph databases arent completely synonymous with triple stores for these reasons: 1. Typically, triple stores are encountered in the RDF/Semantic web context - where the natural storage model for RDF is a list of triples/quads (hence 'triplestore'). The fact that the 'object' of a triple :man a :animal - :animal, in this case, can be the subject of another obviously lends itself to a graph structure, but a specific flavor of graphs - directed, edge-labeled graphs. 2. There are clearly more kinds of graphs than just edge-labeled directed graphs - undirected edge weighted graphs are a very common counterexample. The RDF triple model (in current form) doesn't allow for simple representation of such graphs without hoop-jumping with extraneous nodes (blank nodes). Even then, you could argue reasonably that <a> 0.44355 <b> isnt the same graph structure as <a> :hasWeightNode _:blankNode. <b> :hasWeightNode _:blankNode. _:blankNode :hasWeight "0.44355". 3. Also, the RDF data model allows 'parallel' edges between nodes - 2 subjects can be related to each other via multiple distinct predicates that have no relationship with each other in a semantic sense. 4. Triple stores are really just a list of graph edges - but in practice, most of the edges turn out to be spurious - they're usually 'properties'  of a node and not first class citizens of the graph structure itself. In RDF, for example :a :hasAge "24". :a foaf:knows :b. are both 'equal' as triples and hence considered graph edges, but only the second one represents connectivity in a graph sense - the first 'edge' isnt really an edge but a property of :a with no meaning outside of :a. In RDF, both are called 'properties' but the first type is called a 'literal' while the second is an 'object property'. In Neo4j (AFAIK) - the distinction is made between relationships (second edge) vs. properties (first edge). The 'Property Graph' model is an alternate abstract data model for graph data - TinkerPop, Neo4j etc are in some sense variants of this model, unlike RDF-based triple stores. If I understand correctly, the key idea in Property Graphs is to explicitly separate out node/edge specific key/value data from the underlying graph structure as a design-time decision. 5. Having labeled edges means that your RDF graph is really a composite graph across several edge types - eg a triple store full of edges like :a :hasChild :b :a :isManagerOf :c actually can be thought of as a composite of 2 graphs partitionable by each predicate, unless :hasChild and :isManagerOf are semantically related. The reason #4 and #5 are important is that structural measures like centrality, degree arent immediately meaningful if applied naively on RDF graphs - unless care is taken to separate the 'graphy' portion of the graph from semantic 'noise'. For example, in #5 - the node :a would naively have a degree of 2, but you would reasonably think that :hasChild edges constitute a separate graph from :isManagerOf. 6. SPARQL, as someone else has pointed out, is at its core, a declarative language for subgraph pattern matching in RDF graphs. Just as RDF is a particular kind of graph, SPARQL allows a particular kind of graph operation - pattern matching. Triple stores (standalone or built on existing db platforms) are optimized for this operation. SPARQL is certainly capable of post-processing a retrieved subgraph pattern - the latest iteration has support for aggregate-type operations like sum, count, avg etc. However, other graph operations, particularly computing graph-structural metrics like centrality are hard to do in SPARQL since they require some form of iteration/looping - in other words, like vanilla SQL, SPARQL is not Turing-complete. To mitigate this, certain platforms notably TopQuadrant have constructed iterative processing over RDF/triplestores. But the language itself doesnt yet allow constructs like SQL's 'WITH' clause that could be used to do so. Updated 24 May • View Upvotes