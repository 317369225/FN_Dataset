I have been a C++ software engineer for 2 years. What should I learn or do to become a software architect?
The three key elements of software architecture are analysis, specification and design. Requirements analysis is something of a "dark art" - what is wanted isn't necessarily what is needed, what is understood isn't necessarily either. Giving someone something they think they want but definitely don't need is easy, frequently done, and useless. Giving someone something they need but don't want is hard, also frequently done, and also useless. Building a consensus, then, is absolutely critical and requires not just problem-solving skills but problem-recognition skills (a very different kettle of fish), diplomacy/sales skills (the customer has to buy into the idea) and a lot of nerve (sell too soon and you'll have to deliver something else; too late and they'll have bought something they don't want from someone else). Specifications cover a wide range of possibilities. Formal specifications, developed through formal methods, are very hard to write, very hard to implement but will do precisely what is wanted, perfectly, every time. Tests can always be written in advance. Semi-formal specifications, essentially architectural plans as opposed to detailed blueprints, are much easier to write, much easier to implement and will usually do what's expected. But you haven't proved it, you don't know. Tests can sometimes be written in advance and because there's more fuzziness, you have to do more of them and you have to run them more often. Informal specifications, the equivalent of tourist guidebook articles, can be rattled off rapidly. Implementation becomes much harder, though, because the programmers now have to decypher some of the semantics and discover those that were never explicitly stated at all. This is what you often get in industry and, frankly, the results show it. But because all three can be asked for, you need to know them. Design tends to weave itself into specification, even though they shouldn't be mixed. Design says how things are done, specification says what. Mixing them can muddle that up. Nonetheless, the methodologies themselves are muddled, so I'm collecting all you need to know here. You need to be able to look at the specifications for, say, seL4 and know (even if only in general terms) what's meant and why. Pay attention to software reasoners. Specifics can always be looked up, memorizing arcana is daft. You should be able to work out Abstract Data Types and understand Abstract State Machines. I'd recommend knowing Coloured Petri Nets, because parallel programming is so often messed up, but it's not critical. I'd also recommend knowing grammars, especially EBNF. Flow charts, although out of fashion, are a great way to represent a halfway house between what and how. Modelling data relationships via ontologies can be helpful, so tools like Protege can be repurposed. Because data modelling is a big part of specification and design, knowing about relational design, normalization, when to denormalize, when not to use this model at all (even when it works, see Cobb vs Relational Database Design in a cinema near you) and what alternatives exist (hierarchical systems are found in many scientific data libraries and the MUMPS language, objects you know about, and there's a few others that I can never remember). Personally, I'd also become very familiar with network topologies and graph theory, which gives you mathematical underpinnings for determining what's a sane structure and what's a pig's ear, for data flows, data types, program flows and I/O. That pretty much sums up everything you can expect to find in any good 3-4 year Software Architecture course. It does not include everything that will be there, but these are the things a software architect might actually call on. Accounting, whilst doubtless useful for the self-employed, was never a class I've needed to recall details from. Strange. 