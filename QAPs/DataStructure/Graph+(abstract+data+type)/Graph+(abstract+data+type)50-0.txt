What is the best way to self-teach the skills and knowledge gained in a typical computer science degree?
I think starting by thoroughly learning a programming language is a good idea. It is often said that CS is more than programming or a particular language, but much of CS is done through programming, and is a way for you to pick up good fundamentals. Languages such as C/C++, Python, and Java are popular starters. Some are probably bad choice for starters (ex. Javascript, imo). I started with Java (as my first CS class happened to be taught in this), and Java has its merits over C/C++ and Python, especially as a first language. I prefer Java's static typing, though I also enjoy Python's brevity and readability. C++ is a bit messy for starters, and C is a bit too low-level for your first language, but it has its benefits. It doesn't matter too much what you happen to pick. Once you have picked a language, grab an introductory book (or find resources online); work through the exercises (preferably by actually compiling and running your programs on a real computer) and learn basic programming constructs (if-else, loops, variables, Arrays, Input/Output). This might take a while if you have never programmed before, but you will get used to it. Once you got the basics down and can write simple programs, try building a larger OOP-style project involving multiple classes. This could be from an assignment online, from the back of the textbook, or something simple you wanted to build (some ideas: maybe a simple game with a GUI). You don't have to master the language, but just learn enough basics so that you can code up simple things when you want to (and also begin to think like a computer scientist). In fact, to master a language in all its depth takes quite a bit of time and experience. From this point on, what I describe follows more or less a standard college CS curriculum, which means that it has a substantial theoretical component to it. If you want to just practice programming or are interested in more direct applications such as web design, this may not apply to you, but some of these skills are fundamental to all of CS (and problem solving) , and even if you're writing a web application or a new smartphone app, knowing basic algorithms and data structures (and in general understanding the thought processes of a computer scientist) will help you a lot not only directly with what you're producing/coding, but allow you to have a greater appreciation for the kind of problem solving, design considerations, and analysis that computer scientists practice everyday. Typically, after the introductory CS course, one picks up a little more foundation for mathematical tools in CS: discrete math and basic data structures and algorithms. For this, I also recommend grabbing a textbook or looking for resources online (many colleges have their course notes and problem sets available online; MOOC's are becoming more popular too).  Some basic data structures/algorithms that you should become familiar with: arrays, linked lists, Binary Search Trees, balanced Binary Search Trees (ex. Red-black trees, AVL trees), heaps, sorting algorithms (insertion sort, merge sort, quick sort), and a plenty more. As for discrete math, you should be familiar with basic probability, logic, proof techniques (induction), basic number theory, set theory, automata theory/finite state machines, and basic graph theory. These are more or less tools to help you reason about computation in its various forms. They might seem a little dry/pointless if it's your first time seeing it, so it's important see motivations for certain concepts. For example, basic number theory becomes useful in constructing basic cryptographic primitives. As another example, logic becomes necessary when you reason about how programming languages are compiled. By now, you've explored most of the basics. You can write up simple programs that do what you want, and you are familiar with basic data structures to make your programs efficient, and some basic mathematics to reason about them. Some deeper topics now. None of these are required, but they are part of standard CS curriculums and as a whole instrumental to your understanding of CS. - Algorithms. Using similar resources, learn more advanced algorithms and design principles such as  greedy algorithms, dynamic programming, divide and conquer, and standard graph algorithms (shortest path, max flow, MST). In learning these, it is just as important to develop your intuition for problem solving (and rigorously reasoning about their properties) as to learn the algorithms themselves (you will probably forget the exact details of an algorithm over time). For textbooks, see Introduction to Algorithm Design by Jon Kleinberg and Eva Tardos, or Introduction to Algorithms CLRS (MIT). - Computer Organization. Even if you are not so interested on the hardware side of things, it is good (and fun!) to build up your understanding of how a computer works starting all the way down from transistors and logic gates, going up to a basic CPU, picking up concepts along the way like caches, memory hierarchy, virtual memory, synchronization primitives, assembly languages, and more. Understanding this lower level will make you a better programmer and abstraction-er (and give you intellectual satisfaction). Though it is often emphasized that CS is not really about computers, it is still important to understand how a computer works. - Operating Systems. Could be as an extension of above. Usually the undergrad class on OS is infamous for the amount of coding, so this is a good place to learn good software engineering skills and experiencing bigger projects. You will learn valuable lessons in concurrency, memory management, networking, file system, and even things like security. The best way to get used to concurrency is by coding few of the classic synchronization problems (single reader multiple writer, barrier, dining philosophers) yourself in language with good concurrency support (Python, Java are okay from my experience; Go is very clean in particular). People often put up course projects from their OS on github, so you can probably use one of those if you want to build an mini OS from scratch; but this isn't necessary to move on. From this point on, you have enough basics to start exploring your specific interests. The only thing limiting you is time! Brief overview of some subareas of CS. (Note that my coverage of certain areas is more in-depth and longer only because I happened to learned about them.): More algorithms/data structures: Plenty to learn more beyond the intro class. Some suggested topics: graph theory, linear programming, convex optimization, advanced data structures (ex. persistent data structures), approximation algorithms, distributed algorithms. Not particularly relevant to practice, but many of the mathematical ideas and analysis techniques are beautiful. Theory of Computation. You learn and reason about what computation can and cannot do (mostly the latter). From more traditional topics such as (various) automata, context-free languages, complexity classes (P, NP, #P, BPP, PSPACE), PCPs, connection to randomness, to more recent topics including circuit lower bounds, arithmetic complexity, quantum complexity, communication complexity, various hardness conjectures (ex. Unique Games Conjecture and its relation to optimality of approximation algorithms). Also has many connections to cryptography. Distributed Systems: You learn about how to design large computer systems that are distributed that can deliver some goal (ex. key-value store). Definitely on the more practical side, but the theory behind is interesting as well. Turns out both in real world and in theory, it is hard to guarantee every desirable criteria such as correctness, low latency, robustness, etc. Building real systems is sort of like real life; there are many tradeoffs. Databases Machine learning/Artificial Intelligence: Its importance andrelevance goes without saying. ML in particular (note that there isn't a sharp boundary between ML, AI, statistics, and data mining) has become increasingly popular in the past decade due to "Big Data" and its success in many different domains (from more traditional areas like computer vision or natural language processing, to newer applications like fraud detection, spam filtering, and content recommendation). There are a lot of interesting theory behind ML, with heavy connections to more classical fields like statistics. AI will be an interesting and open field for as long as there are robots aren't as good as humans. Subareas of above that are more focused on a particular niche: computer vision, natural language processing (NLP), robotics, computational biology Programming Languages (PL): This field is more than what you might guess from the name. A good place to start is to explore new paradigms such as functional programming. The theoretical foundations of PL are fascinating, and is closely related to logic. If you are more of an algebraist than an analyst in terms of mathematical preference, you might find PL theory more suited to your tastes than algorithms/complexity. Even areas of math that are traditionally known to be very abstract such as category theory surprisingly has its use in PL Some of the numerous applications of PL theory include theorem provers, verified computation, compilers, type systems, concurrency, language based security, software defined networking, and even foundations of mathematics (see HTT)--pretty much any application where you can benefit from having more well-defined semantics. Compilers. With an application of lot of neat technical ideas in well-defined stages, you can turn a program in a high-level language into machine code that can executed by your computer--how cool is that? It is best to learn compilers by building one; I think this is an invaluable experience if you are considering careers involving software engineering. Computer Graphics. You can build things that you can actually show to your friends. Interesting sub-topics: physically based animations (ex. simulating fluids), computational geometry, computational photography Cryptography: the more mathematical side of building secure systems. It is interesting to see how to rigorously define various notions of security, how to base cryptographic primitives on computationally hard problems. Security: the more practical side of above. Human Computer Interaction: the name says it For additional resources such as Coursera, edX, MIT OpenCourseWare, and course websites from top CS departments (Stanford, MIT, CMU, UC Berkeley, Cornell, UW, etc.) Most of the topics I mentioned so far, though important for foundations, are very academic. I recommend having this academic background because it is often missing in self-taught programmers, and more importantly it exposes to you a lot of fundamental design and problem solving choices in Computer Science. If you want more practical experience (ie. the kind of skills more directly applicable to traditional software engineering role), explore the following (I'm not an expert here so please be forgiving if my list lacks coverage or is outdated, and feel free suggest edits in the comments):  - UNIX. Download Ubuntu (or any distro) and start playing around with it. There are also free courses online (ex. edX) to learn more about it.  - web development. I don't have much to say here from lack of experience but explore Javascript, HTML, CSS, php, Ruby on Rails etc.  - mobile development (iOS, Android)  - backend technologies (MySQL, MongoDB, Hadoop, etc.)  - various open source projects  - various other new web technologies hot at the time  - anything else that intrigues you Though learning on your own will miss out on some aspects of a college curriculum (having professors/TAs to talk to, peers to share ideas with, a more organization, feedback through exams), I think it's certainly doable nowadays if you have sufficient self-motivation, given the amount of resources available online. Learning on your own is probably harder for more purely theoretical subjects (you have to force yourself to work through problems to really learn) than the more programming/building oriented areas, but I guess that also depends on your background and strengths. Make sure you also get a lot interaction with other people (through online forums), and to work on big projects and assignments instead of just learning the material in your head. Like they say, learn by doing it. Also, it often helps to discuss your problems with others. Push yourself to work on challenging (but doable) problems (if you're stuck, reach out to people on StackExchange/Overflow or Quora, they are nice (usually) and very knowledgable) and collaborating with others on larger projects since those are the experiences that self-schooled people will miss out on. Some additional notes:  - Start with an imperative language, but you should experience a functional language (Haskell, Lisp, ML family including OCaml) at some point, as it is a paradigm shift in the way you think about programs and data structures. - I definitely agree with Chris's remark that "underneath many languages are similar." As you learn and write programs more and more, you will come to the understanding that they are all similar in some way. In that sense, it doesn't really matter which language you learn first, but it's just that some are easier than others for starters and for establishing solid foundations. As you get more specialized however, you will find that some more more suited for certain tasks. - If you want to get further with/spice up learning basic data structures and algorithms, competitive programming might be fun to try. I learned most common data structures and algorithms in high school through USACO Training gateway, after reading a competitive programming problem online and finding it intriguing. Most involve solving an algorithmic or mathematical puzzle using an efficient algorithm, usually codeable within one page in length, to produce correct outputs in limited time. Topcoder, Codeforces, Project Euler, IOI, Google Code Jam, ACM ICPC and others are all very good places to start. That was a bit long, but hopefully you can find something you like in there. If you need any clarification, comment blow. Source: based on my experiences as a CS major Updated 24 Jul • View Upvotes