How would you identify the second-largest number in an array using merge sort?You are given as input an unsorted array of n distinct numbers, where n is a power of 2. Give an algorithm that identifies the second-largest number in the array, and that uses at most n+log_2 n−2 comparisons.
Think about how you would determine the best tennis player out of a group of n people. Assuming that the outcome of each game is deterministic, one method would be to determine the best player in n - 1 games using a single elimination bracket. In this model, each number corresponds to the skill level of a player and each game corresponds to a comparison. Note the similarities to merge sort: a similar divide and conquer strategy is used, but since we're only keeping track of the best player in each group, we only need one comparison to merge two groups. We can try to extend this algorithm by keeping track of the top two players in each group, performing two comparisons for every merge. This gets us down to O(n) comparisons, but is still not the optimal solution. Instead, notice that the second-best player must have lost to the best player in one of the matches. Thus, we can look at the log(n) players the best player defeated at any time and find the best, which only takes log(n) - 1 comparisons. In total, we have n+log 2 n−2  comparisons, as desired. As noted here, this lower bound on the number of comparisons can be proved using an adversarial argument, where an infinitely intelligent and evil adversary designs the outcomes of the comparisons to give as little information as possible. This is similar to proving that sorting using comparisons takes at least O(nlogn) comparisons. 