How can a max heap be converted to a min heap efficiently?
Johnny Ho has explained this quite well, but I thought I will give a bit of code to explain this further. So here you go... Below is a heap, which based on a parameter in the constructor, can be changed into min or max heap... [code] public class Heap<T extends Comparable<T>> { public static enum TYPE {MAX, MIN}; private List<T> items; private TYPE type; public Heap(TYPE type) {     this.type = type;     items = new ArrayList<T>(); } public Heap(TYPE type, int initialCapacity) {     this.type = type;     items = new ArrayList<T>(initialCapacity); } public boolean offer(T item) {     // add item to the end of array and shift up     items.add(items.size(), item);     shiftUp();     return true; } public void shiftUp() {     // get the last item in array to shift up     int k = items.size()-1;     while(k > 0) {         // get the parent of the item         int p = (k-1)/2;         T item = items.get(k);         T parent = items.get(p);         // see on what basis shiftup needs to happen         // if it is min heap and item is less than         // parent, move up else keep it         boolean shiftUp = isMin() ? item.compareTo(parent) < 0 :                                                 item.compareTo(parent) > 0;         if(shiftUp) {             items.set(p, item);             items.set(k, parent);             k = p;         }         else {             break;         }     } } public T poll() {     if(items.isEmpty()) {          return null;     }     if(items.size() == 1) {         return items.remove(0);     }     // remove the root item and copy last item in array     // to top and shift it down     T top = items.get(0);     items.set(0, items.remove(items.size()-1));     shiftDown();     return top; } public void shiftDown() {     int k = 0;     // get left child index     int leftChild = k*2 + 1;// 1     while(leftChild < items.size()) {         // see which child we need to swap item with         // if it is min heap and right child in less         // then left child use it else use left         int childIndex = leftChild;         int rightChild = leftChild+1;         if(rightChild < items.size()) {             boolean useRc = isMin() ?                          items.get(rightChild).compareTo(items.get(leftChild)) < 0 :                          items.get(rightChild).compareTo(items.get(leftChild)) > 0;             if(useRc) {                 childIndex = rightChild;             }        }      T item = items.get(k);      T itemToSwap = items.get(childIndex);      // see on what basis shiftdown needs to happen      // if it is min heap and item is more than      // parent, move item down else keep it      boolean shiftDown = isMin() ?     item.compareTo(itemToSwap) > 0 :     item.compareTo(itemToSwap) < 0;     if(shiftDown) {         items.set(k, itemToSwap);         items.set(childIndex, item);         k = childIndex;         leftChild = k*2 + 1;     }     else {         break;     }  } }     @Override     public String toString() {         return items.toString();     }     public boolean isMin() {         return type.equals(TYPE.MIN);     } } [/code] 