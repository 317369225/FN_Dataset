If you had a max heap with n elements and want to get the K largest elements without popping and rebalancing, how would you do it?
By definition, the children of a node in a max-heap are no larger than the node. So we know that the largest node is at the root, and therefore that's definitely in the K largest. Now, by a similar argument, the next-largest element must be one of the two children* of that node, and it's going to be the larger. The next-largest is going to be either the other child of the root, or one of the two children of the node we just took. The pattern continues as we take the third-largest node: The next largest node is always one of the children of the nodes we have already included. That's because, by definition, those child nodes are necessarily no larger than the nodes we've taken already, but they are also at least as big as all of their children. We can now write down the algorithm that will take the K-largest nodes from the tree: 1. Create a set that will contain the candidates for the next-largest node, and put the root in that set. 2. Pick the largest item out of that set, output it, and remove it from the set. 3. Add the children of that node to the set, and go back to 2. Hopefully you'll be able to implement that without much difficulty. The runtime for this algorithm depends on how you store the candidate set. Using a list, the runtime will be O(K^2), which is fine if K is small (K could be 1000 and you'd very probably come in under a second.) A more asymptotically-efficient data structure for the candidate set, since you need to take the largest element all the time, is actually a max-heap itself, which is cute. If K is almost the size of the whole original heap, it's probably just worth popping all the items, since this will give you O(K log N). In that case you're basically heap-sorting a list of all the elements in the heap. * I'm assuming this is a binary heap. Updated 22 Apr â€¢ View Upvotes