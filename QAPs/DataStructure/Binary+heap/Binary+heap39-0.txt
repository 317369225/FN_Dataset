How do we find the minimum element with O(1) complexity from Max-Heapify?
A heap is a tree with some special properties. The basic requirement of a heap is that the value of a node must be ≥ (or ≤) to the values of its children. This is called heap property.   A heap also has the additional property that all leaves should be at  h or  h-1 levels (where h  is the height of the tree) for some h>0 (complete binary trees). That means heap should form a complete binary tree (as shown below). In the below examples, the left tree is a heap (each element is greater than its children) and right tree is not a heap (since, 11 is greater than 2).                                               Types of Heaps?   Based on the heap property we can classify the heaps into two types:   ·        Min heap: The value of a node must be less than or equal to the values of its children                  ·        Max heap: The value of a node must be greater than or equal to the values of its children     Binary Heaps   In binary heap each node may have up to two children. In practice, binary heaps are enough and we concentrate on binary min heaps and binary max heaps for remaining discussion. Representing Heaps   Before looking at heap operations, let us see how to represent heaps. One possibility is using arrays. Since heaps are forming complete binary trees, there will not be any wastage of locations. For the below discussion let us assume that elements are stored in arrays which starts at index 0. The previous max heap can be represented as:                   Note: For the remaining discussion let us assume that we are doing manipulations in max heap.   Existing Solutions   For a given min heap the maximum element will always be at leaf only. Now, the next question is how to find the leaf nodes in tree?   If we carefully observe, the next node of last elements parent is the first leaf node. Since the last element is always at h->count-1 location, the next node of its parent (parent at location (h->count-1)/2) can be calculated as: ( h->count-1)/2+1 = (h->count+1)/2   Now, the only step remaining is scanning the leaf nodes and finding the maximum among them.   int FindMaxInMinHeap(struct Heap *h) {             int Max = -1;             for(int i = (h→count+1)/2; i < h→count; i++)                         if(h→array[i] > Max)                                     Max = h→array[i]; }   This would give the time Complexity: O(n/2)=O(n) Proposed Solution with O(1) Time Complexity As per the previous discussion, we are aware that minimum element will be in leaf nodes only. Based on this property, we can create an auxiliary heap with min-heap properties.   Assume that the original max-heap is called OrigMaxHeap and the auxiliary min-heap is named AuxMinHeap. Note that AuxMinHeap is with min heap properties.   Since a heap is a complete binary tree, a heap with n elements will have maximum of n/2+1 leaves and n/2 internal nodes. This means that AuxMinHeap will has the size equal to half of the size of OrigMaxHeap. So, if we construct a heap with leaf notes of OrigMaxHeap, the minimum element will always be at the root.   Operations with modifications to support this:   Insert: We need to insert to OrigMaxHeap and insert to AuxMinHeap if there is any change to the leaf notes of OrigMaxHeap during its insertion. This would take O(logn) + O(logn/2) Delete: We need to delete from OrigMaxHeap and delete from AuxMinHeap if there is any change to the      leaf notes of OrigMaxHeap during its insertion This would take O(logn) + O(logn/2) Minimum: Just return root element of AuxMinHeap with O(1) time complexity This would take O(1) Other Querieswhich can be solved with this approach: Finding smallest k elements Finding the median 