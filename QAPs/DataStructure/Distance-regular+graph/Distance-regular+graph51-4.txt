How does quantum computing work?
Other answers have already given good descriptions of when and where it works. This answer will try to give a intuitive grasp of how it works, by describing a quantum algorithm in simple terms. This is an original explanation and I'm interested in refining it, so comments are welcome. You know that game where you say "think of a number", then have the person do a series of arithmetic operations with that number, and you can guess the end result even though you didn't know their original number? Quantum computing is a bit like that, except you have a roomful of people thinking of all possible numbers up to 2^n, where n is the number of randomised qubits you start with. If you think of quantum mechanics in terms of "many universes", each of those 2^n numbers is encoded by the binary arrangement of the bits in a separate universe. How is that useful? Because unlike people in normal "multiple universes", you can use quantum interference to get them to "talk to each other" and notice repeating patterns among each other's answers. In particular, just as the regular discrete Fourier transform can give you the dominant temporal frequency (or equivalently, wavelength) of a time series of data, the quantum FFT can give you the "universe wavelength"[*] of a quantum-superposed set of answers; that is, "how many universes sideways would you have to go to find someone with the same answer".  I'll illustrate this using Shor's algorithm for factoring a product of two primes. Let's say the number you want to factor is 10, for simplicity. So here's what you tell your line of people: "Think of a number. Now, raise 3 (an arbitrary prime number less than the number to be factored, which isn't one of the factors) to the power of your number. Now, take the remainder  when you divide by 10 (in other words, the last digit).[**]" (Now the people in the line are thinking, respectively: 3, 9, 7, 1, 3, 9, 7, 1,... in a repeating pattern; check this if you don't believe me.)[***] Next you tell them: "Talk to each other and find out how far forward in the line from you is the next[****] person who is thinking the same number as you." (Mathematically, you do this by telling them to take a fast Fourier transform of the graph which has a spike at their number, so that the quantum interference gives the "wavelength" of that repeating sequence.) Now, everybody but the first 4 people is thinking the number "4"; and the first four people are thinking "huh?", but they're dumb, so they basically take a wild guess. So you have them all shout out their numbers. You hear a chorus of "Four!", strong enough to (very probably) drown out the four people shouting some other number. How does that help you factor the number 10? Well, notice that all the numbers after step 2 were odd, and 5 wasn't among them. In other words, you had all numbers less than 10 whose remainders mod 2 and 5 were both non-zero.[***] There's (5-1)(2-1) possibilities. So your answer, 4, must be a product (n-1)*(m-1), where n and m are the factors you're looking for. 4 factors as 2*2 or 1*4 (and this is much easier to factor by conventional means than your original number, because in general it will have a bunch of small factors and not just two huge prime factors). So the original number, 10, must be either 3*3 or 2*5. It's easy to check both of those possibilities and find which is correct. (Actually, it's a bit more complex if n-1 and m-1 have common factors, but still trivial for a conventional computer to check all the possibilities. And if you're looking to use the answer for most cryptography, you don't even need to do so, because the answer (n-1)(m-1)/GCF which you get is actually the modular logarithm, the number you would have used the factorization to calculate) The number of people you have in your room is 2 to the power of the quantum bits you're working with. So if you have just 2 quantum bits, that's not enough to solve this problem, because there's only 4 people in line, not enough to see the pattern. And if you have 3 qubits, you might have to do it several times, because the first four people in line (who have wrong answers; or as it happens in this case, the right answer for the entirely wrong reasons) are just as loud as the next four (who get the correct, helpful answer). But if you have 4 or more qubits, you'll probably get the right answer on the first try. [*] Actually, there is some classical postprocessing required to turn the answer from the quantum FFT into a true modular logarithm, just as you'd have to postprocess the results of the discrete FFT of a sine wave to find the exact wavelength – removing edge effects going from frequency to wavelength. [**] All the quantum operations you perform must be reversible in principle. The "mod" or "remainder" function by itself is not reversible, but it is if you also keep track of the quotient in some otherwise-unimportant quantum bits. [***]Why is this a repeating sequence? Because if you have a given remainder (say, 3) at step N, then you will always get the same result at step N+1. Eventually, you come back to where you start, and from then on, you're doomed to repeat the same steps in an endless cycle.   [****] The quantum FFT doesn't just give the distance to the"next" in line; it's (about) equally likely to give any multiple of that. But again, that's something you can easily cancel out later, or in the unlikely event that it's not trivial, run the algorithm again to get a more tractable multiple of the answer. And remember, if you are using this for cryptography, you can just use the answer you get directly, because the extra multiplier is irrelevant. (please respond in comments to tell me how well you understood this explanation, so I can improve it if necessary.) tl;dr: An n-bit quantum computer is like having a line of 2^n people who each start with a different "initial input" according to their place in line, and all do exactly the same sequence of reversible steps; then being able to see the wavelength of any repeating pattern of results along that line of people. As such, it can be much faster than conventional computers for certain very repetitive tasks, but it is not good at flexible "branchy flowchart" logic. Updated 190w ago • View Upvotes