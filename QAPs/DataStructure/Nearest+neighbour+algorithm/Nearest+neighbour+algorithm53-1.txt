What are the ways to make a program/code an efficient one?
If you have to repeat code, consider creating a function for it. The function call overhead is much less an issue than the issue you create to maintain the same code twice, if it contains bugs. If you have similar code, but it can be parameterized: Create a function for it. Same as above: One implementation of an algorithm is easier to maintain. On function call overhead: This (roughly) is what happens on processor level when an executable calls a function (this code is  generated by the compiler): The parameters (if any) are pushed onto the stack The address of the instruction after the function call is pushed onto the stack (the return address), so the processor can continue later at the right address The processor jumps to the memory address where the function's code is located (This changes the processor's Instruction Pointer register) The function code first saves the processor state: All registers that are altered by the function are saved on the stack The function executes its unit-of-work The saved registers are restored and removed from the stack The return address is retrieved and removed from the stack and the processor jumps to that address The program clears the parameters from the stack, restoring the stack in its original state (from before the function call) All of these actions occur every time a function is called, so you can imagine that calling a function in a loop can be very costly. Even more when you use a high-level language, as there are many function calls happening without you knowing it. If your programming language supports it (like C/C++): Use the inline function directive. This makes the compiler insert a copy of your function's code at all points where you call it, instead of actually calling one single copy of the function. Let the compiler handle the insertion of the copies. The same applies when the compiler supports macros: Use whenever a bigger size of the program improves performance (but there is a trade-off: A single executable of 1 gibi will load inefficiently, so use sensibly). Now, the rest below may be a bit advanced, but maybe you will have some use for it later: Unless you're very, very sure what's happening in the processor, don't use the register directive for variables. Let the compiler's optimization rules decide which variables should be stored in registers, and which should be in RAM. It's usually better in it than the human, as it observes the entire context for the program, and it probably knows better which methods are best suited for the target platform. As for memory allocation: Use pointers, but use them sensibly. Allocating one single block of memory once and managing the contents in the program will be more efficient, but it will also make it more complicated. As an example: Your program will need to store at least 10 integers, but that might also be 10,000 or 100,000 integers. "Growing" arrays don't exist: A new array is created with a bigger size, the contents of the old array is copied to the new one and the old array is discarded. The bigger the array gets, the slower it will be. The only advantage: Your data is stored in a contiguous block of memory. Instead, consider allocating structured blocks containing: - A fixed array of 100 integers, - A "free" counter that is decreased with every integer stored, and - A pointer to the next structure (of the same layout), which is created when the free counter has reached zero (effectively creating a single linked list). All your program needs is one pointer to the first block in the single linked list, from where it can reach all others. Of course, this is only a simple example where there is no issue of values being removed from the collection, but with a "grow-only"collection this is an elegant trade-off between not allocating too much memory, and maintaining the possibility to work with large data sets. You will, however, probably need to implement you own version of a sorting algorithm that takes the "blocked" characteristic of you allocation structure into account. When working with data sets you'll always see the same patterns re-appearing: CRUD (Create, Read, Update and Delete). They almost always rely on a shared Find() function which locates a key value in the data set. This Find() will be the most often called function when working with the data set, and should therefor be the most efficient algorithm you can find. Techniques like hashing, sorting, binary searching or the use of binary trees should be used to make the Find() as efficient as possible. Check your programming language for implementations for these algorithms (usually, a quicksort or shellsort will be available, but only for plain arrays. Binary trees are special structures that are sorted by design - every new value is inserted in the tree so it maintains it sorted nature. All elements in the tree are linked to another using pointers, and your program only has one pointer to the tree). Study these algorithms, and make sure you understand the trade-offs and implications (like maintaining a linked list for each hash table entry as there can be two keys that are resolved to the same hash). For instance, try these techniques by creating a test program that stores words from a dictionary in a hash table consisting of binary trees. A structure like that can usually drastically reduce the number of iterations the program needs to find a value. Updated 56w ago • View Upvotes • Asked to answer by Sahil Saini