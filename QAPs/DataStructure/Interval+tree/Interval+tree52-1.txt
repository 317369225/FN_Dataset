What are some problems that computer science graduates can solve with ease, but a self-taught programmer would probably not be able to?
I think I can best answer this by listing a few of the the problems I'm working on with my summer students. 1)  Using roofline analysis, what is the provably fastest possible implementation of a fixed-size matrix-matrix multiplication algorithm on a given architecture? 2)  Given that modern processors have both inhomogeneous performance and inhomogeneous efficiency under a power bound, determine the algorithm that leads to optimal load and power balancing for an arbitrary massively parallel scientific kernel. 3)  What are the sources of performance nondeterminism and how can they be mitigated? 4)  What are the security implications of allowing IPMI-accessible sensors to be accessed in userspace, and what changes need to be made in the linux kernel to allow this? 5)  Performance under a power bound is influenced by the choice of algorithm, compiler optimizations and the underlying architecture.  How can one visualize these interactions to understand how scarce power is getting translated into performance? 6)  What is the best ioctl interface to use for batch and scatter-gather access to model-specific registers? 7)  How does one write a user-level library to handle architecture-specific power control features given the interactions of the processor version, BIOS version, kernel version and local policy? 8)  How can one trade off quality of in situ visualization for increased application performance under a power bound? 9)  What are the advantages of using neural networks and genetic algorithms to balance power at runtime across massively parallel simulations? 10)  How should the two power clamping algorithms present in Intel's Running Average Power Limit technology be combined to maximize performance? 11)  Can linear programming provide a bound on performance given scarce power? 12)  How well does per-iteration power allocation do compared to this optimal bound? 13)  How much can hardware overprovisioning improve the performance of a power-limited system? 14)  Given inhomogeneous processors, how should we change our designs for exascale clusters? What's common to all of these is that, with a couple of exceptions, these real-world problems can't be solved just by writing a program.  Here are the aspects that self-taught programmers usually don't have the skills to handle. a)  Finding provably optimal solutions or bounds on optimal solutions.  b)  Solving a class of problems rather than a particular instance. c)  Creating mathematical models (for performance, power consumption, etc.) d)  Generally taking a poorly-specified problems and being able to carve out a solvable, interesting problem.  I'm not saying that one can't be a self-taught computer scientist.  I am saying, though, that computer science is a science, and that the skills needed to be a scientist are very different than the skills needed to be a programmer. 