What all basic data structures and algorithms should one learn before starting competitive programming?
Originally Answered: What are most important algorithms for competitive programming?Here's an example template which contains many important methods for efficiently calculating Prime numbers, Prime factorization,  Divisor count, Factorial numbers, nCr, nCk, GCD, LCM, Modular inverse, Euler function, Sterling number of second kind. It also contains the methods for Fast IO in Java. import java.io.BufferedOutputStream; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStream; import java.math.BigInteger; import java.util.ArrayList; import java.util.Arrays; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.StringTokenizer;   public class Utils {   public static int[] factorials = new int[1000001]; public static int mod = 1000000007; public static BigInteger MOD = BigInteger.valueOf(1000000007);   // Input & Output public static BufferedReader br = new BufferedReader(new InputStreamReader( System.in)); public static OutputStream out = new BufferedOutputStream(System.out);   // Read characters public static char[] c() throws Exception {   StringTokenizer st = new StringTokenizer(br.readLine());   int i = 0; char[] a = new char[st.countTokens()];   while (st.hasMoreTokens()) { a[i++] = st.nextToken().charAt(0); }   return a;   }   // Read a character public static char c0() throws Exception { return c()[0]; }   // Read strings public static String[] s() throws Exception {   StringTokenizer st = new StringTokenizer(br.readLine());   int i = 0; String[] a = new String[st.countTokens()];   while (st.hasMoreTokens()) { a[i++] = st.nextToken(); }   return a;   }   // Read a string public static String s0() throws Exception { return s()[0]; }   // Read longs public static long[] l() throws Exception {   StringTokenizer st = new StringTokenizer(br.readLine());   int i = 0; long[] a = new long[st.countTokens()];   while (st.hasMoreTokens()) { a[i++] = Long.parseLong(st.nextToken()); }   return a;   }   // Read a long public static long l0() throws Exception { return l()[0]; }   public static Integer[] I() throws Exception {   StringTokenizer st = new StringTokenizer(br.readLine());   int i = 0; Integer[] a = new Integer[st.countTokens()];   while (st.hasMoreTokens()) { a[i++] = Integer.parseInt(st.nextToken()); }   return a;   }   public static int I0() throws Exception { return I()[0]; }   // Read integers public static int[] i() throws Exception {   StringTokenizer st = new StringTokenizer(br.readLine());   int i = 0; int[] a = new int[st.countTokens()];   while (st.hasMoreTokens()) { a[i++] = Integer.parseInt(st.nextToken()); }   return a;   }   // Read an integer public static int i0() throws Exception { return i()[0]; }   // Print an object without newline public static void print(Object s) throws IOException { out.write((s + "").getBytes()); }   // Print a newline public static void println() throws IOException { out.write(("\n").getBytes()); }   // Print an object with newline public static void println(Object s) throws IOException { out.write((s + "\n").getBytes()); }   // Flush an output buffer public static void flush() throws IOException { out.flush(); }   public static BigInteger fact(BigInteger n) {   BigInteger result = BigInteger.ONE;   if (n.equals(BigInteger.ZERO)) {   return result;   }   for (BigInteger i = BigInteger.ONE; i.compareTo(n) <= 0; i = i .add(BigInteger.ONE)) { result = result.multiply(i); }   return result;   }   // Use 64 bits integers to avoid overflow errors during multiplication. public static long modPow(long a, long x, long p) { // calculates a^x mod p in logarithmic time. long res = 1; while (x > 0) { if (x % 2 != 0) { res = (res * a) % p; } a = (a * a) % p; x /= 2; } return res; }   public static long modInverse(long a, long p) { // calculates the modular multiplicative of a mod m. // (assuming p is prime). return modPow(a, p - 2, p); }   public static void computeFactorials() {   long f = 1;   factorials[0] = 1;   for (int i = 1; i < factorials.length; i++) { f = (f * i) % mod; factorials[i] = (int) f; }   }   // Choose(n, k) = n! / (k! * (n-k)!) public static long nCk(int n, int k) {   if (n < k) { return 0; }   long a = BigInteger.valueOf(factorials[k]).modInverse(MOD).longValue(); long b = BigInteger.valueOf(factorials[n - k]).modInverse(MOD) .longValue();   // Left to right associativity between * and % return factorials[n] * a % mod * b % mod;   }   // Permute(n, k) = n(n-1)(n-2)...(n-k+1) public static BigInteger Pnk(BigInteger n, BigInteger k) {   BigInteger result = BigInteger.ONE;   if (n.compareTo(k) < 0) {   return BigInteger.ZERO;   }   for (BigInteger i = n.subtract(k).add(BigInteger.ONE); i.compareTo(n) <= 0; i = i .add(BigInteger.ONE)) { result = result.multiply(i); }   return result;   }   public static long gcd(long a, long b) { long c = 0; while (b > 0) { c = a; a = b; b = c % b; } return a; }   public static long lcm(int a, int b) { if (a == 0 && b == 0) { return 0; }   long result = a; long gcd = gcd(a, b); result /= gcd; result *= b; result = Math.abs(result);   return result;   }   public static boolean isPrime(long n) { if (n <= 3) { if (n <= 1) { return false; } else { return true; } } if (n % 2 == 0 || n % 3 == 0) { return false; } for (int i = 5; i < Math.sqrt(n) + 1; i += 6) { if (n % i == 0 || n % (i + 2) == 0) { return false; } } return true; }   public static List<Integer> primeFactors(int n) { List<Integer> factors = new ArrayList<Integer>(); for (int i = 2; i <= n / i; i++) { while (n % i == 0) { factors.add(i); n /= i; } } if (n > 1) { factors.add(n); } return factors; }   public static Set<Integer> uniquePrimeFactors(int n) { return new HashSet<Integer>(primeFactors(n)); }   // Count relatively prime numbers to n public static int totient(int n) {   Set<Integer> primeFactors = uniquePrimeFactors(n);   double r = n;   for (double p : primeFactors) { r *= (1 - 1 / p); }   return (int) r;   }   // Return Nth fibonacci number in the sequence (0, 1, 1, 2, 3, 5, 8,...) public static int getFibonacciNumber(int n) { int F[][] = { { 1, 1 }, { 1, 0 } }; if (n == 0) return 0; power(F, n - 1); return F[0][0]; }   public static void power(int F[][], int n) { if (n == 0 || n == 1) return; int M[][] = { { 1, 1 }, { 1, 0 } };   power(F, n / 2); multiply(F, F);   if (n % 2 != 0) multiply(F, M); }   public static void multiply(int F[][], int M[][]) { long t;   long x = F[0][0] % mod; x *= M[0][0] % mod; t = F[0][1] % mod; t *= M[1][0] % mod; x += t % mod; x %= mod;   long y = F[0][0] % mod; y *= M[0][1] % mod; t = F[0][1] % mod; t *= M[1][1] % mod; y += t % mod; y %= mod;   long z = F[1][0] % mod; z *= M[0][0] % mod; t = F[1][1] % mod; t *= M[1][0] % mod; z += t % mod; z %= mod;   long w = F[1][0] % mod; w *= M[0][1] % mod; t = F[1][1] % mod; t *= M[1][1] % mod; w += t % mod; w %= mod;   F[0][0] = (int) x; F[0][1] = (int) y; F[1][0] = (int) z; F[1][1] = (int) w; }   public static int getDivisorCount(int n) { int d = 1; int y = 0;   for (int i = 2; i <= n / i; i++) { y = 0; while (n % i == 0) { y++; n /= i; }   d = d * (y + 1);   } if (n > 1) { d = d * (2); }   return d;   }   public static boolean[] primes = new boolean[10000000]; public static ArrayList<Integer> primeList = new ArrayList<Integer>();   public static void fillPrimeSieve() { Arrays.fill(primes, true); primes[0] = primes[1] = false; for (int i = 2; i < primes.length; i++) { if (primes[i]) { for (int j = 2; i * j < primes.length; j++) { primes[i * j] = false; } } }   primeList.add(-1); // 0th prime!   for (int i = 0; i < primes.length; i++) { if (primes[i]) { primeList.add(i); } } }   public static int[][] sterlingTable = new int[101][101];   // S(n, k) = S(n-1, k-1) + k * S(n-1, k) public static void computeSterlingNumbers() { sterlingTable[0][0] = 1;   long t;   for (int i = 1; i < 101; i++) { for (int j = 1; j <= i; j++) { sterlingTable[i][j] = sterlingTable[i - 1][j - 1]; t = j; t *= sterlingTable[i - 1][j]; t %= mod; t += sterlingTable[i][j]; t %= mod; sterlingTable[i][j] = (int) t; } } }   public static void main(String[] args) {   System.out.print(Pnk(BigInteger.valueOf(3), BigInteger.valueOf(1)));   }   } 