What are the algorithms for determining if a point is inside an arbitrary closed shape or not?
Testing if a point is inside a polygon is pretty hard for a human if the polygon is a bit more complex. (picture from http://www.ics.uci.edu/~eppstein...) O(n) algorithms: Ray casting: shoot a ray from your point and see how many sides of the polygon it intersects. If the number is even, your point is outside the polygon. If it's odd your point is inside. Winding number: go around the sides of the polygon and sum up the sum of signed angles the points on the sides make with your current point. The result should be 2π if the point is inside and 0 if the point is outside Convex polygon/Starred polygon O(log n) algorithm: Choose a vertex of the convex polygon. Shoot n-1 rays from this vertex to every other vertex. Use binary search to find where your query point lies between two consecutive rays using their angle. Then you just need to test if the point is within a triangle. Grid solution: For a fixed precision split the plane into squares and compute if each square is inside or outside the polygon. Quadtree solution O(log U)?: Build a quadtree to represent the plane for some fixed precision. Each square in the quadtree is either totally inside, totally outside the polygon or intersects the polygon. If it intersects the polygon you either split it in 4 sub squares, or stop because the level of precision is small enough. Vertical slabs (O(n^2) preprocessing O(log n) query): Draw a vertical line through each vertex of the polygon. This splits the plane in n vertical slabs. For each slab compute the segments that cross the slab and sort them by the y of their middle point. For a given query point first use binary search to find the slab your point falls in. Within the slab you can binary search for the lowest segment that crosses the slab and is above our query point. Now you can count how many segments are intersected by a vertical ray that starts from the query point and know if you are inside the polygon or not. This approach can be improved to O(n) pre processing and O(log n) query time. There's another clever approach that splits at each level one triangle into 3 smaller ones, but I don't remember the details exactly. Updated 186w ago • View Upvotes