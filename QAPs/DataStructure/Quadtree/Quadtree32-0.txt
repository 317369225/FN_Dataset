What's the best way to solve the "multiple indexing" problem in functional programming?
In order to understand how to solve this problem, you'll need to first understand where the blog post is wrong, because the solution becomes apparent once the new understanding sets in. Those Are Not Indexes The post starts with a motivation of relational database and says that as tables can have multiple indexes, the author too wants to have the functionality in the language. Here's the example code reproduced >>> val1 = []>>> val2 = []>>> index1 = {1:val1, 5:val2}>>> index2 = {"pepijn":val1, "ben":val2}>>> index2["pepijn"].append("foo")>>> index1[1]['foo'] The actual problem is that the example code doesn't show indexes - it shows two separate containers instead of indexes. The example might look legit upon first glance, but if we push it further to deal with the other cases (insert/delete), we realize that his example immediately breaks down - he will have to do two separate inserts/deletes if he wants to keep the two "indexes" consistent. An index is a covarying container with the main container. But what we have with his example aren't two covarying containers with a main container (in fact the main container doesn't exist), just two separate containers. The example is only seemingly right due to his using mutable objects as examples. As Tikhon Jelvis said, if the author chooses something immutable, like interger or string, the example also breaks down. The example, in relational database terms, is better stated as two tables that have the same structure, instead of two indexes. Updating the data in one table isn't going to have its change reflected in the other table, no matter what database you use, and that is the way it's supposed to be. The example actually shows the problem with mutability if one wants to implement two separate independent containers. FP, given the adherence to immutability, makes the above exceedingly simple. Implementing Indexes The Imperative Way One can argue that the example code is just an example and no need to get pedantic about it, but it's actually relevant, because the choice of example shows why the author has this problem (that others don't have) in the first place. Let's see how a true multi-index problem is actually solved, first the imperative way, and later the FP way. So how do we implement indexes? As stated, it's a covarying container with the main container, so we must have a main container (we will call it Table to stick with database terms): class Table:    def __init__(self):         self.data = []  # actual main container        self.index1 = {} # first index        self.index2 = {} # second index        self.key1 = "key1" # the key for the first index        self.key2 = "key2" # the key for the second index This structure immediately points to the obvious ways to keep the two indexes in sync with the main container, by having a single entry point to insert/update/delete     def insert(self, record):         self.data.append(record)        self.index1[record[self.key1]] = record        self.index2[record[self.key2]] = record    # update delete omitted for brevity    When it's implemented this way, you will have true indexes that are covarying with the actual main container. Implementing Indexes The FP Way And the above also points to the solution in FP way, once you know how FP differs from the traditional imperative OOP way (see Yinso Chen's answer to What is functional programming, and how is it different than other paradigms? for more details). The key difference is that due to immutability, what we do is that we return a new Table object instead of modifying the underlying objects when we do insert/update/delete. class Table:     def __init__(self, data, index1, index2):        self.data = data        self.index1 = index1        self.index2 = index2        self.key1 = "key1"        self.key2 = "key2"    def insert(self, record):        # assuming the FP version of append & set that returns a new data & index.        newData = self.data.append(record)        newIndex1 = self.index1.set(record[self.key1], record)        newIndex2 = self.index2.set(record[self.key2], record)        return Table(newData, newIndex1, newIndex2)    # update/delete omitted for brevity The indexes are still covarying with the data, just like the imperative version. Keep covarying data structures together and "evolve" them together is how the multiple index problem is solved, whether imperatively or FP. Functional Data Structures All functional data structures work exactly the same way - returning a new version of the data structure instead of mutating it. So the question is how, and that answer will stretch this answer beyond its already long length into a full fledged book. Luckily that book has already been written. If you want to know how to create functional data structure, do yourself a favor a pickup a copy of Purely Functional Data Structures by Chris Okasaki - one of the best investments you'll make if you are serious about FP. In the remainder of the answer I'll address the two objections by the author. Tree Walking and Performance From the blog post However, it has no methods for lookingg up other keys, other thanâ€¦ walking the tree? The way this is done in imparative languages is to just have pointers to the nodes, but in a functional language, youre stuck walking the tree. Obviously, an array of objects always has a faster random access lookup time than walking a tree. But it is not true that in FP you are stuck walking the tree. You can always generate an array from the tree, and then use the array for random access. Obviously, doing so has costs, but that's what computing is all about - tradeoffs. Dynamic array that's the darling of imperative world also has costs. All the data structures have strengths and weaknesses. Nothing is suitable in all cases, and the performance characteristics depends on the implementations. That property of data structures is independent of FP. If it's more important to have faster access time to "other keys", don't use trees, use arrays. If it's more important to have faster access time and memory constraint than having FP's strengths, don't use FP. Optimize the program the way you need it to be optimized, and pay for the cost elsewhere, even if it's just programmer's time. Game Engine and Design Choices Knowing the cost goes right along with using the right tool for the right job. The author is working on a game engine in Clojure. Is it the right tool for the job? Plenty people will have reasonable doubts, but obviously he decides that it is worth a shot for him to devote a good chunk of his time toward it. Clojure is quite functional, but not purely functional and has mutable features. Using the right tool for the right job here also means using mutable features where it makes sense, and use FP where it makes sense. And in order to use FP appropriately, one needs to understand how to solve problems the FP way, and knows the tradeoff involved. At the end of the day, it always comes back to understanding the tradeoffs, and use the tools appropriately. What part of the game engine problem is best solved imperatively? And What part of the game engine problem is best solved in FP way? Figuring that out to get the best balance and result is what programming is all about. 