How do you implement a quadtree insertion recursively in C++?
You're inserting a node in a Quadtree, not in a Quadtree_node, so I wouldn't organize the code that way - the tree is empty initially, which becomes a corner case for your insert as you must have an existing Quadtree_node. The this pointer never points to NULL as the object must exist for you to be inside a non-static member-function. If you want to keep it that way, I believe you must insert the new node in the parent. Something like: bool Quadtree_node<T>::insert( T const &x, T const &y ) {   if( this -> x_value == x && this -> y_value == y ) {        return false;   } else {        if( x > this -> x_value && y > this -> y_value ) {             if (!this->north_east) {                this->north_east  = new Quadtree_node<T>(x,y);                return true;            } else {                this->north_east->insert(x, y);            }        }        // similar for the others   }} I would rather have a Quadtree class similar to this pseudo-c++ class Quadtree {    QuadtreeNode* root;    // begin option 1    bool insert(x, y) {        if (!root) {            root = new QuadtreeNode(x, y);            return true;        }        return insert(x, y, root);    }    bool insert(x, y, QuadtreeNode* current_node) {         if(this->x_value == x && this->y_value == y) {              return false;         } else {              if(x > this->x_value && y > this->y_value) {                    if (!this->north_east) {                       this->north_east  = new Quadtree_node<T>(x,y);                       return true;                   } else {                       insert(x, y, this->north_east);                   }              }              // similar for the others         }         return false;    }    //  end option 1    // begin option 2    bool insert(x, y) {        return insert(x, y, root);    }    bool insert(x, y, QuadtreeNode& * parent_node) {         if (!parent_node) {             parent_node = new Quadtree_node<T>(x, y);             return true;         }         if(this->x_value == x && this->y_value == y) {              return false;         } else {              if(x > this->x_value && y > this->y_value) {                    insert(x, y, this->north_east);              }              // similar for the others         }         return false;    }    // end option 2} 