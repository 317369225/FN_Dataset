I am the programming karate kid. You are the programming Mr. Miyagi. How do you train me?We have one year until the grand hackathon that will either bring glory to our names or shame to our families. I am a headstrong novice who is impatient and thinks he knows best when he does not. How can I be trained to perfection in the little time we have before the ultimate showdown? What are our daily practices and goals? How I wax on wax off?
First you must learn what a computer is.  Don't even get in front of one yet. Inside the mystery of the box, there is something ultimately simple.  It is called a Turing machine.   The apparent complexity of the machine comes merely from trying to move data into and out of the computer in the most impressive way possible or, alternatively, to calculate insanely fast. But that power will mislead you.  Build a simple calculator with Tinker-Toys, using flags for memory states ("true" and "not true") and a crank for performing the computation.  A simple game of tic-tac-toe has been made by Danny Hillis and is a marvel to behold (take a trip to the Boston Science Museum). If you understand the few basic logical operations of a computer, the orthogonal, yet complementary nature of memory vs processing, then you are ready to sit in front of one.  Find a graveyard 586 and install Linux on it, running text-mode only.  Make sure the machine has a hard disk light.  It's the last vestige of the hundreds of lights that used to light up a machine room.  Trust me.  Your challenge will be to make this machine faster than a modern one for meaningful tasks. Understand what your computer does.  Find out the sequence of events that begins the bootup process once you press the power button; find the assembly code of your BIOS chip and figure out at which point does the core of your operating system actually start?  Yeah, you're going to have to find books for these.  Do it. When you see the difference between the kernel and the operating system running in user-space, customize your kernel and compile it to your exact hardware.  This is called treating your hardware well. Find what programs/daemons are started after boot.  Understand what they do.  Remove everything you don't need or use.  This is called respecting memory. Now you are worthy of programming the computer.  You can now install your X Windowing environment, but first note that you had to master the command line and get in tune with processes.  You can't do that if Windows running. First learn C (gcc on linux).  C translates into computer code quite cleanly.  You don't have to suffer through assembly anymore.  Learn to profile your code, so you understand what makes good code (from the hardware point of view) and what doesn't.  These tools are readily and freely available.  Use them.  Make a program to find the 20th Mersenne prime. Read up on the history and evolution of operating systems, so you know what questions have been asked and answered.  Revamp the assumptions for the Internet era:  for ex., you don't need big hard-drives anymore because the internet provides what you need on hand.  Replace your hard disk with a 1Gb flash drive and you've just improved the performance of your system by 1000-fold.  Create a mini operating system of your own that's capable of performing several tasks without blocking the user's keyboard and screen I/O.  Start with making single-tasking OS that can store and display text files or use preexisting projects of the same ilk (like GNU Hurd).  To think about:  What are best ways to organize data in memory, data in storage, interface with the user, schedule different tasks? Now that you have the power of the network that early OS designers did not, design a system that includes peer-2-peer networking as part of its design.  Implement the DHT of Kademlia into the kernel so that you can find large amounts of files fast.  Liberate two or more PCs so you can test your implementation. Then, find me.  I will teach you from there. Updated 25 Jun 2013 • View Upvotes