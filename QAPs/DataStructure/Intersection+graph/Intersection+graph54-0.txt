What is it like to be a search software engineer at Facebook?
I was an engineer on the search team in 2012 and 2013, under the Entities group (which I'll talk about later). I had a great time and learnt a ton from some of the smartest people I've known! The Search Team around the Graph Search launch in early 2013. I'm on the iPad, being in New York at the time! Photo courtesy of Wired Magazine. The basic theory of search engines is deceptively simple. For each term in your search string it finds a list of all the documents that contain it. These lists are on the millions if not billions scale. Then, based on your query, it performs unions and intersections of those giant lists, and then try to sort this in context of the searcher, the query, content freshness, time of day, etc. Being Facebook, it also has to make sure you can only see content that is shared with you! When you get into the details, you realize there's a lot of work under the hood to keep a search system as complex as Facebook up and running. The search team was around 60 people in late 2012, spread across Menlo Park, New York and London. It broke down into 5 major areas: Infrastructure These folks speak of latency, reliability, scale and effective space utilization. They maintained Unicorn (Graph Databases: What exactly is Facebook Unicorn?), core pieces of AB testing infrastructure and made the magic happen. They typically worked in C++ and a bit with Hive. The fact that graph search can answer questions like "Restaurants in San Francisco, California liked by my married female friends and graduates of The Culinary Institute of America" in under a second continues to blow my mind when I step back and think about it! Ranking The land of precision and recall. The boundaries between these groups within Search is fuzzy because of the way Facebook lets its employees work with a lot of flexibility, but generally speaking, the ranking team is responsible for making sure the most relevant result is present and on top. To do this, they would train machine-learnt models, blend search results, index more content and ranking features, track a suite of metrics and regressions, collect and analyze logged data, create new features, collect training data and a whole lot more. A lot of the day to day work here would also happen in C++, with some help from Hive to move data around, PHP for business logic, and some R for machine learning and Python for scripting. Product We move higher up in the stack to user experience. This team integrates the search experience into the larger Facebook product and understands and redefines how and what people search for on Facebook. They build the front-line of the product, working through the nuances of interactions on web and mobile, and think long and hard about how people find their long lost friends or a sandwich nearby. They work the closest with design. The work here was typically in PHP, JavaScript, Java (Android) or Objective C (iOS). GrammarThis was a team created for graph search. It consists of linguists and computer scientists which convert your unstructured query "Restaurants in San Francisco, California liked by my married female friends and graduates of The Culinary Institute of America" to a structured oneÂ  "graduated/7299186405/students-2/places-liked/married/users/me/friends/females/intersect-3/places-liked/114952118516947/places-in/273819889375819/places/intersect" EntitiesThis was my group. Facebook searches over a lot more than just people - search results could be pages, places, movies, groups, events, books, etc. The non-people part is referred to as the Entity Graph. Our charter was to do whatever it took to improve the quality of the Entities Graph. If you found yourself in our part of the room, you'd hear of words like deduplication, coverage and quality. We wanted to make the search result for "Mission Chinese Food" returns the best page and that duplicate pages are merged to it. We were also responsible for ensuring that the best page had great photos, events, addresses, phone numbers, etc. (quality). Finally, we tried to make sure as many real world entities as possible had a presence on Facebook (coverage) and that spammy entities were suppressed in search. We used a mixture of machine learning and crowdsourcing to get this done. We'd cut across the stack to do whatever it took, so if you were to find yourself here, you'd probably spend time in Hive, PHP, Java (for Hive UDFs), JS, R and Python. Facebook's been very open about how a lot of search works, so I'd really recommend some of the following as a springboard into the technical details: Under the Hood: The natural language interface of Graph Search Under the Hood: Building out the infrastructure for Graph Search Under the Hood: Indexing and ranking in Graph Search Under the Hood: Building Graph Search Beta Under the Hood: The Entities Graph The Life of a Typeahead Query 