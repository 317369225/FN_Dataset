be c actually turing-complete ? i m not sure but i think the answer be no , for rather subtle reason . i <a href="https://cstheory.stackexchange.com/questions/2547/maximum-computational-power-of-a-c-implementation"> ask on theoretical computer science a few year ago </a> and didn t get a answer that go beyond what i ll present here . in most programming language , you can simulate a turing machine by : a concrete implementation run on a computer would run out of memory if the tape get too long , but a ideal implementation could execute the turing machine program faithfully . this can be do with pen and paper , or by buy a computer with more memory , and a compiler target a architecture with more bit per word and so on if the program ever run out of memory . this doesn t work in c because it s impossible to have a link list that can grow forever : there s always some limit on the number of node . to explain why , i first need to explain what a c implementation be . c be actually a family of programming language . the <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"> iso c standard </a> -lrb- more precisely , a specific version of this standard -rrb- define -lrb- with the level of formality that english allow -rrb- the syntax and semantics a family of programming language . c have a lot of <em> undefined behavior </em> and <em> implementation-defined behavior </em> . a implementation of c codify all the implementation-defined behavior -lrb- the list of thing to codify be in appendix j for c99 -rrb- . each implementation of c be a separate programming language . note that the meaning of the word implementation be a bit peculiar : what it really mean be a language variant , there can be multiple different compiler program that implement the same language variant . in a give implementation of c , a byte have $ 2 ^ -lcb- \ texttt -lcb- char_bit -rcb- -rcb- $ possible value . all datum can represent as a array of byte : a type <code> t </code> have at most $ 2 ^ -lcb- \ texttt -lcb- char_bit -rcb- \ time \ texttt -lcb- sizeof -lrb- t -rrb- -rcb- -rcb- $ possible value . this number vary in different implementation of c , but for a give implementation of c , it s a constant . in particular , pointer can only take at most $ 2 ^ -lcb- \ texttt -lcb- char_bit -rcb- \ time \ texttt -lcb- sizeof -lrb- void \* -rrb- -rcb- -rcb- $ value . this mean that there be a finite maximum number of addressable object . the value of <code> char_bit </code> and <code> sizeof -lrb- void \* -rrb- </code> be observable , so if you run out of memory , you can t just resume run you program with larger value for those parameter . you would be run the program under a different programming language a different c implementation . if program in a language can only have a bounded number of state , then the programming language be no more expressive than finite automaton . the fragment of c that s restricted to addressable storage only allow at most $ n \ time 2 ^ -lcb- \ texttt -lcb- char_bit -rcb- \ time \ texttt -lcb- sizeof -lrb- void \* -rrb- -rcb- -rcb- $ program state where $ n $ be the size of the abstract syntax tree of the program -lrb- represent the state of the control flow -rrb- , therefore this program can be simulated by a finite automaton with that many state . if c be more expressive , it have to be through the use of other feature . c do not directly impose a maximum recursion depth . a implementation be allow to have a maximum , but it s also allow not to have one . but how do we communicate between a function call and its parent ? argument be no good if they re addressable , because that would indirectly limit the depth of recursion : if you have a function <code> int f -lrb- int x -rrb- -lcb- & f -lrb- & -rrb- & -rcb- </code> then all the occurrence of <code> x </code> on active frame of <code> f </code> have they own address and so the number of nested call be bound by the number of possible address for <code> x </code> . a c program can use non-addressable storage in the form of <code> register </code> variable . normal implementation can only have a small , finite number of variable that don t have a address , but in theory a implementation could allow a unbounded amount of <code> register </code> storage . in such a implementation , you can make a unbounded amount of recursive call to a function , as long as its argument be <code> register </code> . but since the argument be <code> register </code> , you can t make a pointer to they , and so you need to copy they datum around explicitly : you can only pass around a finite amount of datum , not a arbitrary-sized datum structure that s make of pointer . with unbounded recursion depth , and the restriction that a function can only get datum from its direct caller -lrb- <code> register </code> argument -rrb- and return datum to its direct caller -lrb- the function return value -rrb- , you get the power of <strong> deterministic pushdown automaton </strong> . i can t find a way to go further . -lrb- of course you could make the program store the tape content externally , through file input\/output function . but then you wouldn t be ask whether c be turing-complete , but whether c plus a infinite storage system be turing-complete , to which the answer be a boring yes . you might as well define the storage to be a turing oracle call <code> fopen -lrb- `` oracle '' , `` r + '' -rrb- </code> , <code> fwrite </code> the initial tape content to it and <code> fread </code> back the final tape content . -rrb- 