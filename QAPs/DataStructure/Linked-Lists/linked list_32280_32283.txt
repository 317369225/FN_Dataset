order of storage of pointer for a link list of length n let $ t -lrb- n -rrb- $ be the number of middle-of-list pointer you need to store for a list of length $ n $ . for a list of length $ n $ , you need to store one pointer to the middle , plus however many middle-of-list pointer you need for the first half , plus however many you need for the second half . this give $ $ t -lrb- n -rrb- = 1 + 2t -lrb- n\/2 -rrb- \ , , $ $ and we can take $ t -lrb- 1 -rrb- = 0 $ , since a list of length $ 1 $ probably doesn t need a middle-of-list pointer . we have a <a href="http://cs.stackexchange.com/q/2789/9550"> reference question </a> on formally solve recurrence like this but , for a rough-and-ready approach , we see that $ t -lrb- 2 -rrb- = 1 $ , $ t -lrb- 4 -rrb- = 3 $ , $ t -lrb- 8 -rrb- = 7 $ so it s pretty clear that $ t -lrb- n -rrb- = o -lrb- n -rrb- $ and , more to the point , $ t -lrb- n -rrb- $ be about equal to $ n $ . well , now we wonder if a link list be really the right datum structure to be use . first off , program a link list with middle-of-list pointer seem to be quite difficult . append a item to the list sound like it ll be awkward because you have all those pointer to update . actually , i m not sure what the datum structure would even look like . but , anyway , maintain the middle-of-list pointer cost we time so we d better hope get something back for we investment of time , such as a saving in space . nope . store the link list need about $ n $ `` next '' pointer and about $ n $ middle of list pointer , for a total of about $ 2n $ . but just store you datum in a binary tree would require $ n $ node , each with a pointer to the left child and one to the right child , again give a total of $ 2n $ pointer . 