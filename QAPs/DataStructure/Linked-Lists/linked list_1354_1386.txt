quicksort vs. insertion sort on link list : performance pedro s answer cover what be go wrong with you first attempt . but i want to talk about a few thing when it come to analyze algorithm that may be a bit subtle . <strong> what be you algorithm ? </strong> before you can start analyze a algorithm , you need to say exactly what you re do . `` quicksort '' , for example , can mean a number of different thing . the basic pattern be : even at this level , there be some ambiguity , since i haven t actually describe how to pick the pivot and how to partition . in the modern era , which probably mean about 20 year , people think that you : in which case the number of comparison be $ o -lrb- n \ log n -rrb- $ in expectation and close to information theoretic bound . but ! notice that you and some commenter like to pick the pivot other way , so it be still important to say what you really mean . pick the pivot deterministically mean that there be case -lrb- depend on you rule -rrb- that will be much much worse . <strong> what be you primitive ? </strong> even once you ve decide what you <em> really </em> want you algorithm to do , you need to think about the `` basic step '' . for quicksort we need : notice that most analysis of sort devolve onto count comparison . we ll talk about why this be next . <strong> how much do you primitive cost ? </strong> finally , in any detailed run time analysis , you need some model of computation in which you can count `` operation '' . the most popular model for algorithm be the `` ram '' which have array with constant-time reads\/writes , the usual arithmetic operation , and integer comparison . -lrb- but there be lot of other . -rrb- for the usual analysis of quicksort , on a input of length $ n $ , you ll want : you can do this with link list -lrb- as in you second try -rrb- or -lrb- more usually -rrb- array , but the actual implementation will be <em> very different </em> . the issue be that in you first try -lrb- accord to other answer -rrb- , you be spend $ \ omega -lrb- n ^ 2 -rrb- $ on partitioning , which change the complexity a <em> lot </em> . <strong> why sorting analysis usually just count comparison . </strong> the reason i write all of this down be that , even in you bad implementation , you weren t do more <em> comparison </em> . most of the effort in analyze sort algorithm base on comparison count <em> only </em> comparison for a few reason : this second part be where you first try fall down . hope this help . <strong> even more </strong> everything so far be still theory . practical sorting algorithm actually need to be try on real machine . this be a whole area , and my understanding be that the current champ be not one of the standard algorithm , but something call `` timsort '' , which you can find here <a href="http://svn.python.org/projects/python/trunk/objects/listsort.txt"> http:\/\/svn.python.org\/projects\/python\/trunk\/objects\/listsort.txt </a> 