How do I solve the following question in Java: I have two linked lists, representing two numbers: l1: 2->3->4, l2: 7->8; add these two numbers and store the result in l1, i.e. l1 should become l1: 3->1->2?I want to do this WITHOUT reversing the lists, i.e. just using RECURSION? All answers with reversing the lists are useless for me.I understood from the question details that recursion is a possibility. So here's a O(N) algorithm with O(1) extra space besides saving the result. First find the length of each list. Then use recursion to sum the 2 lists of digits. If the lists have different lengths, there are 2 cases: - size(l1) > size(l2): suppose l2 has leading zeroes. - size(l1) < size(l2): add nodes do the head of l1 until they have the same size because l1 will store the result. class Ideone { static class Node { int digit; Node next; Node(int value) { digit = value; next = null; } } public int listLength(Node current) { return current == null ? 0 : 1 + listLength(current.next); } // The return node may have a value > 9. public Node sumLists(Node a, int remainingA, Node b, int remainingB) { if (a == null && b == null) return null; if (remainingA == remainingB) { a.next = sumLists(a.next, remainingA-1, b.next, remainingB-1); } else if (remainingA > remainingB) { a.next = sumLists(a.next, remainingA-1, b, remainingB); } else { Node cur = a; // Add a node to the head of list A. a = new Node(0); a.next = sumLists(cur, remainingA, b.next, remainingB-1); } if (a.next != null && a.next.digit > 9) { a.next.digit %= 10; a.digit++; // Carry. } if (remainingA <= remainingB) { // Does list b have a digit? a.digit += b.digit; } return a; } // Sums 2 lists. Saves result in the first one. public Node sumLists(Node a, Node b) { int lengthA = listLength(a); int lengthB = listLength(b); a = sumLists(a, lengthA, b, lengthB); if (a != null && a.digit > 9) { Node cur = a; cur.digit %= 10; a = new Node(1); a.next = cur; } return a; } } 284 Views  View Upvotes