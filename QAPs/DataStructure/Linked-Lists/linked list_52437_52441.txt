find a small element in a change array <strong> here be a amortize solution to the problem in which update may only increase value : </strong> maintain : a link list of some of the item less than the median a link list of all item greater than the median -lrb- and some item less than it -rrb- to return a small item , return a item from # 1 . to update a item greater than the median , change its key in # 2 . to update a item less than the median , remove it from # 1 and add it to # 2 . if this make # 1 empty , rebuild both list use a linear-time partitioning algorithm . update take amortize constant time , use physicist argument and a potential function of twice the size of list # 2 or the banker argument and two coin on each item in list # 2 . <strong> here be a amortize solution in which update may increase or decrease value : </strong> to start , build three link list of size $ n\/3 $ . all item in list # 1 should be less than all item in list # 2 , and all item in list # 2 should be less than all item in list # 3 . one more list will be maintain ; i ll call it the junkyard . to change the key of a item : when increase the key of a item in # 1 , move it to the junkyard . when decrease the key of a item in # 3 , move it to the junkyard . when change the key of a item from # 2 , move it to the junkyard . when change any other key , do not remove it from or add it to any list . the junkyard be call `` full '' when it have size $ n\/6 $ . until then , all item in # 1 be less than the median . once the junkyard be full , rebuild . the amortization argument work the same , but now the potential be six time the size of the junkyard , or , equivalently , each move to the junkyard require 6 coin . <strong> here be a complete deamortize solution : </strong> all operation can be do in constant time use a technique call <em> incremental global rebuilding </em> . maintain three copy of the second version of the structure design above , along with three pointer to they , call past , present , and future . if a structure be pointed to by a and we want to point to it from b , we call that `` rename a to b '' . we will proceed in four stage . after stage 4 , we will rename present to past , rename future to present , and point the future pointer at empty space -lrb- or the null pointer -rrb- . then we will start with stage 1 all over again . each stage last $ n\/36 $ update . query be always answer from present stage 1 : when this stage start : we will never query the structure point to by past again . it be dead , so we don t really care about its contents . present s junkyard have at most $ 2n\/36 $ item in it . future be just a null pointer . during this stage , update be perform on present as usual , but for each update , we perform 36 step of destruct past . as a result , by the end of this stage , $ n $ destructing step have be perform on past and it be empty , use no memory . at the end of this stage , present s junkyard might be as large as $ 3n\/36 $ . stage 2 : when this stage start , we allocate a empty link list that we call future . during this stage , for each update to present we also copy 36 item into future . also , for each item that be update , we update its key in future if it already have be copy . note that the update in future doesn t touch any junkyard , since future be just a link list at this point . at the end of this stage , present s junkyard might be as large as $ 4n\/36 $ , and the item in present and future be identical . stage 3 : when this stage start , we allocate a empty queue that can hold representation of update operation -lrb- for instance , as a pair contain a pointer to the item and its new value -rrb- . during this stage , for each update to present we also enqueue a representation of that update into the update queue , and we perform 36 step of the initialization of future into the structure describe in section 2 above . as a result , by the end of this stage , $ n $ initialization step have be perform on future and it be completely initialize , with a junkyard size of 0 . however , because update be queue , it do not hold the same datum as present , which we will have to fix in stage 4 . at the end of this stage , present s junkyard might be as large as $ 5n\/36 $ and the queue have size $ n\/36 $ . stage 4 : during this stage , for each update to present we also enqueue a representation of that update into the update queue and dequeue two operation to play back in future . during this stage the queue grow by $ n\/36 $ operation and shrink by $ 2n\/36 $ , leave it empty at the end of the stage . at the end of this stage , present s junkyard might be as large as $ 6n\/36 $ and future s junkyard might be as large as $ 2n\/36 $ . we now switch name as describe above , rename present to past , future to present , and point future at the null pointer . the prerequisite for stage 1 be now meet , and at no point do present have more than $ n\/6 $ item in its junkyard . 