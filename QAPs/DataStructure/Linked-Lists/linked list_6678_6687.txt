relation and difference between associative array and hash table ? the abstract datum type -lrb- adt -rrb- be essentially a apus , and a concrete datum structure provide a implementation of that apus . for a give adt , there be often several different choice of concrete datum structure which support the query and update operation describe by the adt . every concrete datum structure for a give adt must support all the operation describe by the adt -lrb- possibly with some probability of success in the case of randomize structure -rrb- , but each concrete structure may make different guarantee of the run time of each operation . the choice of which concrete datum structure to implement for a give adt usually depend on the priority of efficiency of each operation -lrb- include initialize the structure -rrb- and the complexity of implement and maintain the various datum type . some concrete datum structure have excellent theoretical guarantee , but the overhead be such that a slightly less theoretically optimal datum structure may be a better choice in practice . there be far too many adt and corresponding concrete structure to list in a single answer , but here be a few example : a <a href="http://en.wikipedia.org/wiki/associative_array"> dictionary </a> support <code> find -lrb- x -rrb- </code> query . for a a key $ x $ , return the element in the dictionary with key $ x $ , if such a element exist . a dynamic dictionary also support <code> insert -lrb- x -rrb- </code> and <code> delete -lrb- x -rrb- </code> . common implementation of a dictionary include different kind of balanced binary search tree -lrb- e.g. <a href="http://en.wikipedia.org/wiki/red-black_tree"> red black tree </a> -rrb- and various kind of <a href="http://en.wikipedia.org/wiki/hash_table"> hash table . </a> in addition to <code> find </code> a adt may require support of <code> successor -lrb- x -rrb- </code> query . that be , maintain a set of key $ s $ , and give key $ x $ , find the smallest key $ t \ in s $ such that $ s < t $ . concrete datum structure which support the successor adt include various binary search tree , and more complicated structure such as a <a href="http://en.wikipedia.org/wiki/x-fast_trie"> x-fast trie </a> or <a href="http://en.wikipedia.org/wiki/van_emde_boas_tree"> van emde boa tree </a> -lrb- if the key be integer -rrb- . a <a href="http://en.wikipedia.org/wiki/priority_queue"> priority queue </a> be a adt that require <code> insert </code> and <code> delete-min </code> operation -lrb- and sometimes other operation as well , such as <code> find-min </code> <code> increase-key </code> or <code> delete-key </code> -rrb- . datum structure that implement the priority queue adt include : a unsorted link list , which have fast <code> insert </code> but slow <code> delete-min </code> . a sort link list which have fast <code> delete-min </code> but slow <code> insert </code> a binary search tree , which have logarithmic <code> insert </code> and <code> delete-min </code> , and $ sort -lrb- n -rrb- $ initialization time . a <a href="http://en.wikipedia.org/wiki/binary_heap"> binary heap </a> which have logarithmic <code> insert </code> and <code> delete-min </code> , and linear time initialization . there be also other variant of <a href="http://en.wikipedia.org/wiki/heap_%28data_structure%29#comparison_of_theoretic_bounds_for_variants"> heap implementation </a> . a interval stab adt maintain a set of interval on the real line , and support a <code> stab -lrb- x -rrb- </code> query , which return the subset of interval which contain -lrb- be stab by -rrb- the point $ x $ . datum structure that implement the stab query adt include a <a href="http://en.wikipedia.org/wiki/segment_tree"> segment tree </a> and a <a href="http://en.wikipedia.org/wiki/interval_tree"> interval tree </a> . 