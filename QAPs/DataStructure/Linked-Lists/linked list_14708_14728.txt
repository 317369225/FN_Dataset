maintain a efficient order where you can insert element `` in between '' any two other element in the order ? this be know as the <a href="http://en.wikipedia.org/wiki/order-maintenance_problem" rel="nofollow"> `` order maintenance '' problem </a> . there be a relatively simple solution use $ o -lrb- 1 -rrb- $ amortized time for both query and insert . now , by `` relatively simple '' , i mean that you have to understand some building block , but that once you get those , the rest isn t hard to see . <a href="http://courses.csail.mit.edu/6.851/spring12/lectures/l08.html" rel="nofollow"> http:\/\/courses.csail.mit.edu\/6.851\/spring12\/lectures\/l08.html </a> the basic idea be a two-level datum structure . the top level be like the avl tree solution by realz slaw , but the node be directly label with bit string of length $ o -lrb- \ lg n -rrb- $ with a order that match they order in the tree . comparison thus take constant time a tree with fewer rotation than a avl tree be use , like a scapegoat tree or a weight-balanced tree , so relabelling happen less frequently . the bottom level be the leaf of the tree . that level use the same length of label , $ o -lrb- \ lg n -rrb- $ , but hold only $ o -lrb- \ lg n -rrb- $ item in each leaf in a simple link list . this give you enough extra bit to relabel aggressively . leaf get too big or too small every $ o -lrb- \ lg n -rrb- $ insert , induce a change in the top level , which take $ o -lrb- \ lg n -rrb- $ amortized time -lrb- $ \ omega -lrb- n -rrb- $ worst-case time -rrb- . amortize , this be only $ o -lrb- 1 -rrb- $ . much more complex structure exist for perform update in $ o -lrb- 1 -rrb- $ worst-case time . 