How do I reverse a linked list using tail recursion and two pointers?Tail recursion Page on stackoverflow.com Not tail recursion Let the linked list be 1->2->3->4->NULL You can traverse to the end of the list by recursion and then return a pointer to the next node to the previous call, for example after reaching 4 return a pointer to 4 to the previous call (when you were at node 3) so you can have a pointer to the next node and pointer to the current node. Now just change their pointers. You will need to keep track of your head pointer which can be the second pointer which you can change to the end of the list when you reach the end. #include<iostream> using namespace std; struct node { int data; struct node *next; }; void insert(struct node **head,int x) { struct node *newnode= new node[sizeof(node)]; newnode->data = x; newnode->next = *head; *head = newnode; } void display(struct node *head) { while(head!=0) { cout<<head->data<<"->"; head=head->next; } cout<<endl; } struct node * reverse(struct node* newnode,struct node **head) { if(newnode->next==0) { *head = newnode; return newnode; } else { struct node *prev = reverse(newnode->next,head); prev -> next = newnode; newnode -> next = 0; return newnode; } } int main() { struct node *head = 0; int n=10; while(n!=0) insert(&head,n--); display(head); reverse(head,&head); display(head); return 0; } 1.2k Views  View Upvotes  Answer requested by Rupjit Chakraborty