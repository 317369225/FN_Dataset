run time - link list polynomial the run time of the <code> insertterm </code> subroutine be $ \ theta -lrb- n -rrb- $ where $ n $ be the number of term in the polynomial , and this be the worst-case complexity as well as the average-case complexity absent any information about the monomial be insert . the outer loop of <code> polynomialadd </code> run <code> maxdegree -lrb- poly1 . head , poly2 . head -rrb- </code> time . inside each iteration , the inner loop search for a node with the right degree in each polynomial . for term of degree that be absent from the monomial , or present near the end of the monomial , the run time of the inner loop be $ \ theta -lrb- n -rrb- $ where $ n $ be the number of term in the respective monomial . the run time of <code> insertterm </code> have be discuss above ; here all i need to know be that its $ \ theta -lrb- n -rrb- $ . hence the run time of <code> polynomialadd </code> be $ \ theta -lrb- \ max -lrb- x , y -rrb- \ cdot -lrb- x + y -rrb- -rrb- $ where $ x $ and $ y $ be the number of term in the polynomial <code> poly1 </code> and <code> poly2 </code> respectively . the number of call to <code> insertterm </code> in <code> polynomialmul </code> be clearly $ xy $ , since the outer loop always run $ x $ time and the inner loop always run $ y $ time . i assume that <code> node1 . deg + node1 . deg </code> be a typo and you really mean <code> node1 . deg + node2 . deg </code> . i win t give a full proof here , but intuitively speak , this be go back and forth inside the result list , and so on average the time spend in <code> insertterm </code> be about half the length of the list : $ \ theta -lrb- x + y -rrb- $ . therefore the run time of <code> polynomialmul </code> be $ \ theta -lrb- x \ , y \ , -lrb- x + y -rrb- -rrb- $ . it be possible to implement polynomial addition and multiplication with faster run time , but you ll need to improve you code . the core idea be that you waste a lot of time in <code> insertterm </code> , insert at random position in the result list . instead , arrange to construct the result list in order : first the lowest-degree term at the end of the list , then the previous term , etc. -lrb- alternatively , if you find it easier , construct the list in the other order , start with the highest-degree term and maintain a pointer to the <code> next </code> pointer in the last node -rrb- . furthermore , do not traverse the argument again on each iteration through the loop : in addition , iterate over the two argument simultaneously ; in multiplication , where you need to combine term of different degree , remember where you stop so you can start again from the same point . 