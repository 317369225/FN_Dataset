what s the difference between clock and second chance page-replacement algorithm ? <a href="http://en.wikipedia.org/wiki/page_replacement_algorithm#clock" rel="nofollow noreferrer"> clock </a> <em> be </em> <a href="http://en.wikipedia.org/wiki/page_replacement_algorithm#second-chance" rel="nofollow noreferrer"> second chance </a> . give the same input they will both produce the same replacement at the same point in time . the only difference be the detail of implementation . second chance be usually describe in term of a `` fifo '' which be assume to be a link list where there be a pointer to the <code> head </code> and <code> tail </code> and every node contain a pointer to <code> next </code> . then when you remove a page from the head of the fifo you do it by set <code> head = head - > next </code> . when you insert a page on the tail of the fifo you do it by set <code> tail - > next = new_node </code> , <code> tail = new_node </code> , <code> new_node - > next = null </code> . clock be just a simpler -lrb- and slightly faster -rrb- implementation of a fifo where you keep a <em> circular </em> link list . <code> tail - > next </code> point to what be the head in we old structure . we only need one pointer , the pointer to <code> tail . </code> now remove a node from head be simply <code> tail - > next = tail - > next - > next </code> and insert a node on the tail be <code> new_node - > next = tail - > next </code> , <code> tail - > next = new_node </code> , <code> tail = new_node </code> . this be all about the same as the non-circular version . the efficiency come when you need to move a node from the head to the tail . that s just <code> tail = tail - > next </code> with the circular list . by add a second clock hand to the clock algorithm you get a extremely low-cost approximation of not-recently-used -lrb- which be a approximation of least-recently-used . -rrb- in the <a href="https://web.archive.org/web/20110506135229/http://www.cs.iastate.edu/~cs352/notes/ch12-3.pdf" rel="nofollow noreferrer"> two-handed clock </a> algorithm you have two clock hand . one of the hand be just like before , it point at the next page be consider for replacement . when a replacement be require we just keep move this clock hand -lrb- clearing reference bit -rrb- until we find a page with the reference bit clear , and that s the page that get replace . -lrb- so this clock hand be just do the clock implementation of second chance . -rrb- the second clock hand be another pointer into the circularly link list . the purpose of the second hand be to clear reference bit . every once in a while you clear the reference bit on the linked-list node that the second hand be point to , and set <code> second_hand = second_hand - > next </code> . this eliminate one of the problem with second chance , which be that when a page be only use a small amount right after it be first fetch then second-chance will require two cycle through the fifo before that page get replace . in the two-handed clock algorithm those `` short-term usage '' page get replace after just one cycle through the fifo . another replacement algorithm you might look at be <a href="http://cs.nyu.edu/courses/spring02/v22.0202-002/wsclock.html" rel="nofollow noreferrer"> wsclock </a> of carr and hennessy . it be a combination of the two-handed clock with a bunch of heuristic that be helpful in practice . 