what be the time complexity of call successor $ n $ time during tree traversal ? gist : <strong> the time complexity of call the sucessor function multiple time be not merely the product of the number of call and the worst-case bind </strong> , though that product do encompass the worst case . rather , if the function go to be call from every node , a more sophisticated analysis can establish a tighter worst-case bind for specific tree and implementation of the successor function . at best , tree traversal take at $ o -lrb- n -rrb- $ time : $ n-1 $ call be make to the successor function , which take constant time . one simple example of this be the traversal of a link list , which have a successor function that immediately return a pointer to the next node with no additional computation . <img src="http://i.stack.imgur.com/btjou.png" alt="linked list"> the worst `` reasonable '' tree traversal would take $ o -lrb- n ^ 2 -rrb- $ time : $ n-1 $ call be make to the successor function , which search all $ n $ node before determine the successor . for example , if we have a unsorted tree and the successor be define to be the next largest element -lrb- rather than base on its position in the tree -rrb- . of course , we could sort the tree first in time $ o -lrb- n \ log n -rrb- $ and in general , if we expect to call the successor function $ n $ time , it would be wise to preprocess the tree so that it can be traverse in one of the three canonical way : inorder , preorder , or postorder . ok , time to clear a misconception ! let s ask what s the best-case and worst-case scenario for the successor function be when we have a inorder traversal of a binary search tree : <img src="http://i.stack.imgur.com/8innl.png" alt="sorted binary tree"> remember that in inorder traversal , the left subtree be visit , then the parent node , then the right subtree . so a inorder traversal in the tree above give we $ -lsb- a , b , c , d , e , f , g , h -rsb- $ . -lrb- for contrast , preorder traversal would have give we $ -lsb- f , b , a , d , c , e , g , i , h -rsb- $ -rrb- . we start at the beginning of the tree at $ a $ . from $ a $ , the successor function check to see that it have no right subtree -lrb- it doesn t -rrb- before find its closest ancestor for which it be the descendant of the left child . but wait ! i didn t tell you that each node have knowledge of its ancestor , so we potentially have to search the entire tree just to determine where $ a $ be ! so now we split into two case : <em> worst-case </em> : assume that we node have no right subtree , if the tree be a binary search tree , we could find the node in $ o -lrb- \ log n -rrb- $ time . but worst-case , it s not a binary search tree ; in fact , it have no structure , so every call take $ o -lrb- n -rrb- $ time , but if we re consistent about how we search , the total number of step to find the node s successor be at least $ \ sum _ -lcb- x = 1 -rcb- ^ -lcb- n -rcb- x = \ frac -lcb- -lrb- n -rrb- -lrb- n +1 -rrb- -rcb- -lcb- 2 -rcb- = o -lrb- n ^ 2 -rrb- $ . <em> best-case </em> : each node have a link to its ancestor , so from $ a $ to $ b $ take two step -lrb- check for right subtree ; back up to ancestor for which it be the left child -rrb- . the successor function that take the most step be from $ e $ to $ f $ , for which $ e $ first check that it have no right subtree , then check to see if it be the left child of $ d $ -lrb- it isn t -rrb- , or the descendent of the left child of $ b $ -lrb- it isn t -rrb- , and finally if it be the descendent of the left child of $ f $ -lrb- it be -rrb- . that take $ o -lrb- h -rrb- =o-lrb-_NN \ log n -rrb- $ step , but most call to the function win t take that many step . quote the so post , `` observe that each edge in the tree get visit at most twice -lrb- once from parent to child and once from child to the parent -rrb- '' so the total number of node visit be $ 2n $ and hence $ o -lrb- n -rrb- $ worst-case bind . another way to appreciate that the average call to successor be $ < \ log -lrb- n -rrb- $ be to consider a balanced tree with $ n $ node and roughly $ n\/2 $ leave . half of all successor function call will be to a ancestor , half of which be from the left child -lrb- $ \ frac -lcb- 1 -rcb- -lcb- 4 -rcb- n $ -rrb- and thus take only one generation\/step , $ \ frac -lcb- 1 -rcb- -lcb- 8 -rcb- n $ go back two generation , $ \ frac -lcb- 1 -rcb- -lcb- 16 -rcb- n $ go back three . hopefully you see the pattern : $ \ sum _ -lcb- i = 1 -rcb- \ frac -lcb- i -rcb- -lcb- 2 ^ -lcb- i +1 -rcb- -rcb- $ converge to $ 1 $ . and the other half do the step-analogous $ \ min $ function -lrb- search it s right subtree for the leftest child -rrb- , so it also converge to $ 1 $ . the expect time be thus $ 2 $ -lrb- if i ve do my math carefully -rrb- . so that s $ n-1 $ call to a successor function that on average take ~ $ 2 $ step $ \ rightarrow o -lrb- n -rrb- $ time . 