Can you delete a node from its element in a double linked list?So a linked list is a collection of nodes containing elements. One nodes points to another and etc creating a chain that is the linked list. I understand how to delete a node from a list, but how can you call the element.delete() method to notify the node containing it to also perform node.delete()?Short version This is doable, but it’s a bad idea. If you’re considering this approach, you might be thinking about your program wrong. A doubly linked list is just a container for holding values. On principle, containers should be responsible for their contents; contents should not be responsible for their containers. If you’re worried about deleting both the node and the value, pass the node around instead, and delete the value from there. Justification: If your element.delete() method also calls your node.delete() method, what happens if you have an element that is not contained by a node? You probably want to do something with this element outside of the doubly linked list. Otherwise why bother storing it at all? In this case, an orphaned element may have unintended side-effects when deleted. What if later you decide to store your elements in a hash table rather than a doubly linked list? You will need to rewrite code in the element class as well as the node class. This paradigm may also lead to you deleting something more than once, which is bad. Sometimes, a container’s delete method will call it’s value’s delete method. If each of these delete methods calls the other, you’re in infinite loop town. Depending on your language, this could also lead to big dependency issues. In general, it’s dangerous to have objects that reference each other. It can lead to unexpected behavior and in compiled languages, such objects may not successfully link. If you are totally set on doing this and your language allows it, you can hold a pointer or reference to the containing node inside your element. It looks like this. /////////////////////////////////////////////////////////// // Don't do this /////////////////////////////////////////////////////////// class Element { Node parent;   delete() { parent.delete(); } }   class Node { Element value;   delete() { /* do things */} } Alternatively, you could call element.delete() from within your node.delete(), but I don’t like this either. If you ever want to hold on to an object that you remove from your doubly linked list, this version will fail. //////////////////////////////////////////////////////////// // Not recommended, but less egregious //////////////////////////////////////////////////////////// class Element { // Does not contain reference to parent delete() { /* things */} }   class Node { Element value; delete() { value.delete(); } } The best thing to do is to have the delete methods not know about each other, so that you have total control over when things are deleted. Here’s an example containing a method “PopOut,” which removes a node from a doubly linked list and returns the value. /////////////////////////////////////////////////////////// // Do this one! /////////////////////////////////////////////////////////// class Element { // Does not contain reference to parent delete() { /* things */} }   class Node { Element value;   delete() {/* does not touch value */} }   Element PopOut(Node n) { Element e = n.value; n.delete(); return e; } Moral of the story Destroy your children, not your parents. Disclaimer: The code above is pseudo-code, and all the linked-list logic has been left out for clarity. 246 Views