what s the difference between a binary search tree and a binary heap ? <strong> advantage of binary heap over a balanced bst </strong> average time insertion into a binary heap be <code> o -lrb- 1 -rrb- </code> , for bst be <code> o -lrb- log -lrb- n -rrb- -rrb- </code> . <strong> this </strong> be the killer feature of heap . there be also other heap which reach <code> o -lrb- 1 -rrb- </code> amortize -lrb- stronger -rrb- like the <a href="https://en.wikipedia.org/wiki/fibonacci_heap" rel="nofollow"> fibonaccus heap </a> , and even worst case , like the <a href="https://en.wikipedia.org/wiki/brodal_queue" rel="nofollow"> brodal queue </a> , although they may not be practical because of non-asymptotic performance : <a href="http://stackoverflow.com/questions/30782636/are-fibonacci-heaps-or-brodal-queues-used-in-practice-anywhere"> http:\/\/stackoverflow.com\/questions\/30782636\/are-fibonacci-heaps-or-brodal-queues-used-in-practice-anywhere </a> binary heap can be efficiently implement on top of array , bst can not . so we don t have to store 3 pointer per node -lrb- left , right , parent -rrb- plus balancing datum -lrb- e.g. rb-ness -rrb- , save memory by a constant factor . binary heap creation <a href="https://en.wikipedia.org/wiki/binary_heap#building_a_heap" rel="nofollow"> be <code> o -lrb- n -rrb- </code> worst case </a> , <code> o -lrb- n log -lrb- n -rrb- -rrb- </code> for bst . <strong> advantage of bst over binary heap </strong> search for arbitrary element be <code> o -lrb- log -lrb- n -rrb- -rrb- </code> . <strong> this </strong> be the killer feature of bst . for heap , it be <code> o -lrb- n -rrb- </code> in general , except for the largest element which be o -lrb- 1 -rrb- . <strong> `` false '' advantage of heap over bst </strong> heap be <code> o -lrb- 1 -rrb- </code> to find max , bst <code> o -lrb- log -lrb- n -rrb- -rrb- </code> . this be a common misconception , because it be trivial to modify a balanced bst to keep track of the largest element , and update it whenever that element could be change : on insertion of a larger one swap , on removal find the second largest . <a href="http://stackoverflow.com/questions/7878622/can-we-use-binary-search-tree-to-simulate-heap-operation"> http:\/\/stackoverflow.com\/questions\/7878622\/can-we-use-binary-search-tree-to-simulate-heap-operation </a> -lrb- mention <a href="http://stackoverflow.com/a/27074221/895245"> by yeo </a> -rrb- . actually , this be a <em> limitation </em> of heap compare to bst : the <em> only </em> efficient search be that for the largest element . <strong> average binary heap insert be o -lrb- 1 -rrb- </strong> source : intuitive argument : in a binary heap , increase the value at a give index be also <code> o -lrb- 1 -rrb- </code> for the same reason . but if you want to do that , it be likely that you will want to keep a extra index up-to-date on heap operation <a href="http://stackoverflow.com/questions/17009056/how-to-implement-ologn-decrease-key-operation-for-min-heap-based-priority-queu"> http:\/\/stackoverflow.com\/questions\/17009056\/how-to-implement-ologn-decrease-key-operation-for-min-heap-based-priority-queu </a> e.g. for dijikstra . possible at no extra time cost . <strong> bst can not be efficiently implement on a array </strong> heap operation only need to bubble up or down a single tree branch . keep a bst balanced require tree rotation , which can change the top element for another one , and would require move the entire array around . <strong> philosophy </strong> bst maintain a global property between a parent and all descendant -lrb- left smaller , right bigger -rrb- . the top node of a balanced bst be the middle element , which require global knowledge to maintain -lrb- know how many smaller and larger element be there -rrb- . this global property be more expensive to maintain -lrb- log n insert -rrb- , but give more powerful search -lrb- log n search -rrb- . heap maintain a local property between parent and direct child -lrb- parent > child -rrb- . the top note of a heap be the big element , which only require local knowledge to maintain -lrb- know you parent -rrb- . <strong> doubly-linked list </strong> a doubly link list can be see as subset of the heap where first item have greatest priority , so let s compare they here as well : a use case for this be when the key of the heap be the current timestamp : in that case , new entry will always go to the beginning of the list . so we can even forget the exact timestamp altogether , and just keep the position in the list as the priority . this can be use to implement a <a href="http://stackoverflow.com/a/34206517/895245"> lru cache </a> . just like <a href="http://stackoverflow.com/questions/14252582/how-can-i-use-binary-heap-in-the-dijkstra-algorithm"> for heap application like dijkstra </a> , you will want to keep a additional hashmap from the key to the corresponding node of the list , to find which node to update quickly . <strong> see also </strong> similar question on so : <a href="http://stackoverflow.com/questions/6147242/heap-vs-binary-search-tree-bst"> http:\/\/stackoverflow.com\/questions\/6147242\/heap-vs-binary-search-tree-bst </a> 