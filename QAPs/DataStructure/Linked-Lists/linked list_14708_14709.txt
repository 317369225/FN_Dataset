maintain a efficient order where you can insert element `` in between '' any two other element in the order ? instead of simple numbering , you could spread the number out over a large -lrb- constant size -rrb- range , such as integer minimum and maximum of a cpu integer . then you can keep put number `` in between '' by average the two surround number . if the number become too crowded -lrb- for example you end up with two adjacent integer and there be no number in between -rrb- , you can do a one-time renumbering of the entire order , redistribute the number evenly across the range . of course , you can run into the limitation that all the number within the range of the large constant be use . firstly , this be not a usually a issue , since the integer-size on a machine be large enough so that if you have more element it likely wouldn t fit into memory anyway . but if it be a issue , you can simply renumber they with a larger integer-range . if the input order be not pathological , this method might amortize the renumbering . a simple integer comparison can answer the query $ \ leave -lrb- x \ stackrel -lcb- ? -rcb- -lcb- < -rcb- y \ right -rrb- $ . query time would be very quick -lrb- $ \ mathcal -lcb- o -rcb- \ leave -lrb- 1 \ right -rrb- $ -rrb- if use machine integer , as it be a simple integer comparison . use a larger range would require larger integer , and comparison would take $ \ mathcal -lcb- o -rcb- \ leave -lrb- \ log -lcb- integer -rcb- \ right -rrb- $ . firstly , you would maintain the link list of the order , demonstrate in the question . insertion here , give the node to place the new element in between , would be $ \ mathcal -lcb- o -rcb- \ leave -lrb- 1 \ right -rrb- $ . label the new element would usually be quick $ \ mathcal -lcb- o -rcb- \ leave -lrb- 1 \ right -rrb- $ because you would calculate the new numeber easily by average the surrounding number . occasionally you might run out of number `` in between '' , which would trigger the $ \ mathcal -lcb- o -rcb- \ leave -lrb- n \ right -rrb- $ time renumber procedure . you can use float instead of integer , so when you get two `` adjacent '' integer , they <em> can </em> be average . thus you can avoid renumber when face with two integer float : just split they in half . however , eventually the float point type will run out of accuracy , and two `` adacent '' float will not be able to be average -lrb- the average of the surrounding number will probably be equal to one of the surrounding number -rrb- . you can similarly use a `` decimal place '' integer , where you maintain two integer for a element ; one for the number and one for the decimal . this way , you can avoid renumbering . however , the decimal integer will eventually overflow . use a list of integer or bit for each label can entirely avoid the renumbering ; this be basically equivalent to use decimal number with unlimited length . comparison would be do lexicographically , and the comparison time will increase to the length of the list involve . however , this can unbalance the labeling ; some label might require only one integer -lrb- no decimal -rrb- , other might have a list of long length -lrb- long decimal -rrb- . this be a problem , and renumbering can help here too , by redistribute the numbering -lrb- here list of number -rrb- evenly over a choose range -lrb- range here possibly mean length of list -rrb- so that after such a renumbering , the list be all the same length . this method actually be actually use in <a href="http://code-o-matic.blogspot.com/2010/07/graph-reachability-transitive-closures.html"> this algorithm </a> -lrb- <a href="https://code.google.com/p/transitivity-utils/"> implementation </a> , <a href="https://code.google.com/p/transitivity-utils/source/browse/trunk/src/edu/bath/transitivityutils/orderlist.java"> relevant datum structure </a> -rrb- ; in the course of the algorithm , a arbitrary order must be keep and the author use integer and renumber to accomplish this . try to stick to number make you key space somewhat limited . one could use variable length string instead , use comparison logic `` a '' < `` ab '' < `` b '' . still two problem remain to be solve a. key could become arbitrarily long b. long key comparison could become costly 