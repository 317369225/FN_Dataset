What is the best algorithm to reverse the circular linked list?A simple implementation in C++ using three pointers. #include<iostream> #include <stdlib.h>  using namespace std;  struct node { int key; node *next; }*head=NULL,*p,*q,*rear=NULL,*x;  void push(int k) { if(head==NULL) { head = new node; head->key = k; head->next = NULL; rear = head; } else { x = new node; x->key = k; x->next = NULL; rear->next = x; rear = x; } }  void traverse() { x = head; while(x!=NULL) { cout<<x->key<<"->"; //system("pause"); x = x->next; } }  void rev() { x = head->next; p = head; head->next = NULL; while(x) { q = x->next; x->next = p; head = x; p = x; x = q; } }  int main() { int t,k; while(t) { cin>>k; push(k); cout<<"You want to continue - (1/0)"; cin>>t; } traverse(); rev(); cout<<"\n"; traverse(); return 0; }  2.3k Views  View Upvotes