order-preserving update of a sublist of a list of mutable object in sublinear time in a previous answer , i assume that $ s $ be a fixed list of element , consider as a set order by the place of element in the list . only some property of the element be suppose to be modifiable . the problem be to maintain another order list $ f $ where element of $ s $ , filter for that property , could be insert or remove , and such that the rank index of a element in $ f $ be return when the element be insert . assume the list to be fix be essential because , by precompute the rank index of each element in the list , if be possible to check the order of two element in unit time $ o -lrb- 1 -rrb- $ by compare they rank . <strong> in a later comment , the poster of the question indicate that in addition to the state specification of the problem , the list $ s $ itself can be modify by insertion and deletion . </strong> then there may no longer be a way to check the order of two element in unit time . it be possible to maintain a rank index dynamically , as show below , but compute it have a cost $ o -lrb- \ log s -rrb- $ , so that the whole complexity of each operation be multiply by that value , thus have a complexity $ o -lrb- \ log f \ time \ log s -rrb- $ , or , to simplify in $ o -lrb- \ log ^ 2 n -rrb- $ where $ n = s $ be the size of the source list . so i propose here a structure for implement both list $ s $ and $ f $ in such a way that : the order in $ s $ be preserve for both , element can be insert or remove anywhere in $ s $ , any element of $ s $ that be modify to satisfy a property $ p_f $ can be insert in $ f $ , or remove if it no longer satisfy $ p_f $ , for any element , it be possible to find its rank index in $ s $ and in $ f $ all operation be execute with a cost $ o -lrb- \ log s -rrb- $ . furthermore the technique can be extend to handle simultaneously several list $ f_1 , \ ldot f_i \ ldot $ each correspond to a different property $ p_i $ . finally , i propose a technique to maintain a simple link list of the element in $ f $ , so that they can be list in time $ o -lrb- f -rrb- $ independently of the size of the source list $ s $ . the idea be to use a unique <a href="https://en.wikipedia.org/wiki/self-balancing_binary_search_tree" rel="nofollow"> self-balancing binary search tree </a> -lrb- bst -rrb- such as a <a href="https://en.wikipedia.org/wiki/avl_tree" rel="nofollow"> avl tree </a> or a <a href="https://en.wikipedia.org/wiki/red%e2%80%93black_tree" rel="nofollow"> red-black tree </a> -rrb- . this tree be first use to implement the list $ s $ . this may seem strange as there be no a priori order to the element of the list , and they order be determine only by arbitrary insertion and deletion . so the insertion procedure have to be change , in a fairly trivial way , as you choose to insert a new node after some give node of the exist structure -lrb- induce the order as a consequence , since there be none a priori -rrb- and rebalance the tree accordingly . to every node $ n $ , you add a weight $ w_s $ which be the number of element of $ s $ in the subtree root in $ n $ , actually the number of node of that subtree . this weight can be update when insert of delete a node without change the $ o -lrb- \ log s -rrb- $ cost of the operation . furthermore , the weight can be use to compute the rank index of a node in $ o -lrb- \ log s -rrb- $ time , or to retrieve a node from its rank in the same time . the rank index be compute on the fly by add the weight of all the immediate sibling on the left of the path from the tree root to the concerned element of $ s $ . they number be $ o -lrb- \ log s -rrb- $ . conversely , it be easy to find in logn time a element of f from its -lrb- leave to right -rrb- index by walk down from the root and leave enough element on the left . to implement the list $ f $ , one simply mark as such the node of the tree that contain a element of $ f $ . actually they can be simply identify by testing he property $ p_f $ , when that test be cheap -lrb- i.e. at worst $ o -lrb- 1 -rrb- $ -rrb- to be able to compute the index of a element in the list $ f $ , we add to each node $ n $ a second weight $ w_f $ , which be the number of element of $ f $ in the subtree root in $ n $ . this weight be update exactly like the previous one $ w_s $ . it be also use in the same way to get the index of a node in $ f $ or to find a node in $ f $ from its rank . there be a little subtlety in the latter , as , after leave enough node on the left , we may have to search for the next subtree with a non zero weight $ w_f $ , since that weight can be zero for some node . all this can be achieve in time $ o -lrb- \ log s -rrb- $ for each operation . <strong> enumerate $ f $ </strong> if you want to enumerate in order all the element of the list $ f $ , this can be do by enumerate the element of $ s $ by walk the tree , and filter out those that be not in $ f $ . that take time $ o -lrb- s -rrb- $ . but , it may be the case that the list $ s $ be much larger than $ f $ , and it would be convenient to enumerate easily the element of $ f $ without this overhead , in time $ o -lrb- f -rrb- $ . this can be do by maintain in each node a link $ l_f $ , which be nil if the node be not in $ f $ , or be the last node in $ f $ , and which point to the next node in $ f $ when it be a node in $ f $ other than the last one . these pointer have to be maintain every time a node be insert in $ f $ or remove from it . but it be easily do in time $ o -lrb- \ log s -rrb- $ like other operation , thus not modify the complexity . it be obviously possible since we can find the rank $ r $ of a node $ n $ insert in $ f $ , and we can find the node preceed and follow $ n $ from they rank $ r-1 $ and $ r +1 $ , each in time $ o -lrb- \ log s -rrb- $ . but there be faster way to do it . the means for implement the filter list $ f $ be build on top of the self-balancing binary search tree represent the list $ s $ , but they interfere in no way with the operation on that tree concern $ s $ . thus it be possible to implement in the same way as many filter list as may be need , correspond to different filter predicate . <strong> note : </strong> the above sketch the algorithmic technique . write the whole thing be pseudo-code be far beyond what could be consider reasonable in a normal answer . 