How do you print a linked list backwards using recursion with classes?Several comments contain a solution to your homework, but this is not what you need. The goal of this assignment is to help you understand recursion, and this is what I will try to help you with - not with the assignment. Recursion is conceptually the same thing as Mathematical induction, only done in code instead of on paper. You should approach recursion just like you would approach induction. First, look at an example of a linked list you'd like to print in reverse: You'd like your function to print 2,15,1. There are two ways to approach recursion, which both look at absurdly extreme cases: Bottom Up, when you start thinking of empty lists, and Top Down when you start thinking of huge, or even infinite lists. I will describe only the bottom up approach. Bottom up: You start with the stop condition. In this case you think of an empty list, i.e., only NULL. For an empty list you print nothing, so this is quite trivial. void print(Node *p) { if (p == NULL) return; // Not empty, what should we do here? } Next, you look how to extend that into 1 item: It is trivial to implement a function that will print such a tiny list - there is no need in recursion to do that. void print(Node *p) { if (p == nullptr) return; if (p->next == nullptr) { cout << p->id << "\n"; } // what about longer lists? } But what if it is longer than one item? You can't add more and more if conditions for longer and longer lists, right? If you have a list with to items: You know how to reverse print its tail, this is what print(Node *p) does. So why not use this function to reverse print the last element? Since you want to print 2 first, and then 15, then you first call print(Node *p) to reverse print the tail, and only then print 15: print(p->next); cout << p->id << "\n"; This seems to work for lists of length 2, so why not put this code into our print function? void print(Node *p) { if (p == nullptr) return; if (p->next == nullptr) { cout << p->id << "\n"; } else { print(p->next); cout << p->id << "\n"; } } We constructed this code to work with list lengths of up to 2. What about list length 3? Simply follow the code above. You see that the function detects that the length is > 1. In this case the function divides the list into two parts, and starts with printing the tail of the list via print(p->next). It prints 2 and then 15, as we have seen before. After calling print it prints the head node, i.e., 1. This is exactly what we wanted. You can prove by induction that this works for any list length. The implementation of this function is a bit redundant, and you don't really need a special treatment of list length=1. It is not an error to have this redundancy, but is not very elegant. Removing the second if gives us: void print(Node *p) { if (p == nullptr) return; print(p->next); cout << p->id << "\n"; } You can easily validate that it works for lists of length 1,2,3, and use induction to prove that it works for any list. With trivial syntactic reshuffling, you can get rid of the return statement. 678 Views  View Upvotes  Answer requested by Romeo Bismarck