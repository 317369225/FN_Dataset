What is advantage of using linked lists over arrays?I’m assuming here that we’re talking about a relatively low-level language such as C or C++. I’ll also assume that were’ talking about structures holding types that are not themselves arrays or lists, as the question gets much murkier when dealing with structures such as arrays of lists or lists of arrays. First I’ll summarise. Statically declared arrays are of a fixed length and so are poorly suited to data sets of indeterminate size. Dynamically declared arrays require careful tracking of the array’s length and occasional reallocation, which is an expensive operation. There are unfortunate consequences if you attempt to access elements past the end of an array. Insertions and deletions for linked lists are O(1) (where these operations for an array are O(N)), although traversing a list is O(N) which balances this out somewhat. Linked lists make it easier to have a structure holding different types without wasting memory (but have additional overhead). As a very (very) rough rule of thumb, I would use an array whenever random access is required or the size of the data set has a definite limitation. The advantages depend in part on whether you’re talking about statically or dynamically declared arrays. A statically declared array (char x[5]) is of fixed length; the amount of data that can be stored is fixed. A linked list does not have that limitation. A dynamically created array (declared as a pointer then assigned using malloc or similar) will need to have its memory reallocated if it grows too large. The realloc may require the array to be copied in its entirety to a new memory area (although the library function will handle that part.) A dynamically declared array should also have that memory freed before termination. Regardless of whether it was created dynamically or statically, at any time an array is of a particular length and attempting to read or write past the end of the array will do bad things; if you are lucky, it will merely crash your program. If you are unlucky, somebody may abuse your carelessness to break into your system. In any case, you must track the length of your array to avoid this. (Handling pointers properly with linked lists also requires some care, particularly with avoiding accessing deallocated or NULL pointers.) If your array uses dynamically allocated memory, then it can be grown using library functions such as realloc, but realloc may change the location of all members of the array. With a linked list, the memory locations of individual members are static. Insertions and deletions are typically more straightforward with a linked list, as you only need to add or remove a single element and modify one or two pointers (and possibly free up the memory used for a deleted element). With an array, insertions and deletions require all following elements to be shuffled forwards or backwards, so the work required is O(N). However, this is not as large an advantage as it may seem, as simply traversing a linked list to the desired element is also an O(N) operation. While in general an array can hold dissimilar types by using unions, the amount of memory used per element will be the maximum possible size of the type held. A linked list, by using void* pointers (or a union of pointer types), can link dissimilar types. However, for simpler data types an array will use less memory as it lacks the overhead of a pointer (and memory management overhead) for each element. Arrays have their own advantages as well; chiefly, low overhead per element, much more complex memory management, and the ability to access elements randomly. If you read the list above carefully, you will see that each is linked to an advantage for lists: Memory management for lists is much more complex. Great care must be taken with linked lists to avoid dereferencing deallocated memory or null pointers. Traversing linked lists is a very expensive operation; there is no random access. The memory overhead per element is typically much lower with an array, and there is less overhead in adding new elements, assuming that a buffer is used to allow for growth. 432 Views · View Upvotes