parallel vs distribute algorithm the term can mean almost anything , but i will try to present here <em> one </em> way in which the term `` parallel algorithm '' and `` distribute algorithm '' be understand . here we interpret `` distribute algorithm '' from the perspective of `` network computing '' -lrb- think : algorithm that keep the internet running -rrb- . i will use as a run example the problem of find a <strong> proper 3-colouring of a direct path </strong> -lrb- link list -rrb- . i will first describe the problem from the perspective of `` traditional '' algorithm those be also know as <em> centralised algorithm </em> , to emphasise that they be not distribute , or <em> sequential algorithm </em> , to emphasise that they be not parallelise . the model of computing be e.g. the familiar <strong> ram model </strong> . the input be a link list that be store in the main memory of the computer . there be a read-only array $ x $ with $ n $ element ; node number $ x -lsb- i -rsb- $ be the successor of node number $ i $ . the output will be also store in the main memory of the computer . there be a write-only array $ y $ with $ n $ element . we need to find a proper coloring of the list with $ 3 $ color . that be , for each index $ i $ we must choose a color $ y -lsb- i -rsb- \ in \ -lcb- 1,2,3 \ -rcb- $ such that $ y -lsb- i -rsb- \ ne y -lsb- j -rsb- $ whenever node $ j $ be the successor of node $ i $ . there be a single processor that can directly access any part of the main memory . in one time unit , the processor can read from main memory , write to main memory , or perform elementary operation such as arithmetic or comparison . the <strong> run time </strong> of the algorithm be define to be the number of time unit until the algorithm stop . clearly , the problem can be solve in time $ o -lrb- n -rrb- $ , and this be optimal . for the upper bind , follow the link list and color the node with e.g. color $ 1,2,1,2 , \ dotsc $ . for the lower bind , observe that we need to write $ \ omega -lrb- n -rrb- $ element of output . the only difference between parallel and sequential algorithm be that we will use the <strong> pram model </strong> instead of the <strong> ram model </strong> . in the pram model we can consider any number of processor , but here a particularly interesting case be what happen if there be precisely $ n $ processor . while we will have <strong> multiple processor </strong> , there be still just <strong> one main memory </strong> . as before , the input be store as a single array in the main memory , and the output will be write in a single array in the main memory . now in one time unit , each processor in parallel can read from main memory , write to main memory , or perform elementary operation such as arithmetic or comparison . some care be need with memory access that may conflict . for the sake of concreteness , let we focus on the crew pram model : the processor may freely read any part of the memory , but concurrent write be forbid . now in this set it be not at all obvious what be the time complexity of $ 3 $ - color link list . perhaps we could solve the problem in $ o -lrb- 1 -rrb- $ time , as we have $ n $ processor , and only $ n $ unit of input to read and $ n $ unit of output to write ? however , it turn out that the time complexity of this problem be precisely $ \ theta -lrb- \ log \ log ^ \* n -rrb- $ . so it can be solve in <em> almost </em> constant time , but not quite . now thing change radically . the model of computing be e.g. the <strong> local model </strong> , which have very little resemblance to ram or pram . there be no `` main memory '' . there be no `` array '' . we be only give a <strong> computer network </strong> that consist of $ n $ node . each node be label with a unique identifier -lrb- say , a number from $ \ -lcb- 1,2 , \ dotsc , n \ -rcb- $ -rrb- . each node have two communication port : one port that connect the node with its successor , and one port that connect it with its predecessor . <strong> the same -lrb- unknown -rrb- computer network be both we input and the tool that we be suppose to use to solve the problem . </strong> each node be a computational entity that have to output its own color , and the color have to form a proper coloring of the network -lrb- i.e. , my color have to be different from the color of my neighbor -rrb- . note that everything be distribute : no single entity hold the entire input , and no single entity need to know the entire output . all node run the same algorithm . in one time unit , all node in parallel can send message to they neighbor , receive message from they neighbor , or perform elementary operation . the <strong> run time </strong> of the algorithm be define to be the number of time unit until all node have stop and produce they local output . again , it be not at all obvious what be the time complexity of $ 3 $ - coloring . it turn out that it be precisely $ \ theta -lrb- \ log ^ \* n -rrb- $ . from this perspective : research on parallel algorithm be primarily about <strong> understanding how to harness the computational power of a massively parallel computer </strong> . for practical application , consider high-performance computing , number-crunching , multicore , gpu computing , openmp , mpus , grid , cloud , cluster , etc. research on distribute algorithm be primarily about <strong> understanding which task can be solve efficiently in a distribute system </strong> . for practical application , consider computer network , communication network , social network , market , biological system , chemical system , physical system , etc. for example : if you want to know how to multiply two huge matrix efficiently with modern computer hardware , it may be a good idea to first have a look at research related to `` parallel algorithm '' . if you want to know if there be any hope people could form stable marriage in they real-world social network , by just exchange information with those whom they know , it may be a good idea to first have a look at research related to `` distribute algorithm '' . once again , i emphasise that this be just one way in which the term be use . there be many other interpretation . however , this be perhaps the most interesting interpretation in the sense that e.g. pram and local be radically different model . as many other answer show , another possible interpretation be to understand `` distribute algorithm '' from the perspective of e.g. distribute high-performance computing -lrb- computer cluster , cloud computing , mpus , etc. -rrb- . then you could indeed say that distribute algorithm be not necessarily that different from e.g. i\/o efficient parallel algorithm . at least if we put aside e.g. issue relate to fault tolerance . incidentally , there be apparently some interest in the community to make the terminology slightly less confusing . people occasionally use the term <em> distribute graph algorithm </em> -lrb- cf. <a href="http://adga.hiit.fi/" rel="nofollow"> http:\/\/adga.hiit.fi\/ </a> -rrb- or the term <em> network compute </em> to emphasise the perspective that i describe here . however , there be not that much pressure to do that , as we can use formally precise term such as `` local '' and `` congest '' for distribute graph algorithm , `` pram '' for parallel algorithm , and e.g. `` congested clique '' and `` bsp '' -lrb- bulk synchronous parallel -rrb- for various in-between case . 