a efficient datum structure support insert , delete , and mostfrequent you can do all of these in $ o -lrb- 1 -rrb- $ expected amortized time . the essential trick be that we don t need the full power of a priority queue , since key frequency only change by 1 during each insert or delete . my solution below be really just you solution with a `` inefficient '' priority queue that happen to work well for this case : a max priority queue implement as a doubly link list of bucket of key have o -lrb- 1 -rrb- insertmin , deletemax , removefrombucket , and increasekey . maintain a doubly-linked list of bucket , where each bucket have a non-empty hash set of key -lrb- that i ll call a cohort -rrb- and a positive integer -lrb- that i ll call the valcount -rrb- . in a bucket b , each key k in the cohort of b have the same number of unique value associate with it in the set you be maintain . for example , if you set have the pair -lrb- a , apple -rrb- , -lrb- a , avocado -rrb- , -lrb- b , banana -rrb- , -lrb- c , cucumber -rrb- , -lrb- d , dragon fruit -rrb- where the single letter be the key and the fruit be the value , then you would have two bucket : one bucket would have a valcount of 2 and a cohort consist only of one key : a. the other bucket would have a valcount of 1 and a cohort consist of the three key b , c , and d. the doubly-linked list of bucket should be keep order by the valcount . it will be important that we can find the head and the tail of the list in $ o -lrb- 1 -rrb- $ time and that we can splice in a new bucket in $ o -lrb- 1 -rrb- $ time if we know its neighbor . unimaginatively , i ll call the list of bucket the bucketlist . in addition to the bucketlist , we ll need a setmap , which be a hash map mapping key to valuebucket . a valuebucket be a pair consist of the valueset -lrb- a non-empty hash set of value -rrb- and a non-null pointer to a bucket . the valueset associate with a key k contain all the unique value associate with k. the bucket pointer associate with a valueset have a cohort equal to the size of the valueset . the bucket associate with a key k in the setmap be also associate with the key k in the bucketlist . in c + + : to find a max-frequency key-value pair , we just need to look at the head of the bucketlist , find a key in the cohort , look up that key in the setmap , and find a value in the valueset of its valuebucket . -lrb- phew ! -rrb- insert and delete key-value pair be trickier . to insert or delete a key-value pair , we first insert or delete it in the setmap this will change the size of the valueset , so we need to modify the bucket associate with the key . the only bucket we will need to look at to make this change will be the immediate neighbor of the bucket the key use to be in . there be several case here , and they be probably not worth spell out fully , though i d be happy to elaborate if you re still have trouble . 