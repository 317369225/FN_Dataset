Is the DOM NodeList a linked list or an array?That is, does accessing childNodes[i] take O(N) or O(1) time?First, a quick question: If all the containers in your page have no more than five child nodes, what's the complexity of previousSibling/nextSibling and childNodes[i]? Answer: it doesn't matter! Either method of access is going to figure out the right answer very quickly, with only constant-time differences in speed. Most documents won't have max five children anywhere. But most documents will have relatively small numbers of children, such that iterating from zero and and getting sibling by indexing pathological cases will still be pretty fast. This is doubly true in implementations that add mini-caches to make the "wrong" mechanism fast in common cases. So it's probably not worth worrying about this in general. And if it happens that your code is hitting this as an issue, possibly your code is doing something it shouldn't. Now, what if you really do have a case where this matters, and you absolutely unavoidably have to use the DOM for whatever you're tracking? It depends on the implementation. As written, the DOM specs include both childNodes[i] and nextSibling/previousSibling modes of access. You can't make both of them equally fast for random accesses without spending memory to do so (by doing both doubly-linked and an array). (This is arguably a design flaw in the DOM, which should have chosen only one pattern to enable.) But you can add caches that make both relatively fast, for certain access patterns. As far as what current browser engines do: Gecko: nextSibling/previousSibling is O(1). (Historically it made these O(n), but that changed a few years ago for consistency with other engines that used a linked-list implementation strategy.) childNodes[i] is also O(1). This is possible because Gecko stores the data as both a linked list and as an array. (Gecko used to use only an array but switched to using both a few years ago for previous/next performance. But even at that time there were some caches around, to attempt to help with previous/next looping.) So the piper gets paid by extra memory consumption. For more details, see mozilla-central mozilla/content/base/src/nsAttrAndChildArray.cpp in Gecko source. WebKit: nextSibling/previousSibling is O(1). childNodes[i] random access is O(n). As a semi-recent development (how recent, I'm not sure -- within the last couple years, being very generous with my recollection of when a discussion predating this change occurred), childNodes[i] is O(n - i, or i) if a previous childNodes index has occurred and the node that was accessed hasn't been removed yet -- complexity depending whether you're accessing after that node, or before. So sequential childNodes[i] access remains O(1) but with an apparently larger constant factor than in Gecko's case. The tradeoff is that WebKit uses less memory for this. For more details, see CollectionIndexCache.h in trunk/Source/WebCore/dom - WebKit in WebKit source. Blink: nextSibling/previousSibling is O(1). Ordinarily I'd say childNodes[i] would be the same as WebKit, but I'm having trouble interpreting WebKit's revision history well enough to conclusively say when the childNodes[i] cache came into being, to know if it precedes the fork or not (and I'm about out of time to research). (Or if Blink cherry-picked the fixes from WebKit.) Anyone else know more here? Trident (and Presto for historical curiosity): No idea. But given Gecko's history, I'd be surprised if nextSibling/previousSibling aren't O(1). Anyone know? If I were suggesting which to use in practice, I'd say use firstChild/previousSibling/nextSibiling/lastChild. It's O(1) in several of the major engines and probably so in the others. 3.5k Views  View Upvotes