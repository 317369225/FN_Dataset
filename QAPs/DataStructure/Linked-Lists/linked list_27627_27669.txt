algorithm : dimension increase in 1d representation of square matrix there be a simple solution , but it require a different 1d representation of you matrix $ m $ . you suppose it be store in a arbitrarily long 1d array $ a $ , so that new element can be add . then the element of the matrix $ m $ be store such that : $ m -lsb- i , j -rsb- $ be store in $ a -lsb- k -rsb- $ with $ k = -lrb- j-1 -rrb- ^ 2 + i $ if $ i \ leq j $ and $ k = i ^ 2-j +1 $ otherwise . other similar formula be also possible . the idea be to store in order the successive layer of increase matrix size start with the $ 1 \ time 1 $ matrix . store order of a $ 3 \ times3 $ matrix be describe here , each element of the matrix be its index in $ a $ . the first index $ i $ be the line index of matrix $ m $ representation : 1 2 5 <br> 4 3 6 <br> 9 8 7 when you increase the size $ m $ of the matrix , you only have to add the new layer at the end , i.e. add the representation of the last row and last column at the end of the used part of array $ a $ . the cost be linear in $ m $ . <strong> explanation </strong> the initial version of the question ask for a linear datum structure , without explicitly allow for linked-list , which i do not consider more linear than anything else , the memory have generally a linear address space . hence i assume the idea be to use , as efficiently as possible , a one dimensional array $ a $ , without try to mimic pointer . i start look for a efficient way to store -lrb- and retrieve -rrb- the element $ m -lrb- i , j -rrb- $ of the matrix $ m $ in $ a $ , so that extend the matrix with a extra dimensional layer for the highest value of the index , could be do cheaply ... the cheapest be to add the new layer right at the end of the exist matrix , so that the cost would be no more than the number of element to be copy . to do that , while keep a uniform indexing scheme require to have do it uniformly , start from the $ 1 \ time 1 $ matrix . the question be somewhat imprecise regard constraint , i assume that keep each line in one contiguous piece be not really require . the placement of the element of matrix $ m $ in the linear array $ a $ be illustrate by the above $ 3 \ time 3 $ matrix , where each element have the value of its index in $ a $ . this organization be such that the index in $ a $ of a element $ m -lrb- i , j -rrb- $ of the matrix $ m $ do not depend on the size of $ m $ , but only on $ i $ and $ j $ . take $ p = max -lrb- i , j -rrb- $ , the placement in $ a $ of the upper-lefmost submatrix of $ m $ of size $ p $ be independent of the rest of the matrix $ m $ . the element $ m -lrb- i , j -rrb- $ be either on the rightmost column of that submatrix if $ i \ leq j $ , or on its last line otherwise . furthermore , the first $ -lrb- p-1 -rrb- ^ 2 $ element of array $ a $ be already use to store the upper-left submatrix of size $ p-1 $ . one use the next $ 2p-1 $ element of the $ p ^ -lcb- th -rcb- $ row and $ p ^ -lcb- th -rcb- $ column , which contain element $ m -lrb- i , j -rrb- $ . this can be do in different way , and the propose formulum store these $ 2p-1 $ element in top-down and right-to-left order . <em> note : the first version of the formula use $ p = max -lrb- i , j -rrb- $ explicitly to compute the square , a remnant of my initial search for a solution . but @weaklytyped remark rightly that the test compare $ i $ and $ j $ do the job , allow to replace $ p $ by $ i $ or $ j $ , accord to the test result . </em> <strong> actual use of the representation </strong> one characteristic of this representation be that it preserve random access -lrb- access time be constant and independent of index and matrix size -rrb- , which be not usually the case with list representation . however it do not require multiplication for indexing the array $ a $ , since only addition and integer square be need . integer square can be memorize in a linear array , or can be compute with addition only if successive square value be need in a loop , for example to read a line or a column of the matrix , use the formulum $ -lrb- p +1 -rrb- ^ 2 =p ^ 2 +2 p +1 $ . but , as usual , the usefulness of such a representation be highly dependant on the operation need and they frequency . <em> note : this representation be find independently , but it may have be use before . pointer to the literature be welcome . </em> -lrb- <em> add July 1st 2014 , after the answer be accept </em> -rrb- the layer approach describe in the previous algorithm seem more effective than most pointer base representation for two reason : give $ i $ a $ j $ , it allow access of element $ m -lsb- i , j -rsb- $ in constant time ; it have no overhead in space for store pointer -lrb- not to mention possibly greater garbage collection cost -rrb- . however , the last statement be not completely true . we choose to use a array $ a $ of `` sufficient '' length because that initially -lrb- in the first version of the question -rrb- seem a give constraint . but , if we relax that constraint , it be clear that it be a costly solution in space since the array $ a $ must have a size sufficient to store the largest version of the matrix $ m $ that may be use . actually , there be something absurd about the solution present above , if it be to be more than a intellectual exercise -lrb- but the context and motivation of the question be not give -rrb- . if the array $ a $ have the maximum size that will ever be need , why not simply code the maximum size matrix in it , and use at any time only the index that be actually need , give the current matrix size $ m $ ? since pointer be -lrb- now -rrb- allow , this be a good motivation for attempt to get the benefit of the solution present above , without its absurd drawback . the idea be quite simple : keep the layer structure present above , but store the layer separately , rather than contiguously in the same array . so a matrix $ m $ of size $ m $ be implement as $ m $ array $ l_p $ with $ 1 \ leq p \ leq m $ , each $ l_p $ have $ 2p-1 $ element correspond to the element $ m -lsb- i , j -rsb- $ of $ m $ such that $ max -lrb- i , j -rrb- =p $ . in order to access $ m -lsb- i , j -rsb- $ , one only have to compute $ p = max -lrb- i , j -rrb- $ to locate $ l_p $ , and then index appropriately with $ i $ or $ j $ inside $ l_p $ to get the right element . actually , as in the first algorithm above , it may be faster just to have two case base on a comparison between $ i $ and $ j $ . i do not get into the detailed formula , that be somewhat obvious to work out . however this require a extra structure to find a pointer to $ l_p $ when $ p $ be know . three obvious idea come to mind : the first idea be to use a <strong> array of link </strong> to the $ l_p $ layer , which be index by $ p $ . the drawback be that the size of the array must be the maximum possible value for $ m $ , but that be not as bad as the maximum value for $ m ^ 2 $ . the advantage be that access any element $ m -lsb- i , j -rsb- $ will still be in constant time . the second idea be to use a <strong> link list </strong> , which avoid the constant size array . however , the list have to be follow sequentially to get the right layer $ l_p $ . hence access any element $ m -lsb- i , j -rsb- $ will on the average be in linear time with respect to the current size $ m $ . note that , with this solution , it be better to access the list from the end correspond to the largest value of $ p $ . firstly , that be where layer be add or remove . secondly , assume that all element of $ m $ have equal chance of bee access , the probability of find a element in layer $ l_p $ be proportional to $ -lrb- 2p-1 -rrb- \/ m ^ 2 -rrb- $ , hence a higher probability for higher value of $ p $ . indeed , access the list from the higher value of $ p $ be on average twice as fast as access from the lower value of $ p $ -lrb- proof leave as a exercise -rrb- . but access be linear in $ m $ in both case . in order to reduce access time , the access structure can be a <strong> balanced tree </strong> . the size of the tree be linear in $ m $ , as it be with a simple list , but the time complexity of find the right $ l_p $ be now logarithmic in $ m $ , hence also for access a element $ m -lsb- i , j -rsb- $ . while build this balanced tree , it be better to give to each $ l_p $ a weight proportional to $ 2p-1 $ to account for its probability of be the right layer . however , i have not check how much of a difference it make . but actually , try to build a sophisticated balanced tree be probably self-defeating sophistication , because it may have to be maintain , and it may require more computation to be explore . a better solution be probably a widely branch tree that be walk very simply by indexation . -lrb- i have no idea whether this have a official name in textbook -rrb- the node of the tree be array of length $ 2 ^ d $ , so that we can build a balanced tree with node of degree $ 2 ^ d $ . the leaf node be array of pointer to matrix layer , and the other node be array of pointer to other array -lrb- or nothing -rrb- . without go into detail , give a layer number $ p $ , the binary representation of $ p $ be cut into chunk of size $ d $ which be use as index for the array while walk down the tree to find the layer $ l_p $ . with a value for $ d $ of 3 or 4 , this should give simple and fast access for matrix of significant size . 