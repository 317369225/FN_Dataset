best design of a software control page table : to echo the tlb ? page table structure -lrb- and especially page table structure for software manage page table -rrb- be a hot area of research in the mid 1990s . at its root this be just the problem of create a datum structure to represent a map from one set of integer -lrb- the key -lrb- virtual address -rrb- -rrb- to another set of integer -lrb- physical address -rrb- . so you should expect the answer to have something to do with hash table or search tree or both . the `` best '' choice depend on : here be some good thing to read : huck , jerry ; hay , jim : <a href="http://web.stanford.edu/class/cs240/readings/p39-huck.pdf" rel="nofollow"> architectural support for translation table management in large address space machine </a> , <em> int l symp comp arch </em> -lrb- isca-20 -rrb- :39 -50 , 1993 . doi :10.1145 \/ 165123.165128 . for machine with virtual address space that be much larger than the physical address space the inverted page table be the traditional solution . the inverted page table have exactly as many entry as there be physical page . the entry record the virtual address map to that physical address , and also include a link pointer . you look up a virtual address by hash it to find a start entry in the inverted table , then search the link list start at that entry until you either find the virtual address in question , or find the end of the list . there be a number of problem with inverted page table . they don t handle have multiple virtual address map to the same physical address , it be expensive to find all of the physical page that have be map for a particular process -lrb- you need to walk the entire table look for entry with that process s asid -rrb- , and you need a different datum structure to record information about virtual page that have be move to back store . from a performance perspective the inverted page table do poorly at leverage spatial locality because adjacent page hash to disparate location in the inverted page table . the huck and hay paper suggest variation on the inverted page table to address some of the inverted page table s shortcoming . tallurus , madhusudhan ; hill , mark d ; khalidus , yousef a : <a href="http://www.cs.columbia.edu/~nieh/teaching/e6118_s00/papers/p184-talluri.pdf" rel="nofollow"> a new page table for 64-bit address space </a> , <em> acm symposium on operate system principle </em> -lrb- sosp-15 -rrb- :184 -200 , 1995 . doi :10.1145 \/ 224056.224071 . this paper suggest a different approach to deal with the locality problem of the inverted page table . essentially the inverted page table be use for super-block make up of some number -lrb- 16 in the paper -rrb- of normal page . thus you get the nice behavior of the inverted page table -lrb- proportional to the size of physical memory -rrb- but get some locality benefit because subsequent tlb miss tend to be for other page in the same super-block . balum , kavita ; kaashoek , m fran ; weihl , william e : <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.32.4837&amp;rep=rep1&amp;type=pdf" rel="nofollow"> software prefetching and caching for translation lookaside buffer </a> , <em> usenix confernce on operate system design and implementation </em> -lrb- osdi-1 -rrb- :18 , 1994 . this paper suggest that no matter what structure you use for the page table , you should augment the hardware tlb with a large , direct-mapped , software tlb . the hardware tlb usually need to be quite small so suffer from capacity miss . you try to cover a large percentage of the capacity miss by find the appropriate entry in the direct-mapped software tlb . the hope be that the software tlb be relatively quick and cover most access , and then you can use a more complicated structure -lrb- like a forward-mapped page table -rrb- for the few remain miss . so there be lot of choice , and there be lot of variable to consider . the best datum structure choice really depend on the characteristic of you particular machine and you particular workload . you be try to optimize for a sparse , but chunky , map function , try to make sure you can handle operation beyond just lookup efficiently , and try to leverage the spatial locality in the address stream to minimize cache miss while access the page table . 