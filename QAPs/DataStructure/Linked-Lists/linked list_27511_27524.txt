link list implementation problem this should really be on stackoverflow , not computer science , but here s a answer anyway . there be a few point . first of all , you code <em> be not a link list </em> . you create a unbounded array , a array that grow dynamically -lrb- good implementation also shrink dynamically , but that be beyond the scope of this question -rrb- . a link list be <em> define </em> -lrb- more or less -rrb- as in the first implementation : each node store some datum and point to the node after it -lrb- and sometimes behind it , in the case of a doubly-linked list -rrb- . they be two different datum structure . now , onto the question of efficiency . from you code , it seem you be interested in the operation <code> insertatback </code> , <code> insertatfront </code> , and <code> search </code> . both array and list support search in $ o -lrb- n -rrb- $ time , though array can support search in $ o -lrb- \ log n -rrb- $ if they be sort , whereas link list can not . link list have $ o -lrb- 1 -rrb- $ time <code> insertatback </code> and <code> insertatfront </code> operation . while <code> insertatback </code> be $ o -lrb- n -rrb- $ worst-case for unbounded array , it be actually amortize $ o -lrb- 1 -rrb- $ , so it s not that bad . however , <code> insertatfront </code> be $ o -lrb- n -rrb- $ under any measure of time complexity . so , in short , a linked-list be what you want in this situation -lrb- though link list be rarely use on they own , and almost always use as a building block of other datum structure -rrb- . as for you question of space , you re right in that the linked-list be less efficient , as it need to store two pointer for every datum entry . on the other hand , linked-list have the advantage that each node can be store in a separate location in memory , whereas array be store in a contiguous block of memory , which can be bad if the array be really large . 