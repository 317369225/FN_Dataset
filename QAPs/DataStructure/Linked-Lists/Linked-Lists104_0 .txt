Given a number in the form of a linked list and a single-digit integer, multiply the result in place?Do it just like manual multiplication, right to left adding carry from the previous position. Traverse the list backwards multiplying, storing the result mod 10 in each node, and carrying the result divided by 10. If there's carry at the end insert it as a new head node. To traverse singly linked lists backwards you can use recursion for a low-thought implementation but O(n) space. For constant space reverse, multiply creating a new tail with carry, and reverse back. You can't carry more than 9: 9 * 9 = 81, plus 9 from the previous position = 90 thus carrying 9 so you need at most one extra node. static int multiply_node(struct node *node, int mult) { int remainder;  if (!node) { remainder = 0; } else { node->val = node->val * mult + multiply_node(node->next, mult); remainder = node->val / 10; node->val %= 10; }  return remainder; }  struct node * multiply_list(struct node *node, int mult) { int remainder; struct node *ret;  remainder = multiply_node(node, mult); if (!remainder) { ret = node; } else { ret = malloc(sizeof(*ret)); ret->val = remainder; ret->next = node; }  return ret; } 1.2k Views  View Upvotes