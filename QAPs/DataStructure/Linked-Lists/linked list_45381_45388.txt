page management in os kernel page frame management be conceptually very simple ; all you really need be a link list . however , there be two main factor which complicate thing : most operate system use surprisingly simple technique . window , for example , just use a bunch of link list -lrb- or at least it do , last time anyone say anything about it -rrb- . it s hard to say since we can t see the source code , but there be probably n \* m link list where n be the number of possible state a page can be in -lrb- e.g. in-use , free , wait to be page out -rrb- and m be the number of color . linux famously use a <a href="http://linux-mm.org/pageallocation"> buddy allocator </a> to manage physical page , which be only slightly more complicated than a bunch of link list when you think about it . probably the most sophisticated management scheme that have be document extensively be that of solari . see bonwick & adam , <a href="https://www.usenix.org/legacy/event/usenix01/bonwick.html"> <em> magazine and vmem : extend the slab allocator to many cpus and arbitrary resource </em> </a> , usenix 2001 . there be also a extended discussion in the book <em> solari internal </em> . the solari slab allocator go to a lot of trouble to avoid lock contention , cache thrashing , and the like , and also can tune its implementation for different datum type as need . what s interesting be that solari use the same memory allocator to handle page frame that it use to handle kernel object , by nesting slab allocator inside slab allocator . the paper be definitely worth a read . 