How do you invert singly linked list using linked stack?How to invert singly linked list using linked stack (stack with unknown length). No additional lists are allowed (list must be inverted in it's original form).Iterate through the list, and put elements in a stack as you go. Then take the elements out of the stack and change the next pointer as you do so. Usually the best way to figure this stuff out is to just draw it and do exactly what you would do on paper. Quick example in C: #include <stdio.h> #include <stdlib.h> struct LinkedListNode { struct LinkedListNode* next; int val; }; struct StackNode { struct StackNode* next; struct LinkedListNode* val; }; int main() { struct LinkedListNode* head = malloc(sizeof(struct LinkedListNode)); struct LinkedListNode* cur = head; // Initialize linked list with 5 elements for (int i = 0; i < 5; i++) { cur->val = i; cur->next = malloc(sizeof(struct LinkedListNode)); cur = cur->next; cur->next = NULL; } // Iterate through list and add each to a stack struct StackNode *stack = malloc(sizeof(struct StackNode)); stack->next = NULL; cur = head; while (cur->next) { stack->val = cur; struct StackNode *temp = stack; stack = malloc(sizeof(struct StackNode)); stack->val = NULL; stack->next = temp; cur = cur->next; } // Pop elements off of stack and change next pointer head = stack->next->val; while (stack->next) { if (stack->val) { stack->val->next = stack->next->val; } stack = stack->next; } stack->val->next = NULL; // Print out linked list to verify it was reversed cur = head; while (cur) { printf("val is: %d\n", cur->val); cur = cur->next; } } 316 Views  View Upvotes