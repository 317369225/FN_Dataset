question about amortised analysis i think the problem statement be clearer when you think of it as a counter that start at 0 and have a operation that increment the value by one . every time the counter from you problem be incremented , exactly one bit be flip on and zero or more bit be flip off $ ^ \* $ . the potential function from the example problem be not as out-of-the-blue as you might think . the key to the matter be that only a bit that have previously be turn on can be flip off . so every time we do a increment operation and turn on a bit , we will store one unit of time in to we `` savings account '' -lrb- the potential function -rrb- which we can use for turn that bit off later on . $ ^ \* $ this be because when increment the counter , you first look at the rightmost bit . if it be off , you turn it on . if it be on , you turn it of and look at the bit one position to the left . if it be off , turn it on and stop . if it be on , turn it off and look at the bit to the left of that bit . so the number of bit you flip in one operation be equal to the position of the first 0-bit from the right . initially , both the counter and potential function be 0 . after do one increment operation , the counter be 1 and the potential function be 1 as well . if we increment again , the counter become 10 . the potential function remain 1 . after another step , the counter be 11 and the potential function 2 . if we be to increment the counter again , we would need to flip 3 bit to go from 011 to 100 . for this we have to use some of the potential and we end up with a new potential of 1 . the trick be that the total number of bit actually flip so far plus the potential function be always equal to two time the number of increment operation . because the potential function be never negative , the total number of bitflip after $ n $ increment operation be at most $ 2n $ , so each operation take amortize $ 2 $ bitflips . another very good example be the array list . here we have a list -lrb- support iterate over all the element and add a new element -rrb- which be implement by store the element in a array . the array initially start out quite small -lrb- say 2 place -rrb- . when we add a element , it be store in the array . when we be about to add the 3rd element , there be no more space in the array . to counter this , we create a new array of double the size and copy over all the element from the original array . this can take a very long time -lrb- linear in the number of element -rrb- but amortized analysis show that each add operation take only constant time . the array list perform really well in the real world -lrb- much better than the link list -rrb- . each operation can be do in constant time , with the caveat that occasionally a operation will take much longer . so these kind of datum structure be not very fit for use in real-time system but if on occasion you can afford to wait they re very good . 