why , really , be the halt problem so important ? you can use the algorithm which detect whether a link list loop to implement the halting function with space complexity of o -lrb- 1 -rrb- . to do that , you need to store at least two copy of the partial state of the program in memory , plus the overhead of the check program . so on a give computer , you can not test all program that can execute on that computer , only the program that execute on a smaller computer with less than half as much memory . the halt problem for a give finite-size computer can not be solve on <em> that </em> finite-size computer . it can only be solve on a bigger computer . -lrb- this be true for any method , not just the one you propose . i m not go to give a formal proof , but here s the gist . if a computer c can run n different program of which at least one p doesn t terminate , then a computer v that can test whether these n program halt must be able to run n different verifier program too . if c and v be the same computer , then p isn t one of the n different program that v run , so the computer must run at least n +1 different program , which contradict the assumption that c run n different program . -rrb- in addition , you can t <em> just </em> use the algorithm to detect a loop in a link list . you need to know when to stop . you can stop once you ve execute as many step as there be state in the computer . if a program use up to $ m $ bit of memory , then it can have $ 2 ^ m $ different state . this very quickly become impossible . for example , a typical computer execute on the order of a billion instruction per second ; one billion seconds be a little over 30 year . so if you run a computer for 8 year , you can test whether one program with about 250 million billion potential state halt . but that s only $ 2 ^ -lcb- 56 -rcb- $ state , i.e. you can only test a program that work in 7 byte of memory . the number there illustrate that thinking of a computer as a finite-state machine be rarely practical . the number of state may be finite , but it s mind-bogglingly , impractically huge . the only way to reason about non-toy program be in the abstract , not by enumerate state but through logical reasoning . so exclude paradoxical program , the halt problem be decidable the paradox do not come from the problem , but from the attempt at a solution . for any give program , there be a algorithm that say yes if the program terminate , and no if the program doesn t terminate . it s trivial : either <code> print `` yes '' </code> or <code> print `` no '' </code> will do . the problem be to determine which one to call . the impossibility of solve the halt problem mean that there be no algorithm to make this determination . the reason the proof use a diagonalization argument be that it need to show that <em> no </em> solution work ; to do that , it start from a arbitrary purported solution , and show that it must miss some program by construct a miss program . the diagonalization -lrb- what you inappropriately call a paradox -rrb- be in the construction , not in the result program . the result program be not self-referential . there be a more general result call <a href="http://en.wikipedia.org/wiki/rice%27s_theorem"> rice s theorem </a> which state that <em> any non-trivial property </em> of program be undecidable any property that depend only on the behavior of the program and not in the specific way it s write -lrb- for example , do the source code consist of less than 42 character ? be clearly decidable , whereas be there a program whose source code consist of less than 42 character and that return the same result for all input ? be not , nor be do this program ever output anything ? -rrb- . halt be just one example . it s a important one because it often come up in practice -lrb- usually , we want to know whether a program will return a result in reasonable time give the finite resource of the computer it s run on , but since this be rarely practically answerable , we re willing to settle for the simpler question as to whether the program will eventually terminate give enough time and memory -rrb- . 