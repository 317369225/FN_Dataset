what be the difference between abstract datum type and object ? google bring up a similar <a href="https://www.reddit.com/r/compsci/comments/1wtedr/difference_between_adt_and_classes/" rel="nofollow"> question </a> with a <a href="https://www.reddit.com/r/compsci/comments/1wtedr/difference_between_adt_and_classes/cf5mqnc" rel="nofollow"> answer </a> that i think be very good . i ve quote it below . there s another distinction lurk here that be explain in the cook essay i link . object be not the only way to implement abstraction . not everything be a object . object implement something which some people call procedural datum abstraction . abstract datum type implement a different form of abstraction . a key difference appear when you consider binary methods\/functions . with procedural datum abstraction -lrb- object -rrb- , you might write something like this for a int set interface : now consider two implementation of intset , say one that s back by list and one that s back by a more efficient binary tree structure : notice that unionwith must take a intset argument . not the more specific type like listintset or bstintset . this mean that the bstintset implementation can not assume that its input be a bstintset and use that fact to give a efficient implementation . -lrb- it could use some run time type information to check it and use a more efficient algorithm if it be , but it still could be pass a listintset and have to fall back to a less efficient algorithm -rrb- . compare this to adt , where you may write something more like the follow in a signature or header file : we program against this interface . notably , the type be leave abstract . you don t get to know what it be . then we have a bst implementation then provide a concrete type and operation : now union actually know the concrete representation of both s1 and s2 , so it can exploit this for a efficient implementation . we can also write a list back implementation and choose to link with that instead . i ve write c -lrb- ish -rrb- syntax , but you should look at e.g. standard ml for abstract datum type do properly -lrb- where you can e.g. actually use more than one implementation of a adt in the same program roughly by qualify the type : bstimpl.intsetstruct and listimpl.intsetstruct , say -rrb- the converse of this be that procedural datum abstraction -lrb- object -rrb- allow you to easily introduce new implementation that work with you old one . e.g. you can write you own custom loggingintset implementation , and union it with a bstintset . but this be a trade-off : you lose informative type for binary method ! often you end up have to expose more functionality and implementation detail in you interface than you would with a adt implementation . now i feel like i m just retype the cook essay , so really , read it ! i would like to add a example to this . cook suggest that a example of a abstract datum type be a module in c. indeed , module in c involve information hiding , since there be public function that be export through a header file , and static -lrb- private -rrb- function that don t. additionally , often there be constructor -lrb- e.g. list_new -lrb- -rrb- -rrb- and observer -lrb- e.g. list_getlisthead -lrb- -rrb- -rrb- . a key point of what make , say , a list module call list_module_singly_linked a adt be that the function of the module -lrb- e.g. list_getlisthead -lrb- -rrb- -rrb- assume that the datum be input have be create by the constructor of list_module_singly_linked , as oppose to any `` equivalent '' implementation of a list -lrb- e.g list_module_dynamic_array -rrb- . this mean that the function of list_module_singly_linked can assume , in they implementation , a particular representation -lrb- e.g. a singly link list -rrb- . list_module_singly_linked can not inter-operate with list_module_dynamic_array because we can t feed datum create , say with the constructor of list_module_dynamic_array , to the observer of list_module_singly_linked because list_module_singly_linked assume a representation for a list -lrb- as oppose to a object , which only assume a behavior -rrb- . this be analogous to a way that two different group from abstract algebra can not interoperate -lrb- that be , you can t take the product of a element of one group with a element of another group -rrb- . this be because group assume the closure property of group -lrb- the product of element in a group must be in the group -rrb- . however , if we can prove that two different group be in fact subgroup of another group g , then we can use the product of g to add two element , one from each of the two group . <strong> compare the adt and object </strong> cook tie the difference between adt and object partially to the <a href="http://c2.com/cgi/wiki?expressionproblem" rel="nofollow"> expression problem </a> . roughly speak , adt be couple with generic function that be often implement in functional programming language , while object be couple with java `` object '' access through interface . for the purpose of this text , a generic function be a function that take in some argument arg and a type type -lrb- pre-condition -rrb- ; base on type it select the appropriate function , and evaluate it with arg -lrb- post-condition -rrb- . both generic function and object implement polymorphism , but with generic function , the programmer know which function will be execute by the generic function without look at the code of the generic function . with object on the other hand , the programmer do not know how the object will handle the argument , unless the programmer look at the code of the object . usually the expression problem be think of in term of `` do i have lot of representation ? '' vs. `` do i have lot of function with few representation '' . in the first case one should organize code by representation -lrb- as be most common , especially in java -rrb- . in the second case one should organize code by function -lrb- i.e. have a single generic function handle multiple representation -rrb- . if you organize you code by representation , then , if you want to add extra functionality , you be <em> force </em> to add the functionality to every representation of the object ; in this sense add functionality be not `` additive '' . if you organize you code by functionality , then , if you want to add a extra representation - you be <em> force </em> to add the representation to every object ; in this sense add representation in not `` additive '' . <strong> advantage of adt over object </strong> add functionality be additive possible to leverage knowledge of the representation of a adt for performance , or to prove that the adt will guarantee some postcondition give a precondition . this mean that programming with adt be about do the right thing in the right order -lrb- chain together pre-condition and post-condition towards a `` goal '' post condition -rrb- . <strong> advantage of object over adt </strong> add representation in additive object can inter-operate it s possible to specify pre\/post condition for a object , and chain these together as be the case with adt . in this case , the advantage of object be that -lrb- 1 -rrb- it s easy to change representation without change the interface and -lrb- 2 -rrb- object can inter-operate . however , this defeat the purpose of oop in the sense of smalltalk . -lrb- see section `` alan kay s version of oop -rrb- <strong> dynamic dispatch be key to oop </strong> it should be apparent now that dynamic dispatch -lrb- i.e. late binding -rrb- be essential for object orient programming . this be so that it s possible to define procedure in a generic way , that doesn t assume a particular representation . to be concrete - object orient programming be easy in python , because it s possible to program method of a object in a way that doesn t assume a particular representation . this be why python doesn t need interface like java . in java , class be adt . however , a class access through the interface it implement be a object . <strong> addendum : alan kay s version of oop </strong> alan kay explicitly refer to object as `` family of algebras '' , and cook suggest that a adt be a algebra . hence kay likely mean that a object be a family of adt . that be , a object be the collection of all class that satisfy a java interface . however , the picture of object paint by cook be far more restrictive than alan kay s vision . he want object to behave as computer in a network , or as biological cell . the idea be to apply the principle of least commitment to programming - so that it s easy to change low level layer of a adt once the high level layer have be build use they . with this picture in mind , java interface be too restrictive because they don t <em> allow a object to interpret the meaning of a message </em> , or even ignore it completely . in summary , the key idea of object , for kay - be <em> not </em> that they be a family of algebras -lrb- as be emphasize by cook -rrb- . rather , the key idea of kay be to apply a model that work in the large -lrb- computer in a network -rrb- to the small -lrb- object in a program -rrb- . edit : another clarification on kay s version of oop : the purpose of object be to move closer to a declarative ideal . we should tell the object what to do - not tell it <em> how </em> by micromanage be state , as be customary with procedural programming and adt . more info can be find <a href="http://c2.com/cgi/wiki?telldontask" rel="nofollow"> here </a> , <a href="http://www.ccs.neu.edu/research/demeter/related-work/pragmatic-programmer/jan_03_enbug.pdf" rel="nofollow"> here </a> , <a href="http://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html" rel="nofollow"> here </a> , and <a href="http://c2.com/cgi/wiki?accessorsareevil" rel="nofollow"> here </a> . edit : i find a very , very good exposition of alan kay s definition of oop <a href="https://www.quora.com/what-is-alan-kays-definition-of-object-oriented" rel="nofollow"> here </a> . 