How do you add numbers from two linked lists?Given two linked lists, each list node with one integer digit, add these two linked lists. Result should be stored in third linked list. Also note that the head node contains the most significant digit of the number.   Solution: Since the integer addition starts from the least significant digit, we first need to visit the last node of both the lists and add them up, create new node to store the result, take care of the carry if any and the link the result node to node which will be added to second least significant node and continue.   First of all, we need to take into account the difference in number of digits in two number. So before starting recursion, we need to do some calculation and move the longer list pointer to appropriate place so that we need the last node of both lists at same time. Other thing is we need to take care of is carry. If two digits add more than 10, we need to forward the carry to next node and add it to them. If most significant digit addition results in carry, we need to create an extra node to store carry.   Function below is actually a wrapper function which does all house keeping like calculating lengths of lists, calling recursive implementation, creating extra node for carry in most significant digit, and adding any remaining nodes left in longer list.   void addListNumbersWrapper(struct ListNode *list1, struct ListNode *list2, int *carry, struct ListNode **result){         int list1Length = 0, list2Length = 0, diff =0;         struct ListNode  *current  = list1;         while(current){                 current = current→next;                 list1Length++;         }         current = list2;          while(current){                 current = current→next;                 list2Length++;         }          if(list1Length < list2Length){                 current = list1;                 list1 = list2;                 list2 = current;         }         diff  = abs(list1Length-list2Length);         current = list1;           while(diff--)                 current = current→next;           addListNumbers(current, list2, carry, result);         diff  = abs(list1Length-list2Length);         addRemainingNumbers(list1, carry, result, diff);           if(*carry){                 struct ListNode  * temp = (struct ListNode  *)malloc(sizeof(struct ListNode ));                 temp→next =  (*result);                 *result = temp;           }         return; } void addListNumbers(struct ListNode  *list1, struct ListNode  *list2, int *carry, struct ListNode  **result){          int sum;         if(!list1)                 return;           addListNumbers(list1→next, list2→next, carry, result);           //End of both lists, add them         struct ListNode  * temp = (struct ListNode  *)malloc(sizeof(struct ListNode ));         sum = list1→data + list2→data + (*carry);                 // Store carry         *carry = sum/10;         sum = sum%10;           temp→data = sum;         temp→next =  (*result);          *result = temp;           return;  } void addRemainingNumbers(struct ListNode  * list1, int *carry, struct ListNode  **result, int diff){         int sum =0;          if(!list1 || diff == 0)                 return;           addRemainingNumbers(list1→next, carry, result, diff-1);           struct ListNode  * temp = (struct ListNode  *)malloc(sizeof(struct ListNode ));         sum = list1->data + (*carry);         *carry = sum/10;         sum = sum%10;           temp→data = sum;         temp→next =  (*result);         *result = temp;           return;  }   Time Complexity: O(                                                ). Space Complexity: O( ) for recursive stack.   Note:It can also be solved using stacks. 1.2k Views · View Upvotes