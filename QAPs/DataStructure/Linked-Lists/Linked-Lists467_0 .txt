What does node=node->next exactly do in a linked list?A few “pointers” for you, ha ha (I mean tips)… Just as a matter of C syntax, you need a semi-colon after your struct declaration… in this case, the semi should come right after “*node”… your example code omitted this. Also, declaring *node declares a pointer to a node, but you don’t yet have an actual instance of this struct; you will need to create at least one or two intances before you do anything. Before you use node=node->next to traverse the list, remember it is very important to initialize next to NULL (or nullptr in C++11); this indicates the end of the list. When you add a new node after the current one, then next will point to a non-null value. Also, before you traverse the list, you will need to test next. If it is NULL, then executing node=node->next would set node to NULL and then you better stop. So, with the syntax correction in (1) above, the proper declaration would be: struct list { int data; struct list *next; } *node; // NOTE USE OF SEMI-COLON! Note that with C++, you could have next initialized to NULL by default by writing a constructor, but I’m assuming C here. In C, you’ll have to do initialization yourself. Also remember to create an instance, or you’ll have nothing to work with. struct list a_node; // This creates an instance of the struct node = *a_node; // Point to it node->next = NULL; // Initialize the member called "next" Actually, it’s more common to use malloc to create an instance, in which case you will get back a pointer to the instance. struct list *node2; node2 = (struct list *) malloc(sizeof (struct list)); node2->next = NULL; By the way, this works much more smoothly in C++, with the aid of “new”. Finally, we can attach one node to another… node->next = node2; // Place *node2 after *node. Hope this helps. 289 Views