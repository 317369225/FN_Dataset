remove duplicate efficiently and with a low memory overhead why not bin and chain ? the idea be to store positive integer representable by $ n = k + m $ bit in a array $ a $ of $ 2 ^ k $ entry represent range of value : entry $ a -lsb- y -rsb- $ , $ y \ ge 0 $ , represent the range $ -lsb- 2 ^ m y , 2 ^ m -lrb- y +1 -rrb- -1 -rsb- $ . for any $ 1 \ le x \ lt 2 ^ n $ we may write $ x = 2 ^ m y + z $ where $ y $ have $ k $ bit and $ z $ have $ m $ bit . try to store $ z $ -lrb- not $ x $ ! -rrb- at location $ y $ : when $ a -lsb- y -rsb- = z $ already , do nothing : $ x $ be a duplicate . when $ a -lsb- y -rsb- $ be uninitialized , store $ z $ at $ a -lsb- y -rsb- $ . otherwise , store a index into a separate array use to chain the $ z $ s -lrb- which have collide at $ y $ -rrb- in link list . you will have to search linearly through the list head by $ a -lsb- y -rsb- $ and , depend on what the search uncover , potentially insert $ z $ into the list . at the end , $ f -lrb- s -rrb- $ be easy to recover by loop through the initialize entry of $ a $ and -- by merely concatenate two bitstring -- reassemble each $ z $ find at location $ y $ -lrb- either directly or within a chain reference there -rrb- into the original value $ x = 2 ^ m y + z $ . when the distribution be close to uniform and $ 2 ^ k $ exceed $ n $ , there will not be much chaining -lrb- this can be assess in the usual way -rrb- and the chain will tend to be short . when the distribution be nonuniform , the algorithm still work , but can reach quadratic timing . if that s a possibility , use something more efficient than chain -lrb- and pay a little overhead for storage -rrb- . the storage need be at most $ 2 ^ n $ bit for $ a $ and $ 2 ^ -lcb- 2k -rcb- $ bit for the chain -lrb- assume $ m \ le k $ -rrb- . this be exactly the space need to store $ 2 ^ k $ value of $ n $ bit each . if you re confident in the uniformity , you can underallocate the storage for the chain . if nonuniformity be a possibility , you may want to increase $ k $ and fully advocate the chain storage . a alternative way of think about this solution be that it <em> be </em> a hash table with a particularly nice hash function -lrb- take the $ k $ most significant bit -rrb- and , because of that , we only need to store the least significant $ m = n-k $ bit in the table . there be way to overlay storage for the chain with the storage for $ a $ but it doesn t seem worth the bother , because it wouldn t save much -lrb- assume $ m $ be much smaller than $ k $ -rrb- space and would make the code harder to develop , debug , and maintain . 