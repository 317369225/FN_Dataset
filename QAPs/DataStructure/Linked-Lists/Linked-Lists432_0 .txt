How can we recursively check if a singly linked list is a palindrome?I am not able to understand Method 3 of the following link : Function to check if a singly linked list is palindrome - GeeksforGeeksThe first method tells us to store the elements in the stack and pop-up elements from the stack one by one and check from the current element. Method 3 is actually the same, but it uses stack of the compiler. when a recursive function is called, it is stored in the compiler's own stack. This method exploit the same property. That is why most of the recursive functions are convertible to iterative functions using a stack. So, We will send two pointers, first and last. (initially head) and last will be updated to last.next in every recursive call and we won't update the first. eventually, in the topmost element of the stack (obviously compiler's), last will be pointing to the last element of the linkedlist and first will be pointing to the head of the linkedlist. At that point of time, we will compare the first and last, if they are not equal, then we will return false to every element of the compiler's stack below this element. But, if they are equal then we will advance first (which is a global variable and can be updated from anywhere) and function will return. When function will return to next element (bottom of that), first will be pointing to the next-of-head and last will be pointing to previous from tail and so on. A simple, self-explaining code in java would look like. // x is a global variable, whenever an element of stack (recursive call) will be false, //we will return false to every bottom most element. boolean x = true;  //first = head, last = head, initially boolean isPalindrome(node first, node last) { //whenever last will reach at the end of the linkedlist, we will return true. if(last == null) return true;  // in each recursive call, we won't modify first, but modify last. x = isPalindrome(first,last.next);  //remember, when an element of stack return false, we will return false to each bottom most element. if(!x) return false;  //if x is true, we will check the next entry. boolean y = false; if(first.data == last.data) { y = true; }  //advancing first before returning from the current element of the stack. first = first.next; return y; } Thanks A2A, Lehar Bhandari. 1.5k Views  View Upvotes  Answer requested by Lehar Bhandari