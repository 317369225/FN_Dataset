What is the most efficient way to randomize/shuffle a linked list?Can it be done in O(1) space and O(n) time? Or better than both O(n) space and O(n^2) time?The fastest O(1) space algorithm is O(n log n) time. However, with an O(n) space algorithm it's possible to bring this down to O(n) time, as suggested by Chiun Lin Lim. If the list payload is large, a slightly faster approach is to construct a pointer array for the list, shuffle it in place (e.g. using Fisher–Yates), and re-thread the list accordingly. Too see why O(n log n) is the best you can do with O(1) space, note that: With O(1) space, updating the successor of an arbitrary list element necessarily takes O(n) time. Without loss of generality, we can assume that whenever we update one element, we also update all the other elements (leaving them unchanged if we wish), as this also takes just O(n) time. With O(1) space, there are at most O(1) elements to choose from for the successor of any element we're updating. Which specific elements these are will obviously depend on the algorithm. Therefore, a single O(n) time update of all the elements could result in at most c^n different list permutations. Since there are n! = O(n^n) = O(c^(n log n)) possible list permutations, we require at least O(log n) updates. One simple O(n log n) shuffle algorithm is an adapted merge sort: shuffle the left half, then the right half, then merge them by randomly selecting from the two lists. To ensure all permutations are equally likely, elements should be selected according to the Gilbert–Shannon–Reeds model probabilities. While the recursive version of this takes O(log n) space due to stack usage, the iterative version is just O(1) space (thanks Mark Gordon for pointing this out). For an actual implementation, see my answer on stackoverflow.com. Another interesting but not-quite-uniform O(n log n) time shuffle algorithm involves removing the recursive calls from the merge algorithm above, which essentially turns it into an O(n) time riffle shuffle. O(log n) shuffles are then enough to generate a reasonably uniform distribution, with only a constant number of bits of information (see wiki link above for details; thanks Joe Wezorek for suggesting this). The simplest shuffle algorithm that's O(1) space involves calculating the length of the list and then repeatedly deleting a random element and adding it to the end of a new list. This is similar to what Fisher-Yates does for arrays, but ends up being O(n^2) time due to the lack of random access. 2.9k Views · View Upvotes