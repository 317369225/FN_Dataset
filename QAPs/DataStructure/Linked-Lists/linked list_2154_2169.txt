swap space management during pure demand paging to answer this question i will visit some prerequisite understanding . pure demand paging can not be accomplish without hardware support . all modern computer architecture support paging , however many have different implementation detail . x86 processor use what be call a page table to keep track of virtual address space and page mapping , as well as bit about access privilage and , more relevant , whether or not that page be even <em> present </em> in physical memory . violation trigger page fault which be trap by the os . for more information on that , see <a href="http://wiki.osdev.org/paging" rel="nofollow"> this article </a> . in order to answer the question of page swap , we must first visit the question of how the operating system keep track of what page be use by what process and how they be allocate . there be many different datum structure that can be use for such . a flat bit array mark whether a frame be allocate or not be one way . link list or stack be another . with pure demand paging , allocate page be not actually mark as present when they be allocate . this have the effect that no physical ram be set aside for a process until it actually write to it . once it do , the hardware throw a fault which the os trap , and then the os use a swap algorithm if there be no available physical page to assign to the already allocate virtual page . for more information on page frame allocation , see <a href="http://wiki.osdev.org/page_frame_allocation" rel="nofollow"> here </a> . there you will see a general overview of some suitable datastructure . once a suitable algorithm for page allocation be implement , another for allocate disk space for swap must be choose . window , as a example , have historically use a flat file in the filesystem for page swap . i would imagine that for each node in the datastructure keep track of allocate page there be a assocated pointer to a offset in the file , indicate the position of the page in the disk . unix-like operating system have traditionally use separate partition for page swap which be arguably faster since there be no filesystem layer . it be also possible to divorce the swap algorithm datastructure from those of the allocation algorithm , however the two be relate so this be probably not often do . i hope that answer you question despite the relative brevity with which i have treat it . i find that the best way to learn about operate system be to dive into the sometimes nasty architectural specific detail that can be find in site like wiki.osdev.org and www.osdever.net which specifically deal with hobby os make and provide excellent tutorial on such detail . 