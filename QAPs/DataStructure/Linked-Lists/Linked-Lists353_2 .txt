What will be the algorithm/code - deleting the last occurrence of the key which is repeating in linked list eg 6->4->1->6->1->6->6->1->2 will give 6->4->1->6->1->6->2?We need to delete only the keys which are repeated more than once. Like we do not remove 2 as its occurrence is only one time in list.I have written the code in Java. It traverse list two times but the complexity is O(n). First traversal is to store the index values which are needed to be removed. In second traversal, the elements are removed using Iterator. // This creates a list of 20 numbers with random numbers from 1 to 10 List<Integer> list = new LinkedList<>(); for (int i=0; i < 20; i++){ int item = (int)(Math.random() * 10)+1; list.add(new Integer(item)); }  ListIterator<Integer> listIterator;  // Original List // Used ListIterator to traverse list. Complexity = O(n) listIterator = list.listIterator(); while (listIterator.hasNext()) { System.out.print(listIterator.next() + " -> "); } System.out.println();   // Map will store the list item as Key and its index as Value. // If a Key is twice in list, it will store boolean value True together with Index  Map<Integer,Map<Integer, Boolean>> indexMap = new HashMap<>(); listIterator = list.listIterator(); int i=0;  // Complexity O(n) while (listIterator.hasNext()) { int key = listIterator.next(); Map<Integer, Boolean> tempMap = new HashMap<>(); if (indexMap.containsKey(key)) { tempMap.put(i, true); } else tempMap.put(i, false); indexMap.put(key, tempMap); i++; }  // Remove the items using Map listIterator = list.listIterator(); i=0; while (listIterator.hasNext()) { int key = listIterator.next(); if (indexMap.get(key).containsKey(i) && indexMap.get(key).get(i)) { // Complexity of removal using Iterator O(1) listIterator.remove(); } i++; }  // Modified List listIterator = list.listIterator(); while (listIterator.hasNext()) { System.out.print(listIterator.next() + " -> "); } 93 Views  View Upvotes