problem with store a exist triangulation in a dcel the point of a half-edge datum structure be that each half-edge be incident to exactly one face , and each face be represent by a list of half-edge give in order around the face . this be different from a normal planar map in which edge be incident to two face . this can make certain code task easier to deal with . so a -lrb- undirected -rrb- edge $ \ -lcb- u , v \ -rcb- $ get split into two half-edge $ uv $ and $ vu $ which be direct and twin of each other . to list all half-edge -lrb- in order -rrb- incident to a face just require follow next pointer from each edge . something like : in a dcel the code above will walk around all edge in ccw order incident to the face startedge . here be a concrete example : suppose we want to represent a triangulation with a single triangle $ abc $ where $ a $ , $ b $ , and $ c $ be give in ccw order . we create six half edge : $ ab $ , $ bc $ , $ can $ , $ ba $ , $ cb $ , and $ ac $ . set the twin : $ ab.twin $ = $ ba $ , $ ba.twin = ab $ . $ ac.twin = can $ , $ ca.twin = ac $ , $ bc.twin = cb $ $ cb.twin = bc $ . set the next pointer : $ ab.next = bc $ , $ bc.next = can $ , $ ca.next = ab $ $ ac.next = cb $ $ cb.next = ba $ , $ ba.next = ac $ . and prev pointer $ ab.prev = can $ , $ bc.prev = ab $ , $ ca.prev = bc $ , $ ba.prev = cb $ $ ac.prev = ba $ $ cb.prev = ac $ . now we already have implicitly face : if we start with $ ab $ and chase the next pointer around until we get back to $ ab $ , we get $ ab $ , $ bc $ , $ can $ which represent the interior of the triangle . if we start with $ ba $ we get a different list : $ ba $ , $ ac $ , $ cb $ . this list represent the so-called `` unbounded '' face which be the exterior of we triangle . these be the `` cycle '' you mention . the first cycle be the -lrb- cyclic -rrb- list $ ab \ leftrightarrow bc \ leftrightarrow can $ and the second be $ ba \ leftrightarrow ac \ leftrightarrow cb $ . for some application this be all you need , but for other you may want a structure for store extra information about the face . keep in mind that the face be already represent by the double link list $ ab \ leftrightarrow bc \ leftrightarrow can $ . however we can make two datum structure $ f_0 $ and $ f_1 $ for store extra information for the unbounded face $ f_0 $ and the interior of the triangle $ f_1 $ . we then set pointer again : $ ab.face = f_1 $ , $ bc.face = f_1 $ , $ ca.face = f_1 $ , $ ba.face = f_0 $ , $ cb.face = f_0 $ , $ ac.face = f_0 $ . so now each half-edge point to the face incident to it . but we may also want to start with a face structure and then get a list of its incident half-edge . we already have the half-edge store as list , so we just need to point to any arbitrary start of the list , something like : $ f_0 . halfedgelist = ba $ $ f_1 . halfedgelist = ab $ so now give a face $ f $ , we can loop over all its incident half-edge as before : finally , assume you already have correctly set the previous , next , and twin pointer for you half-edge , then you could do something like this : when you create a half-edge , initialize its face pointer to 0 . then add all half-edge to a queue . note i m write pseudo-code , not c + + code here : update : i look at the link you provide and want to give a bit of terminology . above i use the term source and target to refer to the the start and end vertex of the half-edge . in the c + + code you link to source be call tail , and target be the tail of the twin . so if you have a half edge call halfedge : 