How do I reverse elements of a linked list in groups of 'n' at a time, where n is less than equal to size of the linked list?Thanks for the A2A. Okay, so I wrote something pretty plain, it's basically C. Let me walk you through it, step by step. Here's our pretty basic linked list struct. It's got some stuff in it, though. We have a convenient node insertion function, and another node insertion function which inserts a number of nodes. You said you didn't want STL (and by the way, it's not STL, it's C++ Standard Library - STL is an old and totally different thing) so I had to resort to a variadic function, instead of say, initializer list, or some other pretty container. Anyway, you get a free lesson in variadic functions. Moving on. We have a convenient printing function, which is nice. typedef struct list_t { list_t(int value) : Value(value), Next(nullptr) { } list_t* insert(int value) { assert(this->Next == nullptr); list_t* pnew = new list_t(value); this->Next = pnew; return pnew; } list_t* insertMulti(int count, ...) { va_list args; va_start(args, count); list_t* tail = this; for (int i = 0; i < count; i++) { int value = va_arg(args, int); tail = tail->insert(value); } return tail; } void print() { list_t* cursor = this; while (cursor != nullptr) { if (cursor != this) std::cout << ", "; std::cout << cursor->Value; cursor = cursor->Next; } std::cout << std::endl; } int Value; list_t* Next; } list; Okay, so on to the list reversal part. I think we should think about this in steps, because the algorithm actually scales quite nicely when you work your way up, from the problem of reversing an entire list, to reversing just a portion of the list, and then piecing it together in order to get the thing that you were asked. So, how do you reverse an entire list, given just its head? Well, I don't know how you guys do it, but I maintain a few cursors, point to the current and the previous element and move them along, until I hit a wall, which is in this case a tail node, or a node pointing to null. Don't get confused, nullptr is just a C++ 11 fancy way of saying NULL. I guess this code is pretty self-explanatory, so I won't go in depth about commenting it. static void reverse(list*& head) { if (head->Next == nullptr) return; list* previous = nullptr;... (more)