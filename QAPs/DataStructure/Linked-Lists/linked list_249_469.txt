-lrb- when -rrb- be hash table lookup o -lrb- 1 -rrb- ? <em> this answer summarise part of <a href="https://en.wikipedia.org/wiki/the_art_of_computer_programming"> taocp </a> vol 3 , ch 6.4 . </em> assume we have a set of value $ v $ , $ n $ of which we want to store in a array $ a $ of size $ m $ . we employ a hash function $ h : v \ to -lsb- 0 . . m -rrb- $ ; typically , $ m \ ll v $ . we call $ \ alpha = \ frac -lcb- n -rcb- -lcb- m -rcb- $ the <em> load factor </em> of $ a $ . here , we will assume the natural $ m = m $ ; in practical scenario , we have $ m \ ll m $ , though , and have to map down to $ m $ ourselves . the first observation be that even if $ h $ have uniform characteristic the probability of two value have the same hash value be high ; this be essentially a instance of the infamous <a href="https://en.wikipedia.org/wiki/birthday_paradox"> birthday paradox </a> . therefore , we will usually have to deal with conflict and can abandon hope of $ \ mathcal -lcb- o -rcb- -lrb- 1 -rrb- $ worst case access time . what about the average case , though ? let we assume that every key from $ -lsb- 0 . . m -rrb- $ occur with the same probability . the average number of check entry $ c_n ^ s $ -lrb- successful search -rrb- resp . $ c_n ^ u $ -lrb- unsuccessful search -rrb- depend on the conflict resolution method use . every array entry contain -lrb- a pointer to the head of -rrb- a link list . this be a good idea because the expect list length be small -lrb- $ \ frac -lcb- n -rcb- -lcb- m -rcb- $ -rrb- even though the probability for have collision be high . in the end , we get \ -lsb- c_n ^ s \ approx 1 + \ frac -lcb- \ alpha -rcb- -lcb- 2 -rcb- \ quad \ text -lcb- and -rcb- \ quad c_n ^ u \ approx 1 + \ frac -lcb- \ alpha ^ 2 -rcb- -lcb- 2 -rcb- . \ -rsb- this can be improve slightly by store the list -lrb- partly or completely -rrb- inside the table . when insert -lrb- resp . search a value -rrb- $ v $ , check position \ -lsb- h -lrb- v -rrb- , h -lrb- v -rrb- -1 , \ dots,0,m-1 , \ dot , h -lrb- v -rrb- +1 \ -rsb- in this order until a empty position -lrb- resp . $ v $ -rrb- be find . the advantage be that we work locally and without secondary datum structure ; however , the number of average access diverge for $ \ alpha \ to 1 $ : \ -lsb- c_n ^ s \ approx \ frac -lcb- 1 -rcb- -lcb- 2 -rcb- \ leave -lrb- 1 + \ frac -lcb- 1 -rcb- -lcb- 1 - \ alpha -rcb- \ right -rrb- \ quad \ text -lcb- and -rcb- \ quad c_n ^ u \ approx \ frac -lcb- 1 -rcb- -lcb- 2 -rcb- \ leave -lrb- 1 + \ left -lrb- \ frac -lcb- 1 -rcb- -lcb- 1 - \ alpha -rcb- \ right -rrb- ^ 2 \ right -rrb- . \ -rsb- for $ \ alpha < 0.75 $ , however , performance be comparable to chain . similar to linear probe but search step size be control by a second hash function that be coprime to $ m $ . no formal derivation be give , but empirical observation suggest \ -lsb- c_n ^ s \ approx \ frac -lcb- 1 -rcb- -lcb- \ alpha -rcb- \ ln \ left -lrb- \ frac -lcb- 1 -rcb- -lcb- 1 - \ alpha -rcb- \ right -rrb- \ quad \ text -lcb- and -rcb- \ quad c_n ^ u \ approx \ frac -lcb- 1 -rcb- -lcb- 1 - \ alpha -rcb- . \ -rsb- this method have be adapt by brent ; he variant amortise increase insertion cost with cheaper search . note that remove element from and extend table have vary degree of difficulty for the respective method . bottom-line , you have to choose a implementation that adapt well to you typical use case . expected access time in $ \ mathcal -lcb- o -rcb- -lrb- 1 -rrb- $ be possible if not always guarantee . depend on the use method , keep $ \ alpha $ low be essential ; you have to trade off -lrb- expect -rrb- access time versus space overhead . a good choice for $ h $ be also central , obviously . 1 -rsb- as arbitrarily <strike> dumb </strike> uninformed programmer may provide $ h $ , any assumption regard its quality be a stretch in practice . <br> 2 -rsb- note how this coincide with <a href="http://docs.oracle.com/javase/6/docs/api/java/util/hashtable.html"> recommendation for usage of java s <code> hashtable </code> </a> . 