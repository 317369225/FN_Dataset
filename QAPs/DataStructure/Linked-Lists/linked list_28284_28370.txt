how do the os know the physical address of a process first memory page ? the operating system perform a lot of work before execute the first instruction . the os must set up at least two datum structure , the page table and the <a href="http://stackoverflow.com/a/1401595/2209313"> <em> region map </em> </a> . the region map be call different thing in different operating system . inside the linux kernel , for example , it be a link list of memory-region object and some kind of index -lrb- e.g. a red-black tree -rrb- that give you a efficient way of discover the region a specific virtual address belong to . each memory region have a start address , a length , permission -lrb- can the program read\/write\/execute from the region -rrb- , and some information about the `` type '' of the region , include how the region be suppose to be initialize on first use and how the logical information be suppose to be save if a map page need to be move to disk . the first step be that the operating system create a new page table with every virtual page mark as `` invalid . '' next the os read the header of the executable file . the header describe the region map and also give the virtual address of the first instruction to be execute . so the os create a in-memory region map to match the structure describe in the executable header and then try to execute the first instruction -lrb- it do this by use some kind of `` return from interrupt '' instruction that set the root of the page table to the page table for the process we want and then change the program-counter -lrb- instruction-pointer -rrb- to the virtual address of the first instruction . so the processor try to execute the instruction at the give virtual address . but every page in the page-table be marked invalid , so when the processor perform the translation from virtual to physical address the processor will invoke a `` invalid page '' fault , bring control back to the operating system . the operating system will look up the virtual address in the region map . since this be suppose to be the address of the first instruction , then it should be the case that the virtual address be contain in a region that be mark as be executable , and there should be information about where the instruction be located in the original executable file . the os read a page-worth of date from the original executable file into some physical page in memory , and then modify the page table to reflect the new virtual-to-physical mapping . finally the os again try to return-from-interrupt to the instruction address . this time , although there will be tlb miss and cache miss , the translation will give a mapping from virtual to physical address , the processor will eventually try to fetch the require instruction into the l1 cache and execute it . in all likelihood the instruction will try to access some not-yet valid datum location . there will be another `` invalid page '' fault for the datum s virtual address . the os will look up the datum s virtual address in the region map , allocate a physical page , initialize the page , map the page in the page table and then return-from-interrupt a third time . this time the instruction will get fetch and execute , and after another tlb and cache miss for the datum access will actually execute without cause another fault . then we move to the next instruction and start all over again . hopefully we have some spatial and\/or temporal locality so this process doesn t happen with every instruction . 