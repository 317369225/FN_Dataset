Given an array of size n, how do you find all the possible subsets of the array of size k?Would appreciate if you could explain your code/solution a bit and also mention its time complexity.EDIT : Thanks to Nick Wu comments. Firstly remove the duplicates from the array by sorting it or your favourite duplicate removal method. Let the size of filtered array be the new 'n'. Now the given problem is the same as finding all the k-digit numbers on the base n (or with radix n) but not having any of the digits repeated. This can be done by generating all the numbers from to on radix n and excluding the numbers with replicated digits which can be done in For e.g n = 10 & k being 3, we want all the numbers from 100 to 999 without a digit repeated i.e. 123,124,125,126,..985,986,987. The problem as said by Nick Wu is it results in redundant permutation like 123,132,213,231,312 & 321 which give the same set. One way to eliminate them & to speed up the iteration will be that whenever you find two digits in the generated number to be same say the and digit from right (i.e. from unit place) with , then increment the digit by 1 and set the digits from the to the first digit with the sequence . This way we are guaranteed to generate a new valid number after every k iteration. Thus resluting in runtime of (n for manipulating all the digits on finding a number with repeated digit, can be reduced to O(1) by using a memset operation from already calculated & stored bit sequences for such operations or using a custom number representation as done in approach 2). You can implement it in two ways: Approach 1 (Easy but is limited to being less than  max int value for the your language also incurs an extra log(n)  factor for base conversion ) Starting from i = convert the number to radix n by modulo division if the converted number number has a digit repeated say  and digit from right (i.e. from unit place) with , then increment the digit by 1 and set the digits from the to the first digit with the sequence . else store its digits in 2D array of size *k for holding index of elements of all the subsets. do the above two steps for i+1 till you get all the permutation i.e. si becomes The code below will be a better illustration (to be update for step up on finding a repeated digit)  1 2 3 4 5 6 7 8 9101112131415161718192021222324252627282930 int subsets[nCk][K]; // array to hold the indexes of the subsets  bool valid_i,dup_hit[N]; // dup_hit is a hit-array to check if the evaluated number has a duplicate digit  int i,j,si,sk,rem,N_min,N_max,n,k;  N_min = ipow(N,K); // n raised to power k  N_max = ipow(N,K+1); // n raised to power k+1  si = 0;  for(i = N_min; i < N_max; i++)  {  memset(dup_hit,0,sizeof(bool)*N); // reset hit-array  j = i;  sk =0;   while(j > 0 )  {  rem = j%N;  if(dup_hit[rem])  {  valid_i = false; // not a valid subset  break;  }  dup_hit[rem] = true; // set occurrence of this digit to be true.  subsets[si][sk] = rem;  j = j/N;  ++sk; //increment the digit place   }  if(valid_i) ++si; // if the last number was valid then increment si  }  return 0; Approach 2 will be to design your own implementation of n-radix number with n being an input using a linked list of n-bit vectors and performing simple arithmetic of incrementing by 1 on it. Using this data structure you will be solve for any value of n & k. I guess you can speed up the iterations by incrementing the value of the number in higher place of the two place which share the same number then setting the lower digit place say jth from right with j-1 and those right to with j-2,j-3,j-4..,0 