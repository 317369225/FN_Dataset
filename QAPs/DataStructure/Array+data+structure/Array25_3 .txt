Yes, it is possible and a very useful feature. See the following:  1 2 3 4 5 6 7 8 910111213141516171819202122232425262728293031323334353637 class Car {  private String color;  public Car(String c) { //constructor  color=c;  }  public void setColor(String newColor) { //a function taking an argument and returning nothing  color=newColor;  }  public String getColor() { //a function not taking any argument, but returning a String  return color;  }  public void honk() { //a function neither taking any argument, nor returning anything  System.out.println("Beep Beep!!!");  } } class MainClass {  public static void main(String args[]) {  Car myCars[]=new Car[5]; //array to store 5 Car objects  int i;  for(i=0;i<3;i++) //instantiating the first three cars using a loop  myCars[i]=new Car("Red");  //instantiating the other two cars separately  myCars[3]=new Car("Black");  myCars[4]=new Car("White");   System.out.println(myCars[2].getColor()); //getting and printing the color of the Car at index 2  myCars[2].setColor("Gray"); //changing its color to "gray". Note that I am sending an argument here  System.out.println(myCars[2].getColor()); //now the new color will be printed   for(i=0;i<5;i++) {  //calling the functions for each of the object  System.out.print("My "+myCars[i].getColor()+" honks: ");  myCars[i].honk();  }  } } Not only this, you can also store the objects in a more general type of array. An array for objects of a class X can store objects of a class Y if class Y extends class X. As in Java, all the classes extends the class Object by default, the following code is a good example.  1 2 3 4 5 6 7 8 910111213141516171819202122232425 class A {  public int x;  public A() {  x=1;  } } class B {  public int x;  public B() {  x=5;  } } class MainClass {  public static void main(String args[]) {  Object arr[]=new Object[3];  arr[0]=new A();  arr[1]=new B();  arr[2]=new A();  // arr[0].x=10; //doesn't work  ((A)arr[0]).x=10; //works fine. Note the typecast  //((B)arr[0]).x=11; //Compiles fine but doesn't work on runnning. arr[0] has an Object of type A and not B  System.out.println(((A)arr[0]).x);  System.out.println(((B)arr[1]).x);  } } 