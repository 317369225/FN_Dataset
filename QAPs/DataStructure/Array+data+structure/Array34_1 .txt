Why does Java prohibit generic array creation?Arrays in Java remember their component type at runtime. That means to create an array, you need to know the component type at the time you are creating it. Here, T, a type parameter, is an unknown type. Can there be a more detailed explanation than the above?It appears you are quoting my answer to the question Why cant we initialize array of generic object? So I will elaborate. Each object in Java has a "class" which can be retrieved at runtime, using the .getClass() method. When you use .getClass() on an array object, you get the "array class" representing that type of array. Arrays of different component types correspond to different array classes. So .getClass() called on an int array will return a different thing than .getClass() called on a String array. From any array object, we can query its (array) class at runtime, and then from that, get the component type of the array. That is what I meant that the array remembers its component type at runtime. How does an object know its class? That's because it was provided explicitly when the object was created. The same applies for array objects. When you create an array, you must specify the type of array, including an explicit component type. However, Generic types in code are a compile-time illusion. When you have a type variable like T, code that uses that type cannot know what type T is; and in fact, the point is that the code must work with any type in the place of T. That is why the class or method is said to be "generic". That is what I meant when I said T represents a type that is unknown at runtime, and thus you cannot create an array of T since you cannot provide the component type needed to create the array. Note that this contrasts with Generic containers. For example, new ArrayList<T>() is perfectly legal. You might ask, why is it possible to create a List of T, but not possible to create an array of T? Generic types in Java work very differently from array types. A new ArrayList<Integer>() object and new ArrayList<String>() object have the same "class" at runtime. That is, the type parameter is an illusion and it is not possible to tell at runtime whether a list is a list of String or list of Integer. Therefore, such containers do not know their component type at runtime; and correspondingly it is not necessary to know the component type at runtime to create such a container object. 