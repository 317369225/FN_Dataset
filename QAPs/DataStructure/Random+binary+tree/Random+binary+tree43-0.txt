How can we generate a random number with equal probability in the range [1...n] s.t., it doesn't belong to the invalid set of numbers  S ={xi | 1<= xi <=n and i [math] \in [/math] [1...k] and k<n}  using O(k) memory; provided we can call random function only once?
There is a solution that only needs [math]O(\log k)[/math] time to generate a random number. Obviously, it only makes sense to use it if you are going to generate a lot of random numbers. If you want to do it just once, it's better to use the simpler solution by Raziman T.V. -- you need [math]\Omega(k)[/math] time for any initialization anyway. As in the solution by Raziman T.V., the random number we shall generate in our algorithm will be a uniformly distributed random value between 1 and [math]n-k[/math], inclusive. And also the returned value will be the same: the [math](n-k)[/math]-th smallest valid number. We will just compute it in a more efficient way. We will use the [math]O(k)[/math] memory to store the [math]k[/math] forbidden numbers in sorted order. The key is to realize that: the [math]k[/math] forbidden values divide the valid ones into [math]k+1[/math] contiguous segments (some of them possibly empty), we can use binary search to find the right segment, and within the right segment we can then find the right value in constant time. Example: suppose that the 7-th smallest forbidden value is 47. This means that among {1,...,47} there are 40 valid and 7 forbidden values. If the internal random value is 40 or less, we want to output a number smaller than 47, and if it is greater than 40, the output will be greater than 47. Additional bonus: Instead of a sorted array, store the forbidden values in a balanced binary tree. Then you can also add new forbidden values quickly. One of possible uses: generate [math]k[/math] distinct random values from {1,...,n} in [math]O(k\log k)[/math] time. 