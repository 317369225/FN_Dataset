Can someone help me write a problem for printing a binary tree in vertical order in Java?
Your code has two issues, and fortunately, they are minor :) You use an in-order traversal instead of pre-order traversal.  The GeeksForGeeks page says to use an in-order traversal, but an in-order traversal won't give you the same output that they have listed.  A pre-order traversal, on the other hand, will give you the correct output. You iterate over the hash table keys, which as Richard Morris points out, is not an operation that guarantees order.  You could take his suggestion to use a TreeMap, but that will make your code run asymptotically slower.  Instead, you can iterate over the possible keys in order as opposed to iterating over the actual keys.  Since there are [math]\Theta(n)[/math] possible keys, this won't negatively affect the asymptotic run-time complexity.I have fixed your code and documented the fixes with inline comments: import java.util.*;public class BinaryTreeInVerticalOrder {    public static void main(String[] args) {        TreeNode[] nodes = new TreeNode[] {            null,            new TreeNode(1),            new TreeNode(2),            new TreeNode(3),            new TreeNode(4),            new TreeNode(5),            new TreeNode(6),            new TreeNode(7),            new TreeNode(8),            new TreeNode(9)        };        nodes[1].left = nodes[2];        nodes[1].right = nodes[3];        nodes[2].left = nodes[4];        nodes[2].right = nodes[5];        nodes[3].left = nodes[6];        nodes[3].right = nodes[7];        nodes[6].right = nodes[8];        nodes[7].right = nodes[9];        TreeNode root = nodes[1];        printVertically(root);    }    private static void printVertically(TreeNode root) {        Hashtable<Integer, List<TreeNode>> ht = new Hashtable<Integer, List<TreeNode>>();        int level = 0;        traverse(root, ht, level);        // Iterate over all possible keys instead of all actual keys.        // Note, there are still O(n) possible keys.        int min = 0;        int max = 0;        for (Integer i : ht.keySet()) {            min = Math.min(min, i);            max = Math.max(max, i);        }        for (int i = min; i <= max; i++) {            if (ht.containsKey(i)) {                printList(ht.get(i));            }        }    }    private static void printList(List<TreeNode> list) {        for (TreeNode node : list) {            System.out.print(node.val + " ");        }        System.out.println();    }    private static void traverse(TreeNode root, Hashtable<Integer, List<TreeNode>> ht, int level) {        if (root != null) {            // Use a pre-order traversal instead of in-order traversal.            addNode(root, ht, level);            traverse(root.left, ht, level-1);            traverse(root.right, ht, level+1);        }    }    private static void addNode(TreeNode root, Hashtable<Integer, List<TreeNode>> ht, int level) {        if (ht.containsKey(level)) {            ht.get(level).add(root);        } else {            LinkedList<TreeNode> newList = new LinkedList<TreeNode>();            newList.add(root);            ht.put(level, newList);        }    }    private static class TreeNode {        int val;        TreeNode left;        TreeNode right;        public TreeNode(int val) {            this.val = val;        }    }} However, I'd like to propose an alternate solution that is a similar to the GeeksForGeeks solution but algorithmically more efficient. The main difference is that instead of using a hash table, I use an array.  The size of the array is still [math]\Theta(n)[/math] in size, so the run-time is strictly [math]\Theta(n)[/math] instead of [math]\Theta(n)[/math] expected time. Suppose we do a traversal over the binary tree, and we record how many steps left or right a node is from the root.  For example, suppose the root is 0 steps from itself.  Then we subtract 1 when we step to the left child, and we add 1 when we step to the right child.  If we traverse the tree in this manner, we can determine the horizontal position relative to the root for every node in the tree in [math]\Theta(n)[/math] time (so far, this is the same as the GeeksForGeeks solution). Once we have the horizontal positions of every node, we can group the nodes into lists classified by their horizontal positions. Then, we just iterate over all of the lists and output the nodes for each horizontal position from left to right. Now, in terms of actually coding this, we start by making an array of lists (technically, Java doesn't like arrays of lists, so I use a list of lists in my code below).  Each index in the array represents a horizontal position, 0 being the leftmost horizontal position, 1 being the second leftmost horizontal position, etc.  Since we don't know how far left and right the nodes reach in the tree until we traverse the tree, let's just assume the worst.  In the worst case, every node is the left child of its parent or every node is the right child of its parent.  Thus, let's create an array of size [math]2n - 1[/math] to account for either possibility.  The actual horizontal span of the tree will be no more than [math]n[/math] nodes wide, but since [math]2n - 1[/math] is still [math]\Theta(n)[/math], it doesn't hurt the asymptotic efficiency to have an array of size [math]2n - 1[/math]. We need to have the root be the middle value in the array, so start with the root at index [math]n - 1[/math]. Next, we traverse the tree.  I used a pre-order traversal so that nodes higher in the tree show up in the output for a vertical column before nodes lower in the tree show up in the output for a vertical column (so that it outputs 1 5 6 instead of 5 1 6 in the example).  This is actually what the GeeksForGeeks solution uses, but they incorrect call it in in-order traversal, which it is not. As we traverse the tree, we have an index that represents that node's horizontal position.  We find the list at that index in the array, and we add that node to the end of that list.  For the example problem, after traversing the nodes, we'd have: Horizontal Position 0 => [] Horizontal Position 1 => [] Horizontal Position 2 => [] Horizontal Position 3 => [] Horizontal Position 4 => [] Horizontal Position 5 => [] Horizontal Position 6 => [4] Horizontal Position 7 => [2] Horizontal Position 8 => [1, 5, 6] Horizontal Position 9 => [3, 8] Horizontal Position 10 => [7] Horizontal Position 11 => [9] Horizontal Position 12 => [] Horizontal Position 13 => [] Horizontal Position 14 => [] Horizontal Position 15 => [] Horizontal Position 16 => [] (Note that the tree has [math]n=9[/math] nodes, so the root, 1, is at index [math]n-1 = 8[/math].) Once we've built our array of lists, we can just iterate over every list in the array and output it.  Since the size of the array is [math]\Theta(n)[/math], and the total length of all lists is [math]\Theta(n)[/math], this part also runs in [math]\Theta(n)[/math] time. I wrote some code in Java to solve the problem as I have described above.  I wrote it before looking at your code or the GeeksForGeeks answer, so I apologize if it doesn't map one-to-one to your code.  It's also not the cleanest code, but whatever :) import java.util.*;public class BinaryTreeInVerticalOrder {    public static void main(String[] args) {        BinaryNode[] nodes = new BinaryNode[] {            null,            new BinaryNode(1),            new BinaryNode(2),            new BinaryNode(3),            new BinaryNode(4),            new BinaryNode(5),            new BinaryNode(6),            new BinaryNode(7),            new BinaryNode(8),            new BinaryNode(9)        };        nodes[1].setLeftChild(nodes[2]);        nodes[1].setRightChild(nodes[3]);        nodes[2].setLeftChild(nodes[4]);        nodes[2].setRightChild(nodes[5]);        nodes[3].setLeftChild(nodes[6]);        nodes[3].setRightChild(nodes[7]);        nodes[6].setRightChild(nodes[8]);        nodes[7].setRightChild(nodes[9]);        BinaryNode root = nodes[1];        printBinaryTreeInVerticalOrder(root, nodes.length - 1);    }    public static void printBinaryTreeInVerticalOrder(BinaryNode root, int numNodes) {        int numHorizontalPositions = numNodes * 2 - 1;        List<List<BinaryNode>> nodesInVerticalOrder = new ArrayList<List<BinaryNode>>(numHorizontalPositions);        for (int i = 0; i < numHorizontalPositions; i++) {            nodesInVerticalOrder.add(i, new ArrayList<BinaryNode>());        }        getNodesInVerticalOrder(root, nodesInVerticalOrder, numNodes - 1);        for (int i = 0; i < numHorizontalPositions; i++) {            List<BinaryNode> nodesForHorizontalPosition = nodesInVerticalOrder.get(i);            if (nodesForHorizontalPosition.size() > 0) {                int index = 0;                for (BinaryNode node : nodesForHorizontalPosition) {                    if (index != 0) {                        System.out.print(" ");                    }                    System.out.print(node.getKey());                    index++;                }                System.out.println();            }        }    }    private static void getNodesInVerticalOrder(BinaryNode current, List<List<BinaryNode>> nodesInVerticalOrder, int positionIndex) {        if (current == null) {            return;        }        nodesInVerticalOrder.get(positionIndex).add(current);        getNodesInVerticalOrder(current.getLeftChild(), nodesInVerticalOrder, positionIndex - 1);        getNodesInVerticalOrder(current.getRightChild(), nodesInVerticalOrder, positionIndex + 1);    }    private static class BinaryNode {        private int key;        private BinaryNode left;        private BinaryNode right;        public BinaryNode(int key) {            this.key = key;        }        public void setLeftChild(BinaryNode node) {            this.left = node;        }        public BinaryNode getLeftChild() {            return this.left;        }        public void setRightChild(BinaryNode node) {            this.right = node;        }        public BinaryNode getRightChild() {            return this.right;        }        public int getKey() {            return this.key;        }    }} Updated 24w ago • View Upvotes • Asked to answer by Anonymous