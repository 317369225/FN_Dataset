How do I uniformly sample a node from a binary tree?
If the nodes of the tree store the size of their left (or right, or current) subtree, and you know the total size of the tree, you can uniformly sample a node in time proportional to the depth of the tree. Node sample(Tree tree) {  // We will return the rth element (0-indexed) of the pre-order.  int r = random.nextInt(tree.size());  Node root = tree.root();  // When r is 0 we will return our current root.  while (r != 0) {    // Check whether r corresponds to a node in our left subtree    // or our right subtree.    if (r <= root.leftSize()) {      r--; // subtract off size of root.      root = root.left();    } else {      r -= root.leftSize() + 1; // subtract off size of root + left subtree.      root = root.right();    }  }  return root;} If you only know the size, you can uniformly sample a node in linear time. Node sample(Tree tree) {  // We will return the rth element (0-indexed) of the inorder traversal.  int r = random.nextInt(tree.size());  int count = 0;  for (Node node : tree) {    if (count++ == r) {      return node;    }  }  // unreachable  return null;} If we don't even know the size, one simple option is to just count the size then use the previous function. However, it can still be done without calculating the size if you're willing to generate more random numbers. Node sample(Tree tree) {  int count = 0;  Node curr = null;  for (Node node : tree) {    if (random.nextInt(++count) == 0) {      curr = node;    }  }  // Probability we are returning the ith element (1-indexed) is  // 1/i * i/(i+1) * (i+1)/(i+2) * ... * (n-1)/n = 1/n  return curr;} 