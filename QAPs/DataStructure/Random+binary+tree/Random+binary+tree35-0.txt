What data structure should I use to complete this task?
Linked lists are terrible and should not be used except in very special cases. You take a large performance penalty because the nodes are not generally stored consecutively in memory, which destroys your cache performance. In theory, insertion and deletion are fast, but in practice you usually have to search for the location where insertion or deletion will occur, and such a search takes linear time! So unless you have some special situation (e.g. you can know the insertion/deletion location without looking for it), linked lists are a really bad option. You know what else has linear insertion and deletion time? Vectors. However, unlike a linked list, they have superb cache performance, which means in practice their insertions and deletions are usually faster! Plus, you can access them randomly. They are easy to sort, and when they're sorted, you can use binary search to find elements. Most of the time, code written with a linked list would perform better and be easier to write if you used a vector instead. Once the dataset is large enough for linear insertion and deletion to kill the performance, you need to move to a balanced binary tree. They are hard to write, and properly implementing one can take a week or more, especially if you haven't done it before. They have great performance characteristics, though not as good as a vector for searches or traversals (due to both complexity and cache performance). If you want fast lookups using multiple criteria, you should consider keeping the "data" in one place and an "index" in a different data structure. Each element in the index refers to an entry in the main data structure (with a pointer, reference, iterator, or index, depending on how you store the main data; if it's a C++ vector, indices are the only safe method). You can then sort each index a different way; for example, one of them could be sorted by its host data's name, another could be sorted by age, another by address, etc. This let's you get log-n lookup times for multiple types of search. Note that using an index also means that your core data storage doesn't need to be sorted at all, which makes our easier to store your main data in a vector. You may have to be creative to allow fast deletions from this vector; consider swapping the item to delete with the final entry and then popping the back; if keeping the position the same is important (to preserve index validity), consider adding a list of "deleted" items that are available for reuse, and allow the vector to have "holes" in it. On the subject of vector versus binary tree, it's fairly obvious the the vector will win on tiny amounts of data (because it's so simple and the cache performance so good), but the tree will win if you have large amounts of data. My experience with C++ is that the break-even point is about 5 kilobytes; more than that, and you should use a tree. Less, and the vector will typically be faster. If the number of students in the index will be around 1300 or fewer, and if you need 4 bytes in each index entry to refer back to the main data record, then keeping the index as a vector will outperform a binary tree. If you have significantly more students than that, you will likely need to switch to a tree for maximum performance. 