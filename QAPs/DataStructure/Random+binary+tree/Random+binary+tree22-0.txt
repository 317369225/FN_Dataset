What is the logic for cracking the '2048 puzzle'?
2048 is fairly straight forward once you realize what's actually happening. Basically the game spawns 2s or later in the game 4s randomly* What you need to do is merge tiles to finally form 2048. This is basically really a binary tree that looks like this: (pardon my poor handwritting) What you need to do is move up this tree. Since we can't move from the lower levels to the upper levels all together, you must move or "traverse" the tree upwards about two nodes (or tiles in our case) at a time. Since we can only move up the tree by joining adjacent and same numbered tiles, we basically "merge" two nodes at a time. Now on a 4x4 board, which gives us 16 blocks we can't first populate the board with all the nodes/tiles we need then parallel-ly merge all nodes together. Mostly because we don't have have nearly enough space on the board. The binary tree will tell you that in the entire process you need to merge at least 2^10 2s, which is 1024 tiles of 2. We don't have that kind of space, all we have are 16 blocks. So we do what we can, we compromise, we merge what we can and keep it aside, thus creating free space in the process that lets us get or "spawn" more 2s (or 4s). Running out of free space is also the reason you loose the game incidentally, this all makes sense intuitively of course, and most of you already know this. But now that I've outlined the underpinnings of the game, I'll outline the strategy and how to avoid the pitfalls. This is the strategy I use and it has worked for me marvellously so far, both with standard 2048, and most variants** (Adversarial 2048 is an exception) The basic winning move sequence you will need is*** (pardon me for the mess on the paper, this is from when I was doing rough analysis for personal use) This sequence can be (and ideally needs to be) wrapped into the 4x4 grid like so: Notice that once you have this sequence, you can simply execute merges and win. (Moves to 2048 will be R-R-D-L-L-L-D-R-R-R) Now that we know that this is the winning sequence, I always try to keep my tiles as close to this sequence as possible. This basically means, always keeping your biggest tile in the corner, the next biggest tile right next to it in the same row^ and so on. illustration: If you try keeping your tiles in this format you will realize that you often get the chance to "group-merge" a lot of tiles at various stages. This is basically what we need to do, we need to always form this sequence of largest tile in the corner, with next smallest one adjacent to it and so on. When we do this repeatedly (And in some sense recursively) we get series that we can merge after a while, which give us larger tiles, eventually reaching 2048 This is all fine in theory, but it takes a little practice to actually get this right, there are a lot of pitfalls you'll fall into when trying to achieve this, I'll list out some of the dos and don'ts with the caveats, and how to overcome them. You need to keep your largest tiles in the corner, this means essentially restricting our moves or roughly our degrees of freedom (hereby called dof) If I treat every direction as a dof, then we have 4 of them, to the best of my knowledge exercising all of them is the biggest mistake you can possibly make. You will have to restrict yourself to 2 or 3 dofs. Let me elaborate. When the game starts, you need to begin accumulating your tiles in the bottom row with the biggest tile in the corner, so initially you will use a combination of only down and right, the order ofcourse depends on how the tiles spawn. Caveat: Ideally the scenario I am about to describe can be (and should be avoided) by thinking a few moves ahead and looking at the repercussions of merging*^ in the current move vs. hoarding*^ in the current move. Sometimes tiles will spawn such that you cannot move right or down. In such a case, please cross your fingers and move left, but never move up. Typically in such a case, especially early on in the game, the chances of spawning a new tile in the corner where you were accumulating your large tile is small, but if this does happen, it is the worst case scenario, and the later in the game this happens the harder it is to recover from it. See the how to recover a blocked corner tile below. Avoid creating and expanding*^ tiles away from your accumulation corner This is one of the reasons a lot of people get stuck while playing and are unable to finish. They'll have a bunch of fairly large tiles randomly scattered across the board (typical culprits range from 32 to 128). This results in is more and more un-mergeable tiles spawning on the board, filling up the limited amount of free space you have on your board. Ideally if you follow the original generate sequence strategy and align the tiles correctly, you shouldn't run into this problem, but no one's perfect and there's always the randomness to account for, so fret not, this is a recoverable block, but the ease of recovery decreases exponentially the larger the un-mergabale blocking tiles are. There are a couple of ways you can recover from this and you can you should be to use a few of these together for greater effect: Merge the "un-mergable"  to the closest other "un-mergeable" tile it can merge with in number. Merge the "un-mergable" tile one of the tiles in the accumulation region (i.e the bottom row in our case) Both of these can be done by removing all the tiles between them, this is done by merging or increasing the size of these tiles to force merging. For example if you have the following (simplified example): 16|2|4|16 You can try the following: 16|4|4|16 (adding a 2 to the existing 2) then 16|8|4|16 then 16|8|8|16 then 16|16|16|x then 32|16|x|x this frees up space on the board, and you can now try to merge 16 with 32, again since there is now scope for creating the merge sequence. Avoid blocking your accumulation region with a discordant tile. An example of this is having 32|2|128|256 in your bottom row. This type of a break in the sequence can be lethal with larger numbers in your bottom row, the larger the difference or discordance among the tiles, the harder the recovery. The corner blocking mentioned in point 1. is a special case of this sequence discordance. It typically manifests itself like so: 128|256|512|2 The only way to win a game once discordance happens (especially in your accumulation corner, like illustrated above) is to fix the discordance as soon as you become aware of it. This means dropping everything else and focusing all your effort to make the discordant tile large enough to merge with one of the adjacent tiles, for example in our first example this would mean: Converting 32|2|128|256 into 32|32|128|256 so that we can merge the 32 and 32 and recover our sequence. The attentive reader will see why the corner block case is harder to recover, because you need to raise the blocked tile to the same number as your largest tile on the board currently, with fewer number of free blocks than previously available. Recovering from a blocked corner tile in my opinion relies on instinct and intuition and thus comes with practice more than anything else. * I work under the assumption that they are random, I haven't looked through the code to confirm ** See pictures and names in the end *** or some equivalent version, you can have 256|256|512|1024 in your row, the pictured sequence will reduce to this eventually after a bunch of left merges. ^I choose to play the bottom right corner, and play row major rather than column major because it feels natural to me, you can choose any corner you wish, but adapt the moves accordingly) *^ Terminology: Merging: The process of joining two adjacent tiles to create a new higher number tile. Group-Merge: The process of merging multiple adjacent tiles in sequence such that merging one set of tiles allows you to cascade merges. For example: 2|2|4|8 will give x|x|x|16 after a series of R-R-R moves. Expanding a tile: The process of merging a tile with another to increase the number of tile. ----------------------------------------------------------------------------------- All the analysis here is based on rough understanding, and some experience playing the game, none of it is formalized and frankly I lack the right mathematical background for deeper analysis, if someone has done it, I'd love to look at it. I'm sure there are Math Majors who can do this better than I have. In the mean time please feel free to point out flaws or improvements. :) ------------------------------------------------------------------------------------ Images of finished 2048, just to assure you guys that I'm not entirely talking out of my ass. Normal 2048: The one and only original. 2048 3D: Same strategy with modifications for 3D, this is actually easier because of the greater number of free  blocks (27 vs 16), so it's actually more forgiving. 16384 Hex: Same strategy, but requires copious amounts of patience and Zen-Monk level concentration. I was very close before lapses in judgement happened. Maybe someday when I feel brave enough I'll try this again. Updated 65w ago • View Upvotes • Asked to answer by Tushant Jha