How can we generate a random number with equal probability in the range [1...n] s.t., it doesn't belong to the invalid set of numbers  S ={xi | 1<= xi <=n and i [math] \in [/math] [1...k] and k<n}  using O(k) memory; provided we can call random function only once?
Assuming that you have a function rand(i) which generates a random number in [1…i] with uniform probability, here is a solution which has O(K) time and space complexity. Store the invalid set of numbers in a sorted array S[1…K]. We  need to choose one integer uniformly among the remaining N-K integers.  For this, generate a random integer x in the range [1…N-K] using  rand(N-K). Now if we can find the xth unchosen number in [1…N], we can solve the problem. We can use the array S to find this number. If the first element of S is larger than x, x is the xth unchosen number. Otherwise increment x  by 1 and look at the second position in S. Keep continuing this till the next  position in S contains a number greater than x (or we have reached the  end of the array). Since we have incremented x by the number of  positions we have jumped over, we have found the xth unchosen number as  intended. x=rand(N-K)for pos=1 to K:  if x<ar[pos]:    break  x=x+1end forreturn x Since there are N-K unchosen numbers and each of them are picked with equal probability, each valid number is picked uniformly randomly. Obviously, this method uses only O(K) memory. The time complexity is O(K) as well. PS: This answer is essentially copied from another of my answers. 