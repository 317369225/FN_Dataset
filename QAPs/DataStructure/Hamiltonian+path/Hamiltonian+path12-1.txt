Logic Puzzles: Is there a solution for the 100 Boxes game?http://www.googlemodules.com/mod... '100 Boxes' is a puzzle game. Your goal is to fill all the boxes in the 10x10 table. Rules are very simple: you can start from any box, but then if you move in horizontal or vertical direction, you have to leave two boxes blank; if you move in diagonal direction, you have to leave one box blank.
Yes. There are many solutions to this problem. I have written a simple C program which solves this problem. We have a board of 10*10. Each of the 100 cells of this broad can be uniquely identified with (row, column) Following is the strategy: Make the first move. In the program it has been made in the cell (0, 0). You can modify the program to make the first move anywhere. Identify the next move based on previous move. If the previous move was made in (prevRow, prevColumn) then identify all the possible valid next moves using prevRow and prevColumn. There are maximum 8 possible moves that can be made from one cell. Out of these 8, a few may be invalid because they may fall outside the board. Also, if a cell is already occupied then a move can't be made in that cell. Make the next move and call the procedure recursively. If we get to a situation where any move can't be made then return 0 and we backtrack. The calling frame will then try other moves one by one. I have put more emphasis on the algorithm and readability and not on the design. I have used globals. If you don't like globals then feel free to modify the program. The approach used in this solution can also be used to solve Knight's tour. In that case 'N' will be 8 and gMove will need to be defined accordingly. //Tested on Visual C and gcc-4.9.2 compilers. #include<stdio.h>   #define N 10 //The board is 10*10 #define TARGET (N*N) //Final number to be placed is 100 #define EMPTY -1 //Each cell of board is initilly EMPTY   //Global board which has NxN (i.e. 100) cells. int gBoard[N][N];   //These moves represent 8 directions. For example the first one (index 0) represents East. //The 8 directions are: E, SE, S, SW, W, NW, N, NE const int gMove[][2] = { { 3, 0 }, { 2, 2 }, { 0, 3 }, { -2, 2 }, { -3, 0 }, { -2, -2 }, { 0, -3 }, { 2, -2 } }; const int NUM_MOVES = sizeof(gMove)/sizeof(gMove[0]);   void InitBoard(); //Initialize all the cells of the board to empty. void PrintBoard(); //Print the global board int CanMakeMoveInCell(int row, int col); //Can we make the next move in gBoard[row][col]?   //The main component of the solution. //It takes the row and colum of the cell in which previous move was made. //BoardSolver prefers to move in the last direction (prevDirection) if that is available. int BoardSolver(int prevRow, int prevColumn, int prevDirection);   int main() { InitBoard();   int initialRow = 0, initialCol = 0; //The first move will be made in [0][0].   gBoard[initialRow][initialCol] = 1; //Make the first move.   if (BoardSolver(initialRow, initialCol, 0)) PrintBoard(); else printf("Couldn't find a solution\n");   return 0; }   int BoardSolver(int prevRow, int prevColumn, int prevDirection) { int foundSolution = 0; int prevNumber = gBoard[prevRow][prevColumn]; if (prevNumber == TARGET) { foundSolution = 1; } else { int i; for (i = 0; !foundSolution && i < NUM_MOVES; ++i) { //Try to find the solution in all 8 directions. Start with the last used direction. int currentDirection = (i + prevDirection) % NUM_MOVES;   int currentRow = prevRow + gMove[currentDirection][0]; int currentColumn = prevColumn + gMove[currentDirection][1];   if (CanMakeMoveInCell(currentRow, currentColumn)) { //Make the next move in cell (currentRow, currentColumn) gBoard[currentRow][currentColumn] = prevNumber + 1;   foundSolution = BoardSolver(currentRow, currentColumn, currentDirection);   if (!foundSolution) //Undo the move as this didn't work. gBoard[currentRow][currentColumn] = EMPTY; } } } return foundSolution; }   //Can we make the next move in the cell gBoard[row][col]? int CanMakeMoveInCell(int row, int col) { //If row and colum fall inside the board and the cell gBoard[row][col] is unoccupied. if (row >= 0 && row < N && col >= 0 && col < N && gBoard[row][col] == EMPTY) return 1; else return 0; }   void InitBoard() { int i, j; for (i = 0; i < N; ++i) for (j = 0; j < N; ++j) gBoard[i][j] = EMPTY; }   void PrintBoard() { int i, j; for (i = 0; i < N; ++i) { for (j = 0; j < N; ++j) printf("%3d ", gBoard[i][j]); printf("\n\n"); } } 