Given a graph, how to compute all of the possible topological sort outcomes?
Nikhil 's caveat  was definitive until lately [1994] ,as the number of linear extensions can grow  exponentially in the size of the graph. Even the problem of counting the  number of linear extensions is NP-hard. I ll first add details of the earlier method and update the caveat. How it works (it does) : Algorithms for listing all linear extensions in a DAG     are based on backtracking. They build all possible orderings from left to right, where each of the in-degree zero vertices are candidates for the next vertex. The outgoing edges from the selected vertex are deleted before moving on. Constructing truly random linear extensions is a hard problem, but pseudorandom orders can be constructed from left to right by selecting randomly among the in-degree zero vertices.  When the set of constraints is not a DAG, Since the basic topological sorting algorithm will get stuck as soon as it identifies a vertex on a directed cycle, we can delete the offending edge or vertex and continue. This quick and dirty heuristic will eventually leave a DAG Updated caveat: All the linear extensions of a poset can be generated in constant amortized time O(e(P))[=|E(P)|, where each  extension differs from its predecessor by one or two adjacent  transpositions(transposition graphs[1]). The algorithm is practical and can be modified to  efficiently count linear extensions, and to compute P(x < y)(probability that x≺y  ), for all pairs x,y , in time O( n^2 + e ( P )). GenLE: Linear extensions are generated twice ,by adjacent transposition in the poset (P) , which is equivalent to finding the Hamiltonian path of the graph G(P) [1].These extensions are tagged flagged with +/- signs and these signs are changed  in correspondence to the transpositions of the element with it's neighbor in right/left in all possible was Through L.,while maintaining the order. Each time L(P_i) is generated by calling GenLE(i), GenLE(i-1)is called till i=1. Main procedure in the algorithm is recursive and follows the Hamiltonian path of the graph G(P). For proofs and implementation see : Generating Linear Extensions Fast [1] Transposition graphs are bipartite and connected , if the partite sets of G(P) are not the smae size or differ by  more than one , then there is no Hamiltonian path through the graph and linear extensions can not be generated. 