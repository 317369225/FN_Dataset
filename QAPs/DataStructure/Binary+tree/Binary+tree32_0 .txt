What's the best way to print an in-order traversal of a binary tree without using recursion?Given parent node pointers you can do it with constant additional storage and no tree mutations. The starting node is the leftmost in the tree (no left child when you follow left pointers). The next node is 1. If a right child exists it's the left most descendant of that child 2. Otherwise it's the closest ancestor to the right implying this node was the next's left child with the traversal terminating when clause 2 reaches a NULL parent. To use use the referenced test case main  1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 #include <assert,h> #include <stdio.h> #include <stdlib.h> struct node {  int value;  struct node *parent;  struct node *left;  struct node *right; }; static const struct node * leftmost_descendant(const struct node *node) {  const struct node *current;  for (current = node; current && current->left; current = current->left) {  }  return current; } static const struct node * right_ancestor(const struct node *node) {  const struct node *child;  const struct node *current;  for (child = node, current = node ? node->parent : NULL;  current && child == current->right;  child = current, current = current->parent) {  }  assert(!current || child == current->left);  return current; } static void traverse(const struct node *root) {  const struct node *current;  for (current = leftmost_descendant(root); current;  current = current->right ?  leftmost_descendant(current->right) : right_ancestor(current)) {  printf ("%d\n", current->value);  } } static struct node * create_node(struct node *parent, int value) {  struct node *ret;  ret = calloc(1, sizeof(*ret));  ret->value = value;  ret->parent = parent;  return ret; } /* Driver program to test above functions*/ int main() {  /* Constructed binary tree is  1  / \  2 3  / \  4 5  */  struct node *root = create_node(NULL, 1);  root->left = create_node(root, 2);  root->right = create_node(root, 3);  root->left->left = create_node(root->left, 4);  root->left->right = create_node(root->left, 5);   traverse(root);   return 0; } 