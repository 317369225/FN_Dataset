Programming Interview Questions: Binary Trees: How to connect the siblings of a binary tree?Assuming the Queue is the only disallowed data structure, I'll help myself to a dictionary. You could do a recursive depth-aware DFS of the tree in which you populate a dictionary mapping depth to the most recently touched node at that depth. Here's some python code to illustrate this example:  1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 #!/usr/bin/env python from collections import defaultdict class Node:  def __init__(self, data, left=None, right=None, sibling=None):  self.data = data  self.left = left  self.right = right  self.sibling = None  def __repr__(self):  return "Node(data=%s)" % self.data def make_tree(sorted_list):  """  Input: a sorted python list  Output: a binary search tree whose data consists of the sorted_list  """  if len(sorted_list) == 0:  return None  elif len(sorted_list) == 1:  return Node(sorted_list[0])  else:  # get the mid_point and mid_element, that's our root  mid_point = len(sorted_list)/2  node = Node(sorted_list[mid_point])  # the left subtree is everything to the left of the midpoint  node.left = make_tree(sorted_list[:mid_point])  # the right subtree is everything to the right of the midpoint  node.right = make_tree(sorted_list[mid_point+1:])  return node def dfs(root, table=dict(), depth=0, debug_table=defaultdict(list)):  if root is not None: 		  # process all the nodes in the left subtree  dfs(root.left, table, depth+1)	  # check if we've started keeping track of  # nodes at the current depth.  # if we have an entry, then we connect the  # previous node to the current node  if depth in table:  table[depth].sibling = root 		   # whether or not the above check is successful  # assign the most recently touched node at this  # depth to be the current node  table[depth] = root  debug_table[depth].append(root)  # now we process the right subtree  dfs(root.right, table, depth+1)  # the debug_table is just to see a python list of what  # the siblings list looks like  return table, debug_table if __name__ == '__main__':  root = make_tree(range(10))  table, debug_table = dfs(root)  print table  print debug_table 