Here is the key idea about recursive: think how you can solve the problem if you already have got a function which can solve the same type of problem expect that one. For example, you try to calculate the number of nodes of a tree. 1. Let's begin with that I already have a function f, which take a paramerter T, and f(T) = number of nodes in T. 2. Now suppose we got a tree, let's call it A. So now we need to find a way to calculate what f(A) is without using f(A). 3. Give yourself a min, and the answer should be quiet clear. We could got f(A) by summing f(Right_subtree(A)), f(Left_subtree(A)) and 1 (for the root node of A). If f works for all the other trees, the f will works on A. And there is the recursive definition of f. 4. Then we need to deal with board condition, i.e. what is the simplest situation of f. which is still easy. If we run into a leaf node( node without children), then clearly f(T)=1. Now we can define f: f(T) = f(Right_subtree(T)) + f(Left_subtree(T)) + 1 f(T) = 1 [ if T is a leaf node ] And everything is done! If you wonder why such faking could work. Notice that Right_subtree(A) and Left_subtree(A) both is a strickly smaller tree than A, so we will anyway run into our board condition. In gerneral, as long as we can ensure at last it can run into a non-recursive situation (i.e. the board condition), then such faking will be okay. 