How to count inversions using Segment Tree of a given array?
We need a segment tree which allows us to make queries of the form "How many numbers are in the range [i..N]?". More generally, we can ask for queries of the form "How many numbers are in the range [i..j]?". The matching update operation has to be of the form "Insert i into the list of current numbers". So let us try to look for the simplest segment tree which can do the job. This would be one where each node stores the number of elements in the range corresponding to the node. In particular, the leaf nodes will have values 1 or 0 depending on whether the number exists or not. Every non-leaf node stores the sum of its children. In general, if a node's leaves span the range [i..j], its value will be the number of non-zero elements in range [i..j]. We can initialise the segment tree as such: //2^M is the smallest power of 2 which is >=Nint segtree[1<<(M+1)];  //Initialise to 0. segtree[1] is the root.//base is the location in the array corresponding to the first leaf nodeconst int base=1<<M; Inserting i (0-based) into the list would require us to increment the value of segtree from the leaf corresponding to i all the way to the root: void update(int i){  //Leaf corresponding to i is i+base  //parent of node is node>>1  for(int node=i+base;node>0;node>>=1)    segtree[node]++;} Update operation can be done recursively. We pass the required range(l..r) as well as the current range corresponding to the node (L..R): int query(int node,int l,int r,int L,int R){  //If the required range is same as current range, just return the value  if((l==L)&&(r==R))return segtree[node];  //We need to recurse. Find the endpoint of the left child  int M=(L+R)>>1;  //Check whether you need to recurse only into one of the subtrees or both  //node<<1 is the left child, (node<<1)|1 is the right child  if(r<=M)return query(node<<1,l,r,L,M); //Range entirely in left child  else if(l>M)return query((node<<1)|1,l,r,M+1,R); //Entirely in right child  else return query(node<<1,l,M,L,M)+query((node<<1)|1,M+1,r,M+1,R);} The query function for range [l..r] needs to be called as query(1,l,r,0,base-1). This is the general template for segment trees with point updates and interval queries where the sum of values at the nodes is the desired query. The template can be used for counting inversions by following the procedure: scan the array elements from left to right. For each element, query(ar[i],N) gives the number of inversions with ar[i] as the right element of the inversion. Once this is added to the count, update(ar[i]) to add that number into the list. PS: For more about segment trees, check this blog post by Utkarsh. I solve segment tree problems a lot, so what might be "obvious" to me might not be for everyone else. So if something in my answer is unclear, comment and I will try to explain. 