Given a deck of n cards and m shuffling moves, can a skip list or splay tree be used to determine the final state of the deck in O(m log n) time?
I'll try to make the answer simple, by trying to answer the problem step-by-step. I am assuming you know the basics of skip lists and splay trees. There are multiple methods to solve this problem: Skip lists: A skip list is a data structure for storing a sorted list of items using a hierarchy of linked lists that connect increasingly sparse subsequences of the items. These auxiliary lists allow item lookup with efficiently comparable to balanced binary search trees (that is, with number of probes proportional to log n instead of n). In simple terms, the purpose of a skip list is to efficiently search for an element  in a sorted list [expected time: O(log n) per search.] For our problem, we don't need any ordering among the elements, but we need to be able to return the 'i'th element of the list efficiently. This can be done by using an indexed skip list as pointed out by Ashish Gaurav. Now, by shuffling the cards we mean re-arranging the skip list. Let us try to solve this problem first: Given a skip list, can i break it at a point 'i' and get the left and right envelope pointers for this break. This will help you visualize it better: In the above example, assume we want to make a cut after 3 elements. Then the nodes marked in red correspond to the left envelope of the cut and those in blue correspond to the right envelope of the cut. Specifically for our problem, we need to have doubly linked lists (both next and previous for nodes at a level eg. next(1.4) -> 2.4 and prev(2.4) -> 1.4). Also, assume we have doubly linked lists in the vertical direction to move freely between nodes. eg. 1.3 -> 1.4 and 1.4 -> 1.3. Another assumption is that we have stored it as an indexed skip list (length of every link is also stored along with it). If we can find the left and right envelopes as above, then our problem is solved. If we want to remove all nodes between indices 'i' and 'j' and place them between positions 'k' and 'k+1', get the left and right envelopes for cutting before 'i', after 'j' and after 'k'. Let us call these sets Li, Ri, Lj, Rj, Lk, Rk. Each of these sets have O(log n) elements (as this is the envelope and the skip list has O(log n) levels). Now, it is just a matter of rearranging the pointers between elements of these sets. i.e the following links are added: Lk <--> Ri, Lj <--> Rk and Li <--> Rj (add links in both directions). Since we can do each of these in O(log n) time, each shuffling step can be solved in O(log n) provided: left and right envelope can be found in O(log n). Now, finding the left and right envelope for a cut is fairly simple. Assume you are cutting vertically between node 'i-1' and node 'i'. Start with the leftmost node of the topmost level (H.1). Keep traversing nodes on the same level (to the right) as long as you don't cross the ith node. You might reach a point where the left node is at position < 'i' and the right node is at position > 'i'. In such a case, simply add the left node to the left envelope and right node to the right envelope and move to the next level (move to the node below the node which now has position < 'i'). Keep repeating the same until you reach a level where the right node has position = 'i'. Now starting from this node, keep going down to the lowest level in the same column (property of skip list -> for a position, if level 'm' is filled, all levels > 'm' are also filled). For all these, simply add prev(node) to the left envelope and the node itself to the right envelope (eg. prev(3.5) = 2.5). This solves the problem in O(log n) expected time. While re-arranging the links, their lengths also have to be adjusted. But that is fairly simple once you understand this method. Splay trees: Splay trees are one of the most beautiful data structures. A splay tree is a self-adjusting binary search tree with the additional property that recently accessed elements are quick to access again. It performs basic operations such as insertion, look-up and removal in O(log n) amortized time. The main property we are going to exploit for our problem is that, a recently accessed element can be accessed quickly again. In a splay tree, we perform a series of splay operations which are essentially rotations of the tree. A splay operation can be one of zig, zig-zig or zig-zag. The zig step: The zig-zig step: The zig-zag step: Note: Splaying a node 'x' essentially means performing a series of zig, zig-zig (or) zig-zag operations, to bring 'x' to the root of the tree. These are the 3 types of rotations that we will use to solve our problem. We will  essentially be using a series of splays, cuts and joins on the tree. Let us assume we have cards in the following order: [1 2 3 4 5 6 7 8 9]. We want to remove the cards [5, 6, 7] and put it before 1. i.e we want the state of the cards to be [5 6 7 1 2 3 4 8 9]. As we discussed in skip lists, here too we'll try to solve the problem of cutting at a position and show that we can solve the entire problem with this. To perform a cut after node 'i', we first splay the node 'i' (bring it to the root). Now all nodes before 'i' lie in the left subtree of node 'i' and all nodes after 'i' fall in the right subtree. Hence, we can cut the link from node 'i' to it's right subtree, and get 2 trees. The following diagram will illustrate these steps (and the further join steps too very clearly). [ The inorder traversal of the binary search tree after every stage, gives the right ordering of cards. Also, to be able to get the ith node in the inorder traversal of the tree, for each node we need to store the no. of nodes in the left and right subtrees of the node]. In the last diagram, it is easy to see that the inorder traversal of the tree gives the shuffled order of cards after the first shuffle. Both splay trees and skip lists have an expected time of O(log n) per query. In this case, since we a have a randomized binary search tree, the expected height is O(log n), and so in every splay operation we perform O(log n) expected number of steps to bring a node to the root, giving is O(log n) time per query. Thus, in practice both skip lists and splay trees perform fairly well. A couple of very good problems based on the above concepts: http://www.codechef.com/JAN12/pr... http://www.codechef.com/AUG10/pr... There are other methods to solve this problem in O(log n) per query expected time. It can be done using Treaps, Link-cut trees, hybrid segment tree. Actually, the hybrid segment tree is a slightly different method which i tried in a contest and it worked fine for me. (donno what it's called exactly, maybe it has a name, maybe it does'nt). It uses a little extra memory than the above methods though. For 'm' queries, skip lists use O(n log n) memory, splay trees use O(n) memory, and the method i was talking about (hybrid segment tree) uses O(m + n log n) memory. I had implemented the solution for the problem CARDSHUF (mentioned above) using segment trees, which you can find here: http://www.codechef.com/JAN12/st... If required, i can give an explanation for the segment tree method too, but I think the code is fairly simply to understand. References: http://en.wikipedia.org/wiki/Ski... http://en.wikipedia.org/wiki/Spl... http://en.wikipedia.org/wiki/Treap http://en.wikipedia.org/wiki/Lin... 