Given an in-order traversal of a special binary tree having property that the node is always greater than its left and right child. How can we reconstruct the tree efficiently?
The tree structure the question talks about is called a binary heap.  The interesting thing about this question is that there is actually a bijection between binary heaps with labeled nodes 1 through N and permutations of N elements.  To map from binary heaps to permutations just take the in-order traversal of the tree.  The reverse map can be done efficiently with the algorithm I'm going to describe below. As your algorithm runs you should keep a stack of binary trees.  As the algorithm progresses you'll form new binary-heaps and merge existing binary-heaps so that you will end up with one heap at the end.  We'll cheat a little bit in this algorithm an assume all values are unique. Begin by inserting the first node into a heap by itself.  We will consider the parent node of the top heap to be the 'active' node.  The 'active' node will also always be the last inserted node. Now consider the next node in the sequence.  If it is larger than our active node then it must be its parent.  We can add this node as the parent (making it the new active node).  Otherwise the node is the first element in the right subtree of the node.  We can push a new binary heap onto our stack containing this node (again, making this new node the active node). As the algorithm continues the first case becomes more complicated (where the new node is larger than the active node).  The new node may not be the parent of the active node.  Instead it may be the parent of one of the binary heaps lower down on the stack.  Therefore while the new node is larger than the root of the binary heap second from the top, we merge the top binary heap as the right child of the second-from-top binary heap.  When this process ends the new node can be inserted as the parent of the top binary heap. At the end of the algorithm there may be multiple trees in the stack.  Simply merge these trees as though you were inserting a value larger than all others. To prove this is actually a bijection just observe that after each step all trees in the heap lack a right child.  Therefore the merge steps always can succeed. So here's an example.  Consider the binary heap (lifted from Wikipedia) with the in-order traversal of (2, 17, 7, 19, 3, 100, 25, 36, 1).  For simplicity I will represent the state of the algorithm by tracking parent associations and the parent of each binary heap in the stack. The algorithm would initializes as Processing '2' (initial step) heap_stack = [2] parents = [1 -> nil, 2 -> nil, 3 -> nil,                7 -> nil, 17 -> nil, 19 -> nil,                25 -> nil, 36 ->nil, 100 -> nil] And proceed with the following steps: Processing '17' (must be parent of 2) heap_stack = [17] parents = [1 -> nil, 2 -> 17, 3 -> nil,                7 -> nil, 17 -> nil, 19 -> nil,                25 -> nil, 36 ->nil, 100 -> nil] Processing '7' (in right subtree of 17) heap_stack = [17, 7] parents = [1 -> nil, 2 -> 17, 3 -> nil,                7 -> nil, 17 -> nil, 19 -> nil,                25 -> nil, 36 ->nil, 100 -> nil] Processing '19' (merge '7' tree as right child of '17', make parent of 17) heap_stack = [19] parents = [1 -> nil, 2 -> 17, 3 -> nil,                7 -> 17, 17 -> 19, 19 -> nil,                25 -> nil, 36 ->nil, 100 -> nil] Processing '3' (in right subtree of 19) heap_stack = [19, 3] parents = [1 -> nil, 2 -> 17, 3 -> nil,                7 -> 17, 17 -> 19, 19 -> nil,                25 -> nil, 36 ->nil, 100 -> nil] Processing '100' (merge '3' tree as right child of '19', make parent of 19) heap_stack = [100] parents = [1 -> nil, 2 -> 17, 3 -> 19,                7 -> 17, 17 -> 19, 19 -> 100,                25 -> nil, 36 ->nil, 100 -> nil] Processing '25' (in right subtree of 100) heap_stack = [100, 25] parents = [1 -> nil, 2 -> 17, 3 -> 19,                7 -> 17, 17 -> 19, 19 -> 100,                25 -> nil, 36 ->nil, 100 -> nil] Processing '36' (parent of 25) heap_stack = [100, 36] parents = [1 -> nil, 2 -> 17, 3 -> 19,                7 -> 17, 17 -> 19, 19 -> 100,                25 -> 36, 36 ->nil, 100 -> nil] Processing '1' (in right subtree of 36) heap_stack = [100, 36, 1] parents = [1 -> nil, 2 -> 17, 3 -> 19,                7 -> 17, 17 -> 19, 19 -> 100,                25 -> 36, 36 ->nil, 100 -> nil] Finally, merge all binary trees in the stack parents = [1 -> 36, 2 -> 17, 3 -> 19,                7 -> 17, 17 -> 19, 19 -> 100,                25 -> 36, 36 -> 100, 100 -> nil] Which is of course the original binary heap. 