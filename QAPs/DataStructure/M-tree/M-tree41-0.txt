How does a 2D segment tree work?
Well, it is basically 'tree of a trees'. Imagine you are working with sum queries. Then lets create for each x coordinate ordinary sum query segment tree. Now you can compute answer for each query/modification for a O(n * log m) time, where n is number of x coordinates and m is number of y coordinates in your table. How to achieve a O(log n log m) complexity? Easy, now you need to build a segment tree over x coordinates to substitute 'n' for 'log n'. So, for each vertice of the x-coordinate (outer) segment tree lets store a segment tree on y coordinates that corresponds to strip [xl, xr], meaning that it will store for some fixed xl, xr all the sums of rectangles [xl, xr] x [yl, yr] where [yl, yr] is a valid atomic segment tree segment. To do so you will need to sum-up two segment trees without going for naive solution or use partial sums for subqueries.Â  Now while answering queries you basically first traverse by outer tree until you find O(log n) segments that fits your x-part-of-a-query and then for each such segment you are traversing in corresponding segment tree until you find a set of segments that match your y-part-of-a-query. Regarding update, AFAIK 2D-tree works only with a point-wise updates. You should first update inner trees traversing from a leaf to the root of x=xq tree, then traverse from a leaf to the root of a tree that is parent in outer tree of x=xq tree and so on having totally to visit O(log n * log m) nodes of the segment trees. Please refer to the 'first', 'next' and 'then' more as explanatory words since from implementation side of view both querying the 2d segment tree and modifying it will require just a one recursive dfs. As an application advice: don't do overengineering. Before writing a 2D-segment tree you should consider using partial sums, 2D-Fenwick tree or O(1)-static-rmq for 2D since all of them are like 10X shorter and usually faster. For example, 2D-sum-segment-tree [which we were considering] is easy to substitute by 2D-Fenwick, and if we don't have modification queries we should rather solve sum queries for O(1) than O(log n) using partial sums. If you have queries on minimum element in rectangle without modification you can use binary jumps to answer a query in O(1). 