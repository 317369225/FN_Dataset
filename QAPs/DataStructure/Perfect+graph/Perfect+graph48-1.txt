What is an intuitive explanation of A* search?
Other posters answered this by comparison with Dijkstra, so I'm going to try a different perspective: comparing to breadth-first and depth-first search. Depth-first search is like solving a maze puzzle: you go down one path as far as you can, then once you reach a dead end, go back up to the last fork and try the other path, and so on; and you repetitively back up and try other forks, until you reach the goal. In terms of implementation, it's graph traversal using a stack data structure to hold nodes that we've walked by, and haven't explored yet. Breadth-first search, in comparison, is like going around in rings from your starting point, until you finally reach the goal. In terms of implementation, it's graph traversal using a queue data structure to keep track of nodes we've walked by, but haven't explored yet. Now, both algorithms assume that the search is blind, and you essentially stumble around until you find the goal. But what if you could see where the goal is, and whether you're walking in the right direction? A* algorithm does just that. It's like breadth-first search, but with a tweak or two - it uses a priority queue data structure, which pushes nodes to the front of the queue based on how close they're estimated to be to the goal. In effect, it's like going straight towards the goal, and if you reach an obstacle, exploring other nodes in the same general direction to get back on track. The main A* difference over BFS is in 1) using the priority queue, and 2) having a good function that estimates the distance of any node to the goal. If the function is "optimistic" (ie. it underestimates the real distance), A* produces the shortest path to the goal. If the function is "pessimistic" (ie. overestimates the real distance), A* goes towards the goal more aggressively instead of exploring other nodes, so it might do less work but produce suboptimal paths. A* with a pessimistic distance function is often used in games where execution time is very important, and optimal paths less so. 