What is an intuitive explanation of A* search?
Imagine yourself in a city like Chicago or NYC, with distinct city blocks, some very tall buildings, but otherwise a flat geography. In fact, Taipei would work best. The challenge: you need to get from point A (current location) to point B (the Taipei 101 tower) as fast as possible, but can only walk at a constant speed. So, it's all about finding a shortest path (one of several possible, or potentially a unique path). You don't have a map, and don't even have the address of point B, but once you are there, you'll recognize the tower because it's so unique. Also, you have a perfect memory of the area you have visited since the beginning of your search. A simple solution: explore the area around your current location, gradually expanding in all directions. This corresponds to the Breadth-First Search in unweighted graphs and Dijkstra's single-source shortest path (SSSP) search in weighted graphs. In particular, one keeps a list of new locations accessible in one step (one city block) from any one (some) visited location, and selects repeatedly one location that will give a shortest path from the source (comparing path lengths to different potential new locations). After a location is selected, the priorities of adjacent locations need to be updated. By the time point B is reached, the search will have explored a lot of unnecessary area, even in the direction away from B. So, how does one avoid wasting time in search? Key insight: if the tall building at point B can be seen from your initial location (point A), then search can proceed toward point B, exploring other directions only as much as needed for possible detours. Details: the problem is that city blocks will not allow you to move on the straight line. So, A*-search is a small modification of Dijkstra's algorithm that adds something to the priority used to make the next step. Specifically, you can add the straightline distance from the potential next location to the goal (point B). A theorem is proven that guarantees finding shortest paths if the added term is no greater than the actual shortest distance (for example, it can be half the distance). This term is called the admissible function. The sum of the path length so far (A->X) and the admissible function for its intermediate endpoint (X->B) does not exceed the actual path length (A->X->B) and even the shortest path length (A->B). To summarize, from the implementation perspective, A*-search is just Dijkstra's shortest-path algorithm with a very small tweak. It can be applied in explicit graphs in, say, computer games and GPS-based navigation. Even more effectively, it can lead to an exponential speed-up in implicit graphs. For example, if you wanted to solve the 15 puzzle, A*-search is the way to go. A good admissible function would be the sum of distances that each tile needs to travel from the current position to the end position. For more challenges cases, such as the 24 puzzle, there are much fancier admissible functions (R.Korf worked on this topic for many years and his papers are a pleasure to read). So, it is quite possible that the bulk of your program will be computing an admissible function to be used in the otherwise simple graph-based search procedure. Updated 109w ago â€¢ View Upvotes