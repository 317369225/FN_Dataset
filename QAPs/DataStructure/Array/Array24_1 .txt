What's the difference between array and pointer in C/C++?Let me define an array and a pointer. 12 int array[10] = {1,2,3}; int *p = array; The address that the symbol array represents is calculated at compile-time. So, when we access array [ 0 ] with say printf ( "a[0] equals %d \n " , array [ 0 ]); we do just one memory fetch because we already know where the value is located, i.e at the address array. And array [ 2 ] is at 2 units past the address represented by array. So the compiler generates code for adding sizeof ( int ) * 2 to the address represented by the symbol array and then accesses the value at the resultant address. Now, the pointer p stores the same address that array represents in the symbol table. The symbol table has address for the variable p but the contents of the variable are known only at runtime. What I mean to say is that when you do printf ( "p[2] equals %d \n " , p [ 2 ]); you fetch the contents of the variable p from the address that you have for p. It was calculated at compile time just like the address array. Now after the first memory fetch, you get an address. Then you add sizeof ( int ) * 2 to that address and access the resultant address. So even though the result is the same, while using the pointer you made two memory fetches while using an array, it was just one fetch. See for yourself: Before the call printf on line #31 is the code for accessing array [ 2 ]. After line #31 is the code for accessing p [ 2 ]. There are times where you cannot use a pointer for an array or vice-versa. For example, if you have a global array defined in a file, say test1.c. When you declare the array in some other file, you must declare it as an array and not a pointer. 123 /* File test1.c  */ int global_array[10];  1 2 3 4 5 6 7 8 9101112 /* File test2.c  */ extern int *global_array; /* accessing global_array[2] may give you a segfault  * because you were supposed to declare it as an array  * like so-- extern int global_array[];  */ int main(int ac, char *av[]) {  printf("global_array[2] equals %d\n", global_array[2]);  return 0; } This behaviour is due the fact that the compiler generates different code for array indexing and the access through a pointer. 