Given an array of size n, how do you find all the possible subsets of the array of size k?Would appreciate if you could explain your code/solution a bit and also mention its time complexity.There are a number of ways to go about solving this. Ashish Gaurav's answer does this by finding all k-digit numbers which, when written in base n, have all unique digits. His solution does this by manually iterating over all such k-digit numbers. This approach works for small values, but we can do a lot better. Firstly, note that there are such numbers. This scales very quickly. In particular, if is large, then this will also generate all permutations. A standard trick to avoid dealing with permutations is to use bitmasks instead. In particular, we can view the problem as wanting to generate all -bit numbers where exactly bits are 1. This involves doing work, which is a lot better, and moves the dependency of being in the base of a exponential to just being an exponent. Now, using Gosper's hack, we can generate all numbers with 1-bits less than which runs in time, assuming that bit operations on n-bit numbers take time. Note that from this list, it is straightforward to extract all the subsets by iterating over each number and extracting the elements that correspond to bits which are 1 instead of 0. Step 1: The smallest such number is obviously . Step 2: While you haven't generated all the numbers, take the largest one generated, call it x, and compute the following. u = x & (-x); v = x + u; y = v + (((v ^ x) / u) >> 2); y is now the next largest integer with bits as 1. 