Why are software development task estimations regularly off by a factor of 2-3?
Fred Brooks who managed the development of IBM's mainframe operating system OS/360 - a mammoth feat of software engineering by any standard - wrote the seminal book on this topic The Mythical Man Month.  It describes his experience and lessons learnt about what causes most software projects to be delayed.  Listed below are some of these reasons (based on various excerpts from Wikipedia that have been compiled and edited for relavance: The Mythical Man-Month) 1. The Mythical Man-Month and Brook's Law: Brooks discusses several causes of scheduling failures. The most enduring is his discussion of Brooks's law: Adding manpower to a late software project makes it later. A man-month is a concept of a unit of work proportional to the number of people working multiplied by the time that they work; Brooks's law says that this relation is a myth, and is hence the centerpiece of the book. Complex programming projects cannot be perfectly partitioned into discrete tasks that can be worked on without communication between the workers and without establishing a set of complex interrelationships between tasks and the workers performing them. Therefore, assigning more programmers to a project running behind schedule will make it even later. This is because the time required for the new programmers to learn about the project and the increased communication overhead will consume an ever increasing quantity of the calendar time available. When n people have to communicate among themselves, as n increases, their output decreases and when it becomes negative the project is delayed further with every person added. Group intercommunication formula: n(n − 1) / 2 Example: 50 developers give 50 · (50 – 1) / 2 = 1225 channels of communication. 2. The tendency towards irreducible number of errors: In a suitably complex system there is a certain irreducible number of errors. Any attempt to fix observed errors tends to result in the introduction of other errors. This is very difficult to anticipate and causes unpredictable delays in debugging the system leading to delays. 3. Feature creep, creeping featurism or featuritis:  is the ongoing expansion or addition of new features in a product, such as in computer software. Extra features go beyond the basic function of the product and so can result in over-complication rather than simple design. Viewed over a longer time period, extra or unnecessary features seem to creep into the system, beyond the initial goals. Occasionally, uncontrolled feature creep can lead to products far beyond the scope of what was originally intended. For example:  Microsoft's Windows Vista was planned to be a minor release between Windows XP and then the codenamed Windows "Blackcomb" (Windows 7), but it turned out to become a major release which took 5 years of development. And was still a disaster! 4. Accidental complexity: This is complexity that arises in computer programs or their development process which is non-essential to the problem to be solved. While essential complexity is inherent and unavoidable, accidental complexity is caused by the approach chosen to solve the problem. While sometimes accidental complexity can be due to mistakes such as ineffective planning, or low priority placed on a project, some accidental complexity always occurs as the side effect of solving any problem. For example, the complexity caused by out of memory errors is an accidental complexity to most programs that occurs because one decided to use a computer to solve the problem. [ Accidental complexity ] Updated 134w ago • View Upvotes