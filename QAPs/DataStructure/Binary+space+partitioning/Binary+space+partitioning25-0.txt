Is there a way to find the last element of an array without involving a counter, neither explicitly nor implicitly?
Log(n) will do?  Well, we can get close to that if the size of your maximum length of the array is not too big.  In a simple case, let's say the memory partition that you can store your array in is 16 memory addresses long (each location in this partition is 32 or 64 bits long, containing the address of an object, or null).  That means the maximum length of an array you can store will be 16.  Let's say all the add in this partition are initialized to null.  Now write an array of pointers in this partition, starting at the first location in memory. How do we find the length of this array?  Start with the 8th location.  If it's not null, check the 12th location.  Otherwise the 4th location.  See?  Binary search until you find where the array ends and the uninitialized memory begins.  If the space is twice the length of the array, then the search takes log(n+1) steps. But... let's say you want to store the array in an effectively infinite amount of space.  You could do better than n still.  2log(n) by starting with the first memory location, and doubling your position until you hit uninitialized space.  Then you know the boundary of the array is somewhere between position 2^x and 2^x-1, where x is the number of doublings.  x is effectively log(n), so you have to do a bit more than that.  You still have another log(n/2) steps remaining.  So it's log(n) + log(n/2), which is still log(n) runtime complexity. I'd like to add that practically speaking, just keeping a pointer to the end of your array is what you want.  It's a lot simpler. 