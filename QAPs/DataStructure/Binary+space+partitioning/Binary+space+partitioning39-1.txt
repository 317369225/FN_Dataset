How does one begin to tackle understanding a large open source code base?Often times I've wanted to dig in behind the scenes of things such as the linux kernel, the JDK, MySQL. What techniques do you use for getting a handle on a large code base ?
For any well established and large corpus of code there should be some sort of developer's guide that will help get you started.  Search for that and read it. However, even absent that, you can still try this:  Start by hypothesizing (guessing) about what things you'll have to find *somewhere* in that mass of code.  Based on what you know about the functionality of the code (how users access these systems) you can deduce some of the things that have to be there *somewhere*. For example you (should) know that the Linux kernel starts by doing a bunch of hardware/device detection and initializing (a boot process), that it supports a set of command line arguments which may have been passed to it by LILO, GRUB, Syslinux, or some other bootloader (meaning that there must be some code to parse those command line options and store or use those settings), at partition tables usually have to be detected and parsed and at least one filesystem must be located and mounted on / (the root filesystem) and that, ultimately the kernel starts one process in user space (init) and from there it acts as a service responding to system calls (from user space) and hardware events (mostly via interrupts, but possibly also more exotic hotplug or power events. Based on that knowledge you can expect to see some sort of process by which it finds and runs the init program, some code which parses the command line options and does something with them (mostly storing them in some internal data structures), and some sort of dispatch table enumerating the system calls.  You'd also expect to find some sort of interrupt or event initialization system and you'd expect that there's some way to "hook into" these events so that multiple handlers can be associated with certain types of events. Pick any one of those and go read that code.  As you read it you can gain some insights into what it depends on. Look at the directory structure and see if you can guess where they put different things.  Search for README and API and other .TXT or .DOC files which might give highlevel overviews of how the code is organized.  Guess what terms must be used in implementing some of these things that you know must be in there, somewhere, and search for those terms. (Along the way, for the Linux kernel, you'll find that there are lots of details that you didn't foresee.  For example the way in which Linux supports the initramfs (earlier versions had an initrd --- initial RAM disk) which was also available simply as an opaque blob of data if the initrd options weren't being used. There's a hook, formerly called the linuxrc for the initrd subsystem, now name /init in initramfs.  Initramfs is a specific type of cpio archive, so there's a very simplified, specialized, cpio unpacker built into the kernel for that purpose. The kernel sets up an environment for the init process and search in several places for an executable ... falling back to /bin/sh if none of the others are found.  The execve related functionality relies on a modular "binfmt" processing system which can execute old a.out, ELF, and any sort of #! (shebang) scripts, among others.  As you wend your way through code you learn about all these corners that the developers have had to accomodate during the history of the project.  (Particularly given that these can be implemented as loadable modules and can be dynamically loaded by thinks like kmod (or the old kerneld?). Obviously the Linux kernel (or any operating system kernel) is special case given that it isn't linked against the standard C libraries and it doesn't implement the conventional user space "main()" function.  So finding the entry point is different than for any normal C program. For most such programs you can start at "main()" or the equivalent of "main()" in whatever environment your corpus of code is written in.  (Obviously diving into a mass of Clojure or Scala, or Node.js, for example, would be different). Similarly for something like MySQL you know that this code runs as a deamon, has to read command line options, read and parse config files, and based on those, has to find and open various underlying databases (schema) and their associated tables.  You know that it supports multiple storage engines and that some of those may be listed and dynamically linked to it via configuration data. Once a MySQL daemon is loaded and its performed any database initializations (or handled any errors related to missing or damaged data) then you know that, ultimately, it opens sockets (Unix or Internet domain ... or both) and accepts connections.  Those connections than interact with the server through an API (perhaps several different APIs, depending on how they implement replication, for example).  You know that, ultimately, SQL statements have to be passed through this API, they must be parsed, a "plan" must be generated to execute the parsed SQL (queries or DML, data manipulations). So, start with some deductions.  You know certain things have to be there; so you look for those.  When you find them they'll feel familiar because you were expecting them to be there and you already had some preconceptions of what they must look like. You can also explore a system and its internal name space by stracing some of the code paths that call into it.  For example perform strace or ltrace on something simple like the wc command.  Then go look for those system calls in the kernel source code.  Run ltrace on a MySQL daemon and look through the start-up sequence and look up each of MySQL functions that you see listed there.  (Note, you'll want to build your own copy of the binary and run it unstripped to peform this execise.  Consider it a rather important pre-requisite for you to fetch and build the sources for any corpus of code that you intend to study.  Duh!)  You might try running the software under gdb and play with the entry points that you learn about through your tracing or direct source code reading. 