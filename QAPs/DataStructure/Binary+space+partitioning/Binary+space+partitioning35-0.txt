For all sorting algorithms, what works well with a large input size and a small input size?
If you know the inputs will be small (e.g. less than 100 elements or so), then insertion sort is the best choice as it has a simple implementation (no recursion etc.), sorts in-place (no extra memory space needed) and is stable. For small inputs, insertion sort will outperform any other more complicated sort (such as Quicksort) because of its very simplicity (only comparisons, moves, increment operations and jumps used to implement the loops). Rather than the straight insertion sort, you can also go for the binary insertion sort (which uses binary search to find the correct position for the element) which may provide slightly better performance (Not much, as in any case, all the elements after the insertion position will need to be shifted, even if binary search is used). If you are going to be sorting larger lists, which are still kept entirely in memory, then Quicksort (using randomized or median-of-three partitioning) is the classic choice. Also, you can go for a newer hybrid sort such as Timsort. Timsort is a hybrid-merge sort first implemented in Python for the sort library function, and is also used in OpenJDK for sorting Collections. Timsort provides better performance, and another advantage is that it is stable. In any case, if you are using a divide and conquer algorithm, it would be better to use insertion sort for sorting smaller sub-arrays (say size < 128 or < 64) to get better performance. Timsort does this by definition of the algorithm. A good Quicksort implementation would do this as well. Timsort outperforms Quicksort by a significant margin in typical real-world data because it takes advantage of pre-existing sorted "runs" in the data. Of course, Timsort is not anÂ  in-place algorithm, requiring extra space for N/2 items (where N is the total number of items). Of course, Quicksort is not strictly in place either (if you consider the O(log N) stack space. If you are sorting extremely large arrays of data which are stored in secondary storage and cannot be loaded entirely into main memory, the problem is called external sorting. For external sorting, usually some variants of merge sort are used, such as k-way merging or polyphase merging. 