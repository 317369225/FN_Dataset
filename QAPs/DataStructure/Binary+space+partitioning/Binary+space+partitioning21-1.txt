Is it true that writing operating system code and kernel code is extremely difficult? If so, how much do those types of programmers make?
No.  Issues like concurrency, re-entrancy, and real-time constraints aren't unique to kernel programming.  Many non-trivial user-space problems also require fast trace level logging (I like core local circular binary logs spliced together when output is needed) to resolve quickly because they result from a sequence of events and you need to know how you got to the failure. Most kernel programming is device drivers which are simple translations between one software abstraction and a hardware device or (more likely today) the software embedded in that device.  The rest is in line with a lot of other systems software but simpler than distributed systems where you can't even know what's happening in some nodes. The tools are more limited (off-the-shelf memory leak detectors don't work) but haven't been as bad as Stan Hanks' answer and Tony Li's answer suggest for most of 20 years. You can run gdb remotely with a thin kernel  stub attached to a serial driver to get most if not all of its functionality - breakpoints, hardware watch points, single stepping, etc.  Historically BSD even had kernel core dumps on panics although Linus didn't believe in them (there's some chance the relatively untested error path code with potentially corrupt data structures could overwrite something it should not). Loadable kernel modules allow deploying changes without rebooting as long as you don't hang the kernel or crash it. Non-device kernel code like filesystems can be debugged in virtual machines with remote gdb and checkpoints to go back in time. Much of the more complicated "appliance" code people used to link into kernels  now runs in user space to provide better failure partitioning and faster development with no performance penalty as long as you limit data movement and traps between user and kernel space through mechanics like devices memory mapped into user space - I've done that in two appliances,  Andy Bechtolsheim said Arista Networks does something like that, and a user space TCP stack is part of  the C10M solution to 10M simultaneous connections, 10gbits/second, 10M packets/second (they claim 50M), 10us latency, and 1M new connections per second. That can pay a great salary although millions come from equity and appliance companies have high sales costs, poor recurring revenue, and burn a lot of capital causing corresponding dilution getting to a win. Updated 10 Jul 2014 • View Upvotes