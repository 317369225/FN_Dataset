How do you design an algorithm?Imagine you are talking to a 18 year old who likes to study the humanities.
The first step is to clearly define the problem. Usually it can be captured with two questions:  What are the inputs? What are the outputs?  In other words, what information do you have available before the  algorithm begins, and what information do you want to produce before the  algorithm ends? Once you know what those are, the question becomes: What sequence of steps that will produce the desired output, using only the given inputs? That's your algorithm. It's wise to compare the problem to other similar problems that  you've solved, or seen solutions to. This is often the case - so often  that we don't really think of it as "designing an algorithm" even  though, technically speaking, it does count as such. When you have a  problem that does not reduce to something trivial, that's when it gets  fun - that's where creativity comes into play. If the output is a single number, then your algorithm is probably going to look a lot like a mathematical expression. What are the input variables, and how do they impact the result?  Is the result a multiple of this variable? Or does this variable just act as an offset to the resulting number? Or does this variable act as an upper or lower bound on the result? And so on. If the output is a decision - like true/false, yes/no, or stop/go, then your algorithm is probably going to look like a logical expression. Again, what are the input variables, and how do they impact the result?  Is the result normally 'true' and you're most interested in combinations of inputs that make it false, or is it normally false, and you're looking for cases that make it true?  What are the relationships between each possible pair of inputs?  Does it matter if either is true, or must both be true? Those are both simple examples, but you can build more complicated algorithms by combining them. For example, perhaps you need to make a decision whose result depends on relationships between some numbers. In that case, use the paragraph I wrote about coming up with a numerical output, to get an algorithm that calculates each of the numbers that you need, and use the paragraph about logical expressions to get the algorithm that computes the decision. Sometimes you need to operate on a big collection of inputs, or produce a big collection of outputs. You can usually break those down by pretending for a moment that the input and/or output collections are small - just one item - and looking for an algorithm to solve that simplified problem. Then look for a way to solve it with two items, and then with an arbitrarily large collection of inputs or outputs. I've just described the process of building big algorithms from little ones, but in practice the challenging part is usually in the reverse - it's figuring out how to break down a big problem into a few smaller problems. Sometimes you have to look at the problem from the bottom up, sometimes it helps to look at the problem from the top down.  Sometimes it helps to pretend that parts of the problem are solved, when they really aren't, because that frees you to write a solution the remaining parts of the problem... and then you go back and fill in the blanks.  Sidebar: And sometimes that approach bites you in the tail, as you find out that the part you assumed would be easy, is actually impossible. Perhaps it depends on information that you don't actually have available. Or it depends on information that gets calculated later - by a function that depends on the function you're trying to write - a circular dependency. Back to the drawing board. Sometimes it's helpful to consider not just intermediate steps in solving the problem, but intermediate representations of the input data. You take your input data, transform it somehow, and use that as your new input.  This kind of thing is generally done to get a performance improvement, for example if the transformed data structure is smaller than the original, then you can operate on it in less time. Another sidebar: For  example, I once worked on some email software, where we wanted to  quickly reject messages whose recipients don't exist. Speed is important  for that, since spammers like to try every possible combination of  characters to generate an email alias, in hopes that some of the  combinations will go through. The simple solution would be to make a  list of all of the email addresses in the company, and compare the  addresses on each message to the addresses in the big list. If the  company has 10,000 employees, that might work. If it has 100,000, that  might not.  If the company is a university that provides mailboxes to  millions of alums, then there might be a real problem with that  approach.  Fortunately, one of my co-workers was familiar with something called a Bloom Filter (What are the most common kinds of Bloom Filter, and how do they work?).   This gives you a way to 'insert' a large number of strings into a  relatively small bit-array. You can't extract the original strings from  the bit-array, but fast operations on the bit-array will tell you with  certainty if a given string was not in  the original collection. You might get some false negatives, but those  can be made rare enough not to matter. It was well suited to rejecting  spam. It always helps to have a good 'vocabulary' of algorithms, data structures and design patterns to draw from. The bigger your vocabulary is, the more problems you can solve quickly, since they reduce to problems that you already know how to solve.  Or you'll recognize opportunities to reduce time-consuming algorithms to fast algorithms by transforming the input into something that's easier to work with. In theory, once you have defined your inputs and outputs, you have everything you need to come up with the algorithm you need. But in practice, it is often that case that the inputs or outputs are not clearly specified. Something you need is missing. Or something you're given doesn't actually mean what you were told it would mean.  Or, you'll find that you actually cannot compute the desired output, from the desired inputs. In either case you end up needing to negotiate with the people who are providing those inputs and requiring those outputs. This is where people-skills come in. In large software projects, this kind of thing ends up taking half or more of the work week. Sometimes it can be hard to get everyone on the same page. 