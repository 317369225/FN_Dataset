What are the 10 must-know algorithms and data structures for a software engineer?
Originally Answered: What are the most common algorithms and data structures to learn for a developer?Â  Further recommendations?As everybody has mentioned in this thread, there's a common set of data structures and algorithms that you need to know to do basic programming. This includes lists, trees, maps, hashing, sorting etc. If you are into typical enterprise software development, a basic understanding of these will suffice. However, at the same time you need to be aware of the basic and subtle differences between closely related implementations of each of them. One of the questions that I mostly ask in a Java interview is the difference in performance characteristics of an ArrayList and a LinkedList. Unfortunately very few people can give the correct answer. In a related thread I discussed the importance of designing the correct data structure for your problem (What is the importance of designing the right data structure?). Knowing the basics of a data structure is one aspect. But if you are working on a problem that needs that extra performance, you may be required to go for that extra bit of optimization for your data structure. Consider linked lists, the staple food for storing elements in a linked manner. But if you need to get more performance out of this linked implementation, you may go for an Unrolled Linked List (http://en.wikipedia.org/wiki/Unr...). There's nothing fancy about an unrolled linked list. It stores an array of elements at each node rather than a single one, which increases the locality of your pointers and hence makes your data structure much more cache friendly. It's not that often you may get the chance to use an unrolled linked list. But when you can, it helps to have such optimization techniques a part of your repertoire. So the general idea is to learn the basic principles of the commonly used data structures (lists, trees, hashes, maps etc.), but keep an eye towards the variabilities of implementations that each may have. 