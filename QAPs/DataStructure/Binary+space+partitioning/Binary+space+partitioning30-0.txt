How do I create a database when the data structure is likely to evolve at a rapid pace?
You can use a name-value-pair schema.  This can be done in NoSQL databases or in SQL databases depending on availability and other requirements. We have some tables like this in MySQL.  They have primary keys and long strings, and the primary keys are constructed so the leading key is the key most typically used for the data structure, as these types of tables are often accessed only by a single key such as a user ID. In our case, we store the data with a list of name-value-pairs, so the table logically looks like create table name-value-pair-tab ( leading_key bigint, pair_value_type bigint, id bigint, values varchar(big, but less than about 64K), primary key (leading_key, value_pair_type, id) ) engine=innodb partition by hash(leading_key) partitions <lots>; values look like '1=<value1>,2=<value2>,...' and we have a description table that is read into memory ahead of time by apps that associates the numbers used for "names" with real values so they can load and dump from data structures.  pair_value_type is the actual data structure the data maps to. This isn't relational, but we don't need it to be, and a more relational structure would take a lot more space and cache RAM (we have a few billion rows of this kind, and they're heavily updated).  Also, this is tolerant to app-side changes and additions without needing table-level schema changes (which are far more intrusive than app-only changes). You have to write code to encode and decode these to your data structures, but this isn't all _that_ hard and works well for us.  It also lets us use joins on the parts of the key that are interesting to join and we don't need a separate data manager as a lot of other stuff in our schema *is* relational. You can simplify the encoding and decoding by using marshalled binary strings instead of stringified name-value-pairs, but this can expose you to versioning issues that may be hard to deal with in your app-side code. 