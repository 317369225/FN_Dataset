Given a 3d grid of cubes, what is an efficient way of computing an occulation map from a given perspective?
Are you trying to compute the occlusion map for shadows or visibility?  Is it a voxel engine or...a Minecraft clone? :) To tackle this problem, I would tell you to abstract it to the simplest case: Imagine a single row of cubes that you are looking at, head on (you can only see one cube no matter how many are in the row.  Every cube is either empty or filled, but you don't know which without testing it.  This means you have to test every cube from the front to the back until you hit a filled one.  On average, for a row of n cubes, the operation will take anywhere from O(c) (constant time) to O(n) (worst case scenario).  That's not bad, until you start factoring in other dimensions -- imagine a grid of such rows, then your operation time becomes O(n^2) to (worst case) O(n^3).  Anything over O(n*log(n)), as a programmer, should make you cringe. At its heart, it is a very basic "find" operation, and you have a few options for making it faster: Compression -- Compress all of the cubes into larger rectangular prisms, that way you don't have to test each one.  Octrees and Binary Space Partitions may be useful here. "Fake" it.  Use probability or "lossy" compression on the data to make it faster to search through it, at the cost of slight errors in rendering. Cache it.  Cache the occlusion, if possible for several different view angles, and linearly interpolate between the results. Use a combination of techniques, or think hard and create your own.  Think about the data in terms of different transformations or coordinate systems (i.e. polar/spherical coordinates or higher dimensions (4) ). 