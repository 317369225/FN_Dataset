How does one begin to tackle understanding a large open source code base?Often times I've wanted to dig in behind the scenes of things such as the linux kernel, the JDK, MySQL. What techniques do you use for getting a handle on a large code base ?
When approaching a large code base, I usually use a combined major-subsystems/deep-dive approach. Step 1: Understanding the main subsystems The first stage in understanding any piece of software is understanding the major subsystems. Usually, you can look at the source code directory hierarchy as a guide. For example, here's a source code browser for linux: http://lxr.free-electrons.com/ So we can see from this that there are a few subsystems, things like drivers, crypto, kernel, mm, net, fs, ipc. Stage one is to understand what these do, e.g. mm is memory management -- the way pages are allocated, how swap works etc. fs is file systems, ipc -- interprocess communications. You may have to go a few levels deeper than just the top level. For example, you may need to look under kernel to see what the subparts of the kernel are. Similarly if you look at JDK, you're going to find a few different pieces: you need to understand what those pieces are: the parser, the virtual machine, the core libraries, the JNI, the drivers for things like graphics, etc. Step 2: Deep diving Note: Should only be attempted after understanding the major subsystems. Usually, when you're reading source, it's for a reason: you want to make a modification, so you want to understand a particular component. So you can trace that particular component's functioning. Alternatively, if you don't have a particular component in mind, pick some example activities: e.g. for the linux kernel, you might be interested in: how do you kick off a process? So you'd look up where you start, which is the exec() call in unistd.h (http://lxr.free-electrons.com/so...). This is where it gets interesting -- down the rabbit hole you go. That's when you need to understand build systems, makefiles, etc to understand how we get from that one call, all the way down to the bare metal wire. A little more diving takes you to kernel/fork.c (http://lxr.free-electrons.com/so...). A little more diving takes you to the do_fork method (http://lxr.free-electrons.com/so...), which does things like clone the memory space, pass the parameters. Then you go into this function, and you understand that it's a bunch of macros, and the next core method is copy_process (http://lxr.free-electrons.com/so...). Repeat until you get to the bare metal, bottoming out in the specifics of a particular chip. You get the idea. Repeat this a few times for other tasks (what happens when an ipc call is made? What does is really mean to open() and read() a file? What happens when I call malloc()?) and you start to get a feel for the build system, the assumptions built in to things, the coding standards, the layouts etc. These two steps should at least help you get started. 