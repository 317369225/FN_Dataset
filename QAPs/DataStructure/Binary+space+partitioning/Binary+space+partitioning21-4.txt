Is it true that writing operating system code and kernel code is extremely difficult? If so, how much do those types of programmers make?
Tony Li and Stan Hanks covered it. Read their answers before you read mine. Low-level code is hard. That said, I don't think it's harder than doing high-level programming well. It's just much more punishing of those who do it poorly. Instead of a bug causing a web app to be slow or a client not to work on all browsers, you can get random noise or radio silence or, in the worst case, unexpected destructive behavior. Debugging is harder (as already discussed) so you spend a lot more time thinking about your code before you run it. Visually checking your own code (rather than running it and seeing if anything breaks) is a common practice in low-level programming. This also affects how you write your code: you want it to be simple enough that you can still physically read it and develop a very strong confidence that it's right. It's like the difference between Java and Haskell. It's as hard to write good Java code as to write good Haskell code, but Java (with a powerful IDE, Spring and Hibernate) lets mediocre programmers get something sorta accomplished. Haskell stops them in their tracks (unless they're willing to improve). How much do low-level programmers make? I think the answer is going to be disappointing. They do it because they enjoy the work, not because it's paid highly. Outside of a few financial firms (high-frequency trading) the answer is: they make average-plus salaries, and probably rarely more than $200,000. Why? Because they're specialized, and generally very good within their niche, but disinclined to enter the cowboy-coding world of most startups. "Agile" (terminal juniority) and deadline culture are anathema to low-level coders, who can't call themselves finished until something actually works. They're valuable and hard to replace, but they don't have the gigantic pool of jobs that makes it easy to create bidding wars and spike their compensation. Perversely, the most highly-compensated engineers ($300,000 and up) tend to be mediocre programmers slinging Java code, who managed to develop enough social acumen to convince businesses that they're "scaling" or "architecture" experts. The average (both in salary and quality of engineer) within the Java pool is lower, but it's much easier to create bidding wars when in that pool (and with mediocre competition) than in a small, elite pool like Haskell, Clojure, or low-level programming. This is good news if you're trying to hire kernel hackers or Haskell programmers, though, because they're cheap in comparison to their Java counterparts. (An average Haskell programmer is more expensive than an average Java programmer, but the rare Java programmer who is as good as the average Haskell programmer costs $400,000 at least. I'd bet that something similar is true of kernel hackers.) You can get a high level of talent without spending a huge amount of money. 