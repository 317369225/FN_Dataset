What are some differences between arrays and objects in Javascript?
About Objects In JavaScript, objects are defined this way: An Object is logically a collection of properties. Each property is either a data property, or an accessor property All objects have a core set of internal methods: [[GetPrototypeOf]] / [[SetPrototypeOf]] [[IsExtensible]] [[PreventExtensions]] [[GetOwnProperty]] / [[HasProperty]] [[Get]] / [[Set]] / [[Delete]] [[DefineOwnProperty]] / [[Enumerate]] / [[OwnPropertyKeys]] Those internal methods are used for: properties management prototype inheritance mutability of the object (extensibility / freeze) The very basic thing to know about JS object are that: Objects can be created via: the new operator called on a constructor, the literal object notation, or the Object.create() method Object properties are accessed via their "key" names which are a string or symbol value Object properties can be accessed with 2 notations: dot & brackets Functions are invokable objects Object methods are properties which are function objects When a property is not found on an object the potential one of its "prototype" is returned Few examples var myObj = new Object(); // standard built-in Object constructor var myObj = {}; // prefered literal notation alert(location.hostname); // property access via dot notation alert(location["host" + "name"]); // property access via bracket notation & expression function foo(a, b, c) {} alert(foo.length); // return 3 (number of named params), functions are objects myObj.foo = foo; // methods are function objects myObj.foo(1, 2, 3); // functions are invokable objects About Arrays As Arrays are objects they share everything that were already mentioned Array one of the standard ECMAScript "built-in" objects. It is also considered as a "built-in" constructor. Array objects are defined as Exotic Objects These objects generally behave similar to ordinary objects except for a few specific situations. The following exotic objects use the ordinary object internal methods except where it is explicitly specified otherwise below Function objects are very interesting, but let's look at Array objects exotic rules: They gives special treatment to index property keys An index is a String-valued property key that is a canonical numeric String An array index is an index whose numeric value is in the range of 0 to 2^32−1 Properties which key are array indexes are also called elements Every Array object has a length property which value range is 0 to 2^32 Each time an element is added or removed to an array object, the length property is always adapted to be one more than the biggest array index Whenever the value of the length property is changed, every element whose index is not smaller than the new length is deleted. To support all those constraints Array objects have a dedicated [[DefineOwnProperty]] internal method Literal Notations Array objects can be created either via the Array() constructor, or via their dedicated literal notation. myArray = new Array(3); // Array with 3 undefined elements myArray = new Array("a", "b", "c"); // Array with 3 initialized elements myArray = ["a", "b", "c"]; // Array with 3 initialized elements As JavaScript only allow key names which are meant to be string to access to properties with the dot notation, accesing element properties this way would fail: alert(myObj.2); // Syntax Error All Array elements must then be accessed using the bracket notation: alert( myObj[2] ); // OK alert( myObj["2"] ); // OK (returns the same element which array index is 2) Subclassing Array To Subclass an Object Constructor in JavaScript, you need 2 things: Call the parent constructor on the subclass instance from the children constructor Use prototype inheritance In ECMAScript 5 a nice pattern would be this one: function MySubClass() {   // when called with "new" a "this" instance is created   // initialize the subclass instance with the parent constructor   ParentConstructor.apply(this, arguments);   // do special treatments for your Subclass } // do prototypal inheritance MySubClass.prototype = Object.create(ParentConstructor.prototype); // then add subclass specific methods Warning: It doesn't work for Array As Array objects are Exotic objects, classical prototype inheritance + applying the constructor, this method doesn't work. The "this" instance, to behave as expected, has to be created by the Array constructor. Updating a this instance created by a subclass with the Array construcor is not enough. You may use some Hack, but the only real way to subclass JavaScript Arrays is to use the more recent ECMAScript 6 (2015) class notation: class MySubclass extends Array {   constructor() {     super();     // add my subclass initialization   }   // add my subclass methods } Array as Iterators Since ECMAScript 6 again, Array objects are Iterable and can then provide Iterator interface through their property Symbol.iterator var iterator = myArray[Symbol.iterator](); alert( iterator.next() ); // "a" alert( iterator.next() ); // "b" It also means that you can loop over array elements from for...of   loops for (let element of ["a", "b", "c"]) {   alert(element); } For more information I invite you to check the Iteration protocols Array Dedicated methods Last thing, but not least, regarding Array objects compared to core JavaScript objects, they have a dedicated prototype with a very usefull set of methods like: indexOf(), lastIndexOf(), find(), findIndex() join(), concat(), toString() pop(), push(), shift(), unshift() filter(), slice(), splice() map(), reduce() forEach(), some(), every() fill() ... 