How to compute the inverse permutation in a functional programming style?
Sorting does appear to be necessary, yes. However, because the sorted values are consecutive digits, you can perform the sort in linear time using a radix sort. If you're using a sparse, immutable array, e.g. Haskell's Array type, you can interleave the sorting logic into the inverse-permutation function. I'm a bit too lazy to provide you with valid Haskell code, but it'd look something like this: foldl (uncurry Array.set) Array.empty $ zip [1..] Like I said, this isn't quite the interface to Haskell Arrays and I probably got some type voodoo wrong somewhere, but it does the trick in linear time: each value is paired with its index, and each pair is given to Array.set to put the value at the index at which it appears. For example (and using your example), the first element, 3, would become (3, 1); given this tuple, (uncurry Array.set) would put the value 1 at index 3. The next element would be zipped to (8,2), resulting in 2 being placed in the 8th position. Etc. 