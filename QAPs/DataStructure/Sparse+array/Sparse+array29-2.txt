What are the 10 must-know algorithms and data structures for a software engineer?
Dynamic array, linked list, stack, queue, binary search, binary search tree (with its four traversals), hash map, depth first search, breadth first search and merge sort. Those are the 10 most basic ones I can think of. A programmer who truly understands these can derive a multitude of other algorithms and data structures, be it by composing them or by exploiting the mechanism that makes them work. I'm assuming an arbitrary number, like 10, is just a guideline. For this reason, I'll also add to the mix: heap sort (mostly due to its binary heap), Rabin-Karp string match (mostly due to the rolling hash technique), intro sort (as a model for hybrid algorithms and dealing with weaknesses), quick select (as a model for non-obvious exploitation of the "discard part of the input" technique from binary search, as well as its natural application), conditional remove (due to the clever use of read/write pointers: http://en.cppreference.com/w/cpp..., http://en.cppreference.com/w/cpp..., http://mjuchem.com/iterating-and...), prefix tree (both for its efficient lookup and ease of partitioning), skip list (due to the idea of indexing at every n elements and multi level indexing), b-tree (as a model for hybrid data structures and how to improve locality of reference) and maximum submatrix sum (a.k.a. Kadane 2D, due to its trick with running sums). This new list is larger than 10 but still pretty small. Plus, it covers an impressively large repertoire of techniques. Don't limit yourself to just learning the algorithms. Focus on their invariants, strengths, weaknesses, possible optimizations (time and space), variations (and specializations), and most important: understand what's the key idea that makes them work. Updated 22w ago â€¢ View Upvotes