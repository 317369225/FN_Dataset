Software engineering: How to generate a C++ function programmatically?
It's hard to understand what you mean. But from what you are saying about "generating" a function, what you are looking for is closures. You said you wanted to "generate" the function f, where f uses a variable p that is not a parameter to the function, but is "fixed" for f. If you can do something like the following (pseudocode), would it suit your need: make_f(vector<double> p) {    return function f(vector<double> x) {        return x dot p;    };} Here the inner function has access to "p" from the outside. Furthermore, the inner function is returned from the outer function, which means it has access to "p" even after the scope of the outer function no longer exists. This is what a closure is -- an inner function that can refer to outside local variables that exist at the time it was created. Note that here there is no "compiling" code at runtime; rather, the code is all specified at compile time, but the compiler somehow makes it so that the inner function "remembers" p even after the local variable p's scope no longer exists. Most (especially higher-level) languages have closures. However, C/C++ has not had inner functions, until C++11 introduced lambdas. A C++11 lambda is a closure, and does exactly what we described above. With C++11 lambdas, the above would be written something like: std::function<vector<double>(vector<double>)>  make_f(vector<double> p) {    return [p](vector<double> x) {        return x dot p;    };} Note that for this to work, your RungeKutta function would not take a function pointer; rather, it needs to take a more generalized type that can work with other callable types. The parameter type could be std::function, or it could be templated to take any callable type. C++11 lambdas are just syntactic sugar for a function object type. So even if you didn't have C++11, you could still implement the above like the following. This is how closures are implemented underneath anyway. class my_func {    vector<double> p;public:    my_func(vector<double> _p) : p(_p) { }    vector<double> operator() (vector<double> x) {        return x dot p;    }};my_func make_f(vector<double> p) {    return my_func(p);} 