I have a number array from 1 to 1000000, I need to get the time taken by each array element to converge to 1 without any repeated calculation. How should I solve this problem?
Memoization is the way to avoid repeating calculations. // I waste slot 0 here for the sake of readability; thus, the array// has 1000001 slots.const int num_slots = 1000001;int converge_time[num_slots];int collatz(int i) {  if (i < num_slots) {    if (converge_time[i] != 0) return converge_time[i];    else if (i%2 == 0) {       converge_time[i] = collatz(i / 2) + 1;       return converge_time[i];    } else {       converge_time[i] = collatz(3*i + 1) + 1;       return converge_time[i];    }  } else {    if (i%2 == 0) return collatz(i / 2) + 1;    else return collatz(3*i + 1) + 1;  }}void main() {  // I waste slot 0 here for the sake of readability.  for (int i = 2; i < num_slots; ++i) converge_time[i] = 0;  // This will be the base case for the recursion.  converge_time[1] = 1;    for (int i = 1; i < num_slots; ++i)     cout << "Time for " << i << " is " << collatz(i) << "\n";} Pratyush's answer is basically correct (apart from a bug), but since that code doesn't demonstrate the memoization technique which appears to be the core of the question, I thought it was worth expanding. This isn't perfect--it doesn't repeat calculations on the values we need to store, but it may repeat calculations for numbers beyond that range. To prevent *any* recomputation, we'd probably need to use a sparse array. (Edited to add bounds-checking, since my first rendition would have been guaranteed to crash.) 