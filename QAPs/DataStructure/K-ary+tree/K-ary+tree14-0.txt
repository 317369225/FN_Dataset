What are the skills that Google and other top level companies look for in a CV before calling a candidate?
I won't write much here, will just copy an email I received when they decided to interview me.. A NOTE for the readers: This call was for SDET guys, and not something generic. The mail reads as follows: Hi Arka I have included some tips on interviewing below  for your view!  I know its a lot to read, but wanted to give you the  materials to prepare!  I hope this info is helpful to you. Just 1 coding language is enough, you don't need to know all OO languages. ------------------------------ Google Interview Tips: Here are some hints and tips to help you prepare for success! Those who study tend to do FAR better on their interviews! 1) Plan ahead: The  Google engineers who will be interviewing you have only limited  time set aside from their projects, so please reserve time in your  schedule, too! This also helps you relax and perform better  at interview. Please have a pen and paper handy in the case that you are  asked to write some things down. 2) What to Expect: Up to a 45 minute technical interview with a Google software engineer. The  interviewer will be interested in your knowledge of computer science  principles (data structures, algorithms etc.) and how they can be used  in your solutions. 3) Interview Questions: Interview topics  may cover anything on your CV (especially if you have stated that you  are an expert!), whiteboard coding questions, building and developing  complex algorithms and analyzing their performance characteristics,  logic problems, systems design and core computer science principles -  hash tables, stacks, arrays, etc. Computer Science fundamentals are  pre-requisite for all engineering roles at Google, regardless of  seniority, due to the complexities and global scale of the projects you  would end up participating in. 4) How to succeed: At Google, we  believe in collaboration and sharing ideas. Most importantly, you'll  need more information from the interviewer to analyze & answer the  question to its full extent. * Its OK to question your interviewer. * When asked to provide a solution, first define and frame the problem as you see it. * If you don't understand - ask for help or clarification. * If you need to assume something - verbally check its a correct assumption! * Describe how you want to tackle solving each part of the question. *  Always let your interviewer know what you are thinking as he/she will  be as interested in your process of thought as your solution. Also, if you're stuck, they may provide hints if they know what you're doing. * Finally, listen - don't miss a hint if your interviewer is trying to assist you! 5) What is Google looking for?: "We are not simply looking for engineers to solve the problems they  already know the answers to; we are interested in engineers who can  work out the answers to questions they had not come across before." Interviewers will be looking at the approach to questions as much as the answer: * Does the candidate listen carefully and comprehend the question? * Are the correct questions asked before proceeding? (important!) * Is brute force used to solve a problem? (not good!) * Are things assumed without first checking? (not good!) * Are hints heard and heeded? * Is the candidate slow to comprehend / solve problems? (not good!) * Does the candidate enjoy finding multiple solutions before choosing the best one? * Are new ideas and methods of tackling a problem sought? * Is the candidate inventive and flexible in their solutions and open to new ideas? * Can questioning move up to more complex problem solving? Google  is keen to see really high quality, efficient, clear code without  typing mistakes. Because all engineers (at every level) collaborate  throughout the Google code base, with an efficient code review process,  its essential that every engineer works at the same high standard. 6) Still reading..? 7) Ask more questions!: Make  sure you have a decent understanding of Google as a business - further  than Google's main products - find out about what we do here: Company - Google OR: Google At the end of the interview, most interviewers will ask you if you  have any questions about the company, work environment, their  experience, etc. Its clever to have some pre-prepared for  each interview, but don't worry too much if your mind goes blank. If you have questions about the interview process, remuneration or your performance, please direct these to your recruiter. 8) Further reading: *To understand how Google's development teams work - Agile software development *To know more about Google's core projects - Page on google.com If you have not already read through Steve Yegge's technical prep tips, please check out his blog: Get that job at Google *Due  to the size of the products you'll be building, its imperative you're  comfortable with big O notation, here's where to brush up: Big O notation 9) Technical Preparation tips!: The main areas software engineers should prepare to succeed at interview at Google: Algorithm Complexity: It's  fairly critical that you understand big-O complexity analysis. Again  run some practice problems to get this down in application. Sorting: Know  how to sort. Don't do bubble-sort. You should know the details of at  least one n*log(n) sorting algorithm, preferably two (say, quicksort and  merge sort). Merge sort can be highly useful in situations where  quicksort is impractical, so take a look at it. Hashtables: Arguably  the single most important data structure known to mankind. You  absolutely should know how they work. Be able to implement one using  only arrays in your favorite language,in about the space of one interview. Trees: Know about trees; basic tree construction,  traversal and manipulation algorithms. Familiarize yourself with binary  trees, n-ary trees, and trie-trees. Be familiar with at least one type  of balanced binary tree, whether it's a red/black tree, a splay tree or an  AVL tree, and know how it's implemented. Understand tree traversal  algorithms: BFS and DFS, and know the difference between inorder, postorder and preorder. Graphs: Graphs  are really important at Google. There are 3 basic ways to represent a  graph in memory (objects and pointers, matrix, and adjacency list);  familiarize yourself with each representation and its pros & cons.  You should know the basic graph traversal algorithms: breadth-first search and depth-first search. Know their computational  complexity, their tradeoffs, and how to implement them in real code. If you get a chance, try to study up on fancier algorithms, such as Dijkstra and A*. Other data structures: You should study up on  as many other data structures and algorithms as possible. You should  especially know about the most famous classes of NP-complete problems,  such as traveling salesman and the knapsack problem, and be able to  recognize them when an interviewer asks you them in disguise. Find out  what NP-complete means. Mathematics: Some interviewers ask basic discrete math questions. This  is more prevalent at Google than at other companies because we are  surrounded by counting problems, probability problems, and other  Discrete Math 101 situations. Spend some time before  the interview refreshing your memory on (or teaching yourself) the  essentials of combinatorics and probability. You should be familiar with  n-choose-k problems and their ilk – the more the better. Operating Systems: Know about processes,  threads and concurrency issues. Know about locks and mutexes and  semaphores and monitors and how they work. Know about deadlock and  livelock and how to avoid them. Know what resources a processes needs,  and a thread needs, and how context switching works, and how it's  initiated by the operating system and underlying hardware. Know a little  about scheduling. The world is rapidly moving towards multi-core, so  know the fundamentals of "modern" concurrency constructs. Coding: You should know at least one  programming language really well, and it should preferably be C++ or  Java. C# is OK too, since it's pretty similar to Java. You will be  expected to write some code in at least some of your interviews. You  will be expected to know a fair amount of detail about your favorite  programming language. 10) Sample Topics: Coding Sample  topics: construct / traverse data structures, implement system  routines, distill large data sets to single values, transform one  data set to another. Algorithm Design / Analysis Sample topics:  big-O analysis, sorting and hashing, handling obscenely large amounts  of data. Also see topics listed under 'Coding'. System Design Sample topics: features sets, interfaces, class  hierarchies, designing a system under certain constraints, simplicity  and robustness, tradeoffs. Open-Ended Discussion Sample topics: biggest challenges faced, best/worst designs seen,  performance analysis and optimization, testing, ideas for improving  existing products. To practice for your interview you may want to visit the website www.topcoder.com If  you launch the "Arena" widget and then go to the practice rooms where  you can play with the problems in the first/second division as a warm  up. Another great site is projecteuler.net. ----------------------- INFO ON SET What is a SET? At Google, Software Engineers in Test (SET) or Software Engineer in Test develop test frameworks and build robust, scalable, and effective tests. SETs spend a majority of their time coding in either C++, Java, or scripting in Python. A SET is a software engineer, a core developer, who has a passion for test engineering. How is testing done differently at Google? *  Literally within milliseconds of a code check-in, our build process  will automatically select the appropriate tests to run based on  dependency analysis, run those tests and report the results. * By reducing the window of opportunity for bad code to go  unnoticed, overall debugging and bug isolation time is radically  reduced. The net result is that the engineering teams no longer sink  hours into debugging build problems and test failures. * Development teams write good tests because they care about the  products, but also because they want more time to spend writing features  and less on debugging. * Testing teams focus on higher  abstractions, like identifying latencies, system or customer focused  testing, and enabling the process with tools. * SETs avoid becoming  codependents within this system and generally do not write unit tests or  other activities that are best done by the developer. More about SETs * Our SET’s spend time  developing code to prevent bugs. Google has a strong cultural emphasis  on developers improving quality (i.e. unit tests, code reviews, design  reviews, root cause analysis). We want our engineers to spend their time  innovating - not fixing bugs. * SETs enable products to launch faster. They have great influence over internal processes and how developers write code. *  One of Google's less understood capabilities is our massive distributed  computing environment. The testing groups exploit this infrastructure  to do huge amounts of work very quickly and elegantly. * For someone who wants to learn and grow as an engineer, the  uninhibited access to the entire code base is a unique opportunity. The area: Engineering Google  Test Engineers guarantee that our company's software works every time  for every user while scaling to the highest levels. We tackle huge  technical challenges that push the limits of computer science. Our team  is a collaborative, global organization consisting of engineers with the  highest levels of technical depth, programming skill and a passion for  quality. The role: Software Engineer in Test As  a Software Engineer in Test on our Mountain View test engineering team,  you will examine, validate, and test large scale software development  and deployment projects as well as help design and build intelligent  systems that can explore various use cases and scenarios. Google's large variety of products offers an amazing  range of opportunities for you to make a big impact on the quality of  software seen by millions of people around the world. Your primary  responsibility as a Software Engineer in Test will be to work with the  development and test engineering teams to automate testing, create new  test harnesses, implement new automation tools and create innovative  automated test systems. Testing is at least as interesting as development *Do  you like Google's vision of the future of information? You should see  our vision for the future of testing. Google is the ultimate tester's  playground with some of the most sophisticated tools and infrastructure  imaginable. Many of the boring, mundane aspects of testing have been  automated into oblivion and Google testers are now focused on the  hardest, most interesting aspects of testing software. Imagine tools to  visualize an application's internal infrastructure, tools that provide a  video-game style heads up display for bug hunting, tools that transform  testing into a social networking endeavor where testers collaborate  seamlessly and test cases are pulled from the cloud on-demand. The  vision of the future of testing that Google possesses is sweeping and  every single tester is part of it whether they are feeding the vision  with their specific innovations or writing the tools that implement it. Test is a separate organization at Google *At  most companies, testers report to either their product team or their  development team. In many cases this creates a subservient relationship  with testers on the wrong end of the subservience spectrum. This is not  the case at Google. Here, testers are in their own division Engineering  Productivity. Our job is to accelerate product development by helping  developers help themselves. Our task is to make developers more  effective at testing their own products and often developers write more  test cases than testers do. Development actively recruits testers to  their projects and must work to convince us that they take quality  seriously. Teams that do not do so, won't get testers on their projects.  The result is development teams that work hard on quality and treat  testers as valued partners. 