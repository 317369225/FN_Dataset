Given a preorder traversal of a binary search tree, how can we reconstruct binary search tree efficiently?Yes you can make the tree efficiently in 0(n) time .. Let's say pre[]={,,,,,};is having preorder traversal of the tree now try to make a tree form given preorder traversal.  1 2 3 4 5 6 7 8 9101112131415161718192021222324252627282930313233343536373839404142434445464748 struct node{ int data; struct node* left; struct node* right; }; struct node* newNode(int data){ struct node* temp = (struct node *) malloc( sizeof(struct node) );   temp->data = data;  temp->left = temp->right = NULL;   return temp; } struct node* constructTreeUtil( int pre[], int* preIndex, int key,  int min, int max, int size ) {  // Base case  if( *preIndex >= size )  return NULL;   struct node* root = NULL;   // If current element of pre[] is in range, then  // only it is part of current subtree  if( key > min && key < max )  {  // Allocate memory for root of this subtree and increment *preIndex  root = newNode ( key );  *preIndex = *preIndex + 1;   if (*preIndex < size)  {  // Contruct the subtree under root  // All nodes which are in range {min .. key} will go in left  // subtree, and first such node will be root of left subtree.  root->left = constructTreeUtil( pre, preIndex, pre[*preIndex],  min, key, size );   // All nodes which are in range {key..max} will go in right  // subtree, and first such node will be root of right subtree.  root->right = constructTreeUtil( pre, preIndex, pre[*preIndex],  key, max, size );  }  }   return root; } I hope you can see the time complexity is 0(n) 