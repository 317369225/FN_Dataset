Given an in-order traversal of a special binary tree having property that the node is always greater than its left and right child. How can we reconstruct the tree efficiently?Although this problem sounds very abstract, it’s actually quite important, because it’s equivalent to the problem of parsing expressions with infix operators of different precedence levels:   1 + 2 * 4 == 9 && 7 - 4 / 2 + 3 == 8   ↦ (1 + (2 * 4) == 9) && (((7 - (4 / 2)) + 3) == 8) Here’s a linear-time solution in Haskell (programming language):  1 2 3 4 5 6 7 8 910 data Tree a = Nil | Node (Tree a) a (Tree a) deriving Show parse :: Ord a => [a] -> Tree a parse = unbounded Nil where   unbounded t (x : xs) = unbounded (Node t x t1) xs1 where     (t1, xs1) = bounded x Nil xs   unbounded t [] = t   bounded m t (x : xs) | x < m = bounded m (Node t x t1) xs1 where     (t1, xs1) = bounded x Nil xs   bounded _ t xs = (t, xs) (Using <= instead of < would cause equal items to be parsed right-associatively instead of left-associatively.)   