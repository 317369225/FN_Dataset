Given a set of points in a rectangle, can one determine the maximum area of an axis-aligned subrectangle containing none of the points in subquadratic time?
Woot, one of my favorite problems :-). Yes, there are sub-quadratic algorithms for this, but they use some fairly big hammers, and are not things that I want to implement. Deriving such an algorithm is a rather fun exercise in (systematic) log stacking though: I will try to briefly outline an approach using 'standard' tools that leads to an O(nlog^4{n}) time algorithm. Pick a vertical line down median x value that separates the points in half, call this the partition line. We will recursively solve the problem on the two smaller halves (which incurs an extra logn). So we only need to find the max area empty rectangle crossing the partition line in O(nlog^3{n}) time. For each point on the left of the partition, we can compute the first point above/below itÂ  in y value whose x value are also between it and the middle line. Do the same for the points to the right of the partition line. This forms n half rectangles, one for each point. An argument similar to the one for the quadratic time algorithm shows that the max area rectangle is formed by two of these half rectangles, one on each side, by taking the min of their top sides, and max of the bottom sides. Now for a fixed left half rectangle, one can show that the area formed by this intersection is a linear combination of 3 variables given by the right half rectangle. That reduces to an extreme point query in 3D space, which can be handled using 3D convex hulls in O(nlogn) pre-processing and O(logn) per query. Of course, there are the issues of the min/max going the right way, so each left half rectangle can only talk to a subset of the right half rectangles. But that's what (2D) range trees are meant to do... so 2 more logs later, we're done! This approach can be optimized to O(nlog^2n) by doing the divide-and-conquer better, and picking the queries to the extreme point data structures more carefully. Reference: Fast algorithms for computing the largest empty rectangle. Those familiar with programming competitions problems may recognize many of these steps. I imagine the list of 'every OI problem related to these steps' is quite long, but that's probably another story... 