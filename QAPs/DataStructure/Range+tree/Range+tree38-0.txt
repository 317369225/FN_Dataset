What is the efficient solution to SPOJ CCROSSX?
Thanks for A2A, Nick. (I know you know how to do this problem). First of all, there is a long discussion of dynamic programming solutions Brian Bi's answer to What is the property of monotonicity with respect to dynamic programming? I bet there is a way to get O(n log n) with this DP approach, but it currently escapes me. However, I do know how to do it with a greedy algorithm that I learned from a problem at USACO camp in 2009. (CCROSSX is a generalization of that problem.) Here it is: We are going to let [math]h_0,\dots,h_{n-1}[/math] be the input sequence, the heights relative to which the cost of the final configuration will be measured. Now, start by imagining that you have set the heights to [math]g_i = h_0 - di[/math], that is, [math]h_0, h_0 - d, h_0 - 2d, \dots, h_0 - (n-1)d[/math]. The sequence of consecutive differences is [math]-d, -d, \dots, -d[/math]. That is, we have made all the heights as low as they can possibly be. We are going to raise the heights until the last height is at [math]h_{n-1}[/math], where it needs to be in the final configuration. Now, at each step, we're going to take one of the differences and increase it by 1 (e.g., on the first step, we will increase one of the differences from -d to -d+1). This amounts to choosing a pillar, then increasing the height of that pillar and every pillar to the right by 1. Furthermore, we will choose the pillar (out of all viable pillars) such that doing this decreases the cost function by the most. A pillar is not viable if choosing it would cause one of the differences to be greater than d. You do this step a fixed number of times; each time you do it, the last pillar increases height by 1, and you stop when it reaches height [math]h_{n-1}[/math]. I'll leave it to you to show that this is correct. (I'm lazy.) Implementing this thing in O(n log n) is another issue. The first observation is that when you choose a pillar, you don't just lift it by 1, you instead lift it as much as you can before the optimal pillar potentially changes. (This would occur whenever some pillar goes above [math]h_i[/math].) Now,Â  you can do this with a range-tree, but you have to track a lot of information: For each pillar, the amount the cost function would decrease if you chose that pillar. You need to be able to query for the optimum - among all viable pillars, so you also have to track which ones are viable. You need to be able to detect when a pillar goes above its [math]h_i[/math], so you can keep the above data up-to-date. So you need to track: for each pillar, if it is currently above or below [math]h_i[/math] and how much longer it will be before it goes above [math]h_i[/math]. You need to be able to query for the next pillar to go above its [math]h_i[/math] if you start lifting all the pillars in a particular range. I believe this is the most complicated range-tree problem I have done. 