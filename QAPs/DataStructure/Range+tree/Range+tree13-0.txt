How do I answer range median queries efficiently?
Instead of just finding the median, here's an efficient algorithm for finding the kth smallest element in a range. Create a two dimensional orthogonal range tree created from the N points of the form (A[i], i).  Constructing this tree can be done easily in O(N log^2 N) time (although O(N log N) is possible). Now to query the kth element we traverse the first dimension of the tree.  We follow the left subtree if the number of points within our query index range in the left subtree is smaller than k.  This is simply a query on the second dimension tree of the left subtree.  If the kth element isn't in the left subtree we adjust k appropriately and search in the right subtree.  This whole search takes O(N log^2 N) time.  Essentially we have dropped a log N factor from Johnny's solution by wrapping the binary search into the traversal of the tree. It's actually possible to get this down to O(N log N) preprocessing and O(log N) per query.  Skip to about 17:00 in 6.851: Advanced Data Structures (Spring'12) to see Erik Demaine explain orthogonal range trees and how to achieve the faster preprocessing and query times which take mild cleverness and fractional cascading respectively. Updated 55w ago • View Upvotes