How can I explain Computer Science Engineering to a layman?
Originally Answered: Can any person currently doing his/her Btech in CS tell me what is CS all about in laymen terms?Let's say you have a bucket of Lego bricks. These bricks can be assembled and connected in many ways to form different structures. These structure can then be assembled and connected in many ways to form complex structures. Suppose you want to build a car. You can do so in many ways using the brick structures. You can build a race car which can go very fast, but then you might need a lot more bricks, or else you can build a SUV, which is more spacious with less number of bricks, but will go very slowly compared to the race car, or you can build a general purpose car, where it  uses brick structures which are more stable and can run for a long time and can go faster than the SUV but not as fast as the race car. This is called Computer Engineering(CE). [Deals with hardware part. Here the car is equivalent to the computer. Brick structure is equivalent to logic gates and brick is equivalent to a transistor] Your friend, has no idea about the car you just built, in-fact he has never seen a car in his life before, but all he dreams about is cars. He's not interested in making a car by himself and more interested in finding out what all  he can do with a car. He takes a blank paper and starts to sketch an idea he thought which lets the passengers to get radio inside a car. After a while he figures out an alternative which turns out to be a better way to get radio in the car, so he starts sketching this one on a new paper. He shows both the sketches to his dad and he then modifies it in such a way that the passengers now have radio and stereo in the car (still imaginary for your friend and his dad). Later your friend and his dad make sketches to show fuel effecieny and maybe collision detection with other cars. They are not really concerned with the beauty of the sketches, but they constantly improve the efficiency of their ideas. They clearly understands the limit of what they can achieve with a car even though they haven't seen one. This is called Computer Science(CS). [Deals with the theory part] A smart kid in your school knows about your car and the sketches your friend made. He speaks highly about your car to his uncle, who is now convinced that if he has the car, his work would be very much simplified and  he can do more work which results in more profit. He decides to buy a car from you. But seeing the different types of car he gets confused. His nephew advice him not to buy the race car since it's costly and he's never going to need the speed race car to do his work. He buys a general purpose car. Everyone is happy, his uncle can now do ten times the work he used to do which means he's getting richer day by day. He buys more cars from you and gives it to his employees. Now they can all do a lot more work in less time. His uncle gets several new ideas like having a radio and stereo. He shared his ideas with his nephew. He even offered some money if his nephew could implement those idea on the cars he bought. Being a smart kid he accepted the offer and bought all the sketches from your friend. He started learning the sketches and figured which one would fit best for the cars his uncle bought. Then he made a plan on how to make the real thing out of the sketch he had. After the initial planning he started examining several components and selects the best one suited for the purpose, which is also compatible with the cars his uncle bought. He goes and build it on his uncle's car. He test it and finds that it's not perfect, so he reviewed his plan again change some parameter and tries to modify his build, test it again, it's better but not perfect. He now modifies the sketch a little bit and do the implementation again, after testing he's happy with the result and gets paid. This is called Software Engineering(SE) or Information Technology(IT) [Designing and Implementing the theory part onto the hardware] You will study a mix of all the three. Most universities offer computer science engineering which mostly covers the first two and some subjects of IT. Before I continue, let me tell you some misconceptions about CS. Some people will tell you theory subjects are all nothing but boring. These are the fundamentals of CS. If you learn in the right sense, you will love it. Some people will tell you CS is all about programming and programming languages. It's not. It's just a tool. Some people will tell you that you should have taken computer classes during school. It doesn't matter at all. Now I will take you through the 4 years of computer science engineering and explain what exactly you will be learning. All you need to start is a sense of Abstarction. First Year: You will be learning general engineering where you will be introduced to different engineering ecosystems such as mechanical engineering, electrical engineering, civil engineering, chemical engineering and computer science engineering. Your only job is to get familiar with the different engineering streams. You may or not be taught a programming language. This is just an introduction don't overdo anything here. It doesn't matter whether you can program or not at this stage. Just try to get the general idea. Second Year: During the first year, you will probably learn about transistors and it's working in detail in your electrical class. This where the concept of abstraction comes in and this is where we draw the line between an electrical engineer and a computer science engineering. Now we don't really care about the working/construction of a transistor. From now on we will use transistor has our basic building block. We assemble several transistors and connect them smartly to build logic gates, we then connect logic gates smartly to make new logic gates, then using logic gates we build Adder, Arthemetic and Logical Unit and Memory. This is called Digital Electronic. You will learn different methods to arrange the parts we made in digital electronics and how all pieces work together. You will learn how data is transferred from/to memory/cpu, different types of processors and its architecture and common conventions. This is called Computer Architecture and Organization. There is a special kind of maths which deals with only finite elements. Here you will learn about logics - which are used to prove correctness of your program, number theory, polynomials and abstract algebra - used heavily in Security, probability - used in Artificial intelligence, Search Engines, graph theory - used in Networking, game theory - Networking and AI, information theory - used in compression and encoding. This is called Discrete Mathematics (very important). Now you take what you learned in Digital Electronics and Computer Organization and combine it to develop a working CPU. So far all we know is  if you give a voltage (0 for no voltage and 1 for voltage) at certain logic gates some computation(like adding two numbers) will happen. But giving commands in the form of 0's and 1's (eg: 00011001010101) is impractical  (again abstraction comes into play). So we build mnemonics(Assembly Language) to make sense out of the 0's and 1's. It's easier to read ADD than 010100001.  This is called Microprocessor (You could build a traffic light system or a counter or a vending machine with this knowledge. You will also learn the working of various microprocessors). What if I told you someone had made a theoretical model of a computer long before actual computers were built and still capable of simulating any logic? Ok. Now you have mnemonics but it's still cryptic and difficult to perform complex tasks. A better way to tell the computer to perform a task is to make use of a language very similar to us (English). If I write  if (number > 0 ) print " Hello World!" . It makes more sense and the whole process is now simple. But we know by now that computer only understands 0's and 1's and we need something in-between to convert the above English like code to 0's and 1's. [English like code] -> [Bunch of stuffs] ->[Assembly]->[some more stuffs] -> [000011010101010]. The 'Bunch of stuffs' part is called a compiler. Designing an efficient compiler is hard, but to do so, you will need to know it's building blocks.This is called Automata Languages and Computation (This is one of the applications of Automata, there is a lot more to what is automata and its applications; very important) So now you know there exist an easy method to communicate with computers (with English like languages). But soon you will realize there exist 100's of such languages which varies from each other drastically in size, shape and functionality. How about we learn a little about the evolution of various types of languages, its paradigms, methodologies and when to use what - This is called The Principle of Programming Languages. How about we learn the most common paradigm used(Object  Oriented Programming). You are now capable of commanding your computer to do some actions using an Object Oriented Programming Language. Suppose you want your computer to sort a list of numbers. Obviously your computer doesn't know how to sort, so you decided to teach your computer via an Object Oriented Programming Language. You find success in teaching and finally getting the sorted list of numbers. But wait, you teach another way of sorting and computers give the sorted list faster. But wait, when you arrange the list of numbers in a particular way you get even faster result. You will finally realize that the first method is faster when the list of numbers is less and the second method is faster when the list of numbers is more. This is called Data Structures and Algorithm(Agian lot more to it; very important). Third Year: Remember learning the building blocks of a Compiler? Well, here you will learn how to design an efficient compiler - Compiler Constrcution. Now that we know a lot about programming ( both high level and low level), algorithms and compiler construction. How about we automate a bunch of hardware and software functions and make the life of the end user easy, letting them use the computer for other activities (like their work) -   This is called Operating Systems (very important). How about we draw a point on the screen, or a line or circle or combination of lines or circles or both. We now learn efficient algorithms to draw various shapes and maybe animate them. This is called Computer Graphics. You know that you can store data in the memory, but wait, there is a far more efficient method to store data in memory which promises a faster access? -  Database Management System. How about we learn something about connecting two or more computers and sharing information? - Computer Networks Fourth Year: Computers are all connected now. Let's add some security to our data and to our connection - Security Let's build a Check game, player v/s computer - Artificial Intelligence How about a search engine - Information Retrival Faster Computing? - Parallel Processing Let's a make a bigger system and do complex task by combining hundreds of small computers - Distributed System Well, I guess this is it. PS: I have left out a couple of topics intentionally. 