What are some uses of hashing algorithms?
A cute use that used to be obscure but is now pretty common is for probabilistic sets (bloom filters) and cardinality estimation (hyperloglog). They're also used for hash array mapped tries (HAMTs), a persistent alternative to hash maps. (As the name implies, hash maps also use hashs, but I assume everyone knows about them!) Bloom Filter A bloom filter is a way to maintain a set of elements in a space-efficient way with a low probability of false positives (but no false negatives). By accepting a low probability of inaccuracy, you save quite a lot of space in memory! The core idea is to store your set as a bunch of bits. Each time you add a new element, you take the element's hash and set those bits to 1. (Ie adding an element looks like this: insert element bloomFilter = hash element .|. bloomFilter (Where .|. is Bitwise OR.) To check if an element is in the set, we just see whether all the bits of its hash are 1: check element bloomFilter = elementHash .&. bloomFilter == elementHash where elementHash = hash element (Where .&. is Bitwise AND.) Wikipedia has a good illustration: In this example, x hashes to 010001000000010000, so we set those three bits in the bloom filter. We do the same for y and z. However, since w is not in the set, one of the bits of its hash is 0. This is where the inaccuracy comes from: if w had a hash that was made up entire of bits from the hashes of x, y and z, we would think it's in the set too! This happens despite the fact that we never added w and that w's hash is distinct from any element already in the set. Hyperloglog Hyperloglog is an algorithm for counting unique elements without storing them. In spirit, it is like using a bloom filter with very similar probabilitistic behavior. However, it does a better job specifically for counting than a bloom filter would. Hashes are used to turn the incoming stream of elements into something uniformly distributed. I don't feel like writing a description of the algorithm here, so I'll just point you to a blog post about it with visualizations. HAMTs Hash array mapped tries are an alternative to hash maps in functional languages. A trie, or a prefix tree, is a tree data structure for storing key-value pairs. It breaks each key up into a sequence of symbols and uses those sequences as a path through the tree. This means looking something up in a trie is just a matter of following the symbols in a key. Here's a nice illustration from Wikipedia to clear the idea up: So if you had a key called tea, you would look it up by taking the t branch then the e branch and finally the a. Then you would return the value stored at the tea node ( 3 in this case). The problem here is that some keys may be much longer than others. If most of your keys share a prefix, you're wasting a lot of traversal time! Just look at how unbalanced the example tree is. The insight with HAMTs is that we can make the key space have a nice distribution by hashing all the keys: very similar to how hash maps work, actually! So a HAMT is just a trie that uses the hashes of keys to make the paths, which ensures the paths are evenly distributed and of the same lengths.  (The "array mapped" part just refers to a particular way to implement the pointers for branches at each node that's more efficient than just allocating a full array of pointers each time.) Updated 8 Apr 2014 • View Upvotes • Asked to answer by Mubashra Safder