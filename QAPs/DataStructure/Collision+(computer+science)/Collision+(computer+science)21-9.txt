Why do many software engineers not like Java?
Let me answer by telling you about a programming test I evaluated this week. All things considered, it was solid, even succinct Java. The candidate had a ton of industry experience with Java, and it showed. Bear in mind that none of the examples I'm about to give are what I'd call bad or dumb or unnecessarily complex; these are all, for the most part, what Java and the industry call sensible, standard practice. Spoiled as I am with inferred typing, every time I see a line like... HashMap<String, Set<String>> depMap = new HashMap(); ...I die a little on the inside. Because to me, that says, "depMap is a map, which is a map." 52 characters just to define a common data structure? Come on. Indentation included -- and this kind of definition must be indented at least twice -- this kind of crap takes up the majority of my terminal width. Reading through basic declarations is a minor undertaking in and of itself. And when there's a block of declarations like this, my eyes glaze over and my ADD kicks in, and I suddenly and strongly want to do absolutely anything else with my time. I would honestly rather read overly-clever and terse Perl, because I would rather put my brain to use figuring something out than push it through this kind of mind-numbing tautological filler. And for anything even slightly more complicated, especially APIs written by card-carrying members of the Cult of Design Patterns, you see things like this: private static final Logger LOGGER = LoggerFactory.getLogger(Main.class); This initializes a very basic logger from SLF4J: the Simple Logging Facade for Java. Did you catch that word "simple"? This 73-character (69 plus the length of your class' name) monstrosity, in which the word "logger" appears no fewer than four times, is how you do simple logging in Java. It's all uphill from there. This submission also followed the standard Java package naming convention of stress-testing my filesystem with entirely too many nested directories, most of which contained only the next nested directory: src/main/java/com/[company]/[program]/[author]/*.java 7 directories deep, that code is. That's the number of times I had to press tab in my cd command just to get to the code. And this is just for a simple one-off program; it gets all the deeper with each small step of complexity. I have seen, in my career, upwards of 20 nested directories that could not reasonably have been shortened. With most languages, an IDE is a useful tool for managing a sufficiently complicated project; with Java, an IDE is a necessity for navigating an unavoidable labyrinth created by even the simplest of projects. Since it used third-party libraries, as most any Java program in the industry is bound to do, my choices for compiling what was otherwise an extremely basic program were: download all JARs myself and write classpaths in my compile and run commands that stretched several lines in my terminal use Ant use MavenAnd after briefly reliving the utter insanity that come with those latter two, the first option ended up being the least painful. The candidate was nice enough to include a pom.xml, so I naturally tried Maven first. Since I hadn't used it in a while, I first ran mvn and desperately hoped it would Do The Right Thing. But after downloading roughly half of the Internet, not to mention flooding my terminal with literally hundreds of lines describing each step it was taking, Maven informed me that I needed to specify one of its entirely too many (30, by my count) ambiguously named "goals". I spotted at least four or five that could plausibly have meant "just compile the fucking thing," but I got very sick, very quickly, of watching Maven download the same half of the Internet it had already downloaded, every single time it ran, even when it could easily have stopped early with an error message when I gave it invalid input, as I iterated through that list of possible goals. It didn't help that the output was so criminally long with each run that I lost track of where it had dumped that mega-list of goals; if my terminal continued out the top of my monitor, I'm willing to bet that list would be in outer space. I wasn't feeling like scrolling into outer space that day, and I definitely didn't feel like running mvn with no arguments again just to print another copy, so I looked into my other options in the vain hope that they'd be simpler. Skimming through the Apache Ant manual revealed that I'd have to write XML to use it. I honestly believe I saved myself an aneurysm by proclaiming, "fuck that noise," and closing the browser tab. (PROTIP: The key is hearing yourself say it out loud. Otherwise, your brain might still suspect that you're willing to try writing XML just to compile a single-file, <200 line Java program and try to end its own existence before being forced to comply.) And thusly did I find myself Googling class names in compilation errors to find the projects that had the source to make the JARs to give the compiler to build the fucking program. And it gave me much less of a headache than Maven did, because I at least felt like I was making progress. This happens pretty much every time I try to do something with Java. Writing it is a tedious, painful exercise in patience. Reading it is a tedious, painful exercise in patience. Compiling it is, you guessed it, a tedious and painful exercise in patience. And even running it is somehow precisely as painful and tedious as compiling it. Every task in Java -- every task -- is like filling out endless tax forms. And I know, and you know, and Java knows, that it doesn't have to be this way, because you can some-crazy-how accomplish exactly what you can in Java using other languages that are just as portable, performant, and commonly known, but considerably less of a Byzantine clusterfuck. And yet these problems persist. And so I continue to keep my distance. 