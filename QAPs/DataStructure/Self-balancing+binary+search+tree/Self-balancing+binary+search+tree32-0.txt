What are some tips, tricks and gotchas when using a binary tree search algorithm?
Do you mean a Binary Search, a Binary Search Tree based algorithm or the Search algorithm in a Binary Tree? For Binary Searches, you must be very cautious and write tests for corner cases (lots of elements, empty, one element, even number of elements, odd number of elements, needle on the right partition, needle on the left partition, different search paths...) This article mentions a common bug that might trigger overflows: Research Blog: Extra, Extra. It's also very common to get infinite loops and off-by-ones (like trying to access one past the last element or the element to the left of the first). Implement test cases for those scenarios and you should be fine. Now, if you're talking about Binary Search Trees, they are very straightforward to use once you understand their core. They are basically a O(lg n) data structure for most operations you care about, assuming a self-balancing implementation like Red-Black or AVL trees, but in practice they might not perform very well due to poor locality of reference. Roughly speaking, since you allocate the tree nodes one by one, they might end up scattered in memory rather than "close" to each other. In this case, the CPU will have to wait until the different parts of the memory are fetched. You can look up a more elaborate explanation (Locality of reference, Page fault, CPU cache - look for explanation on cache levels). B-Trees are an alternative with great improvements on this. You could also implement your own BST (or, in C++, implement a custom allocator) that allocate nodes from a vector - the pointers to the nodes then would actually be indexes on this vector. 