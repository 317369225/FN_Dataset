Are there really programmers with computer science degrees who cannot pass the FizzBuzz test?
Oh, yes. I've interviewed lots of people who didn't know what exponents were, couldn't write code to add the values in the array, and other things. I haven't asked FizzBuzz before, but I would not be surprised at all to learn that many people can't do it. There's a certain category of questions that fall into that sweet spot of "takes a tiny bit of thinking but not too much." Those are good to validate that you're in the right ballpark. Here's another (somewhat harder) question: Given a list of people with their birth and end years (all between 1900 and 2000), find the year with the most number of people alive. There are some more interesting algorithms for this problem, but people should be able to come up with a basic brute algorithm. Many, however, can't. On the surface, this is what FizzBuzz purports to do: validate very basic problem-solving and coding skills. But FizzBuzz has another element to it that throws people off. I call it the Smart Person's Mirage. Some people who fail this problem are genuinely quite bad. Others are actually good developers who just get caught by the Smart Person's Mirage. Beware the Smart Person's Mirage The Smart Person's Mirage is when a problem looks like it has a "cool" solution, but it doesn't. The dumb (or lazy) developer will not notice or care about the appearance of a potential cool solution. They'll just bang out whatever works. They actually do okay on this problem. The smart developer -- not all, but many -- will notice the appearance of a "cool" solution and chase after it. It's a "mirage" though because there isn't a cool solution. It just looked like there was. This is the "obvious" solution: for i in range(1, 100):    if i % 3 == 0 and i % 5 == 0:        print "FizzBuzz"    elif i % 3 == 0:        print "Fizz"    elif i % 5 == 0:        print "Buzz"    else:        print i The smart person could do this, sure. But come on! There's got to be something more elegant! The thing you print for divisibility by 3 and 5 (FizzBuzz) equals the thing for each value individually (Fizz and Buzz). That's not just a coincidence. They really want to do something like this: for i in range(1, 100):    if i % 3 == 0:        print "Fizz",        if i % 5 == 0:        print "Buzz",    .... But this doesn't work because you still need to print the number if neither of these are true. So maybe they'll wind up here after some trial and error: for i in range(1, 100):    if i % 3 == 0:        print "Fizz",        if i % 5 == 0:        print "Buzz",            if not(i % 3 == 0) and not(i % 5 == 0):        print i,        print '' That's no prettier in the end than the easy solution. But, arg! That repeated modulo-3 and modulo-5 is annoying. Let's combine them. for i in range(1, 100):    if i % 3 == 0:        if i % 5 == 0:            print "FizzBuzz"        else:            print "Fizz"    elif i % 5 == 0:        print "Buzz"    else:        print i Now we just have confusing code. We should have just stuck with the easy, obvious solution. But the smart developer might just identify (intelligently) the potential for a "cool, elegant" solution and never find it. It's a mirage, after all. 