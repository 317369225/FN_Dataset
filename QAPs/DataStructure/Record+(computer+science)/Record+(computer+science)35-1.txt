Are there really programmers with computer science degrees who cannot pass the FizzBuzz test?
The first time I saw the FizzBuzz test was on CodingHorror: @Why Can't Programmers.. Program? If you follow that link, they've moved all of the "I can do that!" comments to a separate dumping ground, and I went to take a look because, obviously, it's such a simple problem. And what I saw there were dozens of comments of "Oh that's easy! Here's my solution:" followed by a solution that wouldn't work. Many of them did not display the number at all. Some displayed both the number and the "Fizz" or "Buzz". The most common issue was one in which if the number was a multiple of 15, it would exhibit incorrect behavior, such as printing FizzBuzzFizzBuzz instead of just "FizzBuzz". The issue was not necessarily an inability to code (although I did see some that would not compile; missing semicolons, etc.) but a failure to take the time to fully understand the requirements and ensure that their solution met each of them. And these were the people who had the arrogance (confidence, if you prefer) to see someone post "Here's an incredibly easy problem and if you can't do this you suck", and write a response to it without error checking. Edit for answer: This is far and away my most viewed and upvoted answer, so just in case anyone out there is looking to hire a junior Java dev, here's my take on it, knowing that the purpose of questions like this is to gain insight into a programmer's mental process. To begin with, clarifying business requirements is always the first step. Does the interviewer want each number/word on a separate line? Printed to console? Is the interval inclusive, exclusive, left inclusive or right inclusive? Next I would spend about a minute or two examining the algorithm, and I came to the same "mirage" conclusion as Gale McDowell. Since there's no clever way to solve it, I'm instead going to spend my time proving that not only can I program, but I can program in a professional environment. First of all, 3 and 5 are magic numbers, so they belong in constants. So are 1 and 100, for that matter. If we never ever wanted to change any of those, the most efficient solution would be to solve the problem once, and then cache it as a string and print it every time. Next, the algorithm itself. The simple and obvious solution has a high cyclomatic complexity in comparison to the difficulty of the algorithm (up to 5 deep) and, while it is perfectly clear, I still think it's ugly. It's hardly resource intensive, so instead of fighting for efficiency or fewest lines of code, I'm instead going to demonstrate both a little more of my knowledge of the language and my preference for semantic solutions. There are four possible states, which is a perfect condition for an enum. I think it's a toss up as to whether or not an enum makes this particular case any clearer, but I like enums. What is printed is a separate concern from the looping process, so it should be a separate method. I know some people hate switch statements in all cases, but I think this is an appropriate situation for one. And so I end up writing this: TonyFizzBuzz for Java Code Example It took me maybe five minutes to type up, after about three minutes of reasoning. Then I cheated a little by taking another minute or two to add in the possibility of giving different bounds from the command line, because I thought it made it more interesting. But then again, YAGNI. It's certainly much longer than most solutions, but each method does exactly one thing, the magic numbers are extracted, the four cases are semantically defined. If this was part of a larger project, I would externalize the string literals for localization or easy modification. I don't like that adding or removing a case requires changing three separate methods. But I definitely did not like the idea that adding a case in the more typical solution would require adding another nested if, in the middle of the if statement hierarchy. I also don't like that I pass i to both methods. I think I could solve both of those issues with multiple inheritance, but that would be way too much overhead, and more time than I would have in an interview. For a more complicated problem that followed this general pattern I would definitely consider it, though. I also did not add a copyright statement or a class definition javadoc, which I would do if I was writing professionally. Updated 13w ago â€¢ View Upvotes