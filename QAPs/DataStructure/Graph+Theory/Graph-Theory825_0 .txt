How do you implement the shortest path in a weighted graph using a dijkstra and bellmaan-ford algorithm?These two algorithms are quite different, Dijkstra's is used for positive weighted graph only but Ford-Bellman's can be use on all kind of weighted graph. Here are the implementation in C++ : But you will need to understand these algorithms and not just use the code because you might need to change it a bit to fit your graph and your modifications. #include <queue> #include <vector> using namespace std;  const int NB_NODE_MAX = 100;  struct Node { int index; int weight;  bool operator < (const Node &other) const { if(weight < other.weight) return false; else return true; } };  vector <Node> neighbour[NB_NODE_MAX]; bool saw[NB_NODE_MAX];  int dijkstra(int begin, int end) { priority_queue <Node> queue; Node init, current; int iNeighbour;  init.index = begin; init.weight = 0;  queue.push(init); while(!queue.empty()) { current = queue.top(); queue.pop();  if(current.index == end) return current.weight; if(saw[current.index]) continue;  saw[current.index] = true;  for(iNeighbour = 0; iNeighbour < neighbour[current.index].size(); ++iNeighbour) { if(!saw[neighbour[current.index][iNeighbour].index]) { Node newNeigh; newNeigh.index = neighbour[current.index][iNeighbour].index; newNeigh.weight = current.weight + neighbour[current.index][iNeighbour].weight; queue.push(newNeigh); } } }  return -1; } The graph is stored here as an adjacency list. And for the other one : const int INFINITE = 1000000000; const int NB_NODE_MAX = 100; const int NB_EDGE_MAX = 100;  struct Edge { int node1; int node2; int weight; };  int nbNode, nbEdge; int bestPath[NB_NODE_MAX]; Edge edge[NB_EDGE_MAX];  int fordBellman(void) { int iNode, iEdge, iStep; bool isModified;  isModified = false;  for(iNode = 1; iNode <= nbNode; ++iNode) bestPath[iNode] = INFINITE; bestPath[nbNode] = 0;  for(iStep = 0; iStep <= nbNode; ++iStep) { isModified = false; for(iEdge = 0; iEdge < nbEdge; ++iEdge) { int node1, node2, weight;  node1 = edge[iEdge].node1; node2 = edge[iEdge].node2; weight = edge[iEdge].weight - bestPath[node2];  if(weight < bestPath[node1]) { bestPath[node1] = weight; isModified = true; } } }  if(isModified) // Improving cycle return -1; else return bestPath[1]; } Here the graph is stored as a list of the edges. I hope this helps ! 258 Views  View Upvotes