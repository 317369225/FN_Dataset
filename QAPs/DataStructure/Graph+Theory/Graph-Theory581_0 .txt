Is there an algorithm faster than O(kn^2) for computing the single source k-step shortest paths on a weighted graph?An O(n^2 logn) or something faster?These two solutions also works for directed graphs: For every starting node u, you can first apply a kind of BFS up-to depth k to find a subgraph which contains all paths of length at most k starting from u: BFS(vertex u, depth k) if k > 0 and u hasn’t already been visited then add vertex u to our solution graph for every vertex v adjacent to u : add edge uv to our solution graph; BFS(v,k-1) else do nothing Then, by applying Dijkstra on this found graph, you have the lengths you’re searching :) Notice that vertices not available in this graph can’t be reached with paths of length at most k. This way, you have the minimal lengths using paths of length at most k starting from u, in onlyO(number_edge∗log(number_edge)).  O(number_edge∗log⁡(number_edge)). Even though this is not the fastest, a simple and beautiful solution is the following: consider your graph’s vertices are numerated from 1 to n. Now consider the n∗n  n∗n matrix M, such that M i,j   Mi,j is the weight of the edge between i  i and j  j , defined as +∞  +∞ if there’s no such direct edge betweeni  i and j  j , and 0 if i=j  i=j . We will now multiply matrices, instead that usual addition is replaced by minimum, and usual multiplication is replaced by sum. So, if AB=C  AB=C , thenC i,j   Ci,j is the minimum of all A i,k +B k,j   Ai,k+Bk,j for all k in {1,…,n}. It’s easy to recursively prove that, if we consider M k   Mk (the k-th power of M  M ), then M k i,j   Mi,jk is the length of the smallest path of at most k  k vertices from i  i to j  j , which is exactly what you search. You can easily compute M k   Mk using exponentiation by squaring, thus resulting in a O(n 3 log(n))  O(n3log⁡(n)) algorithm with a naive implementation of matrix multiplication. Notice how, if you want paths of length exactly k  k , you can simply set M i,i =+∞  Mi,i=+∞ 200 Views