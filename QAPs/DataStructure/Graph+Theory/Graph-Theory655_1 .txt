What is the brute force O(n!) algorithm for computing longest paths?Why does it run in O(n!) time? I'd guess that its something about enumerating all paths and choosing the largest?I'm aware of a Parametrized Dynamic Programming Algorithm that works in ~ O(n!)  O(n!) time. The Algorithm is basically a DFS that enumerates all Paths of a Graph. It ensures that ∀p  ∀p enumerated ∈G=(V,E)  ∈G=(V,E)   no cycles are chosen by inserting into a stack at every level AND avoiding back-edges. Literally, once all the simple paths are enumerated, the longest paths ∀(u,v)∈V  ∀(u,v)∈V are chosen. Notice that whenever we hit a Back-Edge, we do check if the distance has increased. As we are enumerating all paths in the Graph from a start vertex s∈V  s∈V , the worst case scenario is ∏ n−1 i=1 i=(n−1)!  ∏i=1n−1i=(n−1)! paths. Here is Wikipedia's explanation of the same: Longest path problem (Parametrized Complexity) Another clever way, is to use a reduction from the Shortest Simple Paths Problem as follows: ∀e∈E,w(e)=−1(w(e))  ∀e∈E,w(e)=−1(w(e)) . Now, run the SSPP Algorithm and that will give the Longest Simple Paths in a Graph. 196 Views · Answer requested by 1 person