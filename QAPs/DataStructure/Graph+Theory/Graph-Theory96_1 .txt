Is it possible to solve a coin change making problem for some cyclic elements through dynamic programming if using adjacent coins is disallowed?I have an array of different type of coins such as a[] = {1,2,5,20}. Now, I want to pick minimum number of coins to make a certain amount of money where first and last element of the array is considered as consecutive element and no consecutive coins can be selected. How can I solve this problem?It’s easier to solve if you don’t consider the first and last elements to be consecutive. The simple dynamic program has a 2-dimensional array where A[n, k] is the minimum number of coins needed to reach value exactly k using the first n coins. Note that A[n, k] could be infinite if there’s no way to make change for k with the first n coins. Now, to find A[n, k] we consider how many of the nth coin you take. We’ll say the value of the nth coin is a(n) to avoid worrying about off-by-one issues. If you don’t take any of the nth coin, you just need to make change as best you can with the first n-1 coins, so look up A[n-1, k]. If you use c of the nth coin, you’re restricted to using the first n-2 coins, so you need to look up A[n-2, k-ca(n)] and add c to the value to find the minimum number of total coins needed for this case. Do this for every value of c where k up to k/a(n). A[n, k] is the minimum of all the values A[n-1, k] and A[n-2, k-ca(n)] + c you’ve computed here. Now you can solve the problem with dynamic programming, except you might end up using both the first and last coin. To fix this issue, you can either add another dimension to your table to indicate whether the first coin is used and make your code check that during the last coin phase or you can run your algorithm twice, once with the first coin removed and once with the last coin removed to ensure they’re not both used. 130 Views · View Upvotes