What is the brute force O(n!) algorithm for computing longest paths?Why does it run in O(n!) time? I'd guess that its something about enumerating all paths and choosing the largest?Let's assume what we're looking for is the longest simple path; in other words, no vertex appears twice. Whatever the longest path is, it can be written as the sequence of vertices that the path visits, and consecutive vertices in the path will have an edge between them. In other words, it's sufficient to generate every permutation of up to n n vertices, verify that permutation is a valid path by verifying consecutive vertices, calculating the path length, and keeping the longest one found so far. Clearly we can make some shortcuts, for instance we can just generate all permutations of length exactly n n , measure to the first missing edge, and can skip ahead through the permutations beyond that missing edge - but overall there will be O(n!) O(n!) permutations to check. Pretty much exactly the sort of brute force algorithm you'd expect... and, in the absence of any additional information or restrictions about the graph, you would also expect not to be able to do significantly better - the problem is NP-hard, essentially because the only way you can verify a longest path, is to check all of them. 215 Views  View Upvotes  Answer requested by 1 person