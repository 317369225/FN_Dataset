How do I find and enumerate the number of perfect matchings in directed complete graphs?I would like to enumerate All the 1-factors or perfect matchings, of the complete directed graph Kn (the number of vertexes is even ) if there is an algorithm or method to enumerate all the perfect matchings?Assumptions: We are given a complete, directed graph with 2n  2n vertices, where n∈N  n∈N . We wish to find an efficient way to get the number of perfect matchings possible in the graph. We also wish to find an efficient way to enumerate all the perfect matchings possible in the graph. Answer: The number of perfect matchings possible in the graph is 2 n ∏ n i=1 (2i−1)=(2n)!n!   2n∏i=1n(2i−1)=(2n)!n! . This is because, for the first vertex, it has 2(2n−1)  2(2n−1) choices for an edge (×2  ×2 since it could be either the source or destination of the edge). For the second edge, we again pick an unused vertex, which will have 2(2n−3)  2(2n−3) choices for an edge. We repeat this procedure for n  n edges, picking up a factor of 2 n   2n as well as all odd natural numbers less than 2n  2n . The below Python script shows how to efficiently enumerate all the perfect matchings in a complete graph by utilizing backtracking and recursion. It also shows how to efficiently compute the number of perfect matchings in a complete graph, which it verifies against the enumeration. For example, here are the 2  2 and 12  12 perfect matchings it found for n=1  n=1 and n=2  n=2 , respectively: [[(0, 1)], [(1, 0)]] [[(0, 1), (2, 3)], [(0, 1), (3, 2)], [(1, 0), (2, 3)], [(1, 0), (3, 2)], [(0, 2), (1, 3)], [(0, 2), (3, 1)], [(2, 0), (1, 3)], [(2, 0), (3, 1)], [(0, 3), (1, 2)], [(0, 3), (2, 1)], [(3, 0), (1, 2)], [(3, 0), (2, 1)]] def main(): maxNodes = 10 for numNodes in range(2, maxNodes, 2): computed = computeNumPerfectMatchings(numNodes) perfectMatchings = getPerfectMatchings(numNodes) print str(perfectMatchings) assert computed == len(perfectMatchings)   def getPerfectMatchings(numNodes): return helpGetPerfectMatchings(numNodes, 0, list(), list(), [False] * numNodes)   def helpGetPerfectMatchings(numNodes, lowerNode, perfectMatchings, currentMatching, usedNodes): if len(currentMatching) == numNodes / 2: perfectMatchings.append(tuple(currentMatching)) return perfectMatchings usedNodes[lowerNode] = True lowestNextLowerNode = -1 for secondNode in range(lowerNode + 1, numNodes): if not usedNodes[secondNode]: usedNodes[secondNode] = True if lowestNextLowerNode == -1: lowestNextLowerNode = secondNode nextLowerNode = lowestNextLowerNode while nextLowerNode in usedNodes: nextLowerNode += 1 for edge in ((lowerNode, secondNode), (secondNode, lowerNode)): currentMatching.append(edge) helpGetPerfectMatchings(numNodes, nextLowerNode, perfectMatchings, currentMatching, usedNodes) currentMatching.remove(edge) usedNodes[secondNode] = False usedNodes[lowerNode] = False return perfectMatchings   def computeNumPerfectMatchings(numNodes): toReturn = 2 for thisMult in range(3, numNodes, 2): toReturn *= 2 * thisMult return toReturn   if __name__ == '__main__': main() 288 Views · View Upvotes