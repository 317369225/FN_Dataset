If we don't require paths to be simple, is computing longest paths in the complexity class P (polynomial time)?Consider the alg: if there is any cycle then one has solved the longest path problem to all nodes reachable from that cycle (by finding any path to that cycle). For the nodes that don't have any cycle reachable, we have a acyclic graph, which is solvable by DP.I'm going to interpret this problem as requiring us to either output the longest path in the graph, or report that it is infinite, because there exists a positive-weight cycle somewhere. I think what you're saying is an insightful way of looking at the problem. Yes, the longest path problem is only difficult if you require that the path be a simple path. We can even make a more causal statement: this requirement is precisely what normally makes the problem difficult. In the context of an unweighted but directed graph, the graph either has cycles or is a DAG. If it has cycles, this can be detected in linear time and "infinity" can be reported; if it is a DAG, we can use dynamic programming to find the longest path in linear time. Either way, we solve the problem in linear time in this case. In the case of an undirected graph, we have to assume that we are not allowed to traverse an edge and immediately go back on it; otherwise, every undirected graph would have a cycle if it has at least 1 edge. Generally an undirected graph is deemed to be cycle-free if it is a tree. We can detect whether it's a tree or not in linear time, and if it is, we can find its diameter (longest path) in linear time as well. The more complicated case you might not have considered is if you have a weighted, directed graph. The difficulty here is that there may be cycles and still there may be a well-defined, finite longest path -- if the cycle has a negative weight. Here we need something a bit more sophisticated. We multiply the weights of all the edges by -1, and then find the shortest weighted path (or detect that there is a negative-weight cycle) using an algorithm like Bellman-Ford. Multiplying this path back by -1 yields the longest path. Note that this approach doesn't solve the "simple longest path" problem because it may simply return a positive-weight cycle (an infinite, non-simple longest path). The time complexity here is O(VE), which is poly-time. 220 Views  Answer requested by 1 person