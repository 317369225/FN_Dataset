How can I choose 5 of my Twitter friends in a way that maximizes the number of distinct followers they have?Assuming that I have an array of twitter users and their followers, and I want to identify 5 users who have the most number of unqiue followers such that if I ask them to retweet an advertisement for my product, it would reach the most number of users.This problem is tough to solve efficiently, but you can use a greedy algorithm to find an approximate solution.  The approximation will give you a set of 5 friends that collectively have at least 63% of the followers that the ideal set would.  This doesn't sound like a lot, but in practice it's quite good, and there are no efficient approximation algorithms that give better guarantees. In general, suppose you have n  n sets, possibly overlapping, and you want to choose the m  m sets that have the largest union.  (Each set would correspond to a user's followers.)  Then you should select the sets one at a time, at each step choosing the set that adds the most elements to the union.  The resulting collection will have at least (1−1/e)  (1−1/e) times the number of elements you could get if you chose your sets optimally. Why is that? Let A ∗ =s 1 ∪⋯∪s m   A∗=s1∪⋯∪sm be the optimal collection of sets.  Let A 1 ,A 2 ,…  A1,A2,… be the collections of sets that we have chosen so far on each step (where A m   Am is the output of the greedy algorithm, and A 1 ⊆A 2 ⊆A 3 ⊆…  A1⊆A2⊆A3⊆… ). Consider step k  k of the greedy algorithm.  Observe that |A ∗ |≤|A k ∪A ∗ |  |A∗|≤|Ak∪A∗| =(|A k ∪s 1 ∪⋯∪s k |−|A k ∪s 1 ∪⋯∪s k−1 |)+(|A k ∪s 1 ∪⋯∪s k−1 |−⋯−|A k ∪s 1 |)+(|A k ∪s 1 |−|A k |)+|A k |  =(|Ak∪s1∪⋯∪sk|−|Ak∪s1∪⋯∪sk−1|)+(|Ak∪s1∪⋯∪sk−1|−⋯−|Ak∪s1|)+(|Ak∪s1|−|Ak|)+|Ak| =|A k |+∑ k i=1 |(A k ∪s 1 ∪⋯∪s i−1 )∪s i |−|A k ∪s 1 ∪⋯∪s i−1 |  =|Ak|+∑i=1k|(Ak∪s1∪⋯∪si−1)∪si|−|Ak∪s1∪⋯∪si−1| Now an interesting property of sets is that if you add a set to a small set, it will probably add more elements than if you'd added it to a larger set, because with large sets there's the risk that some of the new elements have already appeared in the set, and shouldn't get counted twice.  Formally, if T⊆T ′   T⊆T′ , then |T∪S|−|T|≥|T ′ ∪S|−|T ′ |  |T∪S|−|T|≥|T′∪S|−|T′| . Knowing this, we can simplify our inequality to ≤|A k |+∑ k i=1 |A k ∪s i |−|A k |  ≤|Ak|+∑i=1k|Ak∪si|−|Ak| Now remember that we're using the greedy algorithm, so the set A k+1   Ak+1 will be the elements from the set A k   Ak , plus the set that would introduce the most new elements.  So |A k ∪s i |−|A k |  |Ak∪si|−|Ak| is always ≤|A k+1 |−|A k |  ≤|Ak+1|−|Ak| . So now we have |A ∗ |≤|A k |+k(|A k+1 |−|A k |)≤|A k |+m(|A k+1 |−|A k |)  |A∗|≤|Ak|+k(|Ak+1|−|Ak|)≤|Ak|+m(|Ak+1|−|Ak|) .  With some algebra, this inequality can be written as |A ∗ |−|A k+1 |≤(1−1/m)(|A ∗ |−|A k |)  |A∗|−|Ak+1|≤(1−1/m)(|A∗|−|Ak|) ≤e −1/m (|A ∗ |−|A k |)  ≤e−1/m(|A∗|−|Ak|) So we get |A ∗ |−|A m |≤e −m/m (|A ∗ |−|A 0 |)  |A∗|−|Am|≤e−m/m(|A∗|−|A0|) , and |A m |≥|A ∗ |(1−1e )  |Am|≥|A∗|(1−1e) , meaning the output of the greedy algorithm is guaranteed to yield at least 1−1/e  1−1/e of the optimal value. References: [1] When Greedy Algorithms are Good Enough: Submodularity and the (1 - 1/e)-Approximation 5.8k Views · View Upvotes · Answer requested by A. Mustafa