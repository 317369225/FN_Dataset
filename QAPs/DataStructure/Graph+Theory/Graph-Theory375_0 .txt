Given an N vertex weighted graph, if we can change the weight of K of the edges to zero, what is the shortest path from 1 to N?Thank you for this interesting problem :) First of all, bad news : the problem as it is stated now is NP-complete (easy proof : take an unweighted graph, put a weight of -1 on every edge, and now by using your algorithm with k=0 on every pair of vertices and taking the minimum you have a reduction of hamiltonian path on initial graph). However, there are simple restrictions that makes it solvable in polynomial time; if all edges have positive weight, for example. Let's suppose that all weights are positive. Let's call G your positive-weighted oriented graph and M the number of edge (note that M can be as high as O(N²)) (my algorithm works for oriented graphs, but you can easily emulate a non-oriented edge with two oriented edges). We will also add, for practical purpose, an edge (u,u) with weight 0 for each vertex u. Here is a solution in O(k(N + M)log(N + M)) : First of all, let's work on (k+1) copies of G i.e. you now have a graph G' with (k+1)N vertices and (k+1)M edges. Intuitively, being on vertex u of the i-th of the (k+1) copies of G will represent being on vertex u after having used i of your k weight reduction. To achieve such a thing you will add kM edges to G' : for each edge (u,v) of G and for each 0 <= i < k, you add a edge from the vertex u of the i-th graph to the vertex v of the (i+1)-th graph with a weight of 0. Using one such edge will be equivalent to «skipping» it, which you can do at most k times (you win one level doing so, and there are (k+1) levels). Then, you simply use Dijkstra’s algorithm to find a shortest path from 1 to (k+1)N, which is your answer. Note that there is a «simpler» dynamic programming algorithm which is equivalent to applying Bellman-ford instead of Dijkstra, but then complexity becomes O(kNM)... 317 Views · View Upvotes