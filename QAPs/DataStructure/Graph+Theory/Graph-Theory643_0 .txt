How does the BFS algorithm work in MapReduce code?What you need to understand is that one round of map-reduce with this code will do one parallel step of BFS. At the end of each round, we'll have the correct distance for each node within k steps of the start node, plus its adjacency list. At the end of the round, we'll have the correct distance for each node within k+1 steps of the start node, plus their adjacency lists. So this will need to run as many times as the diameter of the graph. The initial state will give 0 distance for the start node and MAX_INT - 1 (to avoid overflow when adding 1) for all others. The goal of the mapper is to find next distances from a given node. For nodes other than the given node, the list is null because the mapper does not know the adjacency list. For the given node, it outputs the adjacency list together with the current min distance because otherwise we won't have the adjacency list for the next step. This could be made a bit more efficient by keeping track of which step we're on and only outputting next nodes when the minimum distance equals the step number, but it's good enough to demonstrate the basic idea. The reducer needs to be a little complicated because it needs to find the minimum distance from all the distances found in this step, plus pull out the adjacency list because it'll be needed for the next round. This could be made simpler using a different style of pseudocode to simply get the min value in one line and the adjacency list in another, like minDist = min(dest.distance for dest in values) links = find(lambda x: x != null, [dest.links for dest in values]) the code you've shared appears more to be an attempt at actual Java syntax than pseudocode. 577 Views  View Upvotes