How is this Big-theta graph for a linear search algorithm possible?Trying to follow along with this tutorial[1] - how is it possible for the running time to be higher when n is smallest then lower momentarily as n grows? Also, what are some practical examples of what constants k1 and k2 could actually be in this example? Footnotes [1] Khan AcademyBig-O notation (which is a general term covering O(f(n),Θ(f(n)),ο(f(n)),Ω(f(n))  O(f(n),Θ(f(n)),ο(f(n)),Ω(f(n)) , etc) is concerned with the growth of the function when n  n is large. To say that f(n)=Θ(g(n))  f(n)=Θ(g(n)) means that there are two (positive) constants a,b  a,b such that for some N  N , if n>N,ag(n)≤f(n)≤bg(n)  n>N,ag(n)≤f(n)≤bg(n) . As an example, consider f(n)=45n+100sinn  f(n)=45n+100sin⁡n . This function fluctuates wildly, but I can state with certainty that when n>200,44n<45n−100<45n−100sinn<45n+100<46n  n>200,44n<45n−100<45n−100sin⁡n<45n+100<46n , so I can therefore claim that 45n+100sinn=Θ(n)  45n+100sin⁡n=Θ(n) . The two constants are a=44,a=46  a=44,a=46 . To take a more realistic example, consider the selection sort: [code] int[] SelectionSort(int[] array) {   var n = array.Length;   for (var i = 0; i < n; i++) {     var largest = i;     for (var j = i; j < n; j++) {       if (array[j] > array[largest])         largest = j;     }     var temp = array[i]; array[i] = array[largest]; array[largest] = temp;   }   return array; } [/code] This code does n(n−1)2   n(n−1)2 comparisons, and n  n swaps. If each swap takes time s  s and each comparison time c  c , and there's time d  d overhead that is done once each time this function is called, regardless of how big the array is, then the total time used is T(n)=n(n−1)2 c+sn+d=c2 n 2 +2s−c2 n+d=Θ(n 2 )  T(n)=n(n−1)2c+sn+d=c2n2+2s−c2n+d=Θ(n2) . I can tell that, for large n  n , the first term is going to be the dominant term. Any time when n>2sc   n>2sc the first term is going to be larger than the second, and when n>d|2s−c|   n>d|2s−c| the second term is going to be larger than the third. So for large n  n , I can tell that c4 n 2 <T(n)<cn 2   c4n2<T(n)<cn2 , so T(n)=Θ(n 2 )  T(n)=Θ(n2) . I actually don't care in this analysis what the exact value of N  N needs to be, nor what the exact values of a,b  a,b are.  I can compute it, but as you can see, it depends on the exact nature of the implementation. 25 Views · View Upvotes