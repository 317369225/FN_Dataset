If advanced algorithms and data structures are never used in industry, then why learn them?I and people I know have never used any advanced algorithms or data structures in industry and some of us have 20 years of experience in industry. How do you motivate yourself to learn advanced algorithms and data structures or, for that matter, go for Programming contests etc..
Congratulations. I have just tossed your resume in the "no" pile and am muttering to myself about how kids like you are what's wrong with this industry and why I have to retrain every engineer I do hire. You probably think that databases are magic, too. Just throw another index in there and all your problems are solved, right? Why am I doing this? Am I just a grumpy old man who likes putting arbitrary obstacles in front of potential hires? The answer is quite the opposite, in fact. If you have studied and are a trained engineer (note how I keep using that word), you will find the interview process shockingly easy. I'm asking some amazingly simple questions like "write FizzBuzz" or "is JavaScript a functional language?" There are a few super-difficult questions in the phone screen that I don't actually expect you to get. They're there to entice you about the things you will learn working for me. So if I'm not throwing arbitrary barriers in the way, what am I doing? The answer is that I'm designing systems to provide analytic answers from petabyte scale data. Now that Google has everyone convinced that they can search the entire internet as they type, I have to provide similar performance in my web application. Accomplishing this is incredibly difficult. A simple lookup of the specs on even EMC SAN disks tells me that I don't have enough throughput. I can ask for some more expensive Infiniband hardware, but I don't work for Google. We're on a budget here. I need to find a way to take a bunch of cheap boxes and get them to perform together at interactive speeds. One super-powerful box can't do it, but maybe a bunch of IO in parallel can do it. Now all I need to do is ask my engineers to write some query code against these structu... Damn. One of them just tried to load the entire set into memory and blew the stack on the entire infrastructure. We're rolling back his code. He's saying that the code worked in his testing and he doesn't understand why it failed. I shake my head, take him to the whiteboard and explain the concept behind memory being like a data reservoir that can only hold so much. A straight pipe through (i.e. Streaming) is limited only by time (rate of data movement) rather than capacity. He says he understands and will avoid that mistake next time. Maybe he will, may he won't. The mental capacity to handle complex computational problems is rare. Many people exhibit the potential, few realize it. Especially in this world of silly ideas like "why do I need to learn data structures and algorithms?" I may ultimately have to fire him. Which is too bad because I otherwise like him. He just can't do the job. What you need to understand is that your attitude is self-selecting you for jobs that match your ideas of what programming is. However, these are not the fun jobs nor are they the ones that pay really well. Nor are you as likely to do something truly important. If you're ok with just being a low-paid programmer and eventually exiting your profession to do something else, then don't learn algorithms and data structures. If computer science really well and truly excites you, then you know what to do. Follow upFirst off, let me thank everyone for their overwhelming interest in this post! Even those of you who were critical of its content invested in reasoned responses which has kept the dialog going. I am humbled to be at the center of such an important topic. Second, I would like to address those of you who raised concerns on the harshness of this post. When I decided to respond I wanted something more impactful than the answers that had come before. Some of the answers were very good, but none of them had a visceral connection that a young person could grab onto and understand. Much as a movie seeks to make a connection with its viewer by presenting a situation in a "raw" form, so was my goal with this post. Another form of concern I received was that this was a literal story. Please understand that this is only a distillation of the situations I deal with. The specific circumstances have all happened, but not in the order you see here. For example, the last time I had an engineer check in an ArrayList buffer in the middle of streaming code he was not at risk of being fired. He is actually a pretty good engineer and just wasn't thinking at the moment. His code was caught in code review and did not make it to production. I did give the training on data reservoirs to him and his colleagues to help them internalize the concept better in the hopes of preventing the same mistake again. Firing people is a difficult thing. You have to start with "what am I doing wrong?" and "how can I fix the situation?". It usually involves a long process of trying to meet the individual where they're at and finding learning styles that work for them. A lot of people are responsive to good leadership and training. Some appear to be beyond my own ability to reach. Since the focus is on trying not to hire poor fits in the first place, most of those that I have had to dismiss are poor fits for my team (i.e. social issues that don't improve) or fail to retain the things they learn over the long term. The latter situation is difficult for me as an empathetic leader because they'll appear to get better before falling back to their previous levels of performance. Thankfully it's a rare circumstance, but nevertheless poignant. I will stop here to say that some of the best engineers I ever had were those that had little experience in building scalable code but were excited by the opportunities presented to them. In some cases these individuals were more driven to learn and improve than someone who believes themselves confident in their own skills. It is far from a hard and fast rule; just an interesting observation. Third, I noticed some who argued my experience is the exception that proves the rule. To which I would point you to the section on "self-selecting attitudes". The reason why I often have to hire less skilled engineers is because bigger companies than mine (Google, Orbitz, NavTec, SalesForce, etc.) are sapping up these engineers as fast as they can get them. Big Data has created a MASSIVE demand for skilled engineers which has resulted in an overall deficit in the marketplace. Which is why I have to take risks in hiring and hope the training I provide is sufficient. We're all picking up the scraps that remain and hoping we can forge these hires into something impressive. That's good for software engineers, but only if you're willing to recognize that Computer Science and understanding how things work under the covers is important. Otherwise you're going to get weeded out in the phone screens and probably never understand why. Finally, some of you have expressed interest in working in the environment I described. I am hiring at the moment, so feel free to contact me if you are in the Chicago area and think you are a good fit. To give you an idea of what you'll be getting into, I work in the Healthcare Analytics space. Transactional code is easily the 95% of the industry and where most of the off the shelf libraries and software is focused. Analytics is the 5% and is thus poorly served by a handful of BI tools. Those tools tend to fall down in my industry because we care a lot about the detail of the data (i.e. the individual patients) and use summarizations as a mechanism for finding those cases rather than as an end to themselves. This creates a host of challenges that I could go on and on about for hours. Suffice it to say that you will have to understand the mind of database optimizers, you will be working on custom predicate engines at large scale, you will be developing custom OLAP logic, and you will go back and forth between being terrified about the complexity of problems and triumphant when you solve them. Updated 8 Sep â€¢ View Upvotes