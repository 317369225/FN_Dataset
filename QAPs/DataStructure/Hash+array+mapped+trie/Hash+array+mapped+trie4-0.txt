How does functional programming knowledge improve imperative programming, software engineering, and system architecture?How does knowledge of functional programming improve one's skills even when it is not used directly?
I think there are several ways that learning functional programming makes you a better imperative programmer. Functional programming teaches you techniques that can be useful even in the most imperative of languages. As Eric Pepke points out, avoiding mutation can be good. Mutation is often a kind of side-channel for non-local communication between different parts of your program, and non-local things are usually harder to understand. In many cases, avoiding mutation in Java can pay off just as much as avoiding mutation in Haskell. (Avoiding mutation in non–garbage-collected languages, such as C, is harder, but it can be possible and worthwhile.) Another useful functional technique is recursion. Not that recursion isn’t a part of imperative programming, but functional programming forces a familiarity and comfort with recursion, whereas sometimes in imperative programming it’s treated as an advanced technique. If recursion is an easy and accessible tool for you, then when it comes up in a non-functional setting, you’re ready to go. To the extent that functional languages are often products of academic computer science, and that mainstream languages sometimes adopt language features from academia, knowing more about functional programming keeps you ahead of the curve. For example, generics arrived in Java in 2004, but functional programmers have had (more or less) the same thing (called “parametric polymorphism”) since 1982. Similarly, functional programmers had automatic memory management and software transactional memory before these arrived in the imperative/object-oriented mainstream. Finally, learning to think differently about programming makes you a better programmer. Becoming competent in Haskell, Scheme, Standard ML, Racket, OCaml, or Common LISP will make you a better Java, Python, C, Ruby, C#, or JavaScript programmer. Updated 22 Jul • View Upvotes • Asked to answer by Miguel Paraz