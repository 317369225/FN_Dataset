Is object immutability in functional programming inherently performance intensive?
The naive way of achieving immutability can indeed be expensive. You'll have to copy the whole structure which wastes time and memory. However, functional languages use a concept known as structural sharing where different "versions" of an object share as much structure as possible to avoid copying a lot of data. They use clever implementations of data structures, known as persistent data structures, to allow for fast operations while achieving immutability. For example, the immutable vector in Clojure does insertion and look up in O(log 32 n)  , which can be thought of as almost O(1)  due to the large base of the logarithm. The persistent Clojure data structures are pretty fast, and I am sure other functional languages have fast implementations as well. All that being said, mutable data structures are still faster, and sometimes you need to get as fast as possible in a functional language without sacrificing purity and immutability. Different languages let you deal with that in different ways. In clojure there's the Clojure - transients, which lets you use mutable data structures in very restricted contexts to gain better performance. Of course the best source of persistent data structures is Chris Okasaki's book that others have already mentioned. 