How does functional programming knowledge improve imperative programming, software engineering, and system architecture?How does knowledge of functional programming improve one's skills even when it is not used directly?
Functional programming espouses some vales which can be adopted in imperative programming as well. All of them may not be enforced by the language or the compiler or the type system that the imperative language has. But many of them can be used as conventions or best practices (or design patterns if you wish). Not in any specific order these are: Immutability - Immutable data structures are pure and can be used without any synchronization in a concurrent setting. This is a huge benefit that the functional languages offer. A bigger step is to make these data structures persistent, which implies that you can retract back to any of the previous versions of the data structures. This has been inspired mostly from the works of Phil Bagwell (Hash Array Mapped Trie) and has found widespread use in Clojure and Scala. Persistent data structures are also available in Java through third party libraries and are mainly inspired from functional programming. Isolating side-effects - Controlling side-effects has been one of the strongest forces of functional programming. Haskell does it the most idiomatic way through the type system. All functional languages also encourage decoupling side-effects from pure functions. The advantage is that the pure functions can be easily unit tested, reordered and more easily distributed across multiple cores of your CPU.Â  Modularity - This is somewhat a corollary of #2 above. Isolating side-effects from pure functions leads to better modular organization of your code base. This is something which can be used in imperative programming as well.Having said all of the above, some people are of the opinion that Haskell is possibly the best imperative programming language as well with its sequencing abilities through monadic computations. For more details on this have a look at the paper Tackling the Awkward Squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell by Simon Peyton Jones (http://research.microsoft.com/en...). 