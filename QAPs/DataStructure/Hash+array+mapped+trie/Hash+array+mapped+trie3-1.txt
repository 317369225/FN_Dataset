Is object immutability in functional programming inherently performance intensive?
The short answer is "yes, but". Generally something like copy-on-write is used when a structure is updated.  If I have a record that contains three fields, x, y and z.  And I want to change z.  I have to create a new record, so that the old one can continue to exist (for other threads or so we can "go back").  I will use Haskell-like syntax. new_point = Point old_point.x old_point.y new_z Most declarative (functional & logical) languages will provide a nice way to say "use old_point but replace the z parameter with the new value".  I've just typed it out in full. As you mentioned in your question (thanks for the extra detail!) there are many benefits to immutability.  But I'm going to add one more.  Say you have an immutable data structure for your whole application, or at least for the user's session.  As the user makes changes you get new versions of this data structure, and if you save some of the old ones (for example for the last 100 changes) you can use these when the user clicks "undo".  You just go back to the previous state.  Making data immutable and state explicit has many benefits, which usually outweigh the drawbacks. So, can the compiler help optimise the program and remove some of the immutability? Yes!  It can do several things, and there may be others that I haven't listed: 1. If data is local only, it can be destructively updated.  If the compiler knows that the record being updated has not been shared (something called alias analysis) then it knows that a destructive update is safe. 2. A fast garbage collector.  Creating lots of immutable structures may seem costly.  But with a fast (or generational) garbage collector it's really very cheap—and potentially cheaper than manual allocation.  People have written books about this one point so I won't use too much detail.  But a copying or compacting accurate collector can be very quick.  So well tuned that the memory used for the extra immutable records that are created and immediately discarded may not even leave the processor's level 1 cache before being reclaimed by the collector. 3. Compiler optimisations such as fusion and deforestation.  Say you write code that looks like this: output = map f (map g (map h input)) This creates two intermediate lists that are immediately thrown away.  Because the compiler knows the semantics of map, and if the language is purely-declarative, it knows that it's safe to transform this code into: output = map (f . g . h) input This is semantically equivalent, but does not create the intermediate structures. On a related note there are issues when copying a structure has a high cost, for example an array.  Other people have written about how that can be avoided (Clojure persistent vector). Updated 23 Jan • View Upvotes