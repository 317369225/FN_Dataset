How does functional programming knowledge improve imperative programming, software engineering, and system architecture?How does knowledge of functional programming improve one's skills even when it is not used directly?
Some of the previous answers mention specific features of functional programming (pure functions, immutability, isolating side-effects, etc.) but I would like to tackle your question in a different way. It is not just about specific features of functional programming that you may or may not be able to use in your imperative programming language of choice. It is also about the mindset and wider knowledge that you get from learning other programming paradigms (not only functional, but also logical, different kinds of object oriented programming - class based vs. prototype inheritance, etc.) even though you do not directly use them. You see, if you only know one programming language (paradigm), you look at every problem from the viewpoint of your language and try to solve it in the way that is idiomatic for that particular language. As they say, if you only have a hammer, everything looks like a nail. If you don't know any other language (paradigm), it becomes such a hammer and you try to force solutions that might not be particularly appropriate. If you knew other ways to solve the problem, you might be able to solve it more easily. Now this isn't necessarily about using a different language (paradigm) for the problem, you may as well stick with the one you are most comfortable with. But knowing different ways of solving problems will change also your way of programming in the original language that you use. I'm not sure if what i have written is clear, so let me use an example from my personal experience. I professionally program in PHP (web development) but thanks to my interest in functional programming I have changed the way I program in it. Now, I still do object oriented programming in PHP, but for example I try to use higher-order looping functions like array_map, array_filter or array_reduce, because after working with their equivalents in Erlang, I find them much more understandable because you know their higher semantical meaning right upon seeing them instead of having to track what I do in a foreach loop. I also tend to break the code into functions that are more concise, focused and minimize side-effects, which all happens to be more testable (TDD). Of course, I would try to do that even without my experience with functional programming, but when you stick with some language for too long, it is sometimes difficult to see the flaws in your code and to really change your programming style. You always tend to fall back to old (bad) habits, because you find it easier to e.g. use global variable so that you do not have to use so many parameters. When you use a different language (paradigm), you will be forced to use different features and you will find that it is indeed possible to work without those bad habits. 