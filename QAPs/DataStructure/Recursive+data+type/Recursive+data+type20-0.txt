What is it like to learn Haskell without any prior programming knowledge?
I am going to have to be "that guy" and disagree with most of the previous answers. I am someone with a fair amount of experience both teaching Haskell, and programming in Haskell. I learned Haskell after about 8 months of being a programmer and immediately felt an affinity for the language. There isn't the need to understand anything about programming to learn Haskell. Yes, Haskell is a very different language than C++, C, C#, Java, JavaScript, Python, Perl, Go, Ruby, and the list goes on. The reason it seems so different is that most "mainstream" languages share common heritage and frankly aren't very different from each other. People develop this sense that they have learned "lots" of languages, but the differential between each of these languages is relatively small compared to Haskell. In most cases there are not many new ideas (notice I place importance on ideas, not syntax or slight adaptions of different features) introduced by these languages. For example all of these languages use looping constructs as their primary iteration mechanism and you can evolve from a C style loop with explicit indices, to C++ style loops with iterators, to Python style foreach loops or to Ruby style enumerators. At no point do you really need to internalize a brand new idea. In Haskell we only use recursion, this at first might seem to make everything more complicated and confusing, but once you understand recursion you need no other tool, as it generalizes all other iteration constructs. So often when an existing programmer moves to Haskell they complain how alien it seems.  Compared to the other languages you know it's going to feel unfamiliar, and unlike what many people associate "programming" with, precisely because you have very little prior knowledge to lean on. This isn't unique to Haskell; it is just a language with an extremely different set of design decisions. The space of popular programming languages is incredibly narrow-minded, ignoring decades of good ideas people have researched in programming language theory. Trust me: you would feel the same way if you move to a language like Prolog, APL, Forth or anything else off the beaten path. Another complaint from people learning Haskell is that the type system constrains possible programs (rightfully so!) and makes it harder to write code that is wrong. For what ever reason, many people treat type errors as an annoyance instead of a tool—some would call it a superpower. Haskell is useful precisely because it provides the ability to limit the number of wrong programs I can write (this is true flat out, although many people who don't understand type systems will tell you otherwise). Oftentimes for beginners it seems "easier" to write Python because it will accept many more programs even if they just crash at runtime. (This is not so wonderful when that happens at 2am and you are carrying the pager.) I have taught some very green programmers Haskell and they usually have no trouble picking up the language. It just requires them to gain a real understanding of what they are doing, instead of  blindly writing code until it seems to work. As a Haskell programmer, if you clearly understand the rules of the system, programs will always do what you expect, and this is why longtime Haskell programmers talk so highly of the language. Often I can even write code purely by type inspection. This sounds a little bit like black magic, but it's incredibly powerful. For example if you provide me with a function of the type a -> a, I instantly know there is only a single possible implementation, and no others will suffice. To wrap up, I strongly reject the idea that procedural programming is some how a perquisite to Haskell. Knowing how to use for-loops and ifs is not going to help you understand recursion and pattern-matching, and eventually you will have to learn them in the context of Haskell regardless of your previous knowledge. If you have an interest in Haskell: I encourage you to just learn it; it is a very consistent language, and once you understand its small, clean set of core primitives (data types, functions, let bindings, pattern matching) —many of which are shared concepts other functional languages—you can go very far in the language. The community is also very helpful and is always happy to help people learn about the language, tooling, and so on. Updated 19w ago • View Upvotes