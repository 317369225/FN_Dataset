What is the best method to understand recursive functions?
In general, what you are looking for is a problem with two characteristics. First, there is a simple case that can be done by inspection. Second, a large problem can be broken up into subproblems that require the same processing. One of the most common cases is processing a recursively defined data structure. Perhaps the simplest example is a linked list. A linked list has two parts, a head and a tail. The head contains some data, and the tail is a linked list. The simplest linked list is the empty list. This is the case that can be done by simple inspection. Your recursive function will mirror the recursive structure of the data. There is a check for the base cases. These branches contain no recursive calls. If you're not in a base case there is a recursive call for each recursive member of the data structure. To process a linked list, you have one recursive call. For a binary tree, you'd have two. So for a linked list, you have a single check for the empty list, and return the result you are looking for. If the list is not empty, you process the head of the list, then make a recursive call on the tail of the list. Example: summing the elements of a list of numbers C-like pseudocode: sum(list lst) {     if(lst is empty) return 0;     else     {         return list.head + sum(list.tail);      } } In a functional language you'd just use a fold, which does the recursion for you. e.g. (define (sum lst)   (fold + lst 0)) Included just for fun. If you don't know what that means, don't worry about it right now. But definitely look it up! This kind of recursion, where your function calls follow the self-references in the data type, is called structural recursion. Structural recursion is awesome because it is very straightforward to prove the correctness and termination of your algorithm, via induction. This is in contrast to generative recursion, where your function will make recursive calls on data that gets larger or more complex. Notice how we make the list smaller each time a recursive call is made. If we didn't do this, it would be much more difficult to prove that our algorithm terminated. For instance, here is another recursive function: void collatz(int n) {     if (n == 1) return;     else if (n is even) collatz(n/2);     else collatz(3*n + 1); } Notice how in the second recursive call, we are making n larger. This function is very difficult to reason about mathematically. In fact, if you could prove this algorithm terminated, you would have found a proof that has eluded mathematicians for quite some time (called the Collatz conjecture). May have gotten a little off topic here, but recursion gets me excited. Hope this was at least a little informative. 