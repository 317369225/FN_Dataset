Why should or shouldn't I use Swift to write OS X or iOS apps the Functional Programming way?
Actually it's not true to use an imperative language in Functional way and it's only an incorrect approach that peeps think that if one programming language has some Functional like stuff it's okay to use them in Functional way. Honestly imperative languages can not act like functional languages. Why? Haskell is a pure functional language. It means that the functions that you work with have not side effect meaning that they don't change states as opposed to imperative ones. Also, it means that if you send a parameter to a function and then send the same parameter to that function the result is the same. So you may ask how you get stuff from outside world(user)? Well, you use Monad which let's you have impure function in your code. As an instance you use do Monads to glue some stuff and then do manipulate them. If you dig deeper you will notice that Monad has three rules 1. Right identity 2. Left identity 3. Associativity. One of another thing that you should notice is type system. There is a huge differences in Haskell type system and Swift. So having closure in order to send anonymous function to another function or having mapping stuff like fmap(take a look at Swift standard library which states that fmap is swift implementation of Haskell's fmap) doesn't make an imperative programming language suitable for functional programming. So why Swift or other programming languages offer these stuff? Well, as a research imperative programming language designer did find out that having higher ordered functions or mapping stuff is helpful for a programmer even in an imperative programming language but they've never meant that it's suitable for functional programming. Another important thing is function application and currying. Well all functions in Haskell take only one parameter and you may say that how we have map :: (a -> b) -> [a] -> [b] which takes two parameters or how (+) function works? Well, it's done by currying. You may have Prelude> let ex = (+3) By taking a look at its type you will notice Prelude> :t ex -- a function that takes an int and result is int too ex :: Integer -> Integer Prelude> (+) <$> [1,2,3] <*> [4,5,6] [5,6,7,6,7,8,7,8,9] Having that, you also can eliminate the parameter which is known as Point-Free style. How would it work? It's based on Combinatory theory invented by Haskell Curry. Combinatory theory is equivalent to lambda calculus so every function can be written in Point-Free style. So let's say how imperative programming languages would work in this way? If they want to have these kinda stuff they would change their type system which at the end result to functional languages. Another thing is performance. Haskell is a lazy programming language. Meaning that it doesn't evaluate something till you say "Mr. I need those stuff." So working with big lists or other stuff would take you less time. How? Please take a look at this example 1. Prelude> :m + Control.Applicative 2. Prelude Control.Applicative> let x = [1..] 3. Prelude Control.Applicative> :t takeWhile 4. takeWhile :: (a -> Bool) -> [a] -> [a] 5. Prelude Control.Applicative> takeWhile (\x -> x <= 3) x 6. [1,2,3] Take a look at line 2. x is an infinite list meaning that from 1 to infinity. So if I want to manipulate the list it should have the content of the list right? Nope. Haskell is lazy so when I apply the lambda (\x -> x <= 3) to takeWhile function, takeWhile only go further until the condition will be false. So it only manipulate three items which you can see. Someone may say "WOW; Gorgeous" Actually it's. So this is laziness rule which you can find through Haskell. How would an imperative language would work in this way? I would ask you this question: If you have a special value and a function that takes one parameter and returns an special value how would you map that function to that special value?! It's easy in Haskell. Yes, I've used [[aCollection mappedCollection] name] for mapping name method to each element of aCollection and it's useful because it keeps me from writing strange codes like for-in for(id someThing in aCollection) {     [someThing name]; } or I've used this [1,2,3].map! {|item| item * 3} but it's useful in an imperative context but it doesn't mean if one programming language has these stuff means that it's suitable for functional programming. Another thing is tail recursion. Because of Haskell and because of performance in Haskell tail recursion and altogether all recursive are optimized which you can see if you run that recursive function on a 2^64 long list in Haskell and then do the same thing in an imperative language. So mostly functional DOES NOT work. I strongly recommend you to read this paper if you're still curious and want to know about stuff in greater depth. It describes the idea in more depth than me. The Curse of the Excluded Middle 