How can I learn to think like a functional programmer?
The best summary I've seen is that in FP you express truths, and in imperative programming you express steps. Depending on the problem, you can end up doing what looks like imperative programming in FP. I've found this is the case when the domain is "noisy," where I'm going through a structure and there are lots of cases to handle in the traversal (ie. one generalized rule does not suffice), and you can end up implementing step-like logic in response to those cases (think of a switch statement). However, when the domain is less "noisy," you think in terms of a sequence of operations, where the output of one function provides input to another, until you reach a point where you need to change state. At that point, you recurse with the new state, or call an outside function to provide the input you need in the current context. That's one thing I should mention: You change state by calling a function, not by making an assignment (at least if you're striving for pure FP). One neat way to relate to this was expressed in an article I read a while back, though I've since lost it. It said that the Unix command line can be seen in an FP context, if you use pipes. It said that conceptually it uses postfix notation, since output flows left to right, but it's a similar idea. Instead of saving the output of each process to a separate file (you can think of files like "variables" in an imperative language), and then using each file as input to the next invoked process, you link the processes together such that the output of one is the input to the next. The exception in the Unix environment being that you can't pass one process into another, and you can't do recursion (except inside a script). The point when I knew that I had gotten past a crucial threshold in understanding FP was when I was able to solve Exercise 1.11 in SICP. I wrote about it here: SICP Exercise 1.11: "There is no spoon". 