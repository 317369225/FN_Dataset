Is C++ a low level language?
The answer is: definitively, it is. Although C++ provides you with classes that enable you to build your own abstractions thus increasing the level of concepts you operate with, C++ still remains low level language. Why? For number of reasons: C++ lacks for garbage collection. When solving your domain problem you are constantly facing necessity to manage the objects you create. Helper constructions such as std::auto_ptr, std::unique_ptr and std::shared_ptr don't improve the situation significantly. Yes, they are much better than dealing with raw pointers, but you, as a developer of your domain, still need to think which one of them to use to avoid Circular reference and thus memory leak. On the other hand, because C++ has direct access to memory, implementation of garbage collection by itself is either tough or impossible task in general case, so, when coding in C++ you have to get ready for dedicating at least 20% of your thinking to resource management - a very low level and uninteresting task. The standard library of C++ is too poor. For example, only recently Regular expression became part of the standard. And this in modern world of interactive interfaces where string matching is used even more frequently than sum of numbers! So, when you code in C++ you have two options - either to look for some third party non-standard library that solves common basic tasks or to write your own. Particularly in corporate development third party libraries are often very unlikely option because of legal issues, so, the majority of C++ developers I've met end up reinventing their own primitives for very basic tasks oftentimes duplicating the code and making it poorly maintainable. During my career I've seen at least 7 implementations of string splitting in C++. String splitting! Exception handling in C++ is weird and poor. What's the idea of allowing to throw an integer? What can I do with it, if I catch it? Standard exceptions aren't much better. There's no stack unwinding like in C#, no possibility to interact with the point of code that threw the exception like in LISP, no contractual attempt to retry like in Eiffel. Exceptions in C++ are just a handy way to get away from the point where something looks wrong. As a result different libraries select different error handling policies and standards and during integration of those you have to write a really dull layers of wrappers translating from one standard to the other. By its very nature C++ operates with single object file. It does not care about modules, libraries, assemblies, manifests. This may be okay for a language that complies into code that runs both on desktop computers and satellites but this universality costs efforts to implement modules when you really need them. The standard just does not care about cross-module feature - can an exception be thrown from one module and caught in the other? Should different modules share std::type_info instances or not? How should classes be exported from a module? All these questions are not answered because within the framework of C++ standard they cannot be even stated - the standard does not care about the modules - it only cares about contents of single OBJ file. And OBJ file is a really very low level feature.So, yes. C++ is a very bad language for implementing huge applications. It may be good candidate for rewriting crucial parts (small parts!) of your algorithms but its efficiency in terms of high level domain driven design is far below average. 