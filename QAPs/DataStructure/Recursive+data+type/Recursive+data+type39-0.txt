What is the most common mistake using pointers in C?
I can think of two common mistakes off the top of my head. 1) De-referencing a NULL pointer Often in data structures like Trees or Linked lists or Stacks, Queues etc., one would need to access/read/print the value in a node. Typically, these are recursive functions and in the boundary condition, these nodes are non-existent - that is, you just used a NULL pointer to get to that node. Now, you are supposed to writeÂ  - if(pointer){         do something with the value *pointer;}else return; But often in a hurry, we write ////do something with the value *pointer;///// It is more plausible when you try to convert pseudo-codes to real C codes. Easy way to avoid is to practice this - every time you see a pointer being de-referenced anywhere in your code, check if the if not NULL condition is checked first. Else, you might get segmentation faults. 2) Accessing pointers without allocating it It causes confusion among students when to use malloc and when NOT to. For example, you have a structure, say for storing 3D coordinate. Let it be called point3D. You have defined a pointer in your main function as follows: point3D *p; Now, you have a function that returns a pointer of type point3D *. If malloc() is used within that function, you don't need to use malloc() in main. you can simply write p = function(); But often, you might want to put the function's code in main() itself. Then you have to allocate it first with malloc(). In any case, your pointer had to be allocated some memory in that function as well. To sum it up, declaring a pointer to a structure or data type is not enough. For example, the following is illegal int *x;*x = 12; You can understand why. You declared a pointer of type int *, but you didn't allocate it the 4 bytes of memory it needs; explicitly. However, the following is in adherence with C standard. int x;int *y;x = 12;*y = x; The variable declaration inherently uses memory allocation, and the pointer y points to an allocated memory. If you see languages like C++ or Java or any other OOP languages, they always use new() or an object constructor - it's their version of memory allocation so that you can put some data in objects. To sum it up, you can assign a pointer to an already allocated pointer. The memory allocation need not happen in main() or the current function - it can happen in a called function as well. But it has to happen at least once. Otherwise, if you de-reference it; it's as bad as de-referencing a NULL pointer. 