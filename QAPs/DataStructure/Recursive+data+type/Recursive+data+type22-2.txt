What are the high level programming languages?
A very quick introduction to programming. The absolute lowest level language possible is microcode. This is the language internal to a microprocessor. It's rather unusual to see a microprocessor that lets you work in microcode and even more unusual to see anyone use it. The lowest typical language is machine code. This is the language exposed to the system by the microprocessor. It's an operator followed by zero, one or two operands. On modern computers, it's stored in binary. Older machines could use octal or decimal storage. Next up is assembly. These days, it's written in ASCII, with human-readable names for operators and human-intelligible markup for the operands. It generally supports labels for easier reading. This is also a low-level language, but it's not as low as machine code. Two processors that perform the same operations but give them different machine code instruction values should run an assembly program the same. Simple imperative languages, which also form the grouping known as third-generation, are the start of the high level languages. These range between semi-portable to fully portable. In other words, the language makes no direct reference to how the microprocessor is going to do something, it only states what the outcome will be. So long as the language exists on another type of computer, then the program should run and produce the same results on that other computer. Up to this point, the level of the language is dictated by the range of potential environments it will run in, whether or not they actually exist. Beyond this, the level of the language is described in terms of how abstract the program is, how much the language hides implementation details and specific mechanics, and focusses on what you actually want done. They won't run on anything extra, their purpose is to make it practical to solve more complex problems. However, because a lot of detail is hidden, languages that are this high level can potentially make better use of hardware. The compiler can parallelize, restructure and reorder all it likes, provided it does what the program states. Fifth-generation languages pretty much died a death, but they were intended to be the logical conclusion of this development. Instead of writing programs, you wrote specifications or other wholly implementation-agnostic description. There would then be no assumptions, the language would take care of the bits people find very difficult to get right, repetitious tedium would be eliminated, reliability and security would be assured. You will observe that all the modern mainstream languages are third or fourth generation with added syntactic sugar. Turns out most of the promises were easier to meet other ways and specifications were just too hard even for a machine to implement. 