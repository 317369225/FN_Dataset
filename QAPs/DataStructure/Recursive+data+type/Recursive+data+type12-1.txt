What are your favorite tricks or hidden features of OCaml that you use?
To add a few things to Tikhon's list: There are two ways to open a module in a single expression. The first, as Tikhon mentioned is Foo.(of_string (combine_foos foo1 foo2)) The second is let open Foo in of_string (combine_foos foo1 foo2) I don't know how hidden a feature this is given that it's in the grammar, but I didn't always know about it. One extremely silly feature of OCaml (or the standard implementation at least, not sure), that definitely qualifies as "hidden" is recursive data structures. Anyone who's seen a bit of Haskell knows we can write things like ones = 1 : ones. Strangely enough, we can also write the analogous let rec ones = 1 :: ones in OCaml without looping forever!. If you try it out in the REPL, you'll get val ones : int list = [1; 1; 1; ...] and you can actually use this list (take the head, zip it with another list, etc). This sort of thing isn't very useful though since most OCaml functions expect your list to be finite. A bunch of functions in Core.List will check their argument's length for example. A nice recent addition to the language that you might not know about is GADTs. GADTs are like ordinary OCaml variant types, but you give the types of the constructors explicitly. As an example, the typical type declaration type 'a tree  = Empty  | Node of 'a * 'a tree * 'a tree is written in GADT syntax as type 'a tree =  | Empty : 'a tree  | Node : 'a * 'a tree * 'a tree -> 'a tree One useful new thing you can do with GADTs is encoding in the type which constructor was used. For example, type appletype orangetype 'a fruit =  | Honeycrisp : apple fruit  | Granny_smith : apple fruit  | Mandarin : orange fruit and we can now write let is_red : apple fruit -> bool = function  | Honeycrisp -> true  | Granny_smith -> false without the compiler complaining about missing cases. Other uses include existential types and representing type equalities. 