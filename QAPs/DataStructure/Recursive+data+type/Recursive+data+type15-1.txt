Why do interviewers care so much about algorithm and data structure?
Under the hood all your SQL and Linux commands are algorithms and data structures. You might not realize this, but that's how software works. I always ask them to reverse a string. Half the people fail at this test because they refuse to do it. They say they never need to do things like this, they don't remember, they don't care, they don't like tests, they already graduated and they no longer will do tests of any kind... all types of responses, but the truth is that they have no idea whatsoever how to do this and therefore if hired, they will be another problem. If you ever hire a person like that he will copy code from somewhere (Google?) and be done with it. But they really don't understand it and don't care, they are looking for easy management roles and this is just a temporary job while they find one of those jobs in which abilities are subjective and they can manage developers into code fast and dirty hell. If I'm hiring a software developer, I want him to be able to: 1. Given a problem, write an algorithm that solves the problem. That is, the program has a beginning and an ending, it doesn't run forever. I call it algorithmic intelligence. 2. He can write correct iterations and recursive functions. And interchange one with the other easily. 3. He can explain the code. Find bugs, improve the code. Make it clear and make it faster. 4. He understands what a cache is and what cache oblivious algorithms are. (I don't want them to tell me that the cache ruined the tests, if that is the case, there is something really wrong in the developer's head). I would say 90% of the companies flunk this simple test. 5. He understands greedy algorithms. 6. He understands recursive data structures like trees. 7. He knows hash tables. 8. He can translate a problem into a few design patterns and solve said problem using them. That said, I like Joel Spolsky's idea: Hire smart people who can get the job done. The Guerrilla Guide to Interviewing (version 3.0) Knowing factoids are useless when you can search them in 5 seconds using Google. On the contrary, a prospective employee showing that he has CPU power in his head is showing that he is a great asset to the company. Of course that means he can make mistakes. But if he can explain things clearly, probably he will be able to code clearly too. Even worse than coding an obvious mistake is coding something that looks complicated and that it seems that it works, but the code is so complicated that I'm not so sure, and there are a lot of subtle bugs that need to be debugged out. That would be a waste of time and money. Most developers spend 3 days debugging for every day programming. There is 1 bug for every 10 lines of code according to SEI. That means productivity goes into a black hole if the programmers don't follow simple rules like unit testing, code review, etc. Being able to write simple code, unit test it and explain it is part of the whole thing. Unit testing I can explain in a few weeks sitting next to the developer and writing the unit test with him. I only ask him what he thinks about unit tests,to know how much time it will take me to convince him of this fact. A developer cannot be in love with his code ("don't touch my code, it is my kid") and must be able to explain it. He must not fear it and must be able to refactor it into smaller pieces. This is the third ability that Joel should look for. I know I expect this of the people I hire. Joel also mentions that he says something wrong on purpose. He knows the prospective employee realizes this by the look in his face. Then he waits for the person to say what he thinks. If he doesn't say anything, you cannot trust this person. He might now you are making a mistake and he will not speak up. That is a sign that you don't want to hire that person, because he will let you do an expensive mistake only to able to laugh on your back. If you already work at a company and you are told by your boss not to do that during the interview, you know what the company culture is, probably everyone know what you are doing wrong and they won't let you know, because they crave the day the whole project crumbles on its knees, because of the stupid mistakes you were making. I've seen several CTOs make this at projects that use XP, Scrum, Open Source... etc., because they don't like those products / methodologies / philosophies and they simply let them crumble. The idea during the interview is that the developer can politely tell you of your error. For example I went in to an interview and told the interviewers that most developers think that LinkedList is faster than ArrayList when the list is too big, but inÂ  reality Bjarne Stroustrup showed that arrays are always faster. We argued for more than an hour. It was all fun at the beginning, but they didn't buy t. They argued something theoretical, I explained why it didn't hold and explained my point of view. When I thought it was clear, they argued even more, theoretical again, and not taking what I have said into account. Eventually when we got into the next question, they mentioned some esoteric reason about it, all smart and logical, but irrelevant, because they don't understand the basic idea I was explaining. Their reasoning was beyond the one that we all hear during CS classes, about why that could be the only outcome possible, and it had to do with memory management. The problem was that I did my own independent tests and consistently ArrayList beats LinkedList on several orders of magnitude. I don't expect to argue for one hour about such a simple subject during an interview, only to be dismissed without even taking care of the explanation. That is a waste of time. On XP, there is a lemma that says "when you can't agree on something, let the computer talk", meaning, do prototypes or tests and see what the computer has to say about things. On the other hand, do you want to work for a company that doesn't listen to his employees? And if the hiring process is broken, they already allowed the wrong people inside the company, even if the other processes are working (which I doubt), the people are so bad that they will ruin the processes anyway. 