Why are functors, applicative functors and monads important/advantageous in functional programming? (not looking for a definition)
I think functors, applicatives, and monads are amazing. Just think about it. What do the following things have in common: Maybe, list, state, and I/O? Each of them solves a completely different problem. Maybe is used for reporting errors or, in general, for turning partial computations (not defined for all arguments) into pure functions. List is used for processing data sequences or, in general for turning non-deterministic computations into pure functions returning lists of possible outputs. State is used for passing and accumulating side effects from function to function. You must have already used I/O in your Haskell programs, so you know what the IO monad is used for. What all these constructs have in common is that they are used to hide values of arbitrary types. In this sense they are a generalization of containters. Maybe hides zero or one value, list hides a sequence of zero or more values, State hides the future value that will be produced once the initial state is provided. IO hides a value from some external input. Some of these types let you access the hidden value(s). You can pattern match on Maybe to extract the value (or Nothing). You can extract individual values from a list using pattern matching and recursion. You can extract the result of a stateful computation by running it with some initial state (the actual value will depend on what state you use). Finally, you can never extract a value from the IO monad. But you never need it! All these data types provide ways to operate on hidden values. The simplest operation you can perform is to apply a function to the value or values inside a (generalized) container. This functionality is expressed in the Functor class and is implemented by a function called fmap. If you need to apply a function of multiple arguments to multiple containers, you need the Applicative class. Finally, if you have to branch based on the hidden value, you need a Monad class. For instance, in the IO monad, you might perform different actions depending on the key pressed by the user. The branching is implemented in the continuation that you pass to the bind operator >>= of a monad. What's important is that all these computations that return generalized containers (or, as I sometimes call them, embellished values) can be composed. Composition of functions is the basic tool in functional programming. A monad lets you compose embellished functions. And there is even syntactic sugar called the do-notation that hides the complexity of binding and writing the continuations. Composition of Maybe-returning functions does what exceptions do in other languages: it short-circuits the computation after the first Nothing is encountered. Composition of list-returning functions acts like the nesting of loops that iterate over values. Composition of stateful functions passes along the state from computation to computation. Finally, composition of I/O-performing functions does the sequencing of I/O. Notice that all these operations can be easily done in imperative languages. The problem is that they are the main source of programming bugs. Encapsulating them in monads makes them type safe. You give the compiler enough information to check the correctness of these operations. Updated 6w ago • View Upvotes • Asked to answer by Hadi Moshayedi