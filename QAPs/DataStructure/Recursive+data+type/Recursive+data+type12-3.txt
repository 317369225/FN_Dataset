What are your favorite tricks or hidden features of OCaml that you use?
Not hidden at all but I find myself using phantom types to make invariants in my API clear.  You can effectively encode a state machine into the type of a value. An example of this is in a client for Riak I wrote.  One of the invariants is: When you do a GET you might get back an object with siblings.  If you do a PUT that object cannot have any siblings.  You want to use the same object representation for both GET and PUT but you don't want a PUT with siblings to result in a runtime error, you want the compiler to tell you that you've forget to ensure this. So to do that I use a phantom type on the object where the internal representation is always a list but the little type annotation tells you if it might be more than one value or it's guaranteed to be one. So GET looks like this: val get :  t ->  b:string ->  string ->  ([ `Maybe_siblings ] Robj.t, error) Deferred.Result.t See the return value is an [ `Maybe_siblings ] Robj.t. Then PUT is this: val put :  t ->  b:string ->  ?k:string ->  [ `No_siblings ] Robj.t ->  (([ `Maybe_siblings ] Robj.t * key), error) Deferred.Result.t Notice it takes a [ `No_siblings ] Robj.t as input.  So how do you convert from a Maybe_siblings to a No_siblings? With set_content (this is a function operating on a Robj.t which is what t really means here): val set_content  : Content.t -> 'a t -> [ `No_siblings ] t So this takes any kind of Robj.t and turns it into a [ `No_siblings ] t.  Now the compiler will guarantee that we always make sure the object has a single value in it before we do a PUT. This is one trick that I get a lot of milage out of when I do use it.  It's very simple but very powerful. The full code can be found:  orbitz/ocaml-riakc 