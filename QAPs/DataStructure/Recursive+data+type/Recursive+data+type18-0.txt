Why is the struct keyword so verbose?
What Evan said, but mind you that the anonymous typedef, while it relieves you from typing "struct" over and over again in most cases, does not deal with an edge case: You can use pointers to a struct before you've defined what's inside the struct That seems rather useless, but it's useful in two cases: 1. Recursive data structures struct cons { int car; struct cons *cdr; }; cannot be written as typedef struct { int car; cons_t *cdr; } cons_t; because typedefs are only valid after they are fully read, but structs as such can be recursive. Often what people will do in such cases is typedef struct cons { int car; struct cons *cdr; } cons_t; declaring one name "struct cons" to be used exclusively inside the recursive declaration and another, more reasonable name "cons_t" for use outside. (Another common convention, rather than appending _t, is to spell the type name with a capital. Whatever. But it's nice to be consistent within your project.) 2. Abstraction You can have a header file typedef struct frob *frob_pointer_t;frob_pointer_t make_frob_pointer(void);void frob_do_this(frob_pointer_t p);void frob_do_that(frob_pointer_t p); without ever declaring what a struct frob looks like. After all, you only need to know what it looks like if you want to (1) read or write its members, or (2) allocate it (because then you need to know the size). If you are just dealing with pointers, there is no need to know the details, and indeed you don't have to in C. 