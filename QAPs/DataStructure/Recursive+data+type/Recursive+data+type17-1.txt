Why is tail recursion less costly than normal recursion?
Generally, recursive code, like the following pseudocode: factorial(n) {    return (n == 0) ? 1 : n * factorial(n-1);} creates a stack frame for each level of recursion, because it has to recurse all the way to the base case, then return back up while accumulating the products along the way. This means that factorial(100000) would create 1000000 extra stack frames, not a trivial amount of memory. In contrast, tail-recursive code: factorial2(n, accum=1) {    if (n == 0) {       return accum;    } else {       factorial2(n-1, n*accum)    }} is structured such that a smart language implementation notices that factorial2 only calls itself at the end of its logic flow (hence "tail call"), so it can simply adjust the parameters in its current stack frame and GOTO its beginning. This allows you to compute to very large n without fear of stack overflow (assuming the data type of accum can handle the very large result). 