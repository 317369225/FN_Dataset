What are your favorite tricks or hidden features of OCaml that you use?
I don't know if any of these are actually hidden—I've only used OCaml at a couple companies, but am not really part of the OCaml community. I don't know what is or isn't well-known OCaml users. Emacs has some awesome hidden OCaml features. Unicode symbols: Emacs can transparently display syntax elements with pretty Unicode characters (without changing the underlying file): fun x y z -> x /. y *. z <> 10 || x >= 5 && z <= 10 becomes λ a b c → a ÷ b × c ≠ 10 ∨ a ≥ 5 ∧ c ≤ 10 it also changes type variables: map : ('a -> 'b) -> 'a list -> 'b list becomes map : (α → β) → α list → β list Some people really like this :P. you can easily get intelligent auto-completion with merlin. It even worked with js_of_ocaml! Actually, js_of_ocaml itself is a hidden feature: you can easily compile OCaml to JavaScript. It's quite nice! The FFI uses OCaml's object system though, which people normally don't use. This isn't a hidden feature so much as pure evil: OCaml strings are mutable. Yes. OCaml strings are mutable. Mutable! Strings! Gah! You can use ' in variable names. Most of the time, it's used for things like x', pronounced "x prime". But you can also use it for contractions like don't_wait_for which is actually a real function in Async. You can open a module to use its operators for a single expression: Foo.(x <.> y) OCaml can support recursive types with the -rectypes flag. 99% of the time this isn't what you want though! Use it only if you know what you're doing. Normally let rec a = [a];; gives you a type error; with rectypes, it works: # let rec a = [a];;val a : 'a list as 'a =  [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[...]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] OCaml has higher-rank polymorphism as long as you do it through a record. Normally, let foo id = (id "x", id True) would not compile. But if you wrap it up in an appropriately typed record, it works: type id = { id : 'a. 'a -> 'a; }let foo {id} = (id "x", id True) This is a slightly verbose way of making foo : (∀α. α → α) → string × bool. (You can do this more directly in Haskell with RankNTypes.) OCaml has labelled and optional arguments which are handy but can be a bit verbose. It took me far too long to learn the various shortcuts I could take: ~x:x can be written as just ~x: let x = 10 in f ~x ~y:10 if you have an optional argument ?x, you can pass a normal value in as if it was a standard labelled argument: f ~x:10 ~y:11. But if you have an 'a option instead, you can pass that in by using a ?: f ?x:(Some 10) ~y:11 optional arguments should go before non-optional arguments, to allow them to be left out:  f ?x ~y instead of  f ~y ?x if you only have optional arguments, add an extra unit to the function: f ?x ?y () as a meta-note, turns out OCaml warns you about this:  Warning 16: this optional argument cannot be erased. I only found this out when writing this answer! It probably wasn't turned on at Jane Street or something, because we had warnings as errors and I wouldn't have missed it There's a few other neat things I don't remember exactly. If I think of them, I'll add them in. 