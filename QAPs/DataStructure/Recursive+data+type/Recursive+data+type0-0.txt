Why are lists the fundamental data structures in most, if not all functional programming languages?
Lists are basically the simplest sort of data structure you can write in a functional language. In languages with algebraic data types, it's a pretty direct recursive definition: data List a = Cons a (List a) | Nil Even languages without full algebraic data types at least support pairs or structs. In most Lisp variants, for example, lists are just nested pairs. And even without pairs, you could define lists just in terms of lambdas! Philosophically, functional languages tend to prefer things implemented in the language rather than built into the compiler, which gives lists the edge. A list exists purely at the language level where arrays end up exposing a few extra details about the underlying machine (ie contiguous memory). Lists, being a recursive data type, are very amenable to the normal functional style using recursion instead of iteration. At each step, you process the first element and recurse on the rest. This works because the rest of the list is a list itself—in fact, this is exactly what we mean by "recursive data type". A recursive list function like this naturally follows the "shape" of the data type: there is a case for each branch (ie Cons or Nil) and the Cons case handles both the first field (the value) and the second field (the rest of the list). Arrays, on the other hand, do not naturally lend themselves to this style. There's no natural way to split an array into the current element and the rest of the array. Instead, you're expected to keep track of an index explicitly, which makes recursive code uglier and opens you up to more potential problems like off-by-one errors. Immutable lists are naturally a persistent data structure, which means that much of the memory is shared. Semantically, when we return part of a list, we're returning a different entity; however, it can actually be the same pointer. This only works because we know that, in functional code, the list can't be modified. tail (x:xs) = xs -- xs is actually just a pointer, not a new copy Arrays, on the other hand, cannot reuse memory like this. People have tried making "difference arrays" with some of these properties, but they end up too slow in practice, so we still end up copying arrays a lot. Finally, you should note that lists in a lazy language like Haskell behave very differently from lists in a strict language or arrays in either sort of language. A lazy list in Haskell behaves like a stream in a strict language rather than a strict list. One nice consequence is that we can define and use infinite lists like [1..] which contains 1, 2, 3... and so on. This turns out to be very handy for modeling all sorts of useful things like Taylor series (see "Functional Pearl: Power Series, Power Serious" and Power serious). Really, lazy lists are more like a control structure than a data structure. It's a for-loop realized as a first-class data structure. A list is not allocated when it's defined but rather as it's used; this means that code that creates and then consumes a list can actually run in constant space. An expression like sum [1..10000000] does not create a list that's 10000000 elements long. Instead, it evaluates it cell by cell. Since there is no pointer to the start of the list, the garbage collector collects cells we've already summed almost immediately, giving us very nice memory usage. This allows us to exploit lazy lists (and similar lazy tree structures) to do efficient memoization. This is how the classic Haskell Fibonacci implementation works: fib n = fibs !! n  where fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs) When this is run, it only keeps a constant number of past results in memory, giving it much better memory usage than a more naïve memoization strategy. You can see more details—with pictures!—on my blog. So lists are used a lot because they're natural to define, lend themselves well to recursion, have nice properties as immutable data structures and, in lazy languages, function more like loops than normal data. Updated 73w ago • View Upvotes • Asked to answer by Mostafa Hany Gomaa