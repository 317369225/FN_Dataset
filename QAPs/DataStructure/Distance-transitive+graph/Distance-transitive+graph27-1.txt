What are the best sites available on the internet to learn dynamic programming, algorithms, and data structures?
Dynamic Programming :-Dynamic programming is a useful type of algorithm that can be used to optimize hard problems by breaking them up into smaller subproblems. By storing and re-using partial solutions, it manages to avoid the pitfalls of using a greedy algorithm. There are two kinds of dynamic programming, bottom-up and top-down. In order for a problem to be solvable using dynamic programming, the problem must possess the property of what is called an optimal substructure. This means that, if the problem was broken up into a series of subproblems and the optimal solution for each subproblem was found, then the resulting solution would be realized through the solution to these subproblems. A problem that does not have this structure cannot be solved with dynamic programming. Top-DownTop-down is better known as memoization. It is the idea of storing past calculations in order to avoid re-calculating them each time. Given a recursive function, say: fib(n) = 0 if n = 0          1 if n = 1          fib(n - 1) + fib(n - 2) if n >= 2 We can easily write this recursively from its mathematic form as: function fib(n)   if(n == 0 || n == 1)     n   else     fib(n-1) + fib(n-2) Now, anyone that has been programming for awhile or knows a thing or two about algorithmic efficiency will tell you that this is a terrible idea. The reason is that, at each step, you must to re-calculate the value of fib(i), where i is 2..n-2. A more efficient example of this is storing these values, creating a top-down dynamic programming algorithm. m = map(int, int) m[0] = 0 m[1] = 1 function fib(n)   if(m[n] does not exist)     m[n] = fib(n-1) + fib(n-2) By doing this, we calculate fib(i) at most once. Bottom-UpBottom-up uses the same technique of memoization that is used in top-down. The difference, however, is that bottom-up uses comparative sub-problems known as recurrences to optimize your final result. In most bottom-up dynamic programming problems, you are often trying to either minimize or maximize a decision. You are given two (or more) options at any given point and you have to decide which is more optimal for the problem you're trying to solve. These decisions, however, are based on previous choices you made. By making the most optimal decision at each point (each subproblem), you are making sure that your overall result is the most optimal. The most difficult part of these problems is finding the recurrence relationships for solving your problem. To pay for a bunch of algorithm textbooks, you plan to rob a store that has n items. The problem is that yourtiny knapsack can only hold at most W kg. Knowing the weight (w[i]) and value (v[i]) of each item, you want to maximize the value of your stolen goods that all together weight at most W. For each item, you must make a binary choice - take it or leave it. Now, you need to find what the subproblem is. Being a very bright thief, you realize that the maximum value of a given item, i, with a maximum weight, w, can be represented m[i, w]. In addition, m[0, w] (0 items at most weight w) and m[i, 0] (i items with 0 max weight) will always be equal to 0 value. so, m[i, w] = 0 if i = 0 or w = 0 With your thinking full-face mask on, you notice that if you have filled your bag with as much weight as you can, a new item can't be considered unless its weight is less than or equal to the difference between your max weight and the current weight of the bag. Another case where you might want to consider an item is if it has less than or equal weight of an item in the bag but more value.  m[i, w] = 0 if i = 0 or w = 0            m[i - 1, w] if w[i] > w            max(m[i - 1, w], m[i - 1, w - w[i]] + v[i]) if w[i] <= w These are the recurrence relations described above. Once you have these relations, writing the algorithm is very easy (and short!). v = values from item1..itemn w = weights from item1..itemn n = number of items W = maximum weight of knapsack  m[n, n] = array(int, int) function knapsack   for w=0..W     m[0, w] = 0   for i=1 to n     m[i, 0] = 0     for w=1..W       if w[i] <= w         if v[i] + m[i-1, w - w[i]] > m[i-1, w]            m[i, w] = v[i] + m[i-1, w - w[i]]         else            m[i, w] = m[i-1, w]       else         m[i, w] = c[i-1, w]    return m[n, n] Additional Resources Introduction to Algorithms Programming Challenges Algorithm Design Manual 2. Data Structures and Algorithms 1.Geeks for Geeks This is one of the best computer science portal for geeks, mainly focus on Data structures and Algorithms. Analysis of algorithms,Searching and Sorting, Greedy Algorithms, Dynamic programming, Pattern searching, Backtracking, Divide and Conquer and Bit algorithms are explained clearly. 2.Top Coder Top coder is one of the coding contest site mainly focus on algorithmic questions. Here is the good collection of algorithmic topics by various topcoder members. 3. OpenclassRoom- Stanford University Here is the collection of video tutorials by Prof.  Tim Roughgarden from Stanford univ. Topics discussed here are Introduction to fundamental techniques for designing and analyzing algorithms, including asymptotic analysis; divide-and-conquer algorithms and recurrences; greedy algorithms; data structures; dynamic programming; graph algorithms; and randomized algorithms 4. Introduction to Algorithms – Massachusetts Institute of Technology Here is the collection of lecture slides,code on various algorithmic topics by Massachusetts institute of technology 5. Stanford CS Education Library This online library collects education CS material from Stanford courses and distributes them for free. Here are few more sites that might help you to learn data structures and algorithms: 1. CSE 214 - Lecture Notes 2.http://courses.csail.mit.edu/6.8... 3. CS 61B: Data Structures 4.https://www.coursera.org/course/... 5. Page on coursera.org 6. Algorithm Interview Questions 7.http://www.careercup.com/page?pi... 8 LeetCode Online Judge 9 Newest &#39;data-structures&#39; Questions 