How does the optimized version (O(n) solution) of the following problem work?
The first method describes that the diameter can be found by following algorithm: find diameter of left subtree.find diameter of right subtree.find diameter passing through current node. (by finding height of left subtree and right subtree.) [left subtree height + right subtree height + 2] In this algo, for every node, we need to find out the height of left and right subtree. This way, we are calculating the heights of subtree more than once for a single node. Instead what we can do is calculate the height of each subtree once and store it at some place (say node, if we can modify the tree or somewhere else.) and when we go to some node, we already have height of subtree rooted at that node. The code will illustrate it in a better way : We will make an object m, which will store the height of a subtree and diameter of a subtree rooted at that node. class m{        int height;        int diameter;        public m()        {                //base case, when root is null, height of subtree is -1 and it's diameter is 0.                this.height = -1;                this.diameter = 0;        }} Now, the dia function which will return object m for every node will work as follows: //max_dia is a global varialbe which will store the maximum-diameter in a tree.public static int max_dia = 0;m Dia(node root){        if(root == null)        {                // if root is null, we will return the base object m.                return new m();        }        //new object x to find height and diameter of current subtree.        m x = new m();        //l and r will store the object m (height and diameter) of left subtree and right subtree.        m l = Dia(root.left);        m r = Dia(root.right);        // if sum of heights of left subtree and right subtree +2 is greater than current diameter of that node, then we will update the diameter of current subtree.        if(l.height + r.height + 2 > x.diameter)        {                x.diameter = l.height + r.height + 2;                if(max_dia < x.diameter)                {                        max_dia = x.diameter;                }        }        // finding the height of current subtree from left subtree and right subtree.        x.height = Math.max(l.height,r.height) + 1;        return x;} In this way, we will traverse a node only once and time complexity is O(n). I guess this is bit longer and exloit object oriented programming paradigm but it's less confusing and easy to write than that explained in the link. Hope this helps. :) 