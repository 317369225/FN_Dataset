What is the best method for checking if a binary tree is a binary search tree?
Best is hard to define in this case. No algorithm can be faster than O(n) I think the simplest is to do an in-order traversal (left, root, right) and confirm the result is in sorted. Alternatively, we can just remember the critical values for a node as we traverse down (this algo is nice because it doesn't require additional memory albeit at the cost of log(n) stack space) I like the simple recursive algorithm: boolean isBST(BinaryNode<T> n) {       return isBST(n, T.MIN_VALUE, T.MAX_VALUE); } boolean isBST(BinaryNode<T> n, T min, T max) {     if(! (n.value <= n.right.value && n.value >= n.left.value && n.value >=                              min && n.value <= max) ) {              return false;       }     return isBST(n.left, min, n.value) && isBST(n.right, n.value, max) } For any given node, we need to check that it is in between its children not greater than its smallest right parent or smaller than it's biggest left parent. If T is comparable and not say Integer, we switch the <= and >= with the appropriate .compareTo (or your language's equivalent) and find the rightmost and leftmost elements in the tree as our max and min respectively for the initial call. Total time is still O(n) Updated 79w ago • View Upvotes • Asked to answer by Anonymous