How can I solve this “IndexError: string index out of range” when building the decision tree? Check the answer for detailsGabriele Giordano's answer to How can I solve this “IndexError: string index out of range” when building the decision tree? Check the answer for detailsEDIT: The problem was that in some internal list, the element 0 was empty. I solved inserting ‘none’ when that happened. I followed the code posted in this page: Building a decision tree from scratch In my case the data is a list of lists of tuples. my_data = [['word1',(0, 'y'), (0, 'n'), (1, 'n'), (2, 'y'), (3, 'y')], ['word2',(0, 'y'), (0, 'y'), (1, 'y'), (2, 'y'), (3, 'n')],...] I adapted the divisdeset in this way def divideset(rows,column,value):#about 0.82 average # Make a function that tells us if a row is in the first group (true) or the second group (false) split_function=None if isinstance(value,int) or isinstance(value,float): # check if the value is a number i.e int or float split_function=lambda row:row[column][1]>=value#Tuple problem solved with the [1] else: split_function=lambda row:row[column][1]==value # Divide the rows into two sets and return them set1=[row for row in rows if split_function(row)] set2=[row for row in rows if not split_function(row)] return (set1,set2) when building the tree, I have this error: split_function=lambda row:row[column][1]==value IndexError: string index out of range here’s the building tree function for who doesn’t want to check the link: def buildtree(rows,scoref=entropy): #rows is the set, either whole dataset or part of it in the recursive call, #scoref is the method to measure heterogeneity. By default it's entropy. if len(rows)==0: return decisionnode() #len(rows) is the number of units in a set current_score=scoref(rows)   # Set up some variables to track the best criteria best_gain=0.0 best_criteria=None best_sets=None column_count=len(rows[0])-1 #count the # of attributes/columns. #It's -1 because the last one is the target attribute and it does not count. for col in range(0,column_count): # Generate the list of all possible different values in the considered column global column_values #Added for debugging column_values={} for row in rows: column_values[row[col]]=1 print column_values # Now try dividing the rows up for each value in this column for value in column_values.keys(): #the 'values' here are the keys of the dictionnary if value !='':#Inserted to try to avoid the index out of range (set1,set2)=divideset(rows,col,value) #define set1 and set2 as the 2 children set of a division # Information gain p=float(len(set1))/len(rows) #p is the size of a child set relative to its parent gain=current_score-p*scoref(set1)-(1-p)*scoref(set2) #cf. formula information gain if gain>best_gain and len(set1)>0 and len(set2)>0: #set must not be empty best_gain=gain best_criteria=(col,value) best_sets=(set1,set2) # Create the sub branches if best_gain>0: trueBranch=buildtree(best_sets[0]) falseBranch=buildtree(best_sets[1]) return decisionnode(col=best_criteria[0],value=best_criteria[1], tb=trueBranch,fb=falseBranch) else: return decisionnode(results=uniquecounts(rows)) tree=buildtree(all_answers) #IndexError: string index out of range 358 Views