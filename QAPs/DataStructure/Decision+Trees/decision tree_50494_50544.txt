can one increment a $ n $ bit integer use fewer than $ 2 - 2 ^ -lcb- 1-n -rcb- $ bit inspection on average ? we can prove a tight lower bind of $ 2 - 2 ^ -lcb- 1-n -rcb- $ as follow . informally speak , we will argue inductively that whenever a bit be read during the increment procedure , that one of the two possible outcome -lrb- a $ 0 $ or a $ 1 $ can be read -rrb- will cause the algorithm to stop read additional bit . this will show that if we require the average number of read to be strictly smaller than $ 2 $ , then we require a code isomorphic to the standard binary code . suppose that the first bit read by the increment algorithm be bit $ i_1 \ in -lsb- n -rsb- $ . now we have three case to consider . in the first case -lrb- a -rrb- , the algorithm will stop read additional bit regardless of the value of $ i_1 $ . this mean that after read $ i_1 $ , the algorithm must decide which bit must be flip right away , and clearly this will not yield a valid increment algorithm for $ n > 1 $ . in the second case -lrb- b -rrb- , the algorithm will adaptively read another bit , regardless of the value of $ i_1 $ . we note that the algorithm may choose to read a different bit depend on the value of $ i_1 $ . in this case , however , we be already read at least $ 2 $ bit no matter what , so the average number of bit read will exceed $ 2-2 ^ -lcb- 1-n -rcb- $ . finally , in the third case -lrb- c -rrb- , the algorithm will only read another bit for a single value of $ i_1 $ -lrb- say $ 1 $ for convenience -rrb- . that be , when $ i_1 $ be $ 0 $ , the algorithm will determine which bit need to be flip , and when $ i_1 $ be $ 1 $ , the algorithm will probe a second bit . in such a case , the expect number of bit read be at least $ 1\/2 \ cdot 1 + 1\/2 \ cdot 2 = 3\/2 $ . this be the only case where we can hope to beat the standard binary code . now we can apply this argument inductively . suppose now that the algorithm be adaptively read bit $ i_k $ , with $ k \ leq n-1 $ . then in case -lrb- a -rrb- , at most $ n-1 $ of the bit be ever read by the algorithm . this mean that there be a bit that be never read and thus never write to , so the increment algorithm can not be correct . here we assume that the only bit that can be flip be the one read during that particular increment operation . in case -lrb- b -rrb- , we can verify that the expect number of read be at least $ $ \ sum _ -lcb- j = 1 -rcb- ^ -lcb- k-1 -rcb- j\/2 ^ j + 2 ^ -lcb- 1-k -rcb- \ cdot -lrb- k +1 -rrb- = 2 $ $ which be again too many . in case -lrb- c -rrb- , however , the expect number of read can be verify to be at least $ $ \ sum _ -lcb- j = 1 -rcb- ^ -lcb- k-1 -rcb- j\/2 ^ j + 2 ^ -lcb- - k -rcb- \ cdot k + 2 ^ -lcb- - k -rcb- \ cdot -lrb- k +1 -rrb- = 2 - 2 ^ -lcb- - k -rcb- \ cdot -lrb- 2k +3 -rrb- $ $ which be again the only case which might lead we to a better performance than the standard binary code . when perform the $ n $ - th bit read , there be no other bit that the algorithm can read -lrb- since the other $ n-1 $ bit have already be read -rrb- , so only case -lrb- a -rrb- become valid . compute the expect number of read then give exactly $ 2 - 2 ^ -lcb- 1-n -rcb- $ , as require . i find that it help to view this as a binary decision tree , where the internal node be label by the bit read , and the leaf be label by the bit that be flip . so you begin by read the bit label at the root of the tree -lrb- in we case $ i_1 $ -rrb- , then you go left if you ve read a $ 0 $ and right if you ve read a $ 1 $ . with this picture in mind , it become clear that there be only three case to consider at each step of the proof . 