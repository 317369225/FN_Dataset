In C language why is a pointer used when one can assign the variable itself?
Pointers are a very important concept in C.  You can understand it when you are writing code in a very big application and you worry about both memory and operational efficiency. Generally if you go through a linux code , to store data, we use data structures which further are used to created abstract data types. Now EG: in kernel if you have to store all the interfaces (Ethernet, wireless, VM ) you need a generalized list to store (like an array).  Each node of this list can have a lots of data like interface name, ip addresses , ipv6 addresses , link to next and previous interface, arp, nd , mtu and other . Whenever you want to manipulate a node  ( or data in each node) you have to pass the whole node (assuming no pointers). When you pass the whole node in the function, then effectively, first you are passing a LOT of data on stack (which is generally limited) and pushing LOT of data need more instruction (inefficient to do this) and since its pass by value, even if you modify this node, it wont be reflected in the ACTUAL / PARENT list. Pointers help you access virtual memory location and hence there isnt any need to pass big data structures in function calls. Also important memory allocators work by returning a pointer to the allocated memory location. Now to do this without pointers is very difficult, As memory location represent some data stored at that location. and using pointers we can pass a 400MB location to a function, That function will de-reference that memory location to get the value , change it and it would be reflected immediately at that memory location. Dynamic linking of libraries work using the concept of pointers, How else would dynamic linking work (else it would become static linking, increase binary sizes and other problems , may be in some embedded systems)\ Please note , C language supports both pass by value (no pointers, pass a COPY of the variable, and pass by reference , send the memory pointer for that variable, to be modified (not a copy)). This is the tip of the iceberg in vast world of C dominated by pointers. 