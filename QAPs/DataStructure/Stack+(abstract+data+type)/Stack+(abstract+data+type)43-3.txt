What is the difference between a compiler and an interpreter?
Of all the answers, I thought Robin Thomas's was the closest to how I've viewed the issue. I've written a compiler, and worked on an interpreter, and I think most of the answers were adequate on what a compiler does. I wasn't satisfied with most of the answers on what an interpreter does. A compiler just translates from one formal language into another. That pretty well covers it. The language it's translated into will not necessarily be executed after compilation. It may be run through another compiler. The earliest C++ compiler operated this way. It was originally called "cfront." It translated C++ source code into C source code, which was then run through a C compiler. Early C compilers didn't compile directly to object code. They compiled to assembly, which was then run through an assembler to get object code, which was then run through a linker to finally get finished machine code. When I took a compilers course in college, we wrote a compiler that translated a Pascal-like language into 3-address code in C (which was meant to emulate assembly language). This, of course, was run through a C compiler to finally get an executable program. Compilers operate on chunks of code at a time, whether it be a single statement, expression, function, or a whole program. Some of the more modern development environments incrementally compile code to speed up the process. Some may be familiar with the term "edit and continue." This is so that there's not as much time between editing source code, running, and debugging a program. The way I'd describe an interpreter is it "runs a structure." Many of the answers talk about an interpreter running a program "line by line." That's what an interactive interpreter does. I have seen, and have worked on, interpreters that read in an entire program in one go, and then execute them. The way I've seen them work is they create an internal data structure, which it then traverses, picking up information along the way, and acting on it immediately. It is, in a sense, a repeatable process, but it's complicated. There is no regular way that instructions are executed, or way in which information is stored (except for this large, connected data structure in which the program is stored). All of the interpreter's internal operations are dependent on the circumstance in the moment (the state the interpreter is in, and the state that is represented in the internal data structure). Code is not translated into the machine's language. Rather, a set of parameterized, boilerplate procedures is executed, though which ones and in which sequence depend on the internal data structure that the interpreter has constructed for itself. I remember once trying to explain the difference between a virtual machine and an interpreter, and I think for many people the difference is subtle, because it's really a matter of how information is organized in memory, and how a program is executed. A virtual machine, in the sense we're using it here, is really what I'd call an "abstract processor," and it's like the way a Turing Machine operates. (I've written one of these as well.) A Turing Machine is given a starting point, and has a simple set of operations it repeats throughout the entire run of a program. These operations are: read a symbol or code wherever the "head" is on the "tape" (we can analogize this to RAM, for the sake of argument), look up the code internally, and execute one or more internal instructions (that may be parameterized) that correspond to it, which will affect the state of the "head," and possibly the "tape," then repeat this process until it reaches an "end" state. From what little experience I've had with this, a VM's process for fetching information, executing instructions, providing for temporary storage of information, saving state, branching, and storing information long-term, is formalized and regular, and amounts to a simpler process than what an interpreter deals with. A VM does not form a connected data structure from source code. It runs a compiled language (compiled to bytecode), which, if you looked at it, is organized more like machine code. It has its own addressing scheme, which the VM follows to find and store information, and to control program flow. These are the sort of operations that an interpreter would carry out by "reasoning" about relationships in the data structure I talked about. To most people this will make no difference at all. From a computer science perspective, it's a big difference. Updated 18w ago â€¢ View Upvotes