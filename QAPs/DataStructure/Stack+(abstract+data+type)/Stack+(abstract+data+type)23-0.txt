I have a bump in the road of learning object-oriented programming. What are some tips that you can give me from your experience?
If you're the least bit familiar with biology, it makes for a super-easy way to understand OOP. Consider a coyote, a wolf, and a fennec - they're all Canidae.  Below this, the coyote is Canis Latrans, the wolf is Canis Lupus, and the fennec is Vulpes Zerda.  To represent this using OOP, you would begin by defining the base Class for Canidae -everything you'd expect to utilize which is common to all of them would go here.  They all have size, weight, fur color, and the like - these are the Properties of Class Canidae.  Any actions they can perform - eat, poop, call, run, etc - are Methods of Class Canidae. Though the wolf and coyote are the same Genus, our poor little fennec is on its own.  Here, you would define two more Classes, each of which would inherit from Canidae.  Any specific attributes or abilities that the wolf and coyote have but the fennec doesn't would be Properties and Methods of Class Canidae::Canis.  Any specific attributes unique to the fennec would be Properties and Methods of Class Canidae::Vulpes. There are still differences between the coyote and wolf, so we need two more Classes, each of which inherit from Canis, which inherits from Canidae - Canidae::Canis::Latrans and Canidae::Canis::Lupus.  Since our fennec is the only Canidae::Vulpes we're using, we won't need to create a Zerda Class for it. But we have encountered a problem - wolves and coyotes both make noises, but they make different kinds of noises.  They Howl alike, and both Whine, but coyotes can't Bark.  The fennec doesn't Howl, but it can Bark, Whine, and Cry. Since all three can Whine, and Canidae is the common Class all three share, that's where we put the Whine Method - which, since it's the root Class, means we can access Whine from ANY of our Classes the exact same way. Only the wolf and coyote can Howl, so there's no point in it taking up space in Vulpes (which inherits from Canidae).  Latrans and Lupus both inherit from Canis, so Canis is where we put the Howl Method.  Neither the wolf nor coyote can Cry as the fennec can, so the only Class that needs it is Vulpes. (Another option would be to define Howl in the Canidae Class, then create an alias for Howl in the Vulpes Class named Cry.) Bark is a real oddball in this example.  In most OOP languages, we would place it in Class Canidae as a Virtual Method - defining the format that any inheriting Classes would use, but it doesn't actually exist until it is defined in the Classes that will use it (Lupus and Vulpes). The practical upshot of all this is that we've incorporated a great deal of capability into our program with very little redundant code.  We can make a List of Canidae which could be any combination of wolves, fennecs, and coyotes and we can access them all the exact same way.  This is a basic rundown of Inheritance. Should we wind up with conflicts - such as mixing carnivores and herbivores in the same list - we can define an Eat Method one way for carnivores, differently for herbivores, and still be able to call Animal.Eat no matter what. Welcome to Polymorphism. The really neat thing about Classes is that they're just blueprints - they don't actually exist until you instantiate them as an Object.  By that same token, you can crank out half a million Objects from a Class as easily as one. Say we made our Classes like above and instantiate three Objects using Canidae::Canis::Lupus - Wolf(1), Wolf(2), and Wolf(3).  Somewhere along the way, you call Wolf(2).Eat(LittleRedRidingHood) - Wolf(2) is now sated but Wolf(1) and Wolf(3) are still hungry!  Everything stays all nice and orderly because the Methods you defined in the Class can only affect that particular Object. And now you understand Encapsulation. And that's pretty much OOP in a nutshell. 