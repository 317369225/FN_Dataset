Do you think Lisp is jealous of Haskell?
I think the question of jealousy is a little bit stupid. I'll answer a closely related question: What do I miss from Haskell when I am programming in Common Lisp? There are three things I miss greatly: the type system, algebraic data types, and laziness.Haskell's type system is enormously helpful in doing many things. First and foremost, being able to declare the types of your functions with a high degree of accuracy is important in describing the interface to your functions. Yes, Lisp has a type system, but it is nowhere near as expressive as Haskell's. Lisp lacks explicit type polymorphism (e.g., sum :: Num a => [a] -> a) and recursive types, for example. And even the types you can provide to Lisp, the amount the compiler can do with them is somewhat limited. SBCL and CMUCL contain the state-of-the-art in Common Lisp type derivation and inference. Despite them being good, due to the nature of Common Lisp as a language, it doesn't approach what Haskell has to offer, even in theory. Haskell's compiler acts as a sort of "proof checker". All of your types will be validated and verified. If your program compiles, then you know that your program is safe from a type standpoint. Second, I miss algebraic data types (ADTs), and furthermore their generalized variant. Algebraic data types are a very nice way to specify sum and product types, and make one's programs rather total and inductive in the mathematical sense. When combined with pattern matching, algebraic data types make programs short, succinct, and usually correct. Lisp's main data abstractions are structures and classes, along with structure inclusion and subclassing respectively. Often, the way classes work ends up being somewhat clumsy when compared to what can be done with algebraic data types. For example, defining a maybe type in Lisp requires around 10 lines of class definitions, and you still aren't even close to what you'd get with Haskell. I have made an attempt to remedy this problem by making an implementation of algebraic data types in Lisp. The library, cl-algebraic-data-type (CL-ADT) can be downloaded for free from Quicklisp and its source code is here: tarballs_are_good / cl-algebraic-data-type - Bitbucket. CL-ADT has algebraic data type definition, basic pattern matching, exhaustiveness checking. One can define maybe as follows: (adt:defdata maybe  (just t)  nothing) This will give you the constructor function #'just and the nullary constructor (actually a value) called nothing. With these, we get value-level benefits, and very marginal type-level benefits. It is an improvement on the situation, but it still pales in comparison with that provided by Haskell. The last major bit I miss from Haskell is laziness. Expressing unbounded data structures is one of the most powerful abstraction mechanisms I've witnessed in programming. In Haskell, it is possible to express the answer to some questions in full generality, but only choose to compute the relevant bits of the answer when needed. An example of this that I ran into recently is the enumeration of all elements of a context-free language. Problem: Given the grammar of a context-free (CF) language, generate every possible string that is satisfied by that grammar. Any possible acceptable string should be achievable in finite time. Of course, we cannot generate all strings at once; there are (usually) an infinite number of them! Luke Palmer, a Haskell programmer, shows a very elegant and declarative solution on his blog post Enumerating a context-free language. The relevant code is only 8 lines, and it lazily generates a data structure that contains all strings, using a clever monad he wrote called the Omega monad. data Symbol a    = Terminal a    | Nonterminal [[Symbol a]]enumerate (Terminal a) = return [a]enumerate (Nonterminal alts) = do    alt <- each alts    rep <- mapM enumerate alt    return $ concat rep A grammar is specified by constructing the appropriate Symbol structures. Not only this, but the essence of the algorithm is extracted into a completely separate monad library. We can implement the same sort of solution in Lisp, but since the evaluation strategy is strict, we have to either be very explicit on when, where, and how our data get computed, or we have to implement laziness ourselves to the extent that our CF language problem can be expressed in it. I took the former approach and made a DSL for specifying grammars, and wrote a function which enumerates elements up to some particular expansion limit. The code is nearly 200 lines, and a version of the code can be found here: tarballs_are_good / lisp-random / source / enumerate-grammar.lisp. A grammar looks something like so: (defparameter *simple-arithmetic-grammar*  (with-non-terminals (expr add term digit)    (make-grammar expr      :expr (alternates add)      :add  (alternates term                        (list add (terminal "+") term))      :term (alternates digit                        (list (terminal "(") expr (terminal ")")))      :digit (loop :for i :below 2                   :collect (list (terminal (prin1-to-string i))))))) After writing such code, however, I can't help but think it would have been enormously simpler if laziness was a visceral part of the language. Manually setting up computation stacks and queues and explicitly commanding the order of computation and all of that just got in the way of the core problem I was trying to solve. Worse, however, is that the general idea of combining values as dictated by a grammar couldn't be made into a separate library, like Haskell's Omega. The only benefit of writing it the way I did was that it allows very clear estimation of runtime time and memory complexities. Could a better solution be written in Lisp? Surely yes, but it'll end up looking like Greenspunned Haskell. There are other features of Haskell, and even particular implementations of Haskell (namely GHC) that are attractive from a Lisp programmer's perspective, but I think the type system, ADTs, and laziness are by far the most desired. 