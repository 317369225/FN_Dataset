Why do stack variables contain garbage values? Is there any way we can assign our whole stack to NULL?
Stacks contain existing data, which makes your stack-based variables contain gibberish, because stacks are used and reused as you delve in and out of call chains (call into and return from functions). It helps to actually picture a stack, which is also known as a LIFO (last-in, first-out): The stack used in function invocation is just like the stack used as a generic data structure. Each function call is a push onto the stack. Each return is a pop. If you call five functions deep into the stack without returning, you'll have five pushes without a pop and be five frames deep into the stack. If you return from one of those functions—a pop—you'll now be four frames deep. If that function now calls a different function—push—you'll be back on that fifth frame. The same frame. And it'll look just like you left it! Why? Because function invocation is supposed to be fast and simple. It is something for which most processor architectures optimize. Indeed, there is often support for function stacks at the architecture level with instructions called push and pop that preserve the right registers and manage the return value as you move up and down the stack. Could you zero out each stack frame before entering it? Probably, depending on the language and the processor architecture. But why? It is undefined in most languages to read variables before they are assigned values. Moreover, the way stack-based variables work on most languages and architectures is just pointer arithmetic. Say you have two 32-bit integers local to a function. Those integers are never actually "allocated." Instead, the compiler places the first integer at offset zero, the second integer at offset four, and the stack counter starts at offset eight (or whatever—this varies by architecture). Stack management and local variables are nearly zero cost. Mucking around with the stack in an attempt to have your local variables default to zero will violate that. (As an aside, if I were to do some sort of stack cleaning, I wouldn't zero it out. That would only hide bugs. I'd do the exact opposite and poison the stack by writing, say, 0xa5 into every byte, thereby catching uninitialized reads quicker. But the compiler can usually notice those.) Updated 153w ago • View Upvotes