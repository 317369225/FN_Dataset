What is the most simple & efficient C++ code for Dijkstra's shortest path algorithm?
Originally Answered: What is the most elegant implementation of Dijkstra algorithm in C++ that you have seen?I'll give it a shot. Given the following definitions: #define FOR_EACH(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); ++it) struct state { int vertex, weight; }; const int MAX = 1000; // the max number of vertices vector<state> graph[MAX]; // adjacency list, g[i] - list of edges from vertex i int dist[MAX];// dist[i] - distance from the source to vertex i int n; // number of vertices in the graph Dijkstra itself can look like this: void dijkstra(int source) { memset(dist, 63, sizeof(dist)); dist[source]=0; priority_queue<state>q; q.push((state){source,0}); while(!q.empty()) { state top = q.top(); q.pop(); if(top.weight > dist[top.vertex]) continue; FOR_EACH(it,graph[top.vertex]) { int alt = dist[top.vertex] + it->weight; if(alt < dist[it->vertex]) { q.push((state){it->vertex, dist[it->vertex] = alt}); } } } } 