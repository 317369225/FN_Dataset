What is the most simple & efficient C++ code for Dijkstra's shortest path algorithm?
Here is my implementation of the version with priority queue. It's written in C++. It does not return a value, but the global array dist has the distances towards all the nodes. typedef pair<int, int> ii; //The Only Macros I use...usually typedef vector<int> vi; vector<vector< ii > > graph;   int n; vi dist;   void dijkstra(int s) { dist.assign( graph.size() , 100000 ); dist[s] = 0; priority_queue< ii, vector<ii>, greater<ii> > pq; pq.push({0, s});   while(!pq.empty()) { ii v = pq.top(); pq.pop();   for(int i = 0 ; v.first < dist[v.second] && i < graph[v.second].size(); i++) { ii u = graph[v.second][i];   if(dist[v.second] + u.second < dist[u.first]) pq.push({dist[u.first] = dist[v.second] + u.second, u.first}); }   } } It can be compressed to be shorter, though. You can see I use v and u pairs to help myself to understand it. It is compact, efficient and cool. Hope it helps, Muhamed Keta Side Note: If you like what you read then I believe you'll find more in my hatching blog: http://coutcode.com/blog 