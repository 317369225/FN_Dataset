What is the most simple & efficient C++ code for Dijkstra's shortest path algorithm?
Originally Answered: How do I implement Dijkstra's algorithm in C++?If you want to use STL , then its a quite simple code actually. 1) Create a dist[] array(initialised to 0), a mark[] (initialised to 0) array of the nodes and a priority_queue of datatype pair<int,int>.     The dist[] array will contain the minimum distance of the respective nodes from the source at a given instance in the execution of the program. At completion, it contains the desired Single Source Shortest Path.     The first element of the pair in priority_queue is the distance of the node from the source. The corresponding node number is stored as the second element in the pair. The priority_queue will be ordered according to the first element of the pair. 2) Insert make_pair(0,<Source>) into the queue and update dist[<source>] = 0; mark[<source>] = 1; 3) While the priority_queue is not empty, a) Extract the min_element(say,x) from queue.      mark[x] = 2; b) For all the neighbours of x(say y),      if(mark[y] == 0)           insert make_pair(dist[x] + cost[x][y],y) into the queue.           dist[y] = dist[x] + cost[x][y];           mark[y] = 1;      else if(mark[y] == 1 and dist[y] > dist[x] + cost[x][y])          erase make_pair(dist[y],y) from the queue.          dist[y] = dist[x] + cost[x][y]          insert make_pair(dist[y],y) into the queue. The final marked[] array contains 2 at those positions which are reachable from <source>. The dist[] array gives the Shortest Path Distance from Source. If you need to get shortest path also apart from just the shortest path length for all nodes, you can maintain a parent array and fill it accordingly in the 2nd step. Here is a rough design: #include <cstdio> #include <vector> #include <set> #include <queue> #include <algorithm>   using namespace std; #define ii pair<int,int> #define pb push_back int n;int e,source; vector<ii> g[100000]; int dist[100000]; bool marked[100000]; void apply_dijkstra() { set<ii > s; s.insert(ii(0,source)); dist[source] = 0;marked[source] = 1; while(!s.empty()) { ii p = *s.begin(); s.erase(p); marked[p.second] = 2; for(int i=0;i<g[p.second].size();i++) if(marked[g[p.second][i].second]==0) { s.insert(ii(dist[p.second]+g[p.second][i].first,g[p.second][i].second)); marked[g[p.second][i].second] = 1; dist[g[p.second][i].second] = dist[p.second]+g[p.second][i].first; } else if(marked[g[p.second][i].second]==1 && dist[g[p.second][i].second] > dist[p.second]+g[p.second][i].first) { s.erase(ii(dist[g[p.second][i].second],g[p.second][i].second)); s.insert(ii(dist[p.second]+g[p.second][i].first,g[p.second][i].second)); dist[g[p.second][i].second] = dist[p.second]+g[p.second][i].first; } } printf("Shortest Distances are\n"); for(int i=1;i<=n;i++) { printf("Node %d - %d\n",i,dist[i]); } printf("\n"); }   int main() { printf("Enter the number of vertices:\n"); scanf("%d",&n); printf("Enter the number of edges:\n"); int e;scanf("%d",&e); printf("Enter the edges and their weights:\n"); for(int i=0;i<e;i++) { int x,y,w; scanf("%d%d%d",&x,&y,&w); g[x].pb(ii(w,y)); } printf("Enter the source:\n"); scanf("%d",&source); apply_dijkstra(); return 0; } 