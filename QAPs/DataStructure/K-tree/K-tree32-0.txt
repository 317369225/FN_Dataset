What is a kd-tree and what is it used for?
So, k-d trees, at the first look, may appear to be more theoretical than practical in nature. But that's really not the case. k-d trees hold a variety of important applications, some of which include : 1. Nearest Neighbor Search Let's say you intend to build a Social Cop in your smartphone. Social Cop helps people report crimes to the nearest police station in real-time. So what seems to be a problem here ? Yes, you guessed it right. We need to search for the police station nearest to the crime location before attempting to report anything. How could we do it quickly ? Seems k-d trees can help you find the nearest neighbor to a point on a two dimensional map of your city. All you have to do is construct a 2 dimensional k-d tree from the locations of all the police stations in your city, and then query the k-d tree to find the nearest police station to any given location in the city. Okay, I get what they can do. But how do they do it ? If you already know how binary search trees work, understanding how k-d trees work would be nothing new. k-d trees help in partitioning space just as binary search trees help in partitioning the real line. k-d trees recursively partition a region of space, creating a binary space partition at each level of the tree. This is what a 3 dimensional region of space partitioned by a 3 dimensional k-d tree looks like [1] : A 3-dimensional k-d tree. The first split (red) cuts the root cell (white) into two subcells, each of which is then split (green) into two subcells. Finally, each of those four is split (blue) into two subcells. Since there is no more splitting, the final eight are called leaf cells. And how is the tree constructed ? To start with you have a set of points in a k-dimensional space. Let's give ourselves an example of a 2 dimensional k-d tree : Input : (2,3), (5,4), (9,6), (4,7), (8,1), (7,2) Output : A 2 dimensional k-d tree [2] : In case of binary search trees, the binary partition of the real line at each internal node is represented by a point on the real line. Similarly, in case of a 2 dimensional k-d tree, the binary partition of the 2 dimensional cartesian plane at each internal node is represented by a line in the plane. So, in case of binary search trees, the point represented by the internal node serves as the point used to partition the real line. How do we choose a partitioning line in case of 2 dimensional k-d trees ? Essentially, you could choose any line passing through the point represented by the internal node to partition the 2 dimensional cartesian plane. The k-d tree output above has been constructed using a simple method for choosing the partitioning line at each internal node of the tree :- Level 0 :- Choose the partitioning line perpendicular to the first dimension (X in this case) and passing through the point represented by the node in question. Level 1 :- Choose the partitioning line perpendicular to the second dimension (Y in this case) and passing through the point represented by the node in question.                                                    :                                                    :                                                    : Level k-1 :- Choose the partitioning line perpendicular to the kth dimension and passing through the point represented by the node in question.   Level k :- Choose the partitioning line perpendicular to the first dimension (X in this case) and passing through the point represented by the node in question. So basically, at each level we alternate between the X and Y dimensions in order to choose a partitioning line at each internal node of the k-d tree. The labels that you see beside each of the nodes of the k-d tree [2] represent the choice of the dimension for the partitioning line at the nodes on that level. Let's now see how our 2 dimensional k-d tree partitions the 2 dimensional plane [3] : Fine, how do I perform the search ? I'll not say I'll leave that up to you, but you'll have to take help of some other resources in order to understand it completely. I can, however, tell you that this space partitioning by a k-d tree can help you find the nearest neighbor to a specific point in space without the need to explore all the partitions which is what we needed, to do real-time reporting for Social Cop. In order to understand the nearest neighbor algorithm on k-d trees, here is a good resource :  http://www.stanford.edu/class/cs... Let me quickly walk you through some of the other applications of k-d trees, as most of the background of k-d trees has already been covered in the discussion of the first application. 2. Database queries involving a multidimensional search key A query asking for all the employees in the age-group of (40, 50) and earning a salary in the range of (15000, 20000) per month can be transformed into a geometrical problem where the age is plotted along the x-axis and the salary is plotted along the y-axis [4] [4] The x-axis denotes the age of the employee in years, and the y-axis denotes the monthly salary in thousand rupees. A 2 dimensional k-d tree on the composite index of (age, salary) could help you efficiently search for all the employees that fall in the rectangular region of space defined by the query described above. 3. n-body Problem [5] How can we efficiently simulate the movements of a collection of objects moving under mutual gravational attraction? The naive method would involve computing the gravitational force between an object due to every other object in order to simulate its motion under gravitational attraction. Moreover, we would have to do it for every object which would take O(n^2) time. Using k-d trees, however, we can partition the space and for each subdivision of space, figure out its total effect on the rest of space. Below is the pseudo code [6] of the algorithm. Put the objects into a tree. Start at the bottom level of the tree, For every region at a depth d in the tree:     If any children are leaves, then compute the interaction directly     Compute the "Multipole expansion"     Convert this into a local expansion for the parent node and pass it up. Move on to level d-1. When we reach the top of the tree, recurse back down the tree, summing the local expansions. 4. Color Reduction [7] What is an intelligent way to pick 256 colors to represent a full color image? The naive method could be to pick up the colors which are used most often. A more efficient method, however, could represent colors in terms of their RGB values and construct a 3 dimensional k-d tree in order to divide the space containing all the colors of the image. The construction of the k-d tree would stop when the count of the leaf nodes becomes equal to 256. The average of the RGB value of each of the 256 partitions could then be used to get a 256 color palette for the full color image. References :   [1], [2], [3] : http://en.wikipedia.org/wiki/Kd-... [4] : Classification Using Nearest Neighbors [5], [6], [7] : kD Trees Updated 93w ago • View Upvotes