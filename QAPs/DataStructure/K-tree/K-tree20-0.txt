Dynamic Programming (DP): Given a tree T with n nodes, how many subtrees (T’) of T have at most K edges connected to (T - T’)?
Suppose that you root T at some vertex, say 1. Every valid subtree will have a single vertex which is closest to 1, and the subtree will be rooted at this vertex. Hence, if we can count the number of valid subtrees rooted at each vertex, we can solve the problem. Consider the vertex u, the (full) subtree rooted at which is S(u). Define f(u,k) = number of subtrees S' rooted at u which have exactly k edges connected to S(u)-S' Now, every vertex u except the root has, in addition to the edges in S(u)-S', the edge u--parent(u) which lies in T-S'. Thus, f(u,k) is actually the number of subtrees S' rooted at u which have exactly k+1 edges connected to T-S'. Thus the total number of valid subtrees is [math]\sum_{k=0}^K f(1,k) + \sum_{u=2}^N \sum_{k=0}^{K-1} f(u,k)[/math]. Now the question is, how to calculate f(u,k). We can do this recursively. Suppose that f(i,j) has been calculated for all i=children of u, for all k. Let v be the last child of u (the children can be ordered in any arbitrary way). A valid subtree S' could either have v as a vertex or not. If v is not in S', no edge in S(v) can appear in T-S', but the edge u--v will appear in T-S'. Hence exactly k-1 edges in T-S' have to be accounted by the remaining children of u. On the other hand, if v does appear in S', the number of T-S' edges in S(v) could be anywhere between 0 and K, but the number of such subtrees has been calculated already. We can use this method of adding a child to find f(u,k) by a DP over the children. void calculate(int u){  //L is the number of children  //K is the maximum value of k for which to calculate f(u,k);  int DP[L+1][K+1];  memset(DP,0,(L+1)*(K+1)*sizeof(int));  //If no children have been chosen yet, there is 1 subtree with 0 edges missing  DP[0][0]=1;  for(int i=1;i<=L;i++)  {    int v=child[u][i];    for(int k=0;k<=K;k++)    {      //If v is not in the subtree, the number of missing edges increases by 1      if(k>0)DP[i][k]=DP[i-1][k-1];      //If v is in the subtree, it could have any number of edges missing      for(int l=0;l<=k;l++)        DP[i][k]+=DP[i-1][k-l]*f[v][l];    }  }  //Now that the calculation is done, we can set f  for(int k=0;k<=K;k++)    f[u][k]=DP[L][k];} Calling this calculate function from a recursive dfs starting from the root will allow us to calculate the f array in the required order : that is, children before the parent vertex. 