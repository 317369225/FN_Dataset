Write a neat code to find LCA of two nodes ? and whats the complexity?
Some good answers are in How do you find the lowest common ancestor of two nodes in an arbitrary tree? One particular one that I like is the one that uses range minimum query (RMQ), which is discussed here: Algorithm Tutorials How it works: LCA algorithm using RMQ works as follows: Suppose we wanted to find LCA(u, v) 1) Perform euler tour on tree T starting at the root. This could be done using DFS and recording the visited node in pre order. Also at each step of the euler tour record the depth of the current node (depth of the node within the given tree). Store this tour and depth in an array. 2) Now create a segment tree of the depth array. 3) LCA is the node with minimum depth that was encountered while performing a walk from u to v (or from v to u). WLOG assume u was visited first during the euler tour, than RMQ on the range (first time visting u, first time visiting v) on the depth array gives us the LCA(u, v) * RMQ query to segment tree should return a node corresponding to the minimum depth and not the value. More detail (with graphics) can be found on the Topcoder tutorial link above Runtime: Suppose n = |V| and m = |E| (1) takes O(n), since runtime of DFS is O(n+m), and since for tree m = n-1 (2) takes O(n), since initialization of segment tree takes O(n) * Note: You might think it is O(n log(n)), since it performs n updates, and each update takes O(log(n)), but it is in fact O(n) since the total number of vertex in segment tree is n + n/2 + n/4 + ... = 2n. (3) takes O(log(n)) for the RMQ query So overall runtime of this algorithm is O(n). If we were to perform multiple query,   DFS and segment tree initialization could be done before hand in O(n) time, and each LCA query will take O(log(n)) time. Code: My implementation of the LCA using RMQ in C++ (might not be the neatest implementation since I have written it under time constraint to solve one of the programming contest problems): #define MAX_N (1 << 17)#define MAX_V (1 << 17)#define INF 1000000#define REP(i, a, b) for(typeof(a) i=(a); i<(typeof(a))(b); i++)#define rep(i, b) REP(i, 0, (b))typedef long long ll;typedef pair<int, int> pii;// adjacency list of a graphvector<int> G[MAX_V];// the root nodeint root;// number of verticesint V;// For lowest common ancestor calculationsint pre_order[2*MAX_V - 1];int depth[2*MAX_V - 1];int id[MAX_V]; class SegmentTree {    int n;    vector<pii> arr;    void init(int _n) {        n = 1;        while (n < _n) n *= 2;        rep(i, 2*n - 1) arr.push_back(pii(INF, i));    }    // Find the minimum value in the range [a, b)    // @return - pair (depth, index)    pii impl_query(int a, int b, int k, int l, int r) {        if (r <= a || b <= l) return pii(INF, k);        if (a <= l && r <= b) return arr[k];        else                  return min(impl_query(a, b, 2*k + 1, l, (l + r)/2),                                          impl_query(a, b, 2*k + 2, (l + r)/2, r));    }        public:    SegmentTree(int _n) {        init(_n);    }    SegmentTree(int *arr, int _n) {        init(_n);        rep(i, n) update(i, pii(arr[i], i));    }    void update(int k, pii a) {        k += n - 1;        arr[k] = a;        while (k > 0) {            k = (k - 1)/2;            arr[k] = min(arr[2*k + 1], arr[2*k + 2]);        }    }    int query(int a, int b) {        pii res = impl_query(a, b, 0, 0, n);        return res.second;    }};void add_edge(int from, int to) {    G[from].push_back(to);}// v - current node// p - parent node// d - current depth// k - current segmentvoid dfs(int v, int p, int d, int &k) {    id[v] = k;    pre_order[k] = v;    depth[k++] = d;    rep(i, G[v].size()) {        if (G[v][i] != p) {            dfs(G[v][i], v, d+1, k);            pre_order[k] = v;            depth[k++] = d;        }    }}int lca(int u, int v) {    int k = 0;    dfs(root, -1, 0, k);    SegmentTree st(depth, 2*V - 1);    return pre_order[st.query(min(id[u], id[v]), max(id[u], id[v]) + 1)];} 