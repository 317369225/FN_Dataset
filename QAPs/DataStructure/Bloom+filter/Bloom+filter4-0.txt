What is a bloom filter and what are they used for?
Bloom filters are used to quickly check if a value is either: definitely not in a collection, or possibly is in a collection. The way you do this is with multiple hash functions.  A hash function, as far as bloom filters are concerned, is something that takes in a value and spits out an index that will usually change when the input value changes. Let's say you have two of these hash functions. Hash function one, when given "A", spits out 2. Hash function one, when given "B", spits out 3. Hash function one, when given "C", spits out 0. Hash function one, when given "D", spits out 1. Hash function two, when given "A", spits out 0. Hash function two, when given "B", spits out 2. Hash function two, when given "C", spits out 2. Hash function two, when given "D", spits out 2. So let's say you had a list: ["A","B"] Then you did some preprocessing, and you ran each of your values through these two hash functions, then you set the bits corresponding to the outputs to 1. We'll say bit 0 is on the right... You end up with this: 1101 So what does this tell you? Can I determine if "A" was in my collection? Well, no, but it might be. Run "A" through both hash functions.  It points to bits 0 and 2. It's possible that those same bits got flipped because of "C" being in the collection, so you can see the ambiguity, and why we don't know for sure. Is "B" in my collection? The hash functions, for B, enable bits 2 and 3. Well, it might be, because bits 2 and 3 are set to 1.  We could actually figure out that B is indeed in the collection, because nothing else can be responsible for setting bit 3 to 1, but bloom filters aren't used that way.  You take the value you want to check for, see what bits it flips, and then check those bits.  Doing only that is what makes bloom filters very fast (as fast as running your hash functions once). Is "C" in my collection? We don't know, for the same reason that we're not sure about "A".  It could be though. Is "D" in my collection? The hash functions generate 1 and 2. We see the 1-bit isn't enabled.  Therefore, we can determine "D" is definitely NOT in my collection. See how it works?  In this example, the probability that a value is actually in the collection if the bits are flipped is a lot lower than you'd like.  The chances can be increased if you have hash functions that have much fewer collisions, and generate values over a wider range of bits. If the probability of an item's inclusion is high enough, then it's potentially good enough for some purposes.  If the bloom filter saying a value "possibly is" in the collection, with a 90% chance of being true, then it might be an easy way to decide whether to act on that value being present, then, in the unlikely case that it's not, suffering the cost (greatly outweighed by the potential benefit) of undoing the action. 