What is the easiest way of implementing an augmented red-black tree such that it gives me the kth order statistic (kth element) in O(logn) time? Can the set be augmented?Or should I use a skiplist? The answer is needed from a competitive programming view.For the kth order statistic, we can augment a size attribute in nodes of a red black tree. Augmenting red black tree is given in CLRS (3rd edition) in chapter 14 Augmenting Data Structures (page no. 343-344). But there is one thing that is not discussed there in the deletion of RedBlackTree. I will discuss the whole procedure here. INSERTION Insertion into a red-black tree consists of two phases. The first phase goes down the tree from the root, inserting the new node as a child of an existing node. The second phase goes up the tree, changing colours and performing rotations to maintain the red-black properties. To maintain the subtree sizes in the first phase, we simply increment x:size for each node x on the simple path traversed from the root down toward the leaves. The new node added gets a size of 1. Since there are O(lg n) nodes on the traversed path, the additional cost of maintaining the size attributes is O(lg n). In the second phase, the only structural changes to the underlying red-black tree are caused by rotations, of which there are at most two. Moreover, a rotation is a local operation: only two nodes have their size attributes invalidated. DELETION Deletion from a red-black tree also consists of three phases. The first operates on the underlying search tree, the second phase occurs only if the node to be deleted has two children, and the third causes at most three rotations and otherwise performs no structural changes. The first phase either removes one node y from the tree or moves upward it within the tree. To update the subtree sizes, we simply traverse a simple path from node y (starting from its original position within the tree) up to the root, decrementing the size attribute of each node on the path. Since this path has length O(lg n) in an n- node red-black tree, the additional time spent maintaining size attributes in the first phase is O(lg n). The second phase(transplanting phase) in which we transplant the nodes as discussed in the text. When we delete a node which has one children or no children, nothing has to be changed in the size attribute to the node which is transplanted in its position. But, When we delete a node which has two children, we have to change the size attribute of one or more nodes. We handle the O(1) rotations in the third phase of deletion in the same manner as for insertion. Thus, both insertion and deletion, including maintaining the size attributes, take O(lg n) time for an n-node order-statistic tree. Here is the implementation of Red Black Tree with size attribute. I have marked the changes done for augmenting the size attribute. This is tested for the question SPOJ.com - Problem ORDERSET  1 2 3 4 5 6 7 8 910111213141516171819202122232425262728293031323334353637383940 /* Author: Prakhar Jain */ #include <stdio.h> #include <stdlib.h> #define RED		1 #define BLACK	2 struct node { 	int key; 	struct node *left, *right, *p; 	int color; 	int size; }; typedef struct node *NODEPTR; struct node NIL; NODEPTR NILPTR = &NIL; NODEPTR search(NODEPTR root, int k) { 	if (root == NILPTR || root->key == k) 		return root; 	if (k < root->key) 		return search(root->left, k); 	else 		return search(root->right, k); } NODEPTR minimum(NODEPTR root) { 	while (root->left != NILPTR) 		root = root->left; 	return root; } NODEPTR maximum(NODEPTR root) { 	while (root->right != NILPTR) 		root = root->right; 	return root; } void leftrotate(NODEPTR *treeroot, NODEPTR x) {... (more)Loading...