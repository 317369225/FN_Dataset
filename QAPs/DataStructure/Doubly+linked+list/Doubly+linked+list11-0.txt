How can we convert a binary tree to a doubly-linked list in zig-zag level order traversal efficientlyÂ  with/without using recursion?
If not using stack means we cant use recursion then it can be done in [math]O(n)[/math] time by keeping track of the previous level. Being lazy (as well as suspecting it as a homework problem) I will give the code using an array instead of doubly-linked list. You change it for a linked-list easily with appropriate malloc calls, pointer updates and keeping a pointer to left-most and right-most node of previous level as well as size of the previous level. struct DL_Node{Node* t_node;DL_Node* head;DL_Node* tail;} ;DL_Node dl_node[N];int depth = 0;int last_lvl=0,crnt_lvl=1;dl_node[0].t_node = root;int count=1;bool nodes_exist = true;while(nodes_exist){    depth++;    nodes_exist = false;    if (depth%2)    {        for (int i = last_lvl; i < crnt_lvl; ++i)        {            if (dl_node[last_lvl+i].t_node.left != null)            {            dl_node[count++] = dl_node[last_lvl+i].t_node.left;            nodes_exist = true;            }            if (dl_node[last_lvl+i].t_node.right != null)            {            dl_node[count++] = dl_node[last_lvl+i].t_node.right;            nodes_exist = true;            }        }}else   \\ traversing last level in reverse order{    for (int i = crnt_lvl-1; i >= last_lvl; --i)    {        if (dl_node[last_lvl+i].t_node.right != null)        {         dl_node[count++] = dl_node[last_lvl+i].t_node.right;        nodes_exist = true;        }        if (dl_node[last_lvl+i].t_node.left != null)        {        dl_node[count++] = dl_node[last_lvl+i].t_node.left;        nodes_exist = true;        }    }}last_lvl = crnt_lvl;crnt_lvl = count;} If recursion is allowed then store the nodes in a list with there inorder index as well as depth. Then sort the list by depth then by inorder index for nodes of same depth. struct DL_Node{Node* t_node;DL_Node* head;DL_Node* tail;int depth;int index;} ; You can get both inoder index & depth by slightly tweaking the inorder traversal. Just pass the increased depth & index as an arguement when recursively calling inorder on the childeren nodes. Here index is a global variable. inorder(Node* node, int depth){	if (node = null) retrun;	inorder(node.left,depth+1,index);	add_to_list(node,depth,index);	index++;	inorder(node.left,depth+1,index);} 