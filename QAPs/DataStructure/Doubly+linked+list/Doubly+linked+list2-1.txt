Does using a doubly linked list help to reverse the stack in constant time? How?
Spoon fed C# version using System; namespace Irne.Collections{    using System.Collections.Generic;     public class ReversibleStack<T> : IEnumerable<T>    {        internal class ReversibleStackNode<TT>        {            internal ReversibleStackNode<TT> Previous, Next;            internal TT Value;             internal ReversibleStackNode(TT value)            {                this.Value = value;                this.Previous = null;                this.Next = null;            }        }         internal ReversibleStackNode<T> head, tail;        internal bool reversed;        internal int count;         public ReversibleStack()        {            head = tail = null;            count = 0;        }         public IEnumerator<T> GetEnumerator()        {            return new ReversibleStackEnumerator<T>(this);        }         System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()        {            return new ReversibleStackEnumerator<T>(this);        }         public void Reverse()        {            reversed = !reversed;        }         public bool IsReversed {            get { return reversed; }            set { reversed = value; }        }         public bool IsEmpty { get { return (head == null); } }         public int Count { get { return count; } }         public void Push(T value)        {            ReversibleStackNode<T> node = new ReversibleStackNode<T>(value);            if (reversed) {                if (tail == null) {                    head = tail = node;                } else {                    tail.Next = node;                    node.Previous = tail;                    tail = node;                }            } else {                if (head == null) {                    head = tail = node;                } else {                    head.Previous = node;                    node.Next = head;                    head = node;                }            }            count++;        }         public T Peek()        {            return (reversed) ? tail.Value : head.Value;        }         public T Pop()        {            ReversibleStackNode<T> node;            if (reversed) {                node = tail;                if (node != null) {                    tail = node.Previous;                    tail.Next = null;                }            } else {                node = head;                if (node != null) {                    head = node.Next;                    head.Previous = null;                }            }            count--;            return node.Value;        }    }     public class ReversibleStackEnumerator<TT> : IEnumerator<TT>, IDisposable    {        internal ReversibleStack<TT> source;        internal ReversibleStack<TT>.ReversibleStackNode<TT> node;        object System.Collections.IEnumerator.Current { get { return this.Current; } }         internal ReversibleStackEnumerator(ReversibleStack<TT> stack)        {            source = stack;            Reset();        }         public void Dispose() {}         public TT Current {            get {                return node.Value;            }        }         public bool MoveNext()        {            if (source.reversed) {                node = (node == null) ? source.tail : node.Previous;            } else {                node = (node == null) ? source.head : node.Next;            }            return (node != null);        }         public void Reset()        {            node = null;        }    }} Note: Depending on the amount of traversals you're going to use in the stack, it might be more efficient to implement the stack as a circular array. Though that brings its own pros and cons over a LL implementation: Pro: You get better possibilities of cpu cache optimizations - could mean orders of magnitude faster running time (in some situations). This is not the case with a LL, in that each of its nodes are placed on the heap - thus may be scattered randomly across the entire RAM domain - nearly impossible to keep them all in cache. Con: When pushing onto the stack, you either need to ensure the original static array had enough free space to begin with, or you need to use a dynamic array (or as is more usual fake a dynamic by copying into a new larger array). Thus you either have a preset maximum size for the stack, or the push operation might become O(N). This is a Pro for LL, as "growing" the LL is an O(1) operation - both single and double linked lists. Con: The indexing is more complicated for a circular array - thus some extra CPU cycles are taken to find the head/tail node. You can alleviate this through some tricks, but if you go with the simplest method (i.e. mod) then you're paying a division operation (many times more time consuming than an addition / subtraction) every time you access any node in the stack. Pro for LL ... no such complicated indexing is required. Pro: Reversing is pretty much the same principle as a DLL, but the benefit is that much less needs to change in the implementation in order for it to be reversed in O(1) time as opposed to changing a SLL into a DLL. Updated 53w ago