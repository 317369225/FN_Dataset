Does using a doubly linked list help to reverse the stack in constant time? How?
You don't need to reverse the list. Iterate Forward: - Get First - Call get next on it recursively Iterate Backward: - Get Last - Call get previous on it recursively So the actual cost of going backwards is zero. Now, if you actually wanted to reverse the list, the cost would still be linear, as it would be proportional to the number of nodes. You would need to swap the next and previous pointers for every single node in the linked list. Update: Diagram Start                                End      -> Linked List   |                                      |  V                                     V  N1 -> <- N2 -> <- N3 -> <- N4        -> Nodes   |            |            |             |  V           V          V            V D1         D2         D3          D3       -> Data Where: A -> B is a pointer from A to B So I'll explain the linked list, which i tried to show above. The linked list is composed of pointers, called N1, N2, N3, and N4. Each Node has a pointer to next, and previous. In this case the next points are as follows: N1 next points to N2, N2 next points to N3, N3 next points to N4. N2 previous points to N1, N3 previous points to N2, N4 previous points to N3. Also, what I didn't show in the diagram, is that N1 previous points to null, and N4 next points to null. Each node contains a pointer to some data. In java it is an instance of some class. There are two pointers to the start and end nodes N1, and N4 in this case. The linked list itself only keeps track of these two pointers, anything else must be computed. Reversed: Start                                End      -> Linked List   |                                      |  V                                     V  N4 -> <- N3 -> <- N2 -> <- N1        -> Nodes   |            |            |             |  V           V          V            V  D4         D3         D2          D1       -> Data To reverse it two things need to change: 1) The start pointer is now N4 instead of N1. The end pointer is Now N1 instead of N4. So, both of these pointers have been swapped. 2) Now look at the nodes themselves. N4 Next now points to N3, not null! N4 previous now points to null not n3! The previous and next pointers have been swapped for node N4. Likewise, the pointers must be swapped for all the Nodes: N1, N2, N3, N4 Operation #1 is constant time, but Operation #2 is linearly proportional to the number of nodes. Therefore, the total cost of reversing the linked list is linear. Updated 80w ago • Asked to answer by Anonymous