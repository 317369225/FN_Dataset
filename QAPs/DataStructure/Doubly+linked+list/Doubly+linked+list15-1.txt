Ordered Tree to Circular Doubly link list: A non-recursive function treeToList (Node root) that takes an ordered binary tree and rearranges the internal pointers to make a circular doubly linked list out of the tree nodes?
I have came up with one solution but using stack, and using in-order successor and pre-order successor: NodeTree{     Int data;     NodeTree small;//left     NodeTree large;//right}//logic is very simple do the inorder traversal, and modify the large and small pointerNodeTree treeToList(NodeTree treeRoot){          If(treeRoot==null)            return;             Boolean isFirstTimeVisted=false;             Stack tracedStackedNode=new Stack();                         NodeTree current=treeRoot;            NodeTree lastVisitedInOrdrTrvrsl=null;             NodeTree headNode=null;    do{              If(current!=null){                       tracedStackedNode.push(current);                       current=current.small;             }else{                        current=tracedStackedNode.pop();                                                   If(!isFirstTimeVisted){                                 isFirstTimeVisited=true;                                 headNode=current;                           }                          If(lastVisitedInOrdrTrvrsl!=null)                                lastVisitedInOrdrTrvrsl->large=current;                                    current->small=lastVisitedOrdrTrvrsl;                                lastVisitedInOrdrTrvrsl=current;                                 current=current.large;                          }          } while(!tracedStackedNode.isEmpty())         //since we have to create the circular doubly-linked list              headNode.small=lastVisited;              lastVisted.large=headNode;               return headNode;} The program takes O(N) time, where N is the number of nodes and the maximum space it takes in the stack is O(N) if the tree is skewed. Updated 126w ago