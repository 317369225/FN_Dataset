You are given a linked list of N nodes. How would you prove or disprove that this is a Doubly linked list or not?
Since this question has been filed under under C (programming language), I'm assuming this is a question about C.  In that context this question doesn't make sense.  Truthfully, I can't think of a context where it does make sense, but I'm hoping the explanation in C will show why. If you have a struct which represents a node in a doubly linked list you can "cast" any region of memory to that struct.  The underlying region might not contain sensible data, but your C program will happily treat it like a doubly-linked list until something breaks. Likewise, if you start with a valid doubly-linked list there's nothing preventing you from inserting rubbish data, e.g., node->next = 0xFACEFEED;node->prev = 0xDEADBEEF; How do you differentiate between a region of memory that contains rubbish by accident and a region of memory that contains rubbish because your program inserted it there?  Heck, how do you differentiate rubbish from non-rubbish? So neither "you are given N nodes" nor "prove that this is a doubly-linked list" make sense to me if you're talking about C.  What is a "node" if not a struct?  If it's a struct, why can't we just look at its definition? If we're not talking about a struct, what are we talking about?  A void * pointer?  How do we know how many bytes one of your voodoo "nodes" takes up? At the end of the day your memory is just a bunch of undifferentiated 0s and 1s.  The semantics of the data are defined by how our program interacts with it.  A struct is just a convenient way for us to segment a larger region of memory into smaller, named chunks of a pre-determined width. In fact, one way to achieve polymorphism in C is to design clever structs such that the same region of memory can be cast to either struct and work as planned 