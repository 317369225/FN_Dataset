Are there any programming concepts not yet implemented? What are they?
Probabilistic programmingFrom Probabilistic Programming: Probabilistic graphical models provide a formal lingua franca for modeling and a common target for efficient inference algorithms. Their introduction gave rise to an extensive body of work in machine learning, statistics, robotics, vision, biology, neuroscience, artificial intelligence (AI) and cognitive science. However, many of the most innovative and useful probabilistic models published by the AI, machine learning, and statistics community far outstrip the representational capacity of graphical models and associated inference techniques. Models are communicated using a mix of natural language, pseudo code, and mathematical formulae and solved using special purpose, one-off inference methods. Rather than precise specifications suitable for automatic inference, graphical models typically serve as coarse, high-level descriptions, eliding critical aspects such as fine-grained independence, abstraction and recursion. PROBABILISTIC PROGRAMMING LANGUAGES aim to close this representational gap, unifying general purpose programming with probabilistic modeling; literally, users specify a probabilistic model in its entirety (e.g., by writing code that generates a sample from the joint distribution) and inference follows automatically given the specification. These languages provide the full power of modern programming languages for describing complex distributions, and can enable reuse of libraries of models, support interactive modeling and formal verification, and provide a much-needed abstraction barrier to foster generic, efficient inference in universal model classes. Figaro is a library that implements probabilistic programming for Scala, but as said in above paragraphs, it's far less ideal than a language with first-class support for this style of programming. These slides serve as a good introduction to the topic - Probabilistic Programming in Scala. Managed timeI stumbled upon this one only this morning. From Programming with Managed Time (essay + videos): There is a huge gap between how a programmer and a computer experience time. Programmers must manually bridge this gap by choreographing program control flow so that all reads and writes occur in "correct" relative orders. But this is quite difficult: consider initializing objects so their fields are not read too early; asynchronously repairing views so that they are consistent with changing models; organizing analyses (e.g. compilation) into multiple passes so updates (e.g. symbol table entries) are visible where needed; or locking resources that can be manipulated from multiple threads. To make programming easier, the time gap could be eliminated by using timeless pure functions, but the ability to update state directly remains convenient, popular, and often necessary. The linked article has some nice videos that illustrate what "managed time" is set out to accomplish. 