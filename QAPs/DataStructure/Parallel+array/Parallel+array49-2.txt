Are there any programming concepts not yet implemented? What are they?
Imperative programming with transactional memory is one that I'm looking forward to - though I'm not sure that it will ever really happen, because it's a hard problem. Or rather, a few hard problems need to be solved before this becomes a feature of an imperative language.  As Tikhon Jelvis noted in a comment below, transactional memory already exists in the functional language Haskell. But, as someone who writes imperative code for a living, I want to see this implemented in an imperative language... I'll illustrate this idea if it were something added to C#, but keep in mind that the idea isn't inherently related to C#. And if it ever does get implemented in C# it will probably look nothing like my example, because I'm making this up as I go along. (I'm making up the syntax, that is. The notion of transactional memory was thought up long ago, by someone much more clever than me.) If transactional memory existed as a feature of C# (and it would probably need to be a feature of the .Net runtime as well), then you could declare a region of code whose in-memory side-effects would be all be undone if control reaches a "rollback" statement. For example, after the following code runs, y would be guaranteed to be larger than x, no matter what values are returned by foo() and bar(): int x = 1; int y = 2; transaction {     x = myObject.foo();     y = myObject.bar();     if (x >= y)     {         rollback;     } } rollback {     myObject.DeleteOutputFile(); } Furthermore, any in-memory side-effects of foo() and bar() would also be reverted if the rollback happens. Not just the changes to x and y. For example if foo() or bar() updated member variables in myObject, or modified a static field value in another class, or added items to a collection, removed items from a collection, etc, etc. Non-memory side-effects like disk writes or network operations can't be undone automagically, hence the need for the rollback code block at the end. So that kind of pokes a hole in the "everything is a transaction" illusion that this feature tries to create, but I still think this would be a pretty neat feature to have available. You could build more features on top of this basic idea... For example suppose that you replace the "if (condition) rollback" with "commit if (condition);" So then you have an explicit commit point, so then you might as well guarantee an atomic commit. 