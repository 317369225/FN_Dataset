Functional Programming:Â Which of Haskell and OCaml is more practical?
OCaml Haskell is a complete joke when it comes to practicality. The developer tool stack sucks, the defacto standard compiler is grindingly slow and horribly badly written and virtually impossible to build much less develop, the REPL is a toy, the libraries are atrocious and the community consists almost entirely of smug weenies. In contrast, the OCaml community are quieter because they spend their time solving real problems and shipping production code rather than publishing research papers about The Sieve of Eratosthenes (see Page on hmc.edu). Oh, and they're honest. Parallelism OCaml has poor support for multicore parallelism but at least it has been used for large scientific computations on supercomputers using MPI. For example, OCaml held the record for largest symbolic computation ever performed (see Archives of the Caml mailing list > Message from Thomas Fischbacher). Haskell has not. Haskell has a highly experimental and largely ineffectual approach to parallel programming (see Regular, shape-polymorphic, parallel arrays in Haskell) coupled with a bare-bones runtime (nowhere near the level of sophistication or efficiency offered by the JVM or .NET). I am not aware of anybody ever having done anything of that magnitude using Haskell. Concurrency Concurrency is a completely different kettle of fish, nothing to do with parallelism and should not be bundled under the same subheading. OCaml has had very solid support for concurrency for over 15 years now. In fact, 15 years ago the heavily concurrent MLDonkey peer-to-peer file sharing client had hundreds of thousands of users (that's probably more users than all Haskell programs ever written combined). No similar success story exists for Haskell. More recently, Haskell got equivalent support for concurrent programming but with few users so it is nowhere near as mature. Libraries Haskell has a huge number of very poor quality libraries. OCaml has far fewer but much higher quality libraries. If you want linear algebra then OCaml has lacaml. If you want fourier transforms then OCaml has FFTW. Incidentally, FFTW provides the fourier transform routines used in MATLAB which has millions of users and it is written in OCaml. No similar success story exists for Haskell. OCaml has one official set of LLVM bindings that are shipped with LLVM itself. Haskell has several unofficial bindings none of which are bundled with LLVM so you'll need to play "spot the abandonware" before you even start your project. OCaml is vastly superior when it comes to parsing, with many extremely high quality parser generators available mostly along the lines of standard industrial tools like lex and yacc (ocamllex, ocamlyacc, menhir, dypgen, camlp4). I'm not sure Haskell has any such tools and most developers use a quirky parser combinator library called Parsec that is unlike anything you have ever seen before or will ever see again (it is really quite grim, IMO). To give you some idea, I wrote a Mathematica parser using lex and yacc in OCaml and Wolfram Research bought it. I tried to write the same parser using Parsec and found it to be a nightmare in comparison and nobody is going to pay for that. Typeclasses vs modules Haskell has typeclasses. OCaml has higher-order modules. Typeclasses are good "in the small" for things like overloading arithmetic operators. Modules are good "in the large" for structural industrial-size code bases. For example, Citrix use modules to structure their million line code base that is maintained by ~20 OCaml developers. There are no million line Haskell code bases or companies employing 20 Haskell developers but at least the students using Haskell can write the Fibonacci function more elegantly over arbitrary-precision rationals. Software engineering Haskell's safety features will lull you into a false sense of security only to throw you under the bus when a deadline looms. You cannot predict performance. You cannot predict memory requirements. Fancy compiler optimisations break under the most bizarre circumstances. You'll need to learn GHC's intermediate language if you want your code to run ok. That's impractical for engineering. Can you imagine a civil engineer saying the bridge is a beautiful shape but nobody knows how much weight it can take? Things Tikhon forgot to mention Haskell has great support for monads and deterministic parallelism. On the other hand, OCaml has a sack full of language features that are designed specifically to make it more practical. For example, function arguments can be labelled or optional in OCaml. Imagine a function that creates a line with a given width, color, dash style, join and end styles. With Haskell you must specify all 6 arguments every time you call the function. With OCaml you can provide sane defaults and provide only one or two arguments most of the time. Not rocket science but very practical. OCaml has polymorphic variants. For example, OpenGL has the concept of front and back buffers. To refer to the front buffer in Haskell you write: Graphics.Rendering.OpenGL.Framebuffer.FrontBuffer In OCaml you write `front. Again, not rocket science but very practical. Since Perl, dictionaries or hash tables have been one of the most popular data structures. OCaml has had a decent dictionary implementation (Hashtbl) since its inception. In the Haskell world, real users had to complain for 4 years (see Improve interaction between mutable arrays and GC) because Haskell's hash tables were 32x slower than .NETs (see F# vs OCaml vs Haskell: hash table performance) before a serious performance bug in the garbage collector was fixed. Thanks to that fix Haskell is now just 2x slower than OCaml and 10x slower than F# (see Hash table insertion performance: F# vs OCaml vs Haskell). Finally, perhaps you can measure practicality by the number of people who put their money where their mouth is. OCaml has INRIA's CAML Consortium that allows industrial users to fund work and get OCaml under other licenses. The CAML Consortium has garnered 13 members and is still rising. Three companies using Haskell founded the Haskell Industrial Group in 2009. Over 6 years since then they have succeeded in garnering no new paying members at all. 