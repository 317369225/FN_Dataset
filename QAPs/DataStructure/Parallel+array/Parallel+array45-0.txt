Parallel Computing:Â What is the difference between SIMD and MIMD?
SIMD and MIMD are types of parallel architectures identified in Flynn's taxonomy, which basically says that computers have single (S) or multiple (M) streams of instructions (I) and data (D), leading to four types of computers: SISD, SIMD, MISD, and MIMD. Let's skip SISD and MISD, since the question doesn't ask about them, and neither is spectacularly interesting. Single Instruction Multiple Data (SIMD) means that all parallel units share the same instruction, but they carry it out on different data elements. The idea is that you can, say, add the arrays [1,2,3,4] and [5,6,7,8] element-wise to obtain the array [6,8,10,12] in one big whoop: for this, there have to be four arithmetic units at work, but they can all share the same instruction (here, "add"), and work by all performing the same actions in tight, lock-step synchronicity. This usually means putting multiple data-manipulation thingies inside the same processing core as one instruction decoder, for the sake of the tight timekeeping. Here's a picture of a SIMD kind of sports teamwork, for illustration: Multiple Instruction Multiple Data (MIMD) means that parallel units have separate instructions, so each of them can do something different at any given time; one may be adding, another multiplying, yet another evaluating a branch condition, and so on. This is the sort of parallelism you get with threads, which basically let programs dispatch an entire function call to run on a different processor. This means involving multiple fully-featured, independent processing cores, whether they are on the same chip (multi-core), different ones (multi-processor), or a mixture of the two. Here's a picture of a MIMD kind of sports teamwork, for illustration: Flynn's terms have been bandied around in a few different contexts in the years since they were first defined (1966), so by now it is perhaps better to think of them as general names for different modes of parallel execution, rather than as exact names for precisely defined families of processor features. Hope this clarifies the matter somewhat. 