Functional Programming: Which of Haskell and OCaml is more practical?
Haskell. This is a question I'm particularly well-placed to answer because I've spent quite a bit of time with both Haskell and OCaml, seeing both in the real world (including working at Jane Street for a bit). I've also seen the languages in academic settings and know many people at startups using both languages. This gives me a good perspective on both languages, with a fairly similar amount of experience in the two (admittedly biased towards Haskell). And so, based on my own experience rather than the languages' reputations, I can confidently say it's Haskell. Parallelism and Concurrency Haskell has very good multicore capabilities. It has a very well-optimized runtime based on green threads: you can have something on the order of hundreds of thousands if not millions of threads on a laptop. It also has some great concurrency primitives, including what is easily the best STM implementation around. It also supports deterministic parallelism—your code is guaranteed to give the same results as the sequential version. OCaml, on the other hand, does not have anything quite as nice. There are some promising cooperative threading libraries like LWT or Async, but that's about it. I believe actually taking advantage of multiple cores requires using multiple processes, which is a pain. (I understand there are some projects to fix this, but I do not know their current status.) Libraries Haskell has a much better standard library. It also has a larger collection of additional libraries, including some exceptionally useful ones like QuickCheck which are hard to replicate in OCaml. OCaml does have a compelling alternative stdlib in Jane Street's Core, but the one that actually comes with the language is annoying. Haskell also has some really useful domain-specific libraries like ad for automatic differentiation, linear for linear algebra, sbv for interacting with SMT solvers, repa for parallel array processing, euterpea for music, parsec and attoparsec for parings and llvm-general for, well, LLVM. Haskell also has handy DSLs for systems programming like copilot and ivory and even an embedded HDL: Kansas Lava. I do not know of OCaml equivalents for most of these, and cannot think of any OCaml libraries I would miss in Haskell. Haskell is also better equipped for web programming with a nice selection of frameworks like Snap and Yesod. OCaml has a more compelling story for compiling to JavaScript with Js_of_ocaml, but I've found the rest of the web stack lacking. Typeclasses vs Modules Haskell has typeclasses, which are simply awesome. OCaml has a superb module system which can play some of the same roles, but typeclasses are simply more useful, more often. Some specific patterns—like monads—are nicer and easier to use thank to typeclasses. People using OCaml in the real world do still use particular monads like option or async, but they're more awkward than in Haskell, especially when you want to use multiple ones in related parts of your code. Additionally, it's much harder to write generic code against monads in OCaml. In some sense, OCaml modules are better behaved and founded on a sounder theory than Haskell typeclasses, which have some serious drawbacks. However, the fact that typeclasses can be reliably inferred whereas modules have to be explicitly used all the time more than makes up for this. Moreover, extensions to the typeclass system enable much of the power provided by OCaml modules. There's a very definite trade-off, and Haskell typeclasses aren't always better—especially in regards to modularity. But, on the whole, I feel the Haskell side of the tradeoff is more useful more often than the OCaml side. Software Engineering Haskell really helps with software engineering and producing quality code. The type system is even more extensive than OCaml's and helps manage mutable state and side-effects, beyond just stopping normal type errors. Moreover, as a community, Haskell programms seem more likely to encode invariants in the type system, which makes libraries both safer and more self-documenting. On top of this, Haskell has some incredible testing facilities headed by the aforementioned QuickCheck. QuickCheck is a library that allows for really simple randomized testing of your code: you just write out invariants that should hold and the framework automatically generates random inputs to test them. OCaml makes something like QuickCheck more difficult to use, which means that although equivalent libraries exist, people just don't bother using them. Haskell Cons Of course, OCaml has some advantages of its own as well. It has a performance profile that's much easier to predict. The module system is awesome and often missed in Haskell. Polymorphic variants can be very useful for neatly representing certain situations, and don't have an obvious Haskell analog. While both languages have a reasonable C FFI, OCaml's seems a bit simpler. It's hard for me to say this with any certainty because I've only used the OCaml FFI myself, but it was quite easy to use—a hard bar for Haskell's to clear. One really nice use of modules in OCaml is to pass around values directly from C as abstract types, which can help avoid extra marshalling/unmarshalling; that seemed very nice in OCaml. However, overall, I still think Haskell is the more practical choice. Apart from the reasoning above, I simply have my own observations: my Haskell code tends to be clearer, simpler and shorter than my OCaml code. I'm also more productive in Haskell. Part of this is certainly a matter of having more Haskell experience, but the delta is limited especially as I'm working at my third OCaml company. (Of course, the first two were just internships.) Both Haskell and OCaml are uniquivocally superb options—miles ahead of any other languages I know. While I do prefer Haskell, I'd choose either one in a pinch. Updated 42w ago • View Upvotes