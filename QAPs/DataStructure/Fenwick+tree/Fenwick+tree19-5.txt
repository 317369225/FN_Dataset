What is the most complex line of C code you have created or encountered?
Two examples: while (*n++=*i++) ; /* copy one null-terminated array to another , like strcpy() */ i=((n&0x0F)<<4 | (n&0xF0)>>4); /* exchange the hex digits of a byte eg DF becomes FD */ Explanation of while() :Right side of = takes i , takes the value (X) from the memory pointed at , increments i , gives X to the left side of =. Now left side takes n, stores X at the memory pointed at, increments n, and returns X. If X is 0, then while loop terminates, else it goes to next iteration. Here is a small program to illustrate this (this was in response to a comment, but I think it also answer the questions, and has enough information to be an answer) [code] #include "stdio.h" int main () { int i_array[] = {1,2,3,4,0,0,0,0,0,0} ; int n_array[] = {0,0,0,0,0,0,0,0,0,0} ; int *i = &i_array[0] ; int *n = &n_array[0] ; printf ( "before 'while' :\t arrays are :\n" ); printf ( " i_array[]\t{%d,%d,%d,%d,.....}\n",i_array[0],i_array[1],i_array[2],i_array[3] ); printf ( " n_array[]\t{%d,%d,%d,%d,.....}\n",n_array[0],n_array[1],n_array[2],n_array[3] ); while (*n++=*i++) printf("%d\t%d\n",i,n); printf ( "after 'while' :\t arrays are :\n" ); printf ( " i_array[]\t{%d,%d,%d,.....}\n",i_array[0],i_array[1],i_array[2],i_array[3] ); printf ( " n_array[]\t{%d,%d,%d,.....}\n",n_array[0],n_array[1],n_array[2],n_array[3] ); } [/code] Output: before 'while' :         arrays are :  i_array[]      {1,2,3,4,.....}  n_array[]      {0,0,0,0,.....} 2088623364      2088623316 2088623368      2088623320 2088623372      2088623324 2088623376      2088623328 after 'while' :  arrays are :  i_array[]      {1,2,3,4,.....}  n_array[]      {1,2,3,4,.....} So if n and i are pointers to starting of two arrays, then the while loop will copy one to the other terminating at a 0. This is very useful (and very fast) if the arrays are "strings of characters" terminated by 0. To  illustrate, I have added the printing of the memory addresses in the  while loop where you can see that both pointers increase until one points to 0. Very simple !! Very useful !! Explanation of exchanging hex digits : i=((n&0x0F)<<4 | (n&0xF0)>>4); /* exchange the hex digits of a byte e.g. DF becomes FD */ The bit-wise AND operators give the individual hex digits (4bits) which get shifted left or right and combined by bit-wise OR to get the final result. Similar technique can be used to exchange "2 bytes of 16 bit number" or "4 hex digits of 16 bit numbers" etc Updated 23 Aug 2013 • View Upvotes