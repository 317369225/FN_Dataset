What is a Fenwick tree and how do I solve these problems?Chef and Swaps
Fenwick tree is a data structure which supports following queries in O(log(n) ): Inc(x, val) -- increase element as position x by val. PrefixSum(x) -- returns the sum of all elements which index is x or smaller. Note, that operation does not have to be summation, as long as it is commutative and associative. One such operation is maximum or minimum. Furthermore, if operation has an inverse, like addition has (but not maximum nor minimum) you can easily get Sum(a, b) = PrefixSum(b) - PrefixSum(a - 1) Ok, now that I said what fenwick tree does... next logical question is how to implement it? Usually Fenwick tree is implemented as an array. Let's call this array A. Original array shall be noted as Q for no particular reason (or I just like Q from Star Trek). IMPORTANT NOTICE: Let this array start with index 1. Thus first valid index is 1, followed by 2, and so on. Do not use index 0 under this implementation or you're gonna have nasty bugs. Now let's say we have element in that array A[x]. What shall that element hold? It hold the sum of Q[x] + Q[x-1] + Q[x-2] + ... + Q[x - lowbit(x) + 1]. What is this lowbit(x) function? Actually it is pretty simple, it represents the value of least significant bit in x: Example (Numbers are written in binary system): lowbit(1)  =  1 lowbit(10) = 2 lowbit(1010) = 2 lowbit(1100) = 4 And this trick help us compute PrefixSum efficiently. Let's say our x = 1101 in binary. Thus A[1101] = Q[1101], A[1100] = Q[1100] + Q[1011] +  Q[1010] + Q[1001] A[1000] = Q[1000] + Q[0111] + Q[0110] + Q[0101] + Q[0100] + Q[0011] + Q[0010] + Q[0001] Can you see the pattern here? When we add A[1101] + A[1100] + A[1000] we get the sum of Q[0001] + .... + Q[1101] what we asked for. Only thing to notice is we just kept replacing the last one in index x of A with zero. Easy thing to do that programmly is this x &= x - 1; where & is bitwise or. Now that we understood the Prefix sum operation let's move on the Inc(x, val). Notice this: If we increase the index x = 0010, which A[x] need to be affected, that is increased by val? If you observe the structure closely you'll notice it is A[0010], A[0100], A[1000]. What if x = 0011? A[0011], A[0100], A[1000], etc. How to generate next element in that sequence? It's simple actually,  x += x & (x - 1); This trick x & (x-1) is nothing else than lowbit(x) function under assumption x is unsigned. Do not work with negative indexes in your arrays with this data structure. Now that Fenwick tree is dealt with, let's move onto the problem. I'll outline offline solution using Fenwick tree. Online is possible with same asymptotic complexity  by enhancing Fenwich tree with persistence using this:   This is out of scope of my answer. If you have an element at index i, how many inversion is he causing in range [0, i]? Because if we sum that value for all i's we'll get the total number of inversions. And what would happen if we switch elements at index i and j? The absolute number of differences would change by how much? It would increase by 1 for each x between i and j such that   x < A[j]. It would increase by 1 for each x between i and j such that   x > A[i]. It would decrease by 1 for each x between i and j such that  x > A[j]. It would decrease by 1 for each x between i and j such that  x < A[i]. So all we need to compute total number of inversions, and for each query answer how many number between i-th and j-th are element of <A[i], A[j]>. Solution is offline. We remember all queries we need to execute and later on we use that data. Suppose you have an array E_t such that E_t[x] = number of element x in {A[0], A[1], ... A[t] } and you use Fenwick tree on that E_t so you get answer how many number are there in given range before element t. And you use various values of t to answer how many numbers in given range, and given index range are there.. and you problem is done. Now I'm going to better illustrate array E_t on Example given in the task. Thus the array A = [1 4 3 3 2 5]. E_0 = [0 1 0 0 0 0 0] // Because first number is one. E_1 = [0 1 0 0 1 0 0] // Because there is a four E_2 = [0 1 0 1 1 0 0] E_3 = [0 1 0 2 1 0 0] // Another three E_4 = [0 1 1 2 1 0 0] E_5 = [0 1 1 2 1 1 0] This is actual parametrized array, which you change as you inspect more elements of A. It would be unwise to compute each E_t for all t since that would blow up memory space rapidly. Instead you do the queries on adequate version of t, remember the answers and carry on. All E_t are actually cached into Fenwick tree, thus allowing fast rage sum queries. For example, imagine query like this, which you will need to solve this problem. How many numbers with indexes between [1, 4> are bigger than A[4] = 2. I'm using 0-based arrays instead of 1-based as in the task. Sorry for the confusion. So we are looking at numbers [1 |4 3 3| 2 5]. You can imagine this as picking 2 out and inserting it before 4. With t's it it easy  to anser such queries -> All you need is compute the sum of all indexes bigger than 2 to of E_3 - E_0 = [0 0 0 |2 1 0 0|]. With | I am marking interesting boundaries. Order of those operation can be interchanged, that is compute E_3_query [0 1 0 |2 1 0 0|] = 3 - E_0_query = [0 1 0 |0 0 0 0|] = 0 => 3 - 0 = 3. Hope I made myself more clear. It is a bit complex problem. You build this array from earlier iteration.. so something like this: for(int i = 0; i < n; ++i) { inc(A[i], 1) // Do your queries here which you remembered earlier. } This problem is complex if you have never before encountered offline algorithm nor Fenwick tree. EDIT: Problems solution. EDIT2: Trying to elaborate the solution. Updated 18 Sep 2014 • View Upvotes