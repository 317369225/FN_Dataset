What is an intuitive explanation of insertion into an AVL tree?I am not sure if my answer will sufficiently satisfy your curiosity but let me go ahead and give it a shot. Before we get to the magic that's the insertion and deletion operations of an AVL tree, lets gather some background. First there existed binary trees which simply followed a straightforward property: root node is a parent and it can have a maximum of two children. And each children further on follow the same property if there are more elements to be inserted. No other property nor constraints.  (A binary tree) Though this was pretty and all that, it didn't serve any higher purpose rather than simply storing the elements as a tree. A search for a better way to use this property led to what came to be known as the Binary Search Tree. The ultimate selling point of a binary search tree, as the name suggests is its search property. Searching for an element in a binary tree is almost similar to searching for an element in an unsorted array. The complexity of finding an element in a binary tree is . But if you introduce a new property, the search time complexity comes down to . This is because of a technique called Binary search which can be used in a sorted array as well. A binary search tree or a bst, has one additional property that says all the left children are lesser than the root and all the right children are greater than the root. This property helped us in modifying the Binary tree and all the while saving us a lot of search time.  (A binary search tree) But there was one problem with a binary search tree. When elements were not available in a convenient order, the binary search tree kept growing in one particular direction and looked like this: It looks silly doesn't it? So they devised a concept called balancing a binary search tree which essentially maintains the height of a binary search tree at a minimum. After balancing the above tree would look like this: This looks neat doesn't it? So computer scientists did not want to do this mundane activity of balancing a binary search tree every time a new node gets introduced. As a result, they introduced one more property called balancing. AVL trees are nothing but binary search trees that have a special capability called self-balancing. So whenever a new node is introduced, the AVL tree checks whether the height of the tree is minimal. If not, it does a rotation and tries to make the height minimal. For example consider the following tree: If I introduce a new element, say 19, the tree will lose its property of minimal height. Which means that, the tree can further come down in height. For which it will shift the elements 16 and 18, and make 18 the root node of that particular subtree and make 16 and 19 its children. This rotation will take place recursively every time the minimal height is violated. The following image does a good job of describing the multiple cases that would arise when inserting elements into an AVL tree. Images courtesy: Wikipedia. 