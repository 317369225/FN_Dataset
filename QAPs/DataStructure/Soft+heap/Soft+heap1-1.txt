What is the most efficient algorithm to find the kth smallest element in an array having n unordered elements?
So John Kurlak talked about 4 different approaches out which Quick Select has [math]O(n)[/math] average case but [math]O(n^2)[/math] worst case, Here the median of medians algorithm which takes [math]O(n) [/math]in worst cases thus making it much better then quick select.   Algorithm : Find the kth smallest or largest in unsorted array PS:Below algo is for kth largest element in array which can be modified for kth smallest element in array with small changes. Divide the array in to n/5 lists of 5 elements each. Find the median in each sub array of 5 elements. Recursively ﬁnd the median of all the medians, lets call it M Partition the array in to two sub array 1st sub-array contains the elements larger than M , lets say this sub-array is a1 , while other sub-array contains the elements smaller then M., lets call this sub-array a2. If k <= |a1|, return selection (a1,k). If k− 1 = |a1|, return M. If k> |a1| + 1, return selection(a2,k −a1 − 1).   Lets see an interesting  example of this where we have to find out the median of unsorted array in linear time , this may sounds NO at first look because median of array is middle element in sorted array if array is of odd length and middle of two middle elements if array is even length.   we can do it using quick/heap sort which takes [math]O(nlogn)[/math] time but can we improve ? Yes , have you heard about counting sort ? Which takes [math]O(n)[/math] time but extra [math]O(Max-Min+1)[/math] space, Max and Min  are element of array what if array is ar[]={10000000,200000000} , waste of space right ? But if you think about median , which is nothing but middle element of array where k=n/2  if array is odd length, can you see anything now ? Median is nothing but N/2th smallest element in array.Great so we got it , we can call median of medians algorithm up to k=n/2 and we can return ar[n/2] as median.Below is pseudo code for the same.   //selects the median of medians in an arraystatic int selection(int a[], int s, int e, int k){   // if the partition length is less than or equal to 5   // we can sort and find the kth element of it   // this way we can find the median of n/5 partitions   if(e-s+1 <= 5){       Arrays.sort(a,s, e);       return s+k-1;   }      /* if array is bigger we partition the array in sub-arrays of size 5     no. of partitions = n/5 = (e+1)/5 iterate through each partition and recursively     calculate the median of all of them and keep putting the medians in the     starting of the array   */    for(int i=0; i<(e+1)/5; i++){        int left = 5*i;       int right = left + 4;       if(right > e) right = e; //left+(right-left)/2 median will be 3rd element e.g.ar[2] in zero index based array       int median = selection(a,left, right, 2);        swap(a[median], a[i]);   }       /*now we have array  a[0] = median of 1st 5 sized partition a[1] = median of       2nd 5 sized partition and so on till n/5 to find out the median of these n/5       medians we need to select the n/10th element of this set (i.e. middle of it)   */      return selection(a, 0, (e+1)/5, ((e+1)/10));}     call this function selection(ar,0,ar.length-1,k); //k=n/2 which is median   Analysis of Algorithm : Dividing the array by 5 assures a worst-case split of 70-30 and at-least half of the medians are greater than the median-of-medians, hence at-least half of the n/5 blocks have at-least 3 elements and this gives a 3n/10 split, which means the other partition is 7n/10 in worst case.That gives time complexity is [math]T(n) = T(n/5) + T(7n/10) + O(n). [/math] More Read: Page on indstate.edu The Median-of-Medians Algorithm | Hacker News Updated 103w ago • View Upvotes