How do I apply various checks on my code for time-limit, memory-limit, etc irrespective of my programming language?
This is repost of the answer Vivek Prakash's answer to TopCoder: How do online judges identify Time Limit Exceeded? Slow down young man, and let's proceed steadily. Shall we? Now what exactly  you want to achieve is unclear here. Do you simply want to measure the  execution time of the function? Do you want to terminate the program  after the time limit is exceeded? Are you calling the function in a  child process? Is your process running as a privileged user?The  implementation obviously depends on what you want to do and what  environments you are initializing the process with. Nevertheless, there are few different ways. I will get to them one by one with simplest first. 1. Measuring time You  can easily measure the time (clock time & CPU time) taken to  execute a function using clock() and time() functions available in the  header <time.h>. #include <stdio.h> #include <time.h> void my_function(); int main() {     clock_t c0, c1;     time_t t0, t1;     t0 = time(NULL);     c0 = clock();     my_function();     t1 = time(NULL);     c1 = clock();     printf("wall clock time: %ld\n", (long) (t1 - t0));     printf("CPU time: %f\n", (float) (c1 - c0) / CLOCKS_PER_SEC);     return 0; } void my_function() {     printf("%s\n", "Returning from my_function."); } 2. Using SIGALRM See  the code below to understand how you can check whether a function takes  more time than you expect it. There are comments in between the code to  make it easier to understand. You can test by commenting `sleep(3)' and uncommenting `sleep(1)' in my_function() to see what is happening. (Although mixing alarm() and sleep() is a very bad idea, I thought this is the easiest way to show you the effect.) #include <stdio.h> #include <unistd.h> #include <signal.h> #include <err.h> #define TIME_LIMIT 2 void my_function(); void alarm_handler(int); int main() {     if (sigaction(SIGALRM, NULL, NULL) == -1)         err(1, NULL);     // install an alarm handler for SIGALRM     signal(SIGALRM, alarm_handler);     // install an alarm to be fired after TIME_LIMIT     alarm(TIME_LIMIT);     // call your function     my_function();     // cancel any previously set alarm     alarm(0);     return 0; } void my_function() {     //sleep(1);     sleep(3);     printf("%s\n", "Returning from my_function."); } void alarm_handler(int sig) {     printf("%s\n", "Seems you crossed time limit!"); } Now  what happens is that when my_function() is still executing and  TIME_LIMIT is crossed, SIGALRM is fired and alarm_handler() is invoked.  It then prints the message "Seems you crossed time limit!". You can even kill the process using kill() in alarm_handler. 3. Resource Limits Online  judges don't implement TLE by the nasty method I have mentioned above.  They use `struct rlimit' to enforce any type of resource limit including  the time limit. Besides that, there are lots of other signals and  checks used for security and integrity of online judges and even the  simple implementations run into thousands of lines of code. Before proceeding forward, you should take a look at 'man setrlimit'. In  C programs, you can set or get resource limits by setrlimit and  getrlimit respectively. But the caveat is that only a privileged process  may make arbitrary changes to either limit value. Each resource has an associated soft and hard limit, as defined by the rlimit structure. struct rlimit {     rlim_t rlim_cur;  /* Soft limit */     rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */ }; The code snippet below shows how it can be implemented in a very rudimentary way, but enough to give an idea. -- snippet -- #include <signal.h> #include <sys/time.h> #include <sys/resource.h> #define TIME_LIMIT 2 if (sigaction(SIGALRM, NULL, NULL) == -1) {     return -1; } else if (sigaction(SIGXCPU, NULL, NULL) == -1) {     return -1; } struct rlimit rlim; rlim.rlim_cur = rlim.rlim_max = TIME_LIMIT if (setrlimit(RLIMIT_CPU, &rlim) < 0)     err(1, NULL);-- /snippet -- If  your program is running as privileged (root) user, setrlimit sets the  CPU time limit for the program to TIME_LIMIT as defined in the code.  When the soft time limit (rlim_cur) is crossed, SIGXCPU is sent to the  process and when the hard time limit (rlim_max) is crossed, SIGKILL is  sent to the process. You can catch SIGXCPU and do a clean exit. Online judges The  implementation of online judges often takes into account many other  factors like memory limit and security which makes them more  complicated. But the underlying mechanism remains the same. Step by step  they can be written as: Run the process as privileged user Install all signal handlers duplicate input file stream to stdin create a child process set resource limit values in child process switch to unprivileged user in child process exec the program to run in child process In parent process, check for the signals sent using WIFSIGNALED and WTERMSIG, etc. and determine the state of child process. If  you want to learn more about signals and process execution, read  Advanced Programming in UNIX Environment by W. Richard Stevens. http://www.amazon.com/Programmin... The  above mentioned methods and resources may not exactly solve your  problem, but I hope they give you enough idea on how to proceed! This is the repost of the answer Vivek Prakash's answer to Computer Programming: What is the simplest and most accurate way to measure the memory used by a program in a programming contest environment? I assume you want to know how online judges determine 'Memory Limit Exceeded' for a user-supplied program. First you may want to read the general architecture of online judges at How do online judges identify Time Limit Exceeded? where the functioning of online judges has been explained in a very basic way and how they determine TLE - Time Limit Exceeded for a program. Here again the the resource limits come to rescue. But the more useful thing that stand by our side is proc - a file system that contains process information. proc  is the key to determining memory usage by a program. It is an interface  to kernel data structures and is usually mounted at /proc in a  UNIX-based machine. See `man proc` for more detail. For almost  every process running in the system, there is a directory created in  /proc/. The directory name is the process id and it contains several  useful files which convey important information. The two main files of  concern here are: /proc/[pid]/status: This file has  crucial information regarding memory usage such as virtual memory size  (VmSize), size of data segment (VmData), stack size (VmStk), and size of  text segment (VmExe). These sizes are in KB i.e. KiloBytes which is  what often required for the online judge to determinte the memory usage.  (data segment is actually data+bss+heap - which is often confusing!) /proc/[pid]/statm: This  files also contains information about memory usage. The files has a  single row of information where values are placed separated by space.  These values are total program size, resident set size, size of shared  pages, size of text segment, size of lib code, size of data segment +  stack, and  dirty pages. The caveat is that this size  information in /proc/[pid]/statm is in terms of number of pages. But you  can easily get the size in KB by multiplying the number of pages by 4,  assuming in your machine 1 page equals to 4KBs which is usually the case  and that is the value at least in my machine. (I really don't know how  it varies across different machines or OS!) Now with all  this information, the question comes which values (data or stack or text  or combination of some of them) to consider for determining the memory  usage of a process. Before continuing let's have a look at the address  space of a program: Going through What is the stack and heap memory architecture used by C? should provide a better understanding of the address space. Now  the memory we are interested in computing is the sum total of size of  data, bss, heap and stack. VmData in /proc/[pid]/status is the size of  data+bss+heap, and VmStk is the size of stack - both values in Kilo  Bytes. Simply adding VmData nd VmStk gives us the memory usage of the  process. VmData is sometimes inaccurate as the heap size is  inaccurate. Sometimes the kernel allocates more memory than asked for  optimization and the remaining memory is used when demanded later. But  AFAIK they happen when large amount of dynamic memory is allocated by  the process via syscalls suck as brk(). Also sometimes the heap memory  is not used and an anonymous memory mapping is created for large block  of memory requested via malloc(). Below is a piece of  code that shows how to do this. It just contains the portion of interest  and you may have to add/modify many parts to suit your need. int main() {     struct sigaction sigact;     sigact.sa_flags = SA_NOCLDSTOP | SA_NOCLDWAIT;     // define your own signal_handler     sigact.sa_handler = signal_handler;         if (sigaction(SIGALRM, &sigact, NULL) == -1) {         return -1;     } else if (sigaction(SIGXCPU, &sigact, NULL) == -1) {         return -1;     }     int pid;     if ((pid = fork()) == -1) {         perror("fork");         exit(EXIT_FAILURE);     } else if (pid == 0) {    /* child */         /* set resource limit values such as RLIMIT_CPU,          * RLIMIT_STACK, RLIMIT_RSS, etc.          * See `man setrlimit`.          */         // exec user program     }  else {            /* parent */         struct rusage resource_usage;         // set arbitrary lower limit value of memory used         int memory_used = 128;         pid_t pid2;         do {             memory_used = max(memory_used, get_memory_usage(pid));             if ((memory_used > memory_limit)                 kill(pid, SIGKILL);            // wait for the child process to change state             pid2 = wait4(pid, &status, WUNTRACED | WCONTINUED, &resource_usage);         } while (pid2 == 0); } It  is worthwhile to note here that the resource limits are preserved  across execve. So the user-supplied program exec'ed in the child process  inherits the resource limits. Setting RLIMIT_STACK and RLIMIT_RSS to  appropriate values also help in limiting the memory usage of a process. The only function in above code which needs to be implemented is get_memory_usage(). int get_memory_usage(pid_t pid) {     int fd, data, stack;     char buf[4096], status_child[NAME_MAX];     char *vm;     sprintf(status_child, "/proc/%d/status", pid);     if ((fd = open(status_child, O_RDONLY)) < 0)         return -1;     read(fd, buf, 4095);     buf[4095] = '\0';     close(fd);     data = stack = 0;     vm = strstr(buf, "VmData:");     if (vm) {         sscanf(vm, "%*s %d", &data);     }     vm = strstr(buf, "VmStk:");     if (vm) {         sscanf(vm, "%*s %d", &stack);     }     return data + stack;    } This  implementation of get_memory_usage() has used /proc/[pid]/status. You  can also read from /proc/[pid]/statm, and multiply the penultimate value  (number of pages in data+bss+heap+stack) by the page size. A few worthy points can be noted here: VmRSS  in /proc/[pid]/statm is a useful data. It shows how much memory in RAM  is occupied by the process. The rest extra memory has either been not  used or has been swapped out. VmSize is how much virtual memory  the process has in total. This includes all types of memory, both in RAM  and swapped out. These numbers can get skewed because they also include  shared libraries. We can determine the memory used by stack  and heap from /proc/[pid]/smaps. Searching for the keywords `heap` and  `stack` returns two lines of information - the first value in each line  is the range of addresses in heap and stack respectively. This address  is in hexadecimal. So to calculate the size we can simply subtract the  higher value to lower value, convert the result to decimal form and  divide by 4*1024 to get the size in Kilo Bytes. P.S. There may be more accurate ways than this for measuring memory usage and I would love to know about them. 