How can we find the number of palindromic substrings in a string in linear time?
Here is an O(N log N) solution using hashing. Let S[1…N] be the original string. Let T[N…1] be the reversed string. First of all, choose a hashing scheme which allows to calculate the hash for any substring of S and T using only O(N) precomputation. One way would be to use the scheme followed in Rabin-Karp algorithm, which is described here. Using the scheme, precompute the hashes for all prefixes of S and T in O(N) time. These can be used to find the forward/reverse hash for any substring in O(1) time. Now, note that S[i…j] is a palindrome iff S[i…j]=T[j…i]. If our hashing scheme is good enough, this happens iff hash(S[i…j])=hash(T[j…i]). We can check whether the hash for every substring S[i…j] is equal to the hash for T[j…i]. This would take O(N²) time. But we can improve this complexity using binary search. S[i…j] is a palindrome for j-i+1>2 iff S[i]=S[j] and S[i+1…j-1] is a palindrome. The second condition means that for every character/pair of adjacent characters, there is a maximum size of palindrome that can be centred at it. Every shorter substring centred at it will be a palindrome whereas every longer substring won't. For example, consider the string 'zabcdcbef'. If we look at all substrings with 'd' as the centre, 'd', 'cdc', 'bcdcb' are palindromes whereas 'abcdcbe' and 'zabcdcbef' are not. For every centre, use binary search to find the longest palindrome centered around it. Since there are 2N-1 centres and doing binary search takes O(log N) time per centre, the overall complexity is O(N log N). 