What is a very good explanation of how branch and bound works?
Caveat: I'm not a mathematician, so terminology in my answer may be wrong, but the explanation is correct. Hope it's clear enough. Branch and bound is a technique used in integer optimization problems - ie optimization problems for which the variables are integers. Often (though not always) the variables are constrained to have values of either 0 or 1. One example of this is the knapsack problem in which one is asked to select objects, each with a defined cost and a defined value, from a list, with the aim of reaching the highest total value while keeping total cost under a predefined limit. The variables in this case are binary - is each object selected, or not. Branch and bound can be used in integer optimization problems which are not binary, but is easier to explain using binary problems, and specifically through the knapsack problem. The general concept of branch and bound is this - imagine a binary tree, as deep as the number of variables you have, at each level, each variable can take the values 1 or 0 (so at level one you'd have 2 nodes representing "0" and "1", at level 2 you'd have 4 nodes, representing values "00", "01", "10", "11" etc).Â  A solution to the problem would be a path from the top of the tree to the bottom which reaches the highest total value under the given cost constraints, but clearly, checking each combination is highly costly and doesn't scale. In order to reduce the number of calculations, we want to "prune" the tree, ie ignore completely sections of it which we know can't have better results than the best one we've already found, without needing to fully calculate what results they achieve. The way this is done is by finding some way to calculate an upper bound on the best possible result from the part of the tree we're hoping to prune. Often, this is done by relaxing the constraints which are making the problem hard to solve in the first place -- the integer constraints. This is the methodology you use in knapsack. For example, if we have the following objects to select from and are looking for the maximum total value at a total cost of 5 or less: Cost 2, value 4 Cost 3, value 4 Cost 2, value 3 Cost 1, value 1 If we do away with the integer constraints (ie the requirement that each object is either fully in or fully out - allowing fractions of objects to be used) then the solution is easy: greedily pick objects in the order of their "value-for-money" until the cost limit had been exceeded, and remove a fraction of the last object such that the cost limitation is reached exactly. In our original example: 4/2 = 2 units of value per unit of cost 4/3 = 1.333 3/2 = 1.5 1/1 = 1 We thus make the following selections: Select object 1. Total cost = 2<5, total value = 4 Select object 3. Total cost = 4<5, total value = 7 Select one-third on object 2. Total cost = 5, total value = 8.333 This is an upper bound on the value we can reach under the constraints of this specific knapsack problem. The branch & bound algorithm works as follows: at any node we are faced with the question of whether to "take" a certain object from the list, or not. We need to pick one option (take or not) to calculate fully (by recursively calling the branch and bound function). For the second option we only calculate an upper bound (as shown above) and if that upper bound is lower than the fully calculated option, we know the fully calculated option is better. Otherwise, we need to fully calculate the second option too. When programming a branch & bound solution, some things to consider are: Which variables should be at the top of the tree and which at the bottom? (if you can easily prune a large part of the tree at the beginning this reduces computation time) How do you decide at each node which option to fully calculate and which to bound? (you should prefer calculating the one that is more likely to be better, since that gives you a chance of calculating fully only once) Branch & bound cannot guarantee short computation time as that depends on the degree of successful pruning which itself depends on the problem definition (values, costs etc). At worst, you'd need to fully calculate the entire tree. At best, you'd only need to fully calculate one path through the tree and prune the rest of it. 