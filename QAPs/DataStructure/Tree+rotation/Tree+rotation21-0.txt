How does join and split work in a Treap when adding or removing an element?
There may be some confusion here - you don't join/split a treap when adding/removing elements. I'll describe two join/split algorithms, the classic version you probably know, and an enhanced version that takes a few shortcuts. Hereinafter, INSERT and DELETE refer to the treap insert and delete operations, including any necessary tree rotations to correct for heap ordering. DISCARD means severing all links to/from the node in question and throwing it away. One very important caveat: Both treap join algorithms below assume that the two sub-treaps are the result of a previous split, with unchanged priorities. If you're trying to join two arbitrary treaps, whose range of values may actually overlap, you're probably better off building a brand-new treap by individually INSERTing the values of the two sub-treaps instead. CLASSIC TREAP JOIN/SPLIT Prerequisites: The minimum ([math]P_{min}[/math]) and maximum ([math]P_{max}[/math])possible node priorities are reserved. For instance, if you're using a 32-bit integer to store priorities, [math]P_{min} = 0[/math] for joining and [math]P_{max} = 2^{32}-1[/math] for splitting, then the rest can be randomly assigned. To split a treap, you know a value [math]x[/math] that is between the values of the two nodes you want to split the treap on. To join two treaps, all the values in one treap ([math]T_1[/math]) must be less than the smallest value in the second ([math]T_2[/math]). Also, you know a value [math]x[/math] that is between the two ranges. To split a treap in two: ADD [math]x[/math] into the tree with priority [math]P_{max}[/math]. Rotate treap to correct for heap ordering - [math]x[/math] is now the treap root, and its children are the split trees. DISCARD [math]x[/math].To join two treaps: Create a node for [math]x[/math] with priority [math]P_{min}[/math]. Make [math]T_1[/math] its left child and [math]T_2[/math] its right child, so you have a proper BST. Rotate to correct for heap ordering - [math]x[/math] is now a leaf node. DISCARD [math]x[/math]. ENHANCED TREAP JOIN/SPLIT Prerequisites: [math]P_{max}[/math] is reserved (see above for its definition). To split a treap, you know a value [math]x[/math] that's already in the treap, around which you want to split. (For instance, if all contiguous values around the split point are already in the tree, the classic method can't be applied. Of course, [math]x[/math] will remain in one of the sub-treaps). To join two treaps, all the values in one treap ([math]T_1[/math]) mustÂ  be less than the smallest value in the second ([math]T_2[/math]). No intermediate value [math]x[/math] is required, unlike the classic method.To split a treap in two: [1] Find the node with [math]x[/math]. Save its original priority ([math]P_{orig}[/math]). Assign [math]x[/math] priority [math]P_{max}[/math]. Rotate treap to correct for heap ordering - [math]x[/math] is now the root node and the "root" of [math]T_2[/math], while [math]T_1[/math] is its left child. Remove [math]T_1[/math] from treap - [math]x[/math] now only has a right child. Assign [math]x[/math] priority [math]P_{orig}[/math]. Rotate [math]T_2[/math] to correct for heap ordering.To join two treaps: [2] Create a dummy node - value and priority are irrelevant. Make its left child [math]T_1[/math] and its right child [math]T_2[/math]. REMOVE the dummy node - its only purpose was to link the two sub-treaps together, and the heap-ordering rotations needed to move the dummy node to a leaf position for discarding will set everything back in its proper place. NOTES [1] Inspired by this answer on stackoverflow.com. [2] Shamelessly stolen from slide 14 here. 