What is the best (programming) algorithm that you have ever created?Anything that you're proud of and would like to share the algorithm as well?
As a VC (and previously a PM) I haven't done a lot of coding recently. But these are my top three favorite hacks I've done over the last 5-6 years: 1.) Real time electricity consumption algorithm: In my senior year of school I developed an algorithm for estimating the real time consumption of power in a computer as a function of its processors' Thermal design power or TDP. The idea was that if you know some information about the computer's processor architecture, TDP, and its current utilization that you could estimate the power draw of real time applications. While this does nothing for you if your machine just constantly draws the same amount of power (see: HowStuffWorks "How Vampire Power Works") the algorithm could provide some introspection into how different types of applications and workloads affected a computer's power consumption - something very interesting at scale in a data center. I used this algorithm inside of something called The Tesla Project, which a buddy of mine and I submitted for Microsoft's Imagine Cup competition. We ended up being a national finalist for the competition in 2010, and have since looked into patenting it. Some more info on Tesla: Page on Sjsu 2.) Graph theoretic currency arbitrage: In my junior year of school I tried to use math for the darkest of dark sides: finance. My best friend had just done her summer internship in investment banking at Bank of America Merryl Lynch, and I wanted to find a way for me to join her in the following summer. Unfortunately as a student at a 2nd tier school, investment banking was out of the question. So I leveraged my resume and background in competitive programming (and did no little amount of social engineering given that my background in competitive programming was pretty frowntown IMO) to get an interview for a technology role focused on trading. By the time my interviews came up I really didn't care much about the role. I had gotten a return offer for a product management internship at NetApp, and my friend was going to be locked away in a pretty boring part of the company such that even if I did get the role I wouldn't see her that summer. Compared to Facebook and Google I felt like the first two interviews I had were kind of a joke, and owing to my college stupidity/nerd arrogance I even did one of them drunk on speakerphone in my school's computer science club. The third though was pretty hard and fun. I had to design a system for navigating foreign exchange currencies given exchange prices. I was going deep into graph theory at that time, and came up with two approaches: Single point to point optimal currency trading using http://en.wikipedia.org/wiki/Dij... on a cost structure of the foreign exchange ratio between currencies. This seemed like the basic answer but under pressure reproducing it felt decently clutch. Construction of a constantly-updating system of "optimal currency networks" using a Minimum spanning tree  and a similar approach. The idea was that BAML could maintain a constantly-updated MST for certain highly traded currencies and use said tree to prune point to point searches - possibly for memoization (for example: remembering some decent non-direct paths between USD and Cuban Pesos). Employing K-Means clustering (see: http://en.wikipedia.org/wiki/K-m...) on the time series progression of exchange prices to "recognize" certain types of market conditions and trade according to memoized paths from the previous two approaches. For example, if I know that financially today is progressing like six days ago, I might want to further prune my point to point trades by using an optimal subgraph I developed from a previous calculation. The last two approaches were apparently pretty novel, and got me an offer to join BAML for the summer (as well as a solicitation at the end of school to get into algorithmic trading when my interviewer peaced out for a hedge fund). I decided against that course of action and went for my real passion of being a PM, which I think was a better choice in the long run. 4.) Jane Austen Sort (JAS): In my first year as a VC I joined one of the several inter-firm associate fantasy football leagues with a few of my friends. I like football but I wasn't as clued in to the waiver wire and updated news as my friends, so I decided to code a system that chose a ridiculous team for me for the hell of it. I wrote a system I called Jane Austen Sort (or JAS) that selected a player for an open position given the Levenshtein distance between each available player's name and a randomly chosen substring of equal length derived from conversation between Mr. Darcy and Elizabeth in Pride and Prejudice. The player with the shortest distance was chosen. My team was, suffice to say, really really bad. But Team Jane Austen (later named Team Stark because I used a similar approach regarding trades in the season using conversation from Game of Thrones) did well enough to beat one other person that season. Updated 4 Jan 2014 • View Upvotes