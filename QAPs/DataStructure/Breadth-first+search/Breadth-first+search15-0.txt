What are the C# simplest examples of implementation of breadth-first search and depth-first search?
Hi, yes there is of course , very simple and straightforward to understand code provided by Prof. Doc. Robert Sedgewick in his book "Algorithms in Java" , also there is free course on Coursera @Page on coursera.org. I use his code adopted in C# (Original is written in Java but as you know its easy to convert in C#). But before we should consider Graph API - methods that your Graph class provides, no difference Graph is implemented as Adjacency List, Adjacency Matrix or Classes - Vertexes and Edges. API convention is too simple : Graph should have method which returns all adjacency  vertex for concrete - like  public IEnumerable<int> GetAdj(int v)   - where parameter "v" is id of vertex, and method returns collection of neighbor vertexes. Graph should have method VertexCount which returns count of all vertexes in Graph. In .NET world it would be convenient to use Property some thing like   public int VertexCount     So now traversal code becomes too easy to implement. for DFS : public class DepthFirstSearch { private bool[] marked; private int[] edgeTo; private int s;   public DepthFirstSearch(GraphAdjList G, int s) { marked = new bool[G.VertexCount]; edgeTo = new int[G.VertexCount]; this.s = s; }   public void DFS(GraphAdjList G, int v) { marked[s] = true;   foreach (var w in G.GetAdj(v)) { if (!marked[w]) { DFS(G, w); edgeTo[w] = v; } } }   public bool HasPathTo(int v) { return marked[v]; }   public IEnumerable<int> GetPathTo(int v) { if (!HasPathTo(v)) return null;   var stack = new Stack<int>();   for (var x = v; x != s; x = edgeTo[x]) { stack.Push(x); }   stack.Push(s);   return stack; } } In code above there is two arrays "marked" and "edgeTo", "marked" is used to detect if vertex have been already explored by algorithm and "edgeTo" is used to "remember" path to vertex - after which it / from which it was explored. This helps if you want additional methods like GetPathTo vertex. for BFS : public class BreadthFirstSearch { public int[] edgeTo; public int[] distTo; public int s;   public BreadthFirstSearch(GraphAdjList G, int s) { edgeTo = new int[G.VertexCount]; distTo = new int[G.VertexCount];   for (int i = 0; i < G.VertexCount; i++) { distTo[i] = -1; edgeTo[i] = -1; }   this.s = s;   BFS(G, s); }   void BFS(GraphAdjList G, int s) { var queue = new Queue<int>(); queue.Enqueue(s); distTo[s] = 0;   while (queue.Count != 0) { int v = queue.Dequeue();   foreach (var w in G.GetAdj(v)) { if (distTo[w] == -1) { queue.Enqueue(w); distTo[w] = distTo[v] + 1; edgeTo[w] = v; } } } } } Here there one additional array "distTo" which tells you how many edges there is to "v" vertex from starting "s" vertex. I use Adjacency List Graph so if you want to test code provided below or solve some problems you can use this Graph : public class GraphAdjList { private readonly int V;   private readonly List<int>[] Adj;   public GraphAdjList(int v) { V = v; Adj = new List<int>[V];   for (int i = 0; i < V; i++) { Adj[i] = new List<int>(); } }   public void AddEdge(int v, int w) { Adj[v].Add(w); Adj[w].Add(v); }   public List<int> GetAdj(int v) { return Adj[v]; }   public int VertexCount { get { return V; } } } 