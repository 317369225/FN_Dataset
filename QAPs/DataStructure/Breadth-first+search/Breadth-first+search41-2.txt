What graph topics should I study in order to be adequately prepared for a Google Software Engineer interview?
I actually disagree with the other answers (including Gayle's - no offense, of course) due to my own experiences, and I really hope people looking for an answer to this question read mine so as not to get the wrong idea from the other answers and go into the interview unprepared. Skip to the last paragraph for a TL;DR version of the answer. You should know way more than just Breadth First Search and Depth First Search, in my opinion. You should know, in decreasing order of importance: BFS DFS Topological Sort & Shortest-path in a DAG Dijkstra's algorithm Bellman-Ford A-star (A*) Floyd-Warshall (debatable, but it's 5 lines of code, so no reason not to know it)With the exception of Floyd-Warshall, I have seen every single one of these topics come up in a Google interview. BFS & DFS are self-explanatory. There are a huge number of variants that can be asked using them. The rest are more subtle. There are many problems that can be reduced to the topological sort or shortest-path in a DAG problem (heck, I've even seen questions that require you to find the longest path in a DAG), and I personally find these problems awesome, because they're seriously not obvious, but if you figure out the trick, you've solved it - if and only if you know the algorithm for shortest path in a DAG or topological sort beforehand. Now obviously you could figure out the algorithm in the interview as well (it's not that hard, but I would say it's not easy to figure it out in an interview), but why make it hard on yourself? Personally, I'd expect any SWE candidate to have taken an algorithms course (i.e., read the important parts of CLRS), and any algorithms course covers topics 1-5 above. And I'm not even an interviewer - imagine what interviewers expect. Consider this question: You're a photographer for a soccer meet. You will be taking pictures of pairs of opposing teams. All teams have the same number of players. A team photo consists of a front row of players and a back row of players. A player in the back row must be taller than the player in front of him. All players in a single row are on the same team. First, design an algorithm that takes as input two teams and the heights of the players in the teams and checks if it is possible to place players to take the photo subject to the placement constraint. Then, generalize your solution: if you are given n teams, how can you determine the largest number of teams that can be photographed simultaneously subject to the same constraints?Source: Elements of Programming Interviews - excellent book, by the way - covers everything that might come up (except possibly A*), including all of 1-5. (I'm not going to give away the solution here, message me if you want it and can't figure it out.) I'd probably consider asking this question if I was interviewing. It has two parts, one which is considerably simpler than the next, so it can rule out the weaker candidates. The next part (the generalization) is more challenging, and tells me that a candidate can abstract a problem well and then work with the abstraction to solve the problem. Add in someone who is able to code this solution, and you've got a good candidate. Now, I've never interviewed anyone, so I'm just talking here and many actual interviewers might disagree with me, but I think this is all reasonable. So, now I've shown that topological sort and stuff are possible. (As an extra note, the above problem is one of the easier ones I've seen that deal with DAGs. I've seen a much more difficult one, where it's very non-obvious that you can change the problem to a shortest-path-in-a-DAG problem, but that's the exact solution. And it was asked in a Google interview. I can't disclose the question, though.) So what about Dijkstra and Bellman-Ford? Surely they're more specialized, so it's unreasonable to ask them as many might not know them? Ummm.... no. I barely just graduated from university, and I expect anyone who knows algorithms to know Dijkstra's. It's a classic. And I can assure you, many other software engineers at Google and Facebook and other companies will feel the same way, and unfortunately, they can ask you the questions they want. And, in fact, I've seen two questions where the solution was Dijkstra's algorithm, asked in a Google interview (and the candidate had to code it). (Obviously they weren't "find the shortest path in a weighted graph". They were variants, but the bulk of the solution was Dijkstra with a small modification. If you know Dijkstra, the solution wouldn't be hard for you. If you don't know Dijkstra, you're gonna have a hard time.) And better yet, they were followed up with a question about negative weight edges, so you need to know that Dijsktra won't apply then, and you'd need to switch to Bellman-Ford - so you need to know Bellman-Ford. On top of that, one question I've also seen asked in a Google interview was to find the shortest path in an unweighted grid (where there are obstacles or something - I forget if there's something more to the problem). The natural solution is BFS, right? Right, but after that the interviewer asked for a faster solution. That's right. Faster than the linear-time-BFS. The answer? A* (look it up and you'll get it), which is very similar to Dijkstra. I've never seen a question that required Floyd-Warshall for a quick solution, but you might as well throw it in there since it's just one more and, based on the above, you really don't know what you're gonna get, especially at Google, who seem to have a huge number of seemingly random questions at times. I'd be seriously surprised if anything other than these topics were asked on graphs (i.e. matching/max-flow/coloring). Why? You may ask. I just said the interviews are very unpredictable. The reason is that they're much more specialized than shortest-path algorithms, and most undergraduate Algorithms courses don't cover them, so unless you claim specialized knowledge, it's unreasonable to assume you know them. Unlike Dijkstra and the others. It's also much harder to code them in 35 minutes (let alone variants of them), even if you remember the max-flow algorithm. TL;DR: You don't know what will and won't come up in an interview. My answer may have selection bias, but the bottom line is that empirically, whether or not these questions are "good questions" (I'd argue that they are, but that's another debate), these questions are asked. How frequently, I cannot say, but I'd guess that since I've seen so many graph algorithms asked in such a small subset of people, they're probably frequent enough that you can't ignore them (and yes there's selection bias here, but if you, like me, like to be well-prepared, the only thing that will matter is that they can come up.) So study all the above topics. They're not that hard anyway, and any software engineer (or anyone who has taken an algorithms course, really) should be familiar with them. You can forget them after the interview if you don't need them later on in your life, but for now, you better study up. Why take a risk? Updated 30 Jul • View Upvotes • Not for Reproduction