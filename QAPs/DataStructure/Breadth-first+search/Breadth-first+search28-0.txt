How do you implement breadth first search on a binary tree using just recursion and no explicit data structures such as a queue, stack, list etc.?
You can't really. The point of breadth first search is to avoid wasting time by going too deep into the search space, by exploring things in order of their depth. To this time-efficiently, you have to keep track of the frontier - all the stuff you haven't explored but are about to explore. What you can do, if you really want to save space, is use iterated depth-first search. This means you do depth-first search up to depth one, then do depth-first search up to depth two, then up to depth three, and so on (of course, stopping if you find what you're looking for). You can also use different depth increments for each iteration. This is straightforward to do with recursion and doesn't require any bookkeeping (except that the computer will keep track of the program stack). The advantage is that iterated depth-first search saves space; the disadvantage is that it takes longer. For a binary tree, iterated DFS will take at most twice as long as BFS (I think). [Warning: just because I haven't heard of a way of doing what you ask, doesn't mean no one has invented it.] 