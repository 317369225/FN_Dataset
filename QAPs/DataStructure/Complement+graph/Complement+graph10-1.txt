How do I understand bitwise tricks in C++ for competitive programming?
At the heart of the motivation for any bitwise "tricks" that are used for competitive programming, is good old Set Theory. Literally, any operation that you're doing with bitwise tricks, can be thought of as playing with sets. Each number (what we call the "bitmask") represents a set by looking at the number in Binary. If the i'th bit is 1, then element i is in the set, otherwise it's not. Ok, some simple "tricks" explained: (assume lowercase variables are the numbers that represent corresponding sets: i.e. A  is represented by a). So I'm talking about sets. Do we have Union? Intersection? Well yeah, if we have C=A∪B  , then we have c = a | b. Also, if C=A∩B  , then c = a & b. Just check that bit-by-bit the rules of & and | mirror the rules of intersection and union when taken element-by-element Does set A  contain element i  ? This is like asking: Is A∩{i}≠ϕ  ? In terms of numbers, "Is ((a & (1<<i)) != 0)" What is the set {1, 2, 3, ..., n}? Well we need all 1's in the first n bits. We can just take (1<<n) - 1. How do we remove i from A  , given we know it is in A  ? We turn off the 1 at the i'th bit: a - (1<<i). How do you take a complement of a set A  when the Universal set is {1, 2, 3, ..., n}? Well, follow a combination of "tricks" 3 and 4 to get: ((1 << n) - 1) - a. What if we don't know whether i is in A  ? We want A−{i}  ! That's A∩{i} c   . That's a combination of some earlier rules too! (a & ((1 << n) - 1 - (1 << i))). [Also, you can do Balajiganapathi's "Flip ith bit of a" method]. Finally, let's take a standard problem and work our "bitwise tricks" using sets, and then code. We have the Travelling Salesman problem: complete graph of n nodes with distances. You need to find a way to visit all nodes in least total distance. Let F(A, i) = minimum distance needed to traverse all nodes of A, starting from anywhere, but ending at node i. F({i}, i) = 0 for all i. Base case. F(A, i) = min{F(B,j)+d(j,i):j∈B,B=A−{i}}  In terms of code: int f(a, i) { b = a - (1<<i); // remove i from A, given we know it's in A // base case if (b == 0) { return 0; } if (F[a][i] >= 0) { // memoized code return F[a][i]; } // compute recursive case ans = INF; for (j = 0; j < n; j++) { if ((b & (1<<j)) != 0) { // if j is in B ans = min(ans, f(b, j) + dist[i, j]); } } return F[a][i] = ans; } Wow, it turns out that this is my first answer in four months! Hope I haven't lost my touch. 