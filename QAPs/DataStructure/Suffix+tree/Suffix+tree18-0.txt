How hard is it to implement Lempel-Ziv using Suffix Trees?
I used suffix arrays (not suffix trees) in ZPAQ to find LZ77 matches. This gives better compression (at equivalent speed) than the usual method of using hash tables to find matches because you don't need to search a long chain of matches to find the longest one. The longest matches will be adjacent to the current suffix in the array, either just before or just after. However, some of these matches may be in the future, so you will still need to search several positions forward and backward in the suffix array to find the longest match in the past. The disadvantage of this method is that it uses more memory. I used divsufsort rather than write my own suffix sorting code. The suffix array takes 4N memory (where N is your block size). You will also need to build an inverse suffix array (ISA) to map suffix indexes back to their original location. This is fast (O(N) time) but also uses 4N memory. To save memory in ZPAQ I rebuild a partial ISA using 0.5N memory 8 times instead. Of course the method you use to find matches (hash tables or suffix arrays) has no effect on decompression speed or memory. The code took me a few days to write and test. However, that was because I didn't write the suffix array code and also because I could reuse the LZ77 code I had already written using hash tables. You could use suffix trees, of course. But I think that suffix arrays were simpler to work with, and use less memory. I didn't run any tests to see which was faster, but divsufsort is fast enough. ZPAQ source code is public domain. divsufsort (included) is MIT licensed. Both can be found here: ZPAQ 