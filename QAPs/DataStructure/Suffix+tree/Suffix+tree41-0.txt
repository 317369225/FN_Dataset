What's an intuitive explanation on how suffix arrays work?
The suffixes of a string contain (almost) all information about all possible substrings of a string. For example, suppose that you are thinking about the substring "racada" of the string "abracadabra". Oh look, there is the suffix "racadabra" that starts with your substring. That's almost the same thing. Why is this important? Because there are [math]\Theta(n^2)[/math] substrings in an [math]n[/math]-letter string, but only [math]n[/math] non-empty suffixes. For example, it would be pretty expensive to sort all possible substrings: to produce their sorted order you would certainly need [math]\Omega(n^2)[/math] steps because you have to, at least, outputÂ  each of them. On the other hand, it might theoretically be possible to sort just the suffixes faster than that. And once people realized that it actually is possible and came up with clever efficient algorithms to do so, the suffix array was born. The suffix array is simply a compact representation of the sorted list of all suffixes. For example, consider the string "banana". There are six non-empty suffixes: "banana", "anana", "nana", "ana", "na", and "a". We can call them 0, 1, 2, 3, 4, and 5, in this order. (The number of a suffix is the index of the character where it starts in the original string.) If we sort (*) these suffixes, we get the following order: "a", "ana", "anana", "banana", "na", and "nana". In other words, (5,3,1,0,4,2). This is the suffix array for the string "banana". (*) Note that the efficient algorithms do not actually construct all the suffixes and then sort them using a general algorithm -- that would be too slow. Instead, they use clever tricks based on the fact that we know that the strings we are sorting are suffixes of the same string. The basic trick here: any suffix of a suffix is simply some other suffix of the original string. E.g., if you know that suffixes 23 and 47 share the same first 4 letters, you can compare them by comparing suffixes 23+4 and 47+4. Once we have the suffix array, we can use it to answer many types of queries about the original string. For a simple example, consider the standard substring search problem: here's a new short-ish string ("the needle"), does it occur anywhere in your long-ish original string ("the haystack")? Without the suffix array (or a similar precomputed data structure), the best you can do is some standard string search algorithm such as Knuth-Morris-Pratt or Boyer-Moore, all of which are linear in the length of the haystack. However, if we know the suffix array for the haystack, we have just sorted all its suffixes (and hence, almost-sorted all possible substrings). And searching in a sorted list is easy, right? We can use binary search! That is, we start by comparing the needle to the suffix that appears in the middle of the suffix array. If we are lucky and the currently considered suffix starts with the needle, we just found an occurrence of the needle. (And if there are more occurrences, they must correspond to the immediately previous and/or next suffixes.) Otherwise, we just proceed as in a standard binary search: we throw away the first half of suffixes if the needle happens to be larger than the current suffix, and the second half in the other case. Using a few more tricks (e.g., computation of the longest common prefixes array) the time complexity of a single search can be reduced to the length of the needle, plus the logarithm of the size of the haystack. Why is this super-useful? Think bioinformatics, for instance. Your haystack is a piece of DNA: a very long but fixed sequence of bases. You compute its suffix array once. Then, each time you want to find some particular sequence of bases in your haystack, you can do the search extremely quickly, without even looking at most of the haystack. 