What is the most difficult algorithm you have implemented?
An anytime variant of the D* graph search algorithm. Most Computer Science grads should have heard of A*, which can be described as a variant of Dijkstra's algorithm that uses an admissible heuristic to improve computation time. D* is a dynamic variant of A* that efficiently updates an in-memory representation of the search state space when edges in the graph change cost or connections, or the starting node changes. It's particularly efficient when the only edges that change are in close proximity to the starting node of the search. This turns out to be very useful for mobile robots that perceive the world as they drive around, since they (usually) only see areas close to themselves. Anytime algorithms are then variations of graph search algorithms that can be halted at any time during their execution, and return the best path found so far. They are deterministic, and (typically) do eventually return the optimal solution, but usually in a longer time than their non-anytime siblings. So Anytime-D* was effectively a variant of a variant of a variant, and implementing it was like playing Chinese whispers (or 'Telephone', for the American audience here) as a Dutch computer scientist's algorithm from the 1950s passed through three Stanford researchers in the 70s, was tweaked for robotics in the 90s, incorporated an obscure offshoot of dynamic programming in early 2000s, and was further optimised by some bloke from Intel before ending up on my desk with a note from my supervisor saying, "I was asked to review this pre-print today. Want to try it out?" Six months later I had most of a Ph.D. and an irreparable mistrust of functions that preserve state across calls. 