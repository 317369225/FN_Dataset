How is large scale software written in functional languages (especially Haskell)?
Erlang is a mostly functional language (it has a few pragmatic solutions where it makes sense). In Erlang, the main building block is a process. It's sort of like a posix thread in that it will run independently, the main difference is that it has much less baggage (for more on the difference between threads and Erlang processes, see zxq9's excellent answer on Stack Overflow: Page on stackoverflow.com) So when we built the test environment for the 4G LTE node at Ericsson we used a lot of processes. Erlang provides behaviors for the most common use cases, such as servers, message handlers, state machines and so on through the OTP library. Think of them as internalized GOF patterns - like the Iterator. Mostly we used the behavior called gen_server which more or less simply is a server that listens to messages and spin off worker processes to handle them. If you think about it - it's not really that different from a regular function call, except that now you can distribute your application very easily without having to add all that RMI or CORBA cruft that breaks soo easily and is a pain to troubleshoot. So really the way you structure an application is to define communication paths and handlers, much like in OO really. The main difference I feel is that your much less tempted to make things tightly coupled, seeing as the main way to communicate it using asynchronous messages. If you want to read more about Erlang OTP behaviors, go to the Erlang documentation: Erlang -- Overview 