How is large scale software written in functional languages (especially Haskell)?
The idea of encapsulation from OOP is often retained in functional programming to some extent. Functional programmers do separate the interface from implementation and hide complexity from the user of a library. This can be achieved using opaque data structures, which amounts to not exporting constructors in Haskell, for example. However, good functional code tends to present more internals to the user than OO code, I'd say. The idea is types and other internals which immediately make sense should not be hidden away. The language is often concise enough to allow users of that code to quickly adapt it to their needs, unlike some OO languages which require tons of boilerplate to get slightly different behavior. Generally, loose coupling is encouraged. In Haskell, modules tend to provide some logical grouping of interfaces. Things are inherently more loosely-bound, though, but given what I said above that's not a bad thing. Other times, functional programmers solve a more general problem and specialize to the desired usecase. This not only aids code reuse and customizing behavior, but also creates opportunities to spot bugs and prove correctness. Behavior is often readily apparent from polymorphic types, which also serve as documentation. 