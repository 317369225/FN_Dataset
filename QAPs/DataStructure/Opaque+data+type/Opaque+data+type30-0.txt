Where's the productivity in dynamically typed languages?
I agree with you, but putting the case for the other side - you get to the point where you can run your code much faster. This is very helpful if you value interactive development. My favourite dynamically typed language is Smalltalk. In Smalltalk you can copy  any code into a running context in the debugger and test it. It's harder  to do this kind of piecemeal change in statically typed languages, because the compiler won't work without a full compilation unit that declares the types of objects. It feels incredibly productive when you can do this. I think people like PHP for the same reason - you just edit the source, hit reload, and there's the output. There's a bit more overhead in making a clean compilation unit with correct types. The flip side is that in statically typed languages, you know a lot about your code once it compiles. You don't have to test for a whole class of properties because the compiler already proved them for you. In C++ that class is quite small, but there is a spectrum of better results through Java, Scala, Ocaml and Haskell. The type systems that these latter languages provide, if used well, give a very high degree of verification of correct behaviour. Or, put another way, the compiler itself will ensure, to the extent that your types are well modelled, that "invalid states are unrepresentable". On the other hand, in dynamically typed languages, the possible failure modes are vast. You have to test absolutely every possible property of your program, including whether your functions even return the right kind of thing under all possible circumstances. It's no coincidence that automated unit testing originated in the Smalltalk community and is highly valued by Ruby developers, for example. Basically dynamically typed languages allow you to get buggy code to run. Statically typed languages prevent this. There are circumstances where its legitimately preferrable to have running, buggy code, than non-running buggy code. The trouble is those circumstances tend to be short lived, and at the end of it you still have buggy code. 