Can you show me a simple C++ code that can't be done without using pointers? (I'm a beginner and I don't understand why people use pointers)
When I first learned C++ most of my confusion about pointers came from "Why would I use this?"  "What is the point of this construct?"  So, let me lead you through the thought process and experience gained that lead to an understanding of why pointers are necessary. #include <iostream>int main (){	int x = 5;	int* pX = &	std::cout << "x = " << x << " px = " << ((int) pX) << " Value pointed 			by Px = " << *pX << std::endl;	return 0;} A variable is a person-friendly name for a place in memory that contains a value of a certain type.  Above, x is some location in memory that contains the integer value 5.  A pointer to an integer is just a variable that contains not an integer but a place in memory that contains an integer.  So let's pretend for clarity that x refers to memory at address 0.  Let's also pretend that pX refers to memory at address 8. So memory at address 0 (x) contains the value 5.  Memory at address 8 contains the value . . . 0!.  So when we print x, we look in address 0 (because x is another name for address 0), we take the value there, interpret it as an integer, then convert that value into a string: "5".  What happens when we print *pX (the value pointed by px)?  Well first we look at address 8 (pX is another name for address 8) and we see the value 0, which we interpret as a location in memory that contains an integer.  Since we have been asked to dereference (get the pointed-to value) we then look at address 0, interpet the value 5 there as an integer, convert it to a string and print it out "5". Great!  You understood all that!  No why do we NEED pointers?  I am going to point to one reason why pointers are necessary (there are of course other times that they are desireable, but this one is pretty necessary): dynamic memory. Above the variables x and pX are both local variables and are probably stored on the stack.  The compiler knows that an integer is 4 bytes long and that a pointer to an integer is (in this case) 8 bytes long.  So in addition to some other space, when the program above is compiled, a spot for x and a spot for pX are reserved right there during the compilation process.  So, at compile time, the compiler creates space sufficient to fit every variable in your program (local variables are pushed onto the stack when a function is run, but the compiler still needs to know what the stack size is, the size of the things that are pushed onto the stack, how many of them, etc to compile the function).  So, what did we just learn: the compiler needs to know (WHEN COMPILING) the size of every variable so it can make space for it. Now, what happens if we do not know how much space is needed at compile time.  In the following code assume that the user was queried about how many names he will enter and that value was stored in numberOfNames. //assume number of names was entered above by the user in a GetNames() functionstd::string* name = new string[numberOfNames];for (int i=0; i < numberOfNames; i++){     cin << name[i];}/// ... more stuff happens....delete [] name; //Tell the os we no longer need this memory and it can //take it back Now .. what did we just do?  We had absolutely no way of knowing at compile time how many names would be needed.  So there is no way the compiler could prepare space for our five names in advance.  So rather than declare a bunch of strings or a statically-sized array of strings (because we don't know how many) the compiler leaves space for a memory address. So, when we get to the new statement what we do is ask the operating system, hey, can you please allocate enough memory for us to store numberOfNames strings and pass us back a pointer to the first one?  So the operating system finds some memory our program can use and gives us a pointer (all pointers are the same size). So, lets pretend that "name" is at memory address 0 and it contains the value 1024.  The operating system chose the memory location and returned it to our program with the "new" statement.  Let's say we tried to print the value pointed by name like this: cout << *name << endl; What do we do?  Well, name is an alias for address 0 (which the compiler provided for at compile time) we know it contains a memory address and that the value in that memory address contains a string.  So we look at name and find the value 1024, we know we are supposed to go to 1024 get the value there and interpret it as a string and print it to the standard output.  What if we wanted to print the second address (or the nth address where n < numberOfAddresses)? cout << name[1] << endl;  Assume (incorrectly, but ok for this tutorial) that every string is 8 bytes long. What do we do here?  Well we know that name contains an address in memory.  Here we know that the user has requested the second name in the in the memory we allocated.  So we don't look at address 1024 but we look at the address found at address x where [math]x = 1024 + (index * sizeof(string)) [/math]sizeof(string) = 8 and index =1  so the address we look at is 1024 + 8 = 1032.  So we get name[1] from address 1032, interpret it as an string and print it to the standard output. So, without pointers, we could not have had a way to store data of a size unknown to us when the program is compiled.  Because we had pointers, we can ask the operating system to allocate the needed amount of memory for us at run time and pass us a pointer to it ... then we can address memory that could not be stored in our program when it was compiled because we had know way to know how much was needed when it was compiled. Hope this made one (big) reason why pointers are necessary clear to you: they can point to any place in memory, not just the address of another variable your program declares, including memory on the heap that your program asks the OS to allocate for it dynamically at run-time. AFTER THOUGHT: Even languages that do not use "pointers" in the sense of c++ pointers have mechanisms for getting the operating system, or the java virtual machine, or the .NET CLR, to allocate memory for us dynamically and return a way to access that memory ... in those languages those things are called references.  Which are completely different from references in C++ and are more like C++ pointers except you can't do arithmetic with them and other restrictions to make them safer to use. 