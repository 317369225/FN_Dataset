What are the advanced topics in C which are not taught in college but one must know?
Some of the things that I felt I learn a lot better on the job than in school are listed below. I learnt a few of these in school, but I felt I learnt a lot more about practically applying those concepts while working in the industry - you only get a finer appreciation for these when you have to apply them yourself. For what it is worth, I think it is actually healthy that schools focus on the academic and conceptual fundamentals so it's not like you should worry about them when in school. What is important is that you learn to learn. That said, proactively seeking such information will likely make you more productive and let you write better programs. Back to the question at hand: Language features: Advanced preprocessor directives - stringizing, string concatenation and specials such as __FILE__, __LINE__ etc.  [9] Precise control of structure layout - in particular unions, Bitfields and alignment. The use of of void*'s - in real life code you see a lot more of them in far more interesting patterns than in the toy programs you write. Cases where it is appropriate to use goto - yes, there are real world use cases that use it. In school you are taught to religiously avoid it, but there is widely used robust and high performant software that you indirectly use everyday that was written with lots of gotos, such as the Linux TCP stack. [11] Variadic functions The finer points of the right numerical types ( signed vs. unsigned, floats ) General advanced topics of particular interest to C programmers: You can learn these in other languages as well, but odds are you'll are more likely to encounter them if you are writing C code. Dynamic linking, most notably dlm_open and friends. Signals, forking and interprocess communication. Threading, and related advanced concepts such as thread local storage Raw sockets [8] The use of setjmp, longjmp for saving and restoring state. [12] Getting the return address of a function ( this isn't standardized and portable, but there are options for it ) [7] Memory management and fragmentation, particularly in long lived processes. What to be careful about when writing portable code, particularly in terms of what OS primitives you take for granted ( i.e. which platforms have epoll, which ones, which one have kqueues and so on ). Interfacing between kernel modules and user level code and the use of ioctls. A knowledge of software ecosystem and tools that C programmers often deal with: When you get into the realm of large scale programs, a knowledge of these is invaluable for debugging purposes, particularly when there are libraries that are only available to you in the form of binaries. Compiler and linker flags - particularly how to setup good cross platform build, what to link statically vs. dynamically, feedback directed optimization, and so on. Advanced use of gdb ( conditional breakpoints, watchpoints, macros, programmatic execution of code at breakpoints, format paramters to x/FMT ) Use of tracing tools such as dtrace, strace and ltrace etc. [2] What to be aware of when interfacing C with C++ and/or Objective-C code, such as calling conventions.[1] Profiling tools, such as gprof [10] Memory debugging tools, such as Valgrind[4] and Purify[5], Using LD_PRELOAD to load custom libraries. [6] The compiler related toolchain, such as objdump, nm, ranlib, libtool, otool, etc. [2] What do I need to know when mixing C and C++ code?, C++ FAQ [1] ltrace(1): library call tracer, DTrace,strace(1): trace system calls/signals [3] Using the GNU Compiler Collection (GCC) [4] Valgrind Home [5] IBM Rational Purify [6] What is the LD_PRELOAD trick? [7] Using the GNU Compiler Collection (GCC) [8] raw(7): IPv4 raw sockets [9] C Programming/Preprocessor [10] Gprof [11] Linux Cross Reference [12] setjmp.h Updated 107w ago • View Upvotes