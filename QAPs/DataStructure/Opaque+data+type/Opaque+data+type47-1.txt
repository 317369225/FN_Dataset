Can you show me a simple C++ code that can't be done without using pointers? (I'm a beginner and I don't understand why people use pointers)
First - Pointers are everywhere Effectively you can see pointers as the address of the data in RAM (strictly that's not the case exactly, but for simplicity just think of them like that - you rarely need to know that you're actually obtaining a virtual address from the memory allocation table, which in turn is virtually mapped to an OS memory allocation table, which is referencing RAM in a protected space which is yet another form of such virtual allocation handled by a memory manager chip). I would recommend you learn the real detail behind such later, since it helps a lot when you're optimizing to know exactly where and how a variable is placed in RAM - but for this purpose it's not necessary. This then means that any variable is in fact using pointers, whether it's a local stack based, global, or dynamically allocated (it's just that the former two is hiding the pointers through the compiler). Whenever data is read/written in RAM its location (address) needs to be known, and that is a pointer. You'd know this if you write anything in assembly. C however hides some of this, e.g. all stack allocated variables / parameters (i.e. a variable of a specific data type) can be accessed directly in the C language. But it is still making use of this "location in RAM" concept. So even when you're not "using" pointers, you are in fact "using" pointers - just that you don't see it. However, what you're probably asking about is indirected / dynamically allocated variables. And in that case both C and C++ open the actual pointer allocation to you. E.g. the malloc function sets a location in RAM as "used" and then returns the location address (pointer). This is actually what is stored in a variable typed as a pointer (an integer specifying the location of where the data is actually stored) - referred to as indirection. Also, things like arrays are actually implemented similar to pointers. Even a statically declared local array inside a function is just a pointer to the first item in the array. When you're referencing the item at the 2nd index, the pointer is just incremented by the item's size. Where do you need to actually make use of Pointers? The most common scenario is when you don't know before hand just how much data you require. E.g. you get some input data read from a network stream. You can allocate a buffer (i.e. an array), but you need to make it large enough so that all the data can fit inside. This is rarely possible, and is a quick way to waste lots of memory on trivial tasks. So you allocate a buffer calculated as and when you know how large it should be instead of trying to make one enormous array to hold all possible sizes. Thus your program would only need to use the necessary amount of RAM instead of using gigs where a handful of megs would do. Some data structures are difficult to impossible to implement using only statically allocated arrays. E.g. say you're implementing a binary search tree - if you do this inside an array you run into the scenario of lots of wasted space again (because your array needs to be large enough to keep all levels of the tree - even if they're not used or only used partially). But when you're doing this, you're actually building your own pointer system inside that tree - you've just replaced pointers by indexes into the array, so you've not actually avoided indirection at all, you're just indirecting using an added layer of indirection. There are lots of such examples where you "could" try to avoid pointers, but you'd just make your life more difficult, and nearly all of them means you are using pointers and just adding extra manual pointers systems on top of them. But there's one scenario (not the only one) where you should never avoid pointers. Say you make a function which calculates an array of values and need to return that as a result. In fact C even disallows a function to have an array return type - it can only have a pointer return type instead. If your result array is a statically declared local variable it will be deallocated once the function completes, i.e. you use thw weak typing of C to cast a stack based array to a pointer which you then return. So what exactly would a calling environment see - some random spot in RAM which used to hold data but is now marked as free, it might still hold the correct data, but no guarantees as any other process / thread could very easily have overwritten it. Most probably your compiler would throw an error / warning, which should tell you that such is a very bad thing to do. 