When would you use void pointers in C?
I use them most often to provide callback functions (for example, for a data structure iterator), in the spirit of Ken's first and second points: // tree.htypedef struct tree *TREE;typedef void *TREEVAL;// ...int tree_iterate(TREE t, int (*f)(TREEVAL v, void *extra), void *extra);// tree.c// ...int tree_iterate(TREE t, int (*f)(TREEVAL v, void *extra), void *extra) {    if (t == NULL) { return 0; }    int r = 0;    r = tree_iterate(t->left, f, extra); if (r != 0) return r;    r = f(t->val, extra); if (r != 0) return r;    r = tree_iterate(t->right, f, extra);    return r;}// user.cstruct handle_kv_pair_struct {    int x, y;    char *more_data;};int handle_kv_pair(TREEVAL t, void *extra) {    struct kv_pair *p = t;    struct handle_kv_pair_struct *e = extra;    // do something with p and e    if (success) return 0;    else return 1;}int main(void) {    TREE t = tree_new();    // ...    struct handle_kv_pair_struct &e = { .x = 0, .y = 1, .more_data = "cats" };    r = tree_iterate(t, handle_kv_pair, e);    return r;} This is mostly the same as Milosz's answer, but with code. 