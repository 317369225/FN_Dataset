What are the worst code smells you have ever encountered as a developer?
A previous company I won't name had a big, complicated system which had slowly evolved from something they wrote for DEC hardware in the late 80s. Their product needed significant modification and configuration for each customer site, and since they were only slowly moving to git from an ancient, home-grown version control system, each customer site was a different, independent codebase with changes propagated by the simple expedient of copying blocks of text back and forth by hand any time someone remembered to do it when an update was already happening. Sounds lovely, right? There where a number of peculiarities in this codebase, such as every single filename being of the form "ABCDE123.c" or some such, variable names typically being 3 to 5 characters, and so on. What really takes the cake, though, was they way they handled the massive amount of configuration needed for the layout and hardware setup of the customer sites. They had this file format they had developed, consisting of line after line of any of maybe 100 opaque little abbreviated names, followed by between 3 and 50 or so mostly integer arguments that meant different things from one to the next. Some types would have to follow other ones, and would provide more information about them. Each of them had an arbitrary numerical ID the programmer would need to assign. All but one of them would have a parent node's ID number referenced, implicitly constructing a tree structure you could traverse even though the thing it modeled had cycles, which were handled by the equivalent of a special node for "a goto is possible here!". There was evidence suggesting this was originally all dumped in one file, but at some point someone had "improved" it by modifying it to be split over separate files, one per each node type, except not really since sometimes they got put in the same file for simplicity except for some types, for which the system couldn't tolerate that. At compile time, the whole set of files would be traversed until the start node was found, then the whole thing would be used to build up a giant tree structure. To top it all off, portions of this that needed to show up in the UI would include as a subset of their arguments, all of the arguments needed to draw it in Motif out of whichever set of primitives made up that node type. Interns were regularly tasked with learning this system well enough to apply it to whatever the current project was. Without fail, the competent ones would invent something to make the task less awful or replace this system. Without fail, the company would ignore whatever they came up with. This was viewed as something like a right of passage. 