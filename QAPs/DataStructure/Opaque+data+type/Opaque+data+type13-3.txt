C++ (programming language): How do you judge a C++ programmer by only 5 questions?
It's been a while since I've used C++, so I would most likely completely miss touching on newer features.  These are also asked from a design viewpoint, so if you're wanting someone who can write code that runs fast, your questions might be different from the ones I would suggest. When would you use factory methods as opposed to calling a constructor directly? I have several methods, each signature only differing by which child of a base type they'll take, and a signature that takes the base type itself.  How can I ensure that the most specific method signature will be called? What's the difference between public inheritance, private inheritance and containment?  Explain how exceptions are thrown and caught up a stack. Explain what a template is, and the value afforded by the STL. In a hierarchy of three classes, the bottom most child constructor calls a method that has been overridden by the middle child. Explain the order in which the constructors are called and how the calling of the polymorphic method is handled.Oops, that's 6.  I think you could drop any one of these questions and still get a pretty good idea of how well the person knows C++. ================================================== Possible answers as requested.  If you see places where I am incorrect, please note in the comments and I will make corrections. Thank you!   1.  One of the most useful patterns I have seen for factory methods is to implement a listener pattern where listening objects need to register with a broadcasting object.  In some cases, where the two different classes are always related and you wouldn't construct the listening object without providing a pointer to the broadcasting object, it makes sense to use a factory method where the broadcasting object instantiates the listening object, provides it with a pointer to itself, and then returns it to you. Another case for a factory method is to implement a singleton class, where you actually call a static factory method that checks a static instance variable to see if the instance is already instantiated.  If it is, then the factory method returns a pointer to the instance.  If not, then the factory method instantiates the instance, assigns it to the static instance variable, and returns a pointer to the static instance. 2. I actually ran into this problem in C#, and found it was a problem also common to Java and C++.  If two method signatures exist, and one signature takes a base class as a parameter and another signature takes a child class as a parameter, calling that method passing in the child class will favor the most general case -- the signature with the base class will be called. I was ready to call this a bug in C# until I found the behavior to be common across languages!  Two (or more) possible solutions exist to this problem: find a way to eliminate the signature that takes the base class.  This would have been very poor design in the case where I encountered it.  Implement Visitor Pattern to access the correct method signature. SOB is right. 3. Public inheritance is classical inheritance.  If you have a class B that inherits A, you can call methods from A on B and B can use A's protected members and methods. If A has virtual members, you can override them in B.  Methods signatures that take A will also accept B.  It's a true "is a" relationship.  Private inheritance is harder to understand.  If B inherits A privately, then B can call public and protected methods and members of A, but these methods can not be accessed from outside B.  Since this is the case, no "is a" relationship really exists and B can not be passed into method signatures that take A. Containment means that one object "has a" nother object. For example we might say that a MailServer has a MessageQ.  MailServer may actually contain an instance of MessageQ or a pointer to a MessageQ.  In either case, MessageQ is a sovereign object and MailServer does not (by default) have access to MessageQ's protected methods and MessageQ's methods are not accessible from MailServer. You must call those methods on the instance of MessageQ. 4. Let's say that 5 levels into your C++ program an exception occurs.  You tried to format a string as a number and it just couldn't be done, so an exception is thrown. Let's say that the exception is called a NumberFormatException, because it's been a long time since I've used C++ and don't remember what the actual exception would be called. 3 levels up the line (at level 2) in the stack you have a catch that takes a NumberFormatException.  Here's what will happen: First C++ will see if you are contained in a try-catch block at your current level: 5.  If not, it will proceed up to 4 and perform the same check. Finally, it will come up to 3 and you've caught that exception, and it will be handled by the exception handling code in your catch block.  Let's say there's no catch blocks.... Your program will crash due to the exception. 5.  I remember templates being a dream come true.  Without templates, you would have to create the exact same data structure or function if you wanted to have a data structure or function that took a different type. It felt wasteful because you would have all this copying and pasting and then any time you changed your linked list of int, you would have to go repeat the same change to your linked list of char *, your linked list of float, and your linked list of MyClass.  Templates allow you to write data structures and functions without having to know what type you're coding against by allowing you to name a stand in for the type.  You then delay specifying a type until you use the template to declare a variable:  List<int> numbers; The STL is a library full of templates for common data structures like lists, stacks, queues, trees, sort algorithms, search algorithms, etc.  You can use the library with your own objects without the authors of the library having to know you're using the library much less anything about the types you created! 6. I will get back to this one. Updated 52w ago • View Upvotes • Asked to answer by Anonymous