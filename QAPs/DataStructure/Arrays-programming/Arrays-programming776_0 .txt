What is a possible implementation for std::deque?One implementation that immediately comes to mind is a circular buffer/array. You can add elements at the front or end of the array in O(1), and do some subtraction to figure out where to look if you want random access. One issue with this is that after each operation, the container may choose to resize and copy all of the data. This makes it impossible to save simple pointers to elements in the array, because any push/pop risks invalidating references. That's why most implementations, like the one implemented in C++ STL, use a vector of arrays to store the memory instead: At this point, you're pretty close to worst case O(1) time per operation -- in reality, right now it's O(max(blocksize, N/blocksize)) worst case, which is probably good enough for any practical use. The OP of What data structure, exactly, are deques in C++? has an interesting approach that abuses storing the data in multiple places and allocating data incrementally, though this seems fairly impractical. See http://gcc.gnu.org/bugzilla/show... for more explanation of this slight omission in some versions of the C++ standard. Re the other answers, it's impossible to get a hash table with worst case O(1) time for every operation, and it's pretty clear why you would never use a balanced binary search tree to implement a deque. Credits to Irfan's Blog and rowenblog for the images 6.2k Views  View Upvotes