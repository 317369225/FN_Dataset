Arrays in C: Do they know their own size? If not why do I get an incompatible pointer type warning when assigning int (*) [3] to int **I'll start by writing some code that does what you think you're doing. typedef struct {  int **weight; /* adjacency/weight info */  int nvertices; } adjacency_matrix; int main(int argc, char *argv[]) {  adjacency_matrix g;  g.nvertices = 3;  int weight[3][3] = {  { 0, MAXV, 23 },  { MAXV, 0, 12 },  { 23, 12, 0 }  };   int * weight_ptr[3] = {  weight[0],  weight[1],  weight[2]  };  g.weight = weight_ptr; // compatible pointer assignment  return 0; } Note that this will compile. int*[3] can implicitly convert to int**, and each int[3] can be implicitly converted to int* in the second array. The issue here is memory layout. int[3][3] is not an array of three pointers to int, it is three arrays of three ints each, and looks the same, in memory, as int[9]. 333 Views  View Upvotes