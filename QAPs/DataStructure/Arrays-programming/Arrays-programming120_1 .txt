What is the formula to calculate address in three dimensional array?You could calculate that yourself, but better is to use Pascal, where the compiler that does it for you, or adopt to the C style, where you have one dimensional arrays that keep pointers to other arrays. You can do similar with std::vector and have its elements shared_ptr's to other vectors. If you insist, first a 2D example in C-style C++ (C++ has constants); const int COL = 5; const int ROW = 3; int A[ROW][COL] = { ... };  int* getAddress(int row, int col) { return A + row * COL // 'row' full columns + col; } The reasoning is this: you want to compute the address of item in column 'col', that is in row 'row'. Now, since C/C++ uses zero based arrays, you have already 'row' complete rows. But how long is that? Each row has COL items, so multiply row by COL. But haven't we forgotten that an item can be longer than a byte? Nope, cause we have an array of ints, so A = &A[0] is an int*. The compiler takes care of this little detail for us. (Google for pointer arithmetic). Unless you are overlaying variables by using unions and you have for instance a char*. (I usually make a typedef for a byte). Forget that. For 3D that is just a generalisation: const int COL = 5; const int ROW = 3; const int HEIGHT = 7; int A[HEIGHT][ROW][COL] = { ... };  int* getAddress(int height, int row, int col) { return A + height * ROW * COL // 'height' full 2D planes + row * COL // 'row' full columns + col; } You can factor out a common factor above: COL With typedef int[COL] RowType; // 1D row of COL columns typedef RowType[ROW] PlaneType; // 2D plane of rows and columns PlaneType A[HEIGHT]; your 3 dimensional array has become an array of 2D planes in a readable way. You should be able to use sizeof on the typedefs to your advantage. int* getAddress(int height, int row, int col) { return A + height * sizeof(PlaneType)/sizeof(int) + row * sizeof(RowType)/sizeof(int) + col; } This is less efficient, but Major advantage is this is easier to generalize (I think). You always have only one product at most. You can factor out the division. You can replace that by a left shift. I haven't tested any of this. The arrogance of the experienced... Look also for "row major" on google. Good luck! 142 Views  Answer requested by 1 person