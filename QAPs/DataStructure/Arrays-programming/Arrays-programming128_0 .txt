Why don't you need the '&' operator to pass the address of a string literal?Why is char *p = "Quora" valid but not char *p = &"Quora"?Short answer, because "Quora" is an array. This question was added to both C and C++ categories, I'll try to explain both: In C++, the type of the expression "Quora" is const char[6], array of 6 read-only characters (the 6th one is the invisible '\0'). In C, it's just char[6]. Note that it is not a pointer; more on that in a bit. The type of the expression &"Quora" is a pointer to the above: that is, pointer to array of 6 const char in C++ and pointer to array of 6 char in C. When you attempted to compile char *p=&"Quora", you attempted to create a pointer to char using a totally different type of pointer to initialize it with. This is an error in both C and C++. If you were to use correct types, this would compile: const char (*p)[6] = &"Quora"; // C++ char (*p)[6] = &"Quora"; // C Now back to the first one; when you attempted to compile char *p="Quora", you attempted to create a pointer to char using an array as initializer. Both C and C++ have a special rule that if you use an array where arrays are not allowed but pointers are, the compiler will inject code to construct a pointer holding the address of the first element of the array. In this case, instead of T*p=a it will actually compile T*p=&a[0]. So, this is what it looks like: const char *p = "Quora"; // C++ // compiles as if you're taking the address of 'Q': const char *p = &"Quora"[0];  char *p = "Quora"; // C // compiles as if you're taking the address of 'Q': char *p = &"Quora"[0]; One final bit of information, although in C++, char *p="Quora" is an error (online demo: Coliru Viewer ), it used to be allowed (but always deprecated) from 1998 until 2011 for C compatibility. PS did quora break inline code formatting again? first appearance of code now breaks the line, but further ones don't? 2.9k Views  View Upvotes