How do you Print inversions of an array?Is this possible using bit or we have to do using mergesort?The upper bound on number of inversions of an array is O(n 2 )  O(n2) . It’s easy to see that the array formed by the sequence n,n−1,..,1  n,n−1,..,1 , for an arbitrary n  n has n∗(n−1)2   n∗(n−1)2 pairs of inversions. Now, if it is going to take O(n 2 )  O(n2) time in the worst case to print all the inversions, why worry about the time complexity so much? Just try all possible pairs, and print the pairs which form an inversion. Much like this, function printInversions(Array a[1..n]): for i = 1 to n: for j = i+1 to n: if (a[i] > a[j]): print (i, j) Now that is a good first solution, and you can only improve upon it on ‘easier instances’ of the problem. If the given array A  A has I  I inversions, theoretically, the best you can do is O(I)  O(I) . Let’s try to get close to that, and you’re right we can leverage merge sort for the purpose. Lets look at a sample merge function to merge two sorted arrays, which also prints all the inversions formed by pairs of indices, one from each array. function mergeThatPrintsInversions(Array a[1..n], Array b[1..m]): i, j, idx = 1, 1, 1 Array merged[1..(n+m)] while i <= n && j <= m: if a[i] <= b[j]: merged[idx++] = a[i++] else: for k = i to n: print (k,j) // As a[k] > b[j] for all k in i to n merged[idx++] = b[j++] while i <= n: merged[idx++] = a[i++] while j <= m: merged[idx++] = b[j++] return merged Now you can use this in your merge-sort function. function mergeSort(Array a[1..n]): if n <= 1: return a return mergeThatPrintsInversions(mergeSort(a[1..(n/2)]), mergeSort(a[(n/2)+1..n])) Hope this helps! 479 Views · View Upvotes