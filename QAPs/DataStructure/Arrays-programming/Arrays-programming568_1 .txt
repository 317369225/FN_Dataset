I have an array of integers (both positive and negative). How can I find the smallest missing number in the array?Example: A = [5, -3, 2, 1, 0, -2, 4] return -1 EDIT: Thanks for your answers, maybe I had to say that I am not looking for O(nlogn) solution, since it is trivial. What I am looking is O(n) solution in terms of extra storage and run time.The function you are interested in is essentially the http://en.wikipedia.org/wiki/Mex... function. Here's a very simple O(N) time implementation that uses constant additional space (although it modifies the original array). function mex(A, N) i = 0 while i < N if A[i] < N and A[A[i]] != A[i] swap(A[A[i]], A[i]) else i++  i = 0 while i < N if A[i] != i return i i++ return N This algorithm works because it maintains the invariant that if x < N has appeared in the array then A[x] must be x. It runs in O(N) time because each swap increases the number of positions where A[x] = x which can only happen N times. Additionally since we're only performing swaps only the order of the array is disturbed; the array elements are all the same. If you want the minimum value to be x instead of 0, simply subtract x from each array element and add x to the result. 2.3k Views  View Upvotes