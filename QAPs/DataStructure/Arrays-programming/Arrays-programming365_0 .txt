Is there a way return an array from recursion?I have done recursion that returns one value like factorial, fibonacci number. But is there a way to return an array(list) of the values the recursion goes through. If possible can someone give an example code?Yes! In fact, this is extremely useful - in languages that don’t have iteration, this is how map and filter are implemented! (define (map proc lst) (cond [(empty? lst) empty] [else (cons (proc (first lst)) (map proc (rest lst)))])) Used: > (map (lambda (n) (* n 2)) '(1 2 3 4 5 6)) '(2 4 6 8 10 12) > (map ((curry *) 2) '(1 2 3 4 5 6)) '(2 4 6 8 10 12) For the empty list, return an empty list; otherwise, return a list that is the user-supplied function applied to the first element, plus the result for the rest of the list (recursive call). And here’s filter: (define (filter pred lst) (cond [(empty? lst) empty] [(pred (first lst)) (cons (first lst) (filter pred (rest lst)))] [else (filter pred (rest lst))])) Used: > (filter (lambda (n) (zero? (modulo n 2))) '(1 2 3 4 5 6)) '(2 4 6) > (filter even? '(1 2 3 4 5 6)) '(2 4 6) > (filter odd? '(1 2 3 4 5 6)) '(1 3 5) If the predicate returns true, append the element to the head of the result for the rest of the list; otherwise, don’t bother appending it. Note that these are working with singly-linked lists, so that getting the first element (first), the tail (rest), or appending to the front (cons) are constant time operations. Also note they are not tail recursive - they will actually use stack, because the last operation is the cons, not the recursive call. This can be fixed by adding an accumulator argument which keeps the list while it’s being constructed. The only issue is the result will be reversed, and you need to pass in a starting empty list, but both of these are fixable by a wrapper function: (define (map proc lst) (define (map-impl proc lst accum) (cond [(empty? lst) accum] [else (map-impl proc (rest lst) (cons (proc (first lst)) accum))])) (reverse (map-impl proc lst empty))) 3.1k Views · View Upvotes