How do I efficiently store a tree in a 1-d array(s) handling modifications?How about this: vector<pair<int,set<int>>> Tree(n); Since you mentioned O(n) space , so I interpret it as , that the number of nodes has a maximum limit of O(n), and that we can always allocate extra space, which will be enough, since no NEW nodes are added at any point. This is how I think we should go about: 1) The first element (int) in the pair stores the parent of a TreeNode. 2) The second element (set<int>) stores all the nodes which are the child nodes of that node. 3) To add an edge, [ implies parent->node relationship ] set the parent field of the child , and add the id of the child in the parent's set. 4) To delete a subtree, invalidate the parent id of the node to -1, and recursively do this for all the child nodes as well. In each recursive call clear the set<int> (container to hold child id's) as well. 5) Doing a DFS from a node is easy enough, only constraint being that the node should not have been previously deleted , which can be checked by checking its parent field. I suggested set<int> simply because to avoid any repetitive edges (multiple edges). In case you are not comfortable, you could go in with any other user defined data type( structure of your own , or class , or vector). Also , the id of a node is basically its position in the vector. Initially, every node has an id of -2. You will have to take care of boundary cases. 130 Views  View Upvotes