How do I find sum of all subsets of a range in an array?Given an array A of N elements and Q queries of type [ l, r ]. Print the sum of each subset in the range { A[l], A[r] }. For example: A[]= { 1, 2, 3, 4 } and [ l,r ]= [ 1, 3 ] then print sum( 1 ), sum ( 2 ), sum( 3 ), sum( 1,2 ), sum( 1,3 ), sum( 2,3 ), sum( 1,2,3 )This problem can be solved in O(N+Q)  O(N+Q) time. The first observation is that the sum of all subsets in a range [l,r]  [l,r] is equal to the sum of all elements in the range [l,r]  [l,r] multiplied by 2 r−l   2r−l . This can be understood as there are 2 r−l+1   2r−l+1 subsets and each element occurs in exactly half of these subsets. The next part of the solution involves a precomputation step of calculating prefix sums which can easily be done in O(N)  O(N) time. Prefix sum is nothing but the cumulative sum of all elements upto a given index, i.e., pre[i]=∑ j=0 i A[j]  pre[i]=∑j=0iA[j] (Taking array as 0 indexed). Following that each query can be answered in O(1)  O(1) time as the answer for the query is (pre[r]−pre[l−1])∗2 r−l   (pre[r]−pre[l−1])∗2r−l when l≠0  l≠0 and pre[r]∗2 r−l   pre[r]∗2r−l when l=0  l=0 . EDIT: If update operations are also there, the prefix sum logic would fail to give optimum result, thus segment tree or BIT should be used. In that case, time complexity will be O(N+QlgN).  O(N+QlgN). Update: It seems I had misunderstood the question. The actual question is to print the sums of each possible subset individually rather than printing the overall sum. The solution to this is even more simple: Just write down the following recursive function and call it for each query: void solve(int *a, int l, int r, int acc=0){ if(l>r) cout<<acc<<"\n"; else{ solve(a,l+1,r,acc+a[l]); solve(a,l+1,r,acc); } } 960 Views · View Upvotes · Answer requested by Suraj Bora