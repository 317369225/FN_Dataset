In the C programming language, array bound checking does not happen and generates a fatal error as output. Why?For the same reason that the knives don't check if it's your finger or chicken breast when they cut. The reason is that bounds checking require a sort of encapsulation that will always tell you exactly how much space an array has, and exactly that: bounds checking. That means that you can't have free pointers roaming through your arrays without complex reasoning if they are allowed to be there or not. That means that you can't just access a[i]; you have to test if the i is smaller than a certain value. Where do you get that value from? C was conceived as a portable assembler, so retrieving the value a[i] takes one instruction (or a very small number, depending on the architecture). And it would become quite complicated to find the bounds before retrieving the value, doubling (at least) the effort. In C++ you can have bounds checks because you have support for encapsulation, something that C doesn't really offer. I am not sure if the std::vector has bounds checks (std::vector.at has, by standard, it seems) but this is not why you use it. The reason is that you don't want a constant overhead on a million operations for the one time you might make a mistake. And even if you do that, it's a mistake, so you have to correct it. This is why it's far better to keep things unchecked, and use other sort of tools (like ElectricFence) to tell you when you address a point outside of your allocated space. There are simple ways to not exceed your bounds, and not to make mistakes. To go back to my knife analogy: it's something dangerous that you have in your kitchen, but common sense will drive you away from using them that way. Unless you really get one of those murderous rages, which is not really the best time to do programming anyway. 4.6k Views  View Upvotes