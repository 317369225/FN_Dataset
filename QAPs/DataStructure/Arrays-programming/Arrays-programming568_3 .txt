I have an array of integers (both positive and negative). How can I find the smallest missing number in the array?Example: A = [5, -3, 2, 1, 0, -2, 4] return -1 EDIT: Thanks for your answers, maybe I had to say that I am not looking for O(nlogn) solution, since it is trivial. What I am looking is O(n) solution in terms of extra storage and run time.You could sort the array then iterate through the array and find the first missing element. B = sort(A); for(i=0;i<B.length-1;++i){ if(B[i+1]-B[i]>1) { print("Lowest missing number is ",B[i]+1); break; } } The sorting is the more expensive part taking O(n log n), iterating takes O(n) so the whole algorithm isO(n log n). Not sure if there is a way to do it more efficiently. A space hungry linear time algorithm would be to iterate through the array to find the max and min values. Build another array with one bit for each number between min and max. Iterate a second time setting the bit of each number found. Then find the lowest unset bit. A recursive approach would be to define a function which finds the minimum unset value in partition of the array. int minValueBetween(int lowIndex, int highIndex, int[] A) { if(highIndex - lowIndex ==1) { // only 2 elements in the slice if(A[highIndex] > A[lowIndex] +1) { return A[lowIndex] +1; // There is a missing number } else { return MAX_INT; } } else { // More that 2 items recurse int midIndex = (lowIndex+highIndex)/2; int leftVal = minValueBetween(lowIndex,midIndex); int rightVal = minValueBetween(midIndex,lowIndex); return min(leftVal,rightVal); } } 513 Views