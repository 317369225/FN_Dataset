Why don't you need the '&' operator to pass the address of a string literal?Why is char *p = "Quora" valid but not char *p = &"Quora"?For this you need clear idea about how char * and char [] works. char * and char [] both are used to access character array, Though functionally both are same , they are syntactically different. See how both works in order to access string. Now Let us consider following sample example for storing and accessing string using character array – char a[] = "HELLO"; In the above example – String “Hello” is stored in Character Array ‘a’. Character array is used to store characters in Contiguous Memory Location. It will take Following Form after Initialization. We have not specified Array Size in this example.Each array location will get following values – a[0] = 'H' a[1] = 'E' a[2] = 'L' a[3] = 'L' a[4] = 'O' a[5] = '\0' Suppose we have to find out a[3] then firstly compiler will check whether ‘a’ is Array or Pointer ? If ‘a’ is Array Variable then It starts at the location “a”, goes three elements past it, and returns the character there in this method element is accessed Sequentially How let's see how the Char *a Works ? String “Hello” will be stored at any Anonymous location in the form of array. We even don’t know the location where we have stored string, However String will have its starting address. Syntax of char *a : char *a = "HELLO"; the above syntax will take following form – We have declared pointer of type character i.e pointer variable is able to hold the address of character variable. Now Base address of anonymous array is stored in character pointer variable. ‘a’ Stores Base Address of the Anonymous Array [Unknown Array]. Remember that if the declaration is,  char *a = "HELLO"; then the null character { '\0' } is automatically appended to the end of the text string. Address = [Base Address of Anonymous Array]  + [i] Accessing Individual Element : Consider we have to access a[3] then – In Short if ‘a’ is a pointer, it starts at the location “a”, gets the pointer value there, adds 3 to the pointer value, and gets the character pointed to by that value In both Cases a[3] returns same Character but Procedure is Different. Now if  you write char *p = &"Quora" then then it means that means you are trying to store the address of a pointer to a pointer(a double pointer) to a single pointer which is give error. You need to use char **p=&"Quora";  which will work fine. &(ampersand operator is called address of operator) and *(value at the address operator). In fact character arrays are internally stored and accessed using pointers, that is using the the base address of the character array. For this reason & is not required for scanf() when you are taking character array as input. 437 Views · View Upvotes