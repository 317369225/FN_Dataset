Arrays in c language?#include <stdio.h> int main() { int i1=-3; int arr[5]; int i2=-4;   printf(“i: %d %d\n”,i1, i2); arr[3]=3; printf(“3: %d\n”,arr[3]); arr[4]=4; printf(“4: %d\n”,arr[4]); arr[5]=5; //out of bound arr[-1]=6; //out of bound printf(“5: %d\n”,arr[5]); printf(“i: %d %d\n”,i1, i2); } after compiling cc -o arrayboundary arrayboundary.c you get 11700> ./arrayboundary i: -3 -4 3: 3 4: 4 5: 5 i: -3 6 As you can see i2 gets overridden by arr[-1] because the variables are on stack like this: int arr[5] int i2 int i1 Dependent on the way of implementation, compiler, version, so nobody can predict where exactly. I have overwritten one above one below and while i2 gets overwritten by arr[-1] it’s below that on stack. If you write higher up you will get a stack boundary error and a crash on my Linux at least, because the stackframes are protected by the operating system. For me. Not on Windows. No protection there. Security/Features - Ubuntu Wiki - none of which you have on Windows. None. I just want to make clear about that. None but the most basic, but none of the modern or advanced. That’s why Windows is so crappy. But enough of that. Your program crashes on my machine because of: security. But let’s see what we can find out about this. *** stack smashing detected ***: ./arrayboundary terminated [1] 17738 abort (core dumped) ./arrayboundary As you can see, the writing of one array above the stack is not causing a crash on my machine, maybe a safety space, arr[6]=xxx just crashes. So much about that. Let’s see, if we can find out about our bugs and if we respected the boundaries. There is a patch available to enable boundary check by gcc, but it’s not active on my machine and I don’t start recompiling just for this. But we have other options anyway. > gcc -Wall -Wextra -fsanitize=bounds -o arrayboundary arrayboundary.c You get more warnings and with this the output changes to this: > ./arrayboundary i: -3 -4 3: 3 4: 4 arrayboundary.c:13:5: runtime error: index 5 out of bounds for type 'int [5]' arrayboundary.c:14:5: runtime error: index -1 out of bounds for type 'int [5]' arrayboundary.c:15:22: runtime error: index 5 out of bounds for type 'int [5]' 5: 5 i: -3 6 And that’s the way you deal with that. Be careful about your boundaries, activate this sanitize flag during development and if you are still learning. And go and use your debugger. gcc -g -o arrayboundary arrayboundary.c gdb arrayboundary Check manuals on the net or man or tutorials about using gdb on Youtube. For starters: “start” starts the program, stops on the first line. “list” shows your program. “p <name>” prints a variable like “p arr[4]”. With “step” you follow the program, with “next” you don’t follow into a function call but just execute it and remain in the actual procedure. With “bt” you get the stackframes. “info stack” information about stack, “info reg” about registers and “info locals” the local stack. (gdb) info locals i1 = -3 arr = {4195936, 0, 4195488, 0, -12096} i2 = -4 (gdb) or (gdb) x/16xw $rsp 0x7fffffffcfb0: 0x00000000 0x00000000 0xfffffffd 0x00000006 0x7fffffffcfc0: 0x00400660 0x00000000 0x004004a0 0x00000003 0x7fffffffcfd0: 0x00000004 0x00000005 0xf7a35000 0xa89677e6 0x7fffffffcfe0: 0x00400660 0x00000000 0xf7a2e830 0x00007fff (gdb) p &i2 $5 = (int *) 0x7fffffffcfbc (gdb) info locals i1 = -3 arr = {4195936, 0, 4195488, 3, 4} i2 = 6 (gdb) p/x arr $10 = {0x400660, 0x0, 0x4004a0, 0x3, 0x4} (gdb) If you want to see the whole mess. As you can see there was one integer left free behind the array. Or whatever that was, it just should have crashed. I hate such things. gcc makes them one element larger than he has to because stupid people don’t get it, that arrays count from 0…elem-1 and not 1…elements. *** It it will certain crash on 6, because it hits the frame boundary and that’s protected on my system. The -1 is overwriting i2 -2 would be overwriting i1. Play around with that, understand that completely, before you go on. Very good question. You may also ask: why doesn’t GCC check that by default? Because that’s fucking slow to do on every element. And you can access to the local space anyway with every pointer you like. So what’s the gain in that? ADA did that and see where ADA is now. It’s a Java slave, we don’t want to end as Java slaves, do we? If you don’t respect the boundaries of your arrays you should not be anywhere near code in the first place. There are jobs free in marketing, though. But I guess you can make it, you ask the good questions. *** I found the reason for that additional point on the stack: 16 byte alignment! 66 Views · Answer requested by Kartik Shah