Why isn’t the address of an array a pointer to pointer in C++?Accept it as a fact of life. If you really need to use a function that accepts a pointer to pointer to int and you have an array of ints, you have a few options to convert an array to a pointer to int, first, then take an address of that pointer: int *pa1 = a; int *pa2 = reinterpret_cast<int *>(a); int *pa3a = reinterpret_cast<int *>(&a); int *pa3b = (int *)&a; int *pa4 = static_cast<int *>(a); , but not: int *pa5 = &a; int *pa6 = static_cast<int *>(&a); int **ppa5 = &a; int **ppa6 = static_cast<int **>(&a) All of this should not come as a surprise if you understand that ‘int (*)[]’ is not convertible to ‘int *’, as Sergey Zubkov pointed out. Now, when you see that reinterpret_cast that accepted &a and somehow magically worked, you may be tempted to start passing it to functions accepting int *, instead of int **, but that would be a mistake, too and compiler would, again, tell you that int (*)[5] cannot be converted to neither of the two pointer types. However, what’s interesting is that reinterpret_cast doesn’t really care about all that and it happily completes the conversion. Again, that shouldn’t come as a surprise if you understand that reinterpret_cast is pure alchemy, converting whatever you want into whatever you want. Same holds true for the good old C-style hammer-cast. If you try looking into the raw pointer values of a and &a, surprisingly or not, you will observe the same values, e.g. via: printf(“%p %p\n”, a, &a); or cout << a << &a . So, as I said, accept it as a fact of life. Although it might make sense to you, the language won’t let you do it - implicitly convert an address of an array to neither pointer to int, nor pointer to pointer to int. 318 Views · View Upvotes