What is the difference between an array and a vector?I really wish for more context on this question. "Arrays" and "vectors" can each mean multiple things. For example: arrays C/C++ are vastly different things from arrays in javascript/Python/perl; LISP does not have "array" altogether, but does have "vector;" if this is not enough to drive you crazy, math has its own idea of "vector," which frankly works out closet to Haskell's tuples (oh, another concept). Realize this: names are just names, different people call different things the same names. Generally speaking, there are a few ways of differentiation between "array" and "vector": Low level programming languages (By that I meant C++; C does not have vector if I recall correctly); also old programming languages (by that I meant LISP): "Arrays" connotates (different languages have ever so different precise definitions) low-level, concrete cells of memory. Takes C as an example. When you define an array of length 5, you know precisely how many bytes that would take, and you know precisely where to find 2nd and 3rd cells; you can set a pointer to that array location and do pointer math/operations on it and get precisely the element you want. Note 1: you can change an array length with realloc (if you malloc it). Note 2: you can also control where your memory lives. A local array lives in stack; a malloc-ed array lives in heap. "Vectors" connotates a high level abstraction that provides constant cost (i.e. O(1)) read and write. There are thus 2 main points (emphasized above). Vector is an abstraction, so you do not know where exactly your data is. You can't get the precise address in memory of each of your cells. You don't even know if your cells are completely consecutive (array or arrays still provide excellent access costs). In fact, your vector may as well be a hashtable! Vector implementation abstracts this from you, for good or for ill. Vector does provide "constant cost" access (read and write), which means that the cost of accessing your elements do not grow with the size. This does not mean it costs exactly 1 CPU cycle/assembly instruction to access. Write cost, in particular, is "amortized" (i.e. it's roughly constant over many operations), which means it is possible to trick your implementation into O(n) write. There is a special case: Java. Java is kinda like "middle language," half low-level, half high level. As such, most concepts in Java is a funk. Just look at generic (yeah, we give you type check; not, you can't investigate at runtime). Anyhow, array is another funky case. "Array" proper in Java is fixed sized construct (the Array instance can't be resized), but null-able and immutable variable (you can set your variable to a different array instance). The whole "new int[]" thing makes me wonder if array is really array (in the sense that cells are actually consecutive in memory) and the thing probably lives in heap. There is "ArrayList," which sounds like irony to me (a LISP lover). It acts more or less like C/C++/LISP vectors, and it does not act like LISP's list, which is LinkedList. Finally "Vector" is not defined by Java proper and usually does not mean "vector" in low-level/old languages. It usually denote mathematical vector (see below for more explanation). For high-level languages (Python, perl, Javascript, C#): For high-level languages, "array" is equivalent of low-level/old languages. As such, a new line is drawn between "array" and "vector": "Array" is the data structure. It provides O(1) access. Basically, you store data in arrays. The language defines the array as a part of its specification/standard library. "Vector" is the mathematics concept. Basically, you multiply matrix with vectors. The library (usually for linear algebra and such fun) provides vector concept to facilitate its API. 3k Views  View Upvotes