I have an array of integers (both positive and negative). How can I find the smallest missing number in the array?Example: A = [5, -3, 2, 1, 0, -2, 4] return -1 EDIT: Thanks for your answers, maybe I had to say that I am not looking for O(nlogn) solution, since it is trivial. What I am looking is O(n) solution in terms of extra storage and run time.Here is my Solution. I can solve it using O(n) time complexity and O(1) space. 1.) Bring all left negative to one side and all positive to other side in O(n) 2.) shift all positive to left side in O(n) , we only need positive number ,if all are negative then return 1; 3.) Use this positive array as a auxiliary array , for each element in an array ,make value of array negative corresponding to array element. 4.) search this array ,first array element with non negative value will be ans. public class Solution { public int shiftToLeft(int num[],int n){ int left=0,right=n-1; while(left<right){ while(left<n && num[left]<=0)left++; while(right>=0 && num[right]>0)right--; if(left<right){ int temp=num[left]; num[left]=num[right]; num[right]=temp; left++;right--; } } int pos=-1; for(int i=0;i<n;i++){ if(num[i]>0){ pos=i; break; } } if(pos==-1) return -1; int remElements=n-pos; int c=0; for(int i=pos;i<n;i++){ num[c++]=num[i]; } return remElements; } public int firstMissingPositive(ArrayList<Integer> A) { int n=A.size(); int num[]=new int[n]; for(int i=0;i<n;i++){ num[i]=A.get(i); } int size=shiftToLeft(num,n); if(size==-1){ return 1; } for(int i=0;i<size;i++){ if(Math.abs(num[i]-1)<size && num[Math.abs(num[i]-1)]>0){ num[Math.abs(num[i]-1)]=-1*(num[Math.abs(num[i]-1)]); } } for(int i=0;i<size;i++){ if(num[i]>0){ return i+1; } } return size+1; } }  526 Views