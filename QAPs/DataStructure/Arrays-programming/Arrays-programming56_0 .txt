How do I find all the subarrays of an array in increasing order of their lengths?For {1,2,3} i donâ€™t want {1},{1,2},{1,2,3},{2},{2,3},.. and so on. I want {1},{2},{3},{1,2},.. and so on.Updated. A2A. Increasing order subarray Code: void subarray_increasing_order() { int N = 4; int a[] = { 1,2,3,4 };  for (int width = 1; width <= N; width++) { for (int i = 0; i <= N - width; i++) { for (int j = 0; (j < width) && (i + j < N); j++) { CO << a[i + j] << " "; } CO << EL; } CO << EL; } CO << EL; }  // CO means std::cout // EL means std::endl Output 1 2 3 4  1 2 2 3 3 4  1 2 3 2 3 4  1 2 3 4 Details: Say, N is number of elements Assume N bits exist in your data type  For example You have N = 4 elements, i.e. 1 2 3 4 So you have 4 bits in your data type So 1000 means 1 1100 means 1,2 0011 means , ,3,4 0101 means ,2, ,4 // Not possible you need sub array (contiguous, so we shift always) 1111 means 1,2,3,4 Algorithm, (Example, N = 4): Set 1 to N MSB bits, and do as below steps:   Set 1 MSB bits (left-most), right shift 1 bit each time, N-1 times, that is 3 more times  You have N= 4 bits, set 1 left most bit 1, , , 1000 // set 1 MSB bit ,2, , 0100 // now right shift once , ,3, 0010 // now right shift once more , , ,4 0001 // now right shift once more   Set 2 MSB bits (left-most), right shift 1 bit each time, N-2 times, that is 2 more times  You have N= 4 bits, set 2 left most bits 1,2, , 1100 // set 2 MSB bits 2,3, 0110 // now right shift once ,3,4 0011 // now right shift once more  Set 3 MSB bits (left-most), right shift 1 bit each time, N-3 times, that is 1 more times  You have N= 4 bits, set 3 left most bits 1,2,3, 1110 // set 3 MSB bits 2,3,4 0111 // now right shift once   Set 4 MSB bits (left-most), right shift 1 bit each time, N-4 times, that is 0 more times  You have N= 4 bits, set 4 left most bits 1,2,3,4 1111 // set 4 MSB bits Non increasing subarray is simpler Start with each of the 1, 2, 3, if there are more elements to right, add 1 element each time. Example: For {1,2,3}, Note the below: 1 has 2 & 3 on right 2 has 3 on right 3 has no elements on right Algorithm (Example, N = 3): // start with 1, add 1 more element on right each time if exists {1} {1,2} {1,2,3}  // start with 2, add 1 element on right each time if there are more elements {2} {2,3}  // start with 3, add 1 element on right to set each time if there are more elements {3} (Excuse if any typos in the above) 600 Views  View Upvotes  Answer requested by 1 person