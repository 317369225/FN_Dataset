Why is the first element in an array referenced as 0?There is one important practical reason: pointer arithmetic. An array is just some elements (bytes/words/…) of the same size in memory. When referencing an array element, what happens is a memory access to base address + offset. The base address is usually represented by the name of the variable, while the offset is the size of one element times the array index. In C it looks like this: int array[N]; int a = array[2]; // access to second element int b = array + 2; // using pointer arithmetic int c = ((char*)array) + 2*sizeof(int); // accessing as if the elements were byte sized The last line accurately represents what’s going on at the level of the assembler. So the 1st element is at the address where the array starts, and to make the above arithmetic work, it’s offset ends up being zero. Now, some languages start arrays at index 1 (pascal, matlab/octave…) or at an arbitrary user defined index (Ada can do that, not sure if there’s any other). In those languages the compiler has to “offset the offsets” for each array access, or even worse, generate more instructions. It just gets worse with dynamic array bounds checking built into some languages. TL;DR: Indexing arrays from zero is closer to how accessing memory actually works, and is as a result faster to run/compile/interpret. 184 Views · View Upvotes