An array (n) is given. The array can be traversed by jumps of size <= k. If at index i, a jump can land you anywhere from i+1 to i+k index?The cost of traversal is the sum of all the elements of the array on which you have landed inclusive of first and last element. Is it possible to solve this in O(n) complexity? I am aware of the naive method. Example: array 1 5 2 8 7 9 1 for k = 2, the solution will be 1 + 2 + 7 + 1 = 11.The best method I can think of is O(n logn). It can be done using bottom up approach. Start from the end of the array. Answer for ith position will be stored in dp[i]. To compute dp[i], you can use segment tree to find minimum from i+1th to i+kth dp values. After computing dp[i], this value can be inserted in segement tree to compute furthur dp values. EDIT: I guess one can use deque to get O(n) performance. Deque will only store elements in the current window such that they are in descending order from back to front. At every index i, remove element at the top of deque if it's no longer in the range i+1 to i+k. Now compute dp[i]. Push this result at the back of deque. Now remove elements from the deque that are previously present in deque and if they are smaller than currently calculated dp[i]. Every element will be added and removed once, hence complexity will be O(n). This deque method is explained here : Maximum of all subarrays of size k (Added a O(n) method) - GeeksforGeeks 157 Views  View Upvotes