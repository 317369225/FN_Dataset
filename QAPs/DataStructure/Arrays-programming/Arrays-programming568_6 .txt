I have an array of integers (both positive and negative). How can I find the smallest missing number in the array?Example: A = [5, -3, 2, 1, 0, -2, 4] return -1 EDIT: Thanks for your answers, maybe I had to say that I am not looking for O(nlogn) solution, since it is trivial. What I am looking is O(n) solution in terms of extra storage and run time.#include <iostream> #include <unordered_map> using namespace std; typedef unordered_map<int, int> hashmap; int main() { int array[] = {5, -3, 2, 1, 0, -2, 4}; hashmap map; int min = array[0]; for (int i = 0; i < (sizeof(array)/sizeof(*array)); i++) { if (array[i] < min) min = array[i]; map[array[i]] = 1; } while (map[min] == 1) min++; cout << min << endl; return 0; } Please feel free to comment on the above solution. 341 Views  View Upvotes