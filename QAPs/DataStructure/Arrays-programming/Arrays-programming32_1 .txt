Is it possible to have a dynamic contiguous array without its size being fixed internally?Link which contains some details about the question: Is it possible to have a dynamic contiguous array without its size being fixed internally?Basically, once the capacity of the original array is exhausted and you need to add more elements to it, you have three options: You put it into contiguous memory block next to other elements. In general case you can’t guarantee that memory next to original memory block is vacant (not occupied by other data), which is why you also can’t guarantee that you can safely expand it’s size to accommodate new elements. So you might have to memcpy() the original contents elsewhere, which results in O(log n) amortized append complexity. You ensure that memory next to original memory block is unoccupied. In principle you can achieve that by not malloc()ing anything after the “unbound” array (and maybe having to do some libc hacking). In virtually any practical case, way more simple and robust approach would be just to allocate “big enough” arrays at startup and to try to get away with it. You put it somewhere else. Since now you have multiple chunks of memory where the elements are stored, on read/write access you need to determine the right chunk first. Which is how you lose a straightforward O(1) access time that array normally guarantees and end up with a tree-ish data structure with O(log n)-ish read/write complexity. So, you get something with “size not fixed internally” but it’s not an array. 65 Views · View Upvotes