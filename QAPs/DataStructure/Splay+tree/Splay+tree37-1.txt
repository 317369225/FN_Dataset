What are some algorithms and data structures which should definitely be included in one's ACM ICPC team notebook?
I'd agree mostly with Nick Wu that the contents of your team notebook don't usually matter.  Over my two world finals appearances I personally wrote up 9 solutions and not once did I use any kind of reference material.  I recall at a regional contest I used a notebook to verify that my point rotation code was correct, but that's about it. I see notebooks as having limited value for a couple reasons Lots of algorithms/solving strategies can't really be captured in a single implementation.  For example you can't have 'dynamic programming' or 'greedy' example implementations. The common things that do come up frequently you just memorize.  An example implementation of Ford Fulkerson won't help me implement it significantly faster.  This is something that is going to vary with experience.  Judges avoid cookie cutter problems where the solution is some classic algorithm you may have seen before.  However this isn't always the case, for example ECNA 2012 had a min cost bipartite matching problem that needed very little extra code. But obviously there is no penalty for having a notebook so you should have one.  Maybe you will get lucky.  Let me make a short list of things that should definitely make it to your notebook. Geometry primitives.  dot product, cross product, bisector, intersection, rotation, hull.  Consider doing geo with <complex>. Binary Index Tree, range min query, segment tree Extended Euclidean algorithm and fast exponentiation (if you can't remember them) Floyd Warshall, Dijkstra, Max flow Honestly most of this stuff is stuff you probably shouldn't need a notebook for and you should be able to reproduce given enough time.  The notebook can help you implement faster and serve as a sanity check.  Past this there are some miscellaneous algorithms you probably won't need but it will pay off if you do need them, including: Big integer arithmetic Bellman Ford 2-SAT solver Tarjan's SCC algorithm Tarjan's biconected components algorithm (was in WF 2011) Min cost flow Suffix arrays/Suffix tree Heavylight decomposition Simplex algorithm Splay tree That list includes mostly includes almost everything I have in my own personal repository that I use for online competitions. 