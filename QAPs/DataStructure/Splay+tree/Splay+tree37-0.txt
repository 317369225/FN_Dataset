What are some algorithms and data structures which should definitely be included in one's ACM ICPC team notebook?
I think the rule of thumb is that, the included codes should be something: your team does not know how to code from scratch; OR your team knows, but it takes a lot of time (e.g., complex algorithm / data structure) to code and/or debug. For example, I am quite sure for most world finalist teams, at least one member knows some network flow algorithms well and can code from scratch. But with a Dinic algorithm snippet in hand, it definitely saves your time for implementation and debugging. You have more time to focus on how to model the problem. Ideally, any items falling into 1. and 2. should be included. But you know there is a page limit... For 2. these really vary a lot with your "expertise". I myself am very confident in 2D geometry, which means I can code most operations (e.g., vector rotation, inner product, cross product, finding intersection between two segments) from scratch accurately and efficiently, therefore there is no need to include them. These kinds of things save spaces to contain more 1. items. These are some random items which neither fall into category 1. or 2. appearing in my mind: DFS / BFS / Shortest Path Disjoint Set Union Geometry subroutines Binary-Indexed Trees (easy to code/memorize, even you don't fully understand them) ---- The following (summarized, but not exhaustive) compilation may be useful: (Will update if I find more) Data Structures: Segment Tree Suffix Array Splay Tree Graph Algorithms: Bridge / Articulation Point / Bi-connected Components Strongly Connected Components / 2-SAT Euler Path / Cycle Lowest Common Ancestor Network Flow - Maximum Flow - Minimum Cost Maximum Flow Maximum Matching Geometry: Subroutines (2D / 3D) - Dot products / Cross products - Rotation - Reflection Intersections between [math]X[/math] and [math]Y[/math], where [math]X, Y \in \{[/math]Circle, Polygon, Segment, Line[math]\}[/math] Closest distance between [math]X[/math] and [math]Y[/math], where [math]X, Y \in \{[/math]Circle, Polygon, Segment, Line[math]\}[/math] 2D / 3D Convex Hulls String Matching: KMP Suffix Array (also mentioned in Data Structures) Aho–Corasick string matching algorithm Maths: Linear Programming (Simplex) System of Linear Congruence FFT Useful formulae that your team cannot derive quickly (Yes, it's permitted to included printed items) (Also see: My answer to Number Theory: What important topics of number theory should every programmer know?) Java (hmm... we code mainly in C++, but sometimes Java helps): BigInteger / BigDecimal Snippets I/O Snippets ---- As additional notes, I think the team notebook should be designed as a neat set of APIs, which are easily reusable: I have solved quite a bunch (10~20?) of ACM-ICPC problems (during training + regional contests) using the data structure Suffix Array algorithm with runtime O(n lg n). While I don't fully understand the details about its construction, with a well-written code snippet, I can solve these problems efficiently once I identify the reduction to a Suffix Array solution. ---- From my experiences, the team notebook was used more often during my 8 Asian regional contests than in the 2 World Finals. (In 2010 WF, my team didn't use the notebook at all; while in 2011 WF, my teammate used the Maximum Flow algorithm and the Bi-connected Components algorithm.) I find that the notebook is quite helpful for Asian regional contests (there are quite a few problems with classical solutions), but this may vary across different regions. But all in all these snippets can be useful elsewhere. (e.g., during online contests, for other teams, or even for teams in the next generation) Updated 163w ago • View Upvotes • Asked to answer by Tudor Achim and Sai Teja Pratap