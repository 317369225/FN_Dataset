Is it necessary to make an int pointer (int *p) to point to an int and a char pointer (char *p) to point to a string?
Short answer:  Yes.* I put an asterisk on that because the short answer applies to the vast majority of programming under normal circumstances.  Even for experts, I'd say "Yes, most of the time."  There are situations when it's not true, but those are quite rare normally, and if you find yourself in such a situation, you need to be very aware of what you're doing.  At that point, you are no longer writing portable C or C++ code.  Your program will now rely on details of your C or C++ compiler that the standard leave implementation defined or undefined. First, let's get one inaccuracy out of the way:  Pointers do not store "addresses which are actually alphanumeric."  Pointers do store addresses, but the addresses themselves are not alphanumeric.  On any computer you're likely to encounter, they're ordinary numbers, stored in binary.  For convenience, we tend to display them in hexadecimal, but you could just as easily display the value of an int or a char in hexadecimal. Next, pointers are their own family of types.  The type int * is distinct from char *, and both of those are distinct from both int and char.  In general, the types foo and pointer-to-foo are distinct, but related types.  In fact, you can even have pointer-to-pointer-to-foo, and that too is a distinct type. Now on to the nitty gritty. In C and C++ a char variable holds a single byte, by definition.  Note, that C/C++ do not require a byte to be 8 bits, although that's likely to be true for most machines you'll use. (It's not true for some specialized machines, such as certain embedded processors.)  A char represents the minimally addressable unit for whatever machine you're on. All other objects, including variables of type int, are made up of multiples of this minimally addressable unit.  The C/C++ operator sizeof will tell you how many char sized units are required to store a given type.  On a typical 32-bit or 64-bit x86 system, sizeof(int) will be 4.  Other systems might have sizeof(int) == 2 or sizeof(int) == 8.  It is even possible to have sizeof(int) == 1! Depending on the machine architecture you're using, objects may also have to be aligned specially in memory.  For the simple built-in types ( char, short, int, long, float, etc.), the required alignment typically matches the size of the type.  So, an int might be 4 bytes large and have to be on a 4 byte boundary.  Some architectures are more lax here:  The x86 architecture, for example, doesn't generally require alignment for most things, but it will perform much better if you do align things.  The C and C++ compilers will align things by default on those machines.  On more strict processors, if you try to access an object such as an int and the pointer isn't aligned correctly, your program will actually crash on the spot.  In Linux or UNIX, this will typically get reported as a bus error. Most of the time, the compiler takes care of all of this for you.  When you say char c; or int i;, the compiler allocates the appropriate number of bytes with the appropriate alignment for you.  If you then say char *pc = &c; and int *pi = &i;, you will now have pointers to those locations.  Everything is good and well defined. What if you said:  int i; char *pi = (char*)&i;?   That code will compile.  It likely won't even give you any errors or warnings!  But what can you safely do with such a pointer? Not much, unless you're willing to be non-portable.  That pointer points to the first byte of int i.  What's in that byte?  Implementation defined.  If it's a little-endian machine, you'd see the lower bits of i.  If it's a big-endian machine, you'd see the upper bits of i.  There are few things you can do safely here.  You can use the pointer to copy the int, but you need to remember to copy all of bytes.  (This is how simple implementations of memcpy work.)  In fact, the C and C++ standards have special rules specifically for char* that are intended to let memcpy-like things work, although largely in an implementation defined manner. What if you had instead said:  char c; int *pc = (int*)&c;?  What can you do with that pointer value?  The short answer:  Nothing.  You now have an int pointer that points at a single byte.  Chances are very good that the system you're on has sizeof(int) > sizeof(char), and may even require greater alignment for int than char. So how about arrays?  In C and C++, arrays are both contiguous and homogenous.  Each element is the same size (given by sizeof), and the elements are stored contiguously with no gaps.  In fact, the language will even add padding to objects themselves (and increase the sizeof for the type accordingly) to ensure there are no gaps between the objects in an array. C and C++ allow you to use pointers to efficiently access and manipulate the contents of an array.  An array variable decays to a pointer to its first element in many contexts, making it easy to get a pointer into the array.  That is, you can say something like char ac[42]; char *pc = ac;, and *pc will point to the first element of ac.  Likewise, you can use array indices with pointers.  Under the hood, the compiler translates that to pointer arithmetic.  Continuing the example, the expressions ac[10] and pc[10] both access the same element of the array. You might be wondering:  How are pointers different than the array itself, then?  Simple:  Pointers can move, the array cannot.  You can add or subtract integers from the pointer to move the pointer.  As long as the pointer stays within the array, everything remains well defined.  (The pointer may also point to the first element after the array, and as long as you do not dereference the pointer when it does, everything remains well defined.)  The ++ and -- operators act as short cuts for adding and subtracting 1 from a pointer. That allows you to write loops like: for (i = 0; i < 42; i++)    *pc++ = i; But... I handwaved something by using an array of char:  What happens when the pointer points to something that is larger than a byte? The answer is that pointer arithmetic always moves in whole elements.  When you say a[i] with an array, that always takes you to the i-th element.  The same is true if you have a pointer to the first element.  The compiler scales the index appropriately under the hood to make this work.   So, if I say int ai[10]; int *pi = ai;, then both ai[3] and pi[3] point to the same element. How does it know the scale factor?  It knows from the type of pointer.  And what is the scale factor?  It's the value returned by sizeof for the type.  In fact, you're guaranteed that the size of an array in memory is determined by the number of elements in the array times sizeof(type) for the type of elements in the array.  (That guarantee is what allows you to call malloc to allocate variable length arrays of any type.  It extends from the homogenous and contiguous guarantees I mentioned earlier.  But, I digress.) So what if I say char ac[42]; int *pc = (int*)ac;?  Well, this will compile.  Depending on the compiler and your settings, it may or may not give warnings.  But if you try to use the pointer *pc, weird things will happen.  Depending on the machine, you may even crash. What if you instead said:  int ai[10]; char *pi = (char*)ai;  The situation is less dire, as a char* can point at anything (as stated earlier).  You are definitely in implementation defined territory; however, you could use this to implement memory copies or memory fills.  You definitely need to know what you're doing. In general, it's bad practice to mix pointer types like this.  There may be cases where it's called for, but 99%+ of the time it's completely avoidable. So what are pointers to int and char actually useful for?  Lots of things, mostly involving arrays and or dynamically allocated storage.  Pointers to struct are even more interesting (especially when the struct itself contains pointers), as you can build arbitrary data structures that are dynamically allocated. But given the length of this answer already, I'll just leave you with that. 