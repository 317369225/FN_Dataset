How much additional memory overhead does NSArray in Objective-C have versus standard C arrays?
It depends. For an immutable array, there is almost no overhead other than the obvious overhead of the array object instance itself (which stores the pointer to the buffer and its length). For a mutable array, there is going to be more overhead because generally there is some empty space in the array to allow for insertions without reallocation of the backing buffer. Like other vector implementations, the size of the backing buffer is bounded by a constant multiple of the number of elements actually in the array. For extra fun, you can examine the actual source. I can almost guarantee you that you will be surprised at how it's implemented, as it is self-centering so that it can be efficiently used as a deque, and all of the key operations have to go through a few chokepoints to facilitate the fact that you can subclass NSMutableArray by only implementing three methods: http://www.opensource.apple.com/... Edit: Wow, I totally missed the part about an array of floats. With the 32-bit runtime (e.g. iOS), you're going to have a much bigger overhead from having to box each float in an NSNumber to put it into an NSArray. On OS X, every malloc'd instance has to be at least 16 byte aligned, so you're blowing through at least 4 words plus the actual pointer to the NSNumber instance. You can use a CFArray with NULL value callbacks to store the values unboxed, though this requires hacky float-to-pointer casting. You could always use std::vector... With the 64-bit runtime, the NSNumber overhead should actually not be that bad depending on the value of the float. Objective-C and Foundation work together to use tagged pointers to fit NSNumbers with sufficiently small values directly in the 64-bit "pointer" itself. 