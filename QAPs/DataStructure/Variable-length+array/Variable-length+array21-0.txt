Why do people still use C when they have C++?
Fear, prejudice, tradition, and modifying existing  software which were the same reasons some people still clung to assembler after C compilers were generating better code.  For a while C++ compilers lagged behind C on correctness (IIRC issues with volatile were what ended the Linux kernel compiled as C++ project) and optimizations although that's no longer the case (the early 1990s were 20 years ago). Stroustrup's The Design and Evolution of C++  begins with C++ was designed to provide Simula's facilities for program organization together with C's efficiency and flexibility for systems programming.  That efficiency goal means all features with time and space penalties are optional whether you have hundreds of bytes or gigabytes. Member functions are by default non-virtual,  are called with the same machine code as C functions with no extra indirect, and have no space overhead. Classes and C structures have identical layouts until you add virtual members or virtual inheritance.  Moving from "struct" to "class" in C++ only changes the default access from public to private. The compiler never generates class/struct temporaries for conversions and pass by value unless you define single argument constructors without the explicit keyword and don't disable the copy constructor.  This is better than C which is usually silent about accidentally passing structs by value. Templates can generate extra code, although that also holds for generic programming in C using macros like the BSD <sys/tree.h> and <sys/queue.h>.  In either language you can avoid that where you need to. Obviously parts of the C++ standard library like <iostream> are large, although the same holds for C standards like <stdio.h> and most of the time skipping one implies you'd avoid the other. If you need them and no C++ alternate  will do, the parts of C not in standard C++ are usually implemented as vendor-specific extensions and not a reason to limit yourself.  GCC's list of C99 features in C++ is extensive. Compilation speed is also comparable until you start abusing templates which is  rarely (boost::spirit is much more convenient than manually generating parsing code or using lex + yacc) the right choice.  Basic C++ features like inheritance don't impose a noticeable overhead. C++ provides more ways for the ignorant to do bad things than C, although a few guidelines (like Google's C++ style guide) and a little training can fix that without loosing important functionality.  It offers more ways for the stupid to screw up than 'C', although you're better off with more competent people and when you're stuck 'C' is also wrong due to pointers and manual resource management. Updated 23w ago • View Upvotes