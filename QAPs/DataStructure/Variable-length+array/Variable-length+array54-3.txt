What's the difference between writing software for Windows and Unix?
Some of the answers here explain a few of the differences very nicely, especially those by Narayana Ravikumar and James McInnes. However, let me try and provide my own perspective for the same. To begin with, I'm not big programmer. I write code as a hobby and sometimes contribute to Open Source Projects. One of the major projects I tend to contribute to is GNU Wget. Those using *nix systems, probably know what I'm talking about. For the others, Wget is a popular command line tool for downloading content from the internet. When it comes differences between writing software for Windows and Unix, I'd like to split this into two sections: Tools and Development Environment Differences in software code Tools and Development Environment The tools available for programming vary by a large amount with the programming language you use.  Let's first take the example of C/C++. On a Windows system, you have access to a brilliant Integrated Development Environment (IDE) known as Microsoft Visual Studio. I've used VS in the past and I must say it's the best IDE I've had the chance of using. IntelliSense (tm) is a brilliant feature provided by VS for code completion. It also provides some static syntax checking among other things. Visual Studio is truly a beast. However, when it comes to compiling C programs on MSVC, it is a huge pain because MSVC supports only the ancient C89 standard. Microsoft has refused to upgrade their compiler to support the newer standards. This becomes a major issue when developing the software and will be reflected in the next section. Other compiler options include using MingW and/or CygWin. Both are a huge pain to configure manually. Eclipse and Netbeans are other great IDE's that also set up a MingW environment for you. Another important component of a development environment is a version control system. Now Visual Studio comes with Microsoft's own SourceSafe. But for everything nice about Visual Studio, there is also a very hefty proce tag associated with it. In the open source community, the most popular VCSs include Git and Mercurial. I'm not sure about Mercurial, but while Git supports Windows, setting it up and using it is surely much more of a pain than on *nix systems. On a *nix system on the other hand, setting up a development environment is pretty easy. You have some brilliant text editors available which can double as amazing IDEs (ViM, Emacs). Installing GCC is extremely easy on any distro. And since GCC is absolutely amazing and supports every standard of C/C++ it is the best compiler out there for flexibility. You also have the option of installing and using other compilers like LLVM/Clang. Apart from that the same IDE's Netbeans and Eclipse are also available on most *nix systems.  Depending on your preferences, you could use a purely console based development environment (Vim + plugins + gcc) or a GUI based IDE like Eclipse. Git, hg, svn, etc. all work very easily out of the box and have loads of extensions and utilities available which you can use to extend their capabilities. Differences in CodeThis is where things get really ugly. I have some experience in maintaining cross-platform console applications. And Windows does cause a bit of pain. Checking the source for GNU Wget, I see nearly 938 lines of code specifically written so that Wget works on MS Windows. This is a project with only about 100,000 lines of code. Hence, maintaining a Windows port accounts for nearly 1% of the codebase. Coming to where the differences occur, a major chuck of this code are functions that programmers take for granted on *nix systems but are not available on Windows. Hence, they've been reimplemented in Wget for their use. Another major difference in the handling of signals and making system calls. This also accounts for a large portion of the code. Other issues are minor and much more subtle, which makes it very difficult to identify and fix them. For example, a recent issue I faced was that Wget printed an extra newline on the Windows systems only. Turns out that is because Windows command prompt cannot handle invisible characters the same way Bash/zsh and every other shell on *nix systems does it. As mentioned above, when you want your code to be portable to Windows systems, you'll have to stick to the ancient C89 standard instead of using all the features from the latest and greatest version of C, C11. This means you cannot use variable length arrays, or single line comments using `//`.  Another missing feature is the ability to mix variable declarations and other code statements. All this makes writing and maintaining C programs that work on Windows too a huge pain. One more point that one needs to remember when writing portable source is line endings. Windows uses `\r\n`to signify line endings, Linux uses `\n` while OSX uses `\r`. This means the program needs separate logic for reading from or writing to Windows / Linux and OSX files. Similarly, there is a difference between how Windows and *nix systems represent directory paths. While *nix systems use `/` to represent a separator, Windows uses the opposite, `\`. The backslash symbol, `\` on *nix systems is used to escape characters and will cause your program to try and access completely different files than expected. This is a small list of differences between writing programs for *nix and Windows systems. P.S. This answer specifically targets C/C++. Other languages may have their own quirks and issues. 