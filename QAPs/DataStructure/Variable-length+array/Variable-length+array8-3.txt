Why doesnâ€™t "sizeof(a)/sizeof(a[0])" work for an array passed as a parameter?
I'm keeping what is below for posterity and to make the chain of conversation that follows in the comments make sense. Otherwise... My answer was quite wrong in the deep specifics. However, it seems that an array parameter is passed and treated as just another pointer with Microsofts compiler (under Visual Studio 2015) and by GCC 4.6.3 - I would test further compilers, but doing so can be a bit of trouble. What is more is that several groups of rules that call themselves "secure coding styles" all state that you should not rely on 'sizeof(a) / sizeof(a[0])' working at all and always pass the actual size of the array to the function as well. --- Older Answer --- For the example you posted, the 'int a[]' notation you used as the function parameter is actually a programmer convenience and hold-over from very early versions of the language that is, under the hood, converted to 'int *a'. When you do 'sizeof(a)' later on, you have just asked for the size of the pointer - which, depending on the age of the OS, machine and compiler, can be 2, 4 or 8. On the other hand, you could do 'sizeof(*a)' which would first de-reference the pointer and is the equivalent of 'sizeof(a[0])' The C language technically does not have array parameters - it has the basic types (whcih generally mirror machine data sizes) and pointers. Arrays and strings are just pointers - nothing special about them at all. (Note that this idea - that 'int a[]' is just 'int *a' under the hood is one of the things that a lot of people get caught by, including some kernel developers. If I'm not mistaken, Linus Torvalds has had some somewhat harsh words to say about people doing the above - 'sizeof(a)' and expecting it to be the size of an array item and not the pointer - and noted that this is why the Linux Kernel source has the ARRAY_SIZE() macro.) 