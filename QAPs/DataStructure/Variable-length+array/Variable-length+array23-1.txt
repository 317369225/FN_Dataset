In what cases is Java slower than C++ by a big margin?
To answer this question, you first need to break the problem into the possible causes of slowness: Garbage collection. This can be both a blessing and a curse. If your program follows the "most objects die young" model, garbage collection can actually be a benefit (less fragmentation, more cache locality). However, if the program doesn't follow this model, the JVM will spend a lot of resources traversing the heap. Larger objects. All objects in Java have a vtable pointer, whereas C++ allows you to have POD structs with no overhead. In addition, all java objects are lockable. Depending on the JVM, this may add another field to the object. Larger objects == fewer objects in the cache == slower. (On the other hand, Java 7 has compressed pointers on 64 bit, which partially makes up for this.) Lack of inline objects. In Java, all classes are pointers. In C++, objects can be allocated within other objects or on the stack. This can increase cache locality, and reduce the cost of dynamic memory allocation. Calling platform functions. In Java, there is a non-trivial overhead for JNI calls and marshaling objects into native code. If you need to make very frequent calls to custom C++ code, this will add overhead. Abstraction-forced inefficiencies. For example, in Java, Strings are immutable. If you want to write an XML parser, and you only use String objects (no char[]s), it will be slow because of the extra allocations. Increased usage of virtual calls. Almost all calls in the JVM are virtual. There's lots of code to attempt to remove this; however in cases where the JVM can't resolve a virtual call, it prevents inlining and can make the code slower. Lack of advanced compiler features and the ability to go to assembly. If you're writing code that could benefit from a bit of handrolled assembly, Java will likely underperform. Personally, I think that the big ticket item is Garbage Collection. Forcing lots of full GCs in a program with lots of memory is one of the easiest ways to get an order of magnitude difference between Java and C++. Issues like larger objects or lack of inline objects can also be big if they push the working set of your program outside of the L2 range. Abstraction-forced inefficiencies and platform functions can also cause slowdowns, but these are generally isolated to lower level code. If you use well written Java libraries, this is usually not too much of a problem. Updated 290w ago â€¢ View Upvotes