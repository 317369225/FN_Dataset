In what cases is Java slower than C++ by a big margin?
Generally agreed with Ben Maurer's answer to In what cases is Java slower than C++ by a big margin? (hey Ben!). A few small points: In the newest JVMs, Escape Analysis is available which can determine that a certain allocation never escapes (a) the local function or (b) the local thread. This means that allocation can be done without acquiring any locks, and often times on the stack itself. In both cases it's a simple "bump the pointer" allocation, which is equivalent to stack allocation in C. Even without escape analysis, young generation allocation is done in Thread-Local Allocation Buffers (TLABs) by bump-the-pointer allocation requiring no synchronization. So small object allocation in Java can sometimes be faster than naive malloc() implementations in C. Better mallocs like Google's tcmalloc pull similar tricks, but are somewhat limited due to C's relative inability to relocate objects in memory after allocation. Regarding inlining and virtual methods, there are actual some cases where Java can do a significantly better job than C. Particularly, C can't do inlining across a dynamically linked function, since inlining happens at compile time rather than runtime. Java, on the other hand, can dynamically inline a function call across class or library boundaries, even when the actual implementation class is unavailable at compile time. For many workloads this is a benefit over C++'s virtual method calls which always require a vtable call. JIT compilers use smart invalidation logic to de-optimize the inlines if the previous dynamic properties are lost (e.g. new classes are loaded). Newer versions of GCC provide some of this benefit with so-called "whole program optimization" or "link time optimization" (http://gcc.gnu.org/wiki/LinkTime... allows inlining across object files within a project. But it is still fundamentally not allowed to inline across a dynamic link boundary (e.g. to inline the implementation of a zlib call, etc). Many large projects get around this by duplicating standard library functionality into their codebase. Finally, a disadvantage of Java for performance critical systems is lack of easy access to platform-specific calls, even those that have been available in POSIX for years. For example, if you want to call posix_fadvise on a file descriptor to inform the kernel of your intended access pattern, you are SOL without resorting to JNI, etc. Updated 215w ago â€¢ View Upvotes