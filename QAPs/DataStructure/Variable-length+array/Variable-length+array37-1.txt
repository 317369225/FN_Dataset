Why do we need arrays when we have vectors in C++?
You can indeed stop using C-style arrays, because you now have std::array. This gives you all the advantages of C-style arrays, plus a C++ layer so (for example) you can use all the STL algorithms with them. There are other two other options for contiguous-storage arrays: std::vector<T>, as you noted, and std::unique_ptr<T[]>. Here are the tradeoffs: Initial size vector and unique_ptr<T[]> allow the size to be specified at run-time array only allows the size to be specified at compile time Resizing array and unique_ptr<T[]> do not allow resizing vector does Storage vector and unique_ptr<T[]> store the data outside the object (typically on the heap) array stores the data directly in the object Copying array and vector allow copying unique_ptr<T[]> does not allow copying Swap/move vector and unique_ptr<T[]> have [math]O(1)[/math] time swap and move operations array has [math]O(n)[/math] time swap and move operations, where [math]n[/math] is the number of elements in the array Pointer/reference/iterator invalidation array ensures pointers, references and iterators will never be invalidated while the object is live, even on swap() unique_ptr<T[]> has no iterators; pointers and references are only invalidated by swap() while the object is live. (After swapping, pointers point into to the array that you swapped with, so they're still "valid" in that sense.) vector may invalidate pointers, references and iterators on any reallocation (and provides some guarantees that reallocation can only happen on certain operations). Compatibility with concepts and algorithms array and vector are both Containers unique_ptr<T[]> is not a Container Updated 71w ago â€¢ View Upvotes