Why is everyone asking questions about C, C++ and JavaScript and not about Fortran?
I find I must take quite a different perspective: No, I don't believe that ForTran is dead yet.  Its death has been long predicted, but there has been sufficient niche dependency on it that migrating to something else doesn't seem to have been practical yet. ForTran is a difficult language, because it was first designed before the concepts of programming languages, their syntax and semantics, started to be understood.  This also means that the runtime model it imposes on the designer is crude compared to what has been possible since.  For instance, it can't support recursion, which is a major disadvantage to whole classes of algorithms.  (I don't know if somewhere a version was developed that uses a runtime stack and manages to amend this, but I haven't heard of one.  I once tricked the compiler into accepting it by using 2 mutually recursive subroutines -- a subroutine trying to call itself is considered a syntax error -- and it went into the recursion apparently alright -- but it could never come back out.)  And one of the most fundamental lexical assumptions, that white space delimits words and symbols, is not true in ForTran!  e.g. the loop statement "DO 5 I = 1,15" means exactly the same as DO5I=1,15 .  Big problem: right up to the comma in "1,15", the latter also starts out as a perfectly legal assignment statement using the variable DO5I .  So good compilers don't grow on every bush. And speaking of compilers, there must be a dozen different dialects, each with its own restrictions and modifications. But two more serious omissions: 1 - while it has homogeneous arrays (e.g.  int evens[] = {2,4,6,8,10}; in C++) it doesn't have heterogenous arrays ("records" in Pascal, Ada, and Modula; "structs" in C; "structs" or "classes" in C++; etc).  This is a major obstruction to software engineering.  ForTran programs tend to resort to declaring a separate array for each of what should have been fields in a struct/record/class, and trying to treat them as lying in parallel. 2 - the last time I saw ForTran it had no capacity for runtime heap allocations.  No dynamic memory use.  No pointers.  The last I heard was that if you needed such functionality the most you could do was try to simulate it with large arrays and array indexes.  Likewise with anything needing to use a stack.  Very inefficient and error-prone. Not very good qualifications for a language of the future. BTW, BASIC and Pascal were mentioned (in the same sentence <shudder>).  ForTran is at least safer and more robust than BASIC, and better capable of larger projects.  Pascal is way apart from them both (notably more recent dialects like Object Pascal, that have good string handling, separate compilation, classes etc) and is at once compact, easy to use, equipped with powerful data abstractions, and suited to robust, serious software engineering projects.  Though regrettably it lacks (lacked?) an exception mechanism, one thing that Java in particular does very well. 