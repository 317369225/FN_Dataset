Does the following code in C++ allocate array at run time or at compile time?
Variable-length array is a new feature in C since C99 and optional since C11. It will allocate a memory region on stack during runtime. How can you reserve memory for a structure in compile time without knowing its size? There's no support for VLA in C++ (See the reason in the C++ standard discussion here Why no VLAs in C++0x?, also in these questions Variable length arrays in C++?, Variable length arrays (VLA) in C and C++, Does C++ support Variable Length Arrays?, Why doesn't C++ support dynamic arrays on the stack?). The only way for you is std::vector<>. However gcc and Clang support it as an extension in C++ mode. That means compiling them in strict C++ standard conforming mode won't work. And it doesn't work in other non-supported C++ compilers, too. Why is new int[n] valid when int array[n] is not? Variable-length automatic arrays are allowed in ISO C99, and as an extension GCC accepts them in C90 mode and in C++.  These arrays are declared like any other automatic arrays, but with a length that is not a constant expression.  The storage is allocated at the point of declaration and deallocated when the block scope containing the declaration exits.Using the GNU Compiler Collection (GCC) GCC and C99 allow an array's size to be determined at run time. This extension is not permitted in standard C++. However, Clang supports such variable length arrays in very limited circumstances for compatibility with GNU C and C99 programs: The element type of a variable length array must be a POD   ("plain old data") type, which means that it cannot have any   user-declared constructors or destructors, any base classes, or any   members of non-POD type. All C types are POD types. Variable length arrays cannot be used as the type of a non-type template parameter.Language Compatibility#vla Are variable length arrays an extension in Clang too? 