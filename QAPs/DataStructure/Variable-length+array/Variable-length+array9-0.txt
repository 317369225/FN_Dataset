Why is sizeof() implemented as an operator in C?
sizeof() is implemented as an operator evaluated by the compiler, at least in part, because knowing the size of a data type is implicit to making pointer arithmetic work in C.  Consider the following code: static int base;int *p = &base;int *q = p + 1; If you were to examine the numeric values of p and q, you would find that the numeric value of q is actually 4 greater than that of p, not 1 as the code would suggest. (This is on a typical Unix implementation of C for common architectures like x86 or ARM. Other architectures might give different results.) This is because pointer arithmetic expressions are scaled by the size of the data type the pointer points to. The compiler also needs to know sizes of various elements for the purpose of laying them out in memory, either on the stack in the case of automatic variables, or in the data segment, in the case of static variables. Once you see that the compiler needs to know these sizes, it's not hard to understand why user code might need to know the same sizes, too.  The canonical example is in memory allocation: int *arrayOf64Ints = (int *)malloc(64 * sizeof(int)); Since malloc() operates in terms of bytes, we need to perform the scaling ourselves that the compiler would have if we'd just declared an array of 64 integers. In practice, sizeof() can almost always be evaluated by the compiler at compile time and reduced to a constant.  The sole exception is with variable-length arrays as defined in C99, whose size cannot be evaluated except at runtime. Beware this common trap: int elementCount(int array[]){  return sizeof(array) / sizeof(array[0]);}int main(){  int myArray[42], x, y;  x = sizeof(myArray) / sizeof(myArray[0]);  y = elementCount(myArray);  printf("%d %d\n", x, y);  return 0;} This code prints "42 1" (in a 32-bit environment). Why? Because, in the elementCount() function, the parameter declaration "int array[]" is treated as if it were "int *array".  The expression "sizeof(array)" then returns the size of the pointer, not the size of what it points to.  This is a common violation of secure programming standards; see ARR01-C. Do not apply the sizeof operator to a pointer when taking the size of an array. Hat tip: Karthik Keyan for the A2A. 