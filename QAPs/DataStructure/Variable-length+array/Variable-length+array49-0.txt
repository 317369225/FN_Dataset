What is C99 and C11 in C programming?
These are different standards of C. By different standards I mean New features adopted from other languages Old features that are improved Enhancement on security Standardizing newly launched APIs Let me give you examples. Prior to C99 long long myVar; or // This is a single line comment would have given error. The biggest feature probably in C99 would be variable length array. Try compiling this below before C99 and it will give you error  FILE * concat_fopen (char *s1, char *s2, char *mode) {     char str[strlen (s1) + strlen (s2) + 1];     strcpy (str, s1); strcat (str, s2);     return fopen (str, mode); } but in C99, it jsut works fine. Now similarly C11 also brings some new features in C Security C’s security has always been a matter of concern. Insecure features – such as string manipulation functions that don’t check bounds and file I/O functions that don’t validate their arguments – have been a fertile source of malicious code attacks. This will replace strcat(), strncpy() with strcat_s() and strncpy_s() The nasty and harmful gets() function is now removed from C11. If you have used C99 then you know that it was already deprecated in C99 and now in C11 it is removed completely. Now it is replaced with gets_s() fopen() is also improved in C11. Now fopen() can take another option for   create-and -open which is equivalent to POSIX O_CREAT | O_EXCL flags it means wx create text file for writing with exclusive access wbx create binary file for writing with exclusive access w+x create text file for update with exclusive access w+bx or wb+x create binary file for update with exclusive access Additionally a safer version fopen_s() is also available Features The _Noreturn function Specifier _Noreturn declares a function that does not return. This new functions specifier has two purposes: suppressing compiler warnings on a function that doesn’t return, and enabling certain optimizations that are allowed only on functions that don’t return. _Noreturn void func (); //C11, func never returns Type-Generic Functions C11 doesn’t have templates yet but it does have a macro-based method of defining type-generic functions. The new keyword _Generic declares a generic expression that translates into type-dependent “specializations.” In the following example, the generic cubic root calculation macro cbrt(x) evaluates to the specializations cbrtl(long double), cbrtf(float) and the default cbrt(double), depending on the actual type of the parameter x: //C11 only #define cbrt(X) _Generic((X), long double: cbrtl,                                default: cbrt,                                 float: cbrtf)(X) Finer control over Threads. Now you don't need to depend on POSIX pthreads to manipulate with threads. You have C11 specific threads like in C++11 defined in headers like <threads.h>. Creating truly atomic objects is also very easy now using <stdatomic.h> In Conclusion C11 attempts to fix what was broken in C99. It makes some of the mandatory features of C99 (variable length arrays, complex types and more) optional, and introduces new features that were already available in various implementations. Not less important, C11 designers worked closely with the C++ standards committee to ensure that the two languages should remain compatible as much as possible. Chances are good that unlike its predecessor, C11 will receive a warm reception. As a bonus, software written in C11 will be more robust against security loopholes and malware attacks. 