What are sort and search algorithms?Sort and search algorithms are exactly and intuitively what they say they are. There are a bunch of different sorting algorithms: insertion sort, merge sort, bubble sort etc. They essentially sort a potentially unordered series of elements (e.g. as in a list) in some notion of order (e.g. alphabetically, numerical, or some arbitrary definition of another type of ordering). For example, as an example in rough ocaml-style pseudocode: rec sorter (x : integer list) : integer list =  if x = [], then []  else if x = element1::element2::rest_of_list,  then if element1 <= element2, element1::sorter(element2::rest_of_list)  else element2::sorter(element1::rest_of_list) The above is actually one iteration of bubble sort (where the largest number in a given iteration 'bubbles' out to the end). As you can see, this is *not* efficient, as you'd need to make several passes to ensure the list is fully sorted. More efficient sorting algorithms can be accomplished with for example binary heaps. As for searching, you've probably heard of binary search. This works if something is already sorted. As rough pseudo-python style pseudocode with a recursive function: rec binary_search (x : integer list) (n : element): bool  if x[middle_of_list] = n then true  else if x[middle_of_list] < n then binary_search(firsthalfof_x)(n)  else binary_search(secondhalfof_x)(n) There are other search algorithms as well. Almost any good algorithm is based on the idea of 'divide-and-conquer'. You could also naively search through each element of an array or list or other such data structure and check whether the element is the element of interest, . 