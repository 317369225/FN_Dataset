How is the fuzzy search algorithm in Sublime Text designed?The fuzzy search functionality in Sublime Text is truly amazing. How is it designed or how would you design something similar? (Preferably in JavaScript)There's actually a shortcut to a pretty good approximation. I unfortunately don't remember who to credit, but I saw this mentioned in a similar discussion and thought it was a neat solution. Split your query into characters, join them with a regex wildcard, and then run the regex on your set of strings. 1234 # python for string in strings_to_search:  if re.search(".*?".join(query), string):  pick(string) Or if you like golf... 1 matches = [s for s in strings_to_search if re.search(".*?".join(query), s)] If you disable backtracking, a search across n strings with query length k should run in O(nk) time (perhaps depending on the regex engine). That doesn't help with highlighting the matches, but for that you can: observe that regex matching is deterministic, so regex-replace on the result set to insert some formatting; or write a very simple regex parser to do custom stuff. Since the only operators are the . and *, you can do it with a DFA. Actually, let's have that custom parser. (Live demo here.)  1 2 3 4 5 6 7 8 910111213141516171819202122232425262728293031323334353637383940414243444546474849 // I've neither proven this correct nor tested it extensively. Beware. // ...but at least it's in JavaScript? function fuzzyMatch(searchSet, query) {  var tokens = query.toLowerCase().split(''),  matches = [];  searchSet.forEach(function(string) {  var tokenIndex = 0,  stringIndex = 0,  matchWithHighlights = '',  matchedPositions = [];  string = string.toLowerCase();  while (stringIndex < string.length) {  if (string[stringIndex] === tokens[tokenIndex]) {  matchWithHighlights += highlight(string[stringIndex]);  matchedPositions.push(stringIndex);  tokenIndex++;  if (tokenIndex >= tokens.length) {  matches.push({  match: string,  highlighted: matchWithHighlights + string.slice(  stringIndex + 1  ),  // Maybe use this to weight matches?  // More consecutive numbers = higher score?  positions: matchedPositions  });  break;  }  }  else {  matchWithHighlights += string[stringIndex];  }  stringIndex++;  }  });  return matches; } function highlight(string) {  return '<span class="highlight">' + string + '</span>'; } 