★Computational Complexity Theory: What's the meaning and significance of P ≠ NP?
I'm not entirely satisfied with the existing answers, so I'll have a go at it.  See the end for tech notes. P (standing for "polynomial time") is, roughly, the class of problems which can be solved efficiently by a computer.  NP (standing for "nondeterministic polynomial time") is, roughly, the class of problems for which a purported solution can be checked efficiently.  So the question P ?= NP means, roughly, if a computer can easily check the solution to a problem, can it also find a solution efficiently?  Of course, any problem in P is in NP: if you can solve the problem yourself, just do that and compare the answers.  So, some NP problems are easy. Sudoku is a good example of an NP problem.  It's easy to check the solution to a Sudoku puzzle.  Even if the grid were 100x100 or 10000x10000, a computer could easily check that each number is between 1 and 9/100/10000, and that each number appears exactly once in each row, column and box.  But is it possible to write a computer program which will solve any Sudoku problem, even for a large grid? You can tell something about the answer here using something called "NP-hardness".  If a problem is NP-hard, then in some sense it's at least as hard as any problem in NP.  This is true of Sudoku, for example: it's possible (for a computer) to turn any NP puzzle into a (very large) Sudoku puzzle, so if you can solve Sudoku, you can solve anything.  In other words, if P != NP, then nobody can write a program which quickly solves any large Sudoku puzzle.  A problem like Sudoku which is in NP and is also NP-hard is called "NP-complete". There are many relevant examples of NP problems.  Planning travel routes, packing shipping crates, folding proteins, breaking cryptography, compressing data, almost every problem in artificial intelligence, most problems in design... all these are in (some variant of) NP, and many of them are NP-complete. If P = NP, then computers can solve all these problems efficiently.  P != NP is decidedly less exciting: it means that we can't hope for a fast general problem-solving program.  This is the expected result, and it changes the world less than P = NP.  But computer scientists hope that the techniques used to prove that P != NP will greatly advance our understanding of the field.  Also, cryptographers hope to eventually prove that certain encryption algorithms are unbreakable. OK, now some technical notes.  First up, the "P" and "NP" that I described above are actually closer to classes called FP and FNP, but FP ?= FNP is more or less equivalent to P ?= NP.  Also, "polynomial time" doesn't necessarily mean "fast" or even "feasible": an algorithm taking N^100 steps becomes impossible at N=2.  However, "feasible" requires a lot more (complicated) assumptions about how fast the computer is, how much memory it has, what instructions it can carry out, etc, so most computer scientists think about polynomial time instead. Finally, note that all this applies only to deterministic algorithms which solve all instances of a problem on a conventional computer.  It may be (but probably isn't) the case that even if P != NP, you could solve every NP problem using a randomized algorithm, an algorithm which solves almost every instance, and/or an algorithm that uses quantum computers.    Embed Quote 