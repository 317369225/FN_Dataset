★What are P, NP, NP-complete, and NP-hard?
To solve the above recurrence relation, you just have to use Master theorem. You can see that a = 4, b = 4, f(n) = nlogn = (n^c)(log^k n), where c = k = 1 log a to base b = log4 to base 4 = 1 = c So its case 2 of Master theorem, which gives T(n) =  Θ(n^c)(log^k+1 n) = Θ(n^1)(log^2 n) = Θ(n log^2 n) To understand NP Complete and NP Hard classes, you need to have a basic understanding of a couple of things. A   decision problem is a problem that you can always answer either "yes"   or "no". For example, "Do you have a brother?". You can always answer   "yes" or "no" for such questions. Such problems are what we call   decision problems. A deterministic Turing machine is the machine   that we are used to normally. A computer is a deterministic Turing   machine. A non-deterministic Turing machine is a machine that comes  with  unlimited parallelism. For example, if you come to a fork on a  road,  you can either take the left road or the right road. That is how   deterministic Turing machine operates. But since non-deterministic   Turing machine has unlimited parallelism, it can take both the roads.   Its similar to running multiple threads on a computer.  Non-deterministic  Turing machines cannot be realized in practice. A decision problem is in class P,  if we can solve the problem in polynomial time using a deterministic  Turing machine. It  means that we can solve the problem very quickly. It  shall finish the  problem in some time n^k, where k is some constant.  For example, finding  the max element in an array, checking whether a  string is palindrome or  not, checking whether a number is prime or not,  and so on. A decision problem  is in class NP, if we can  solve it in polynomial time using a  non-deterministic Turing machine to  get the answer "yes" to your  problem. (The answer "no" is considered  to be in co-NP class). That  means that we cannot solve the problem in polynomial time using a deterministic Turing machine. But we can always check whether our solution is  right in polynomial time. So if someone gives  you an NP problem and  the answer as "yes", we can check whether the  answer is right or not in  polynomial time. But keep in mind that we  cannot find the answer in  polynomial time (only check whether an answer  is right). A problem X is in NP-Complete if we can prove that it’s in NP and that we can reduce a known NP  problem Y to X in polynomial time, i.e., we can quickly solve Y  if we  know how to quickly solve X. It means that if anyone finds out a  polynomial time solution to any NP-Complete problem, then every NP  problem can be solved in polynomial time. This shall prove that P = NP.  Eg: 3-SAT (conjunction of 3-clause disjunctions), Minesweeper problem.  Every NP problem can be reduced to 3-SAT problem (Cook’s Theorem) A problem is in NP-Hard if and only if its “atleast as” hard as an NP problem. The formal  definition is that a problem X is in NP-Hard if there is an NP-Complete  problem Y such that Y can be reduced to X in polynomial time. But since  any NP-Complete problem can be reduced to any other NP-Complete problem  in polynomial time, all NP-Complete problems can be reduced to any  NP-Hard problem in polynomial time. So if there is solution for one  NP-Hard problem in polynomial time, there is a solution for all NP  problems in polynomial time. NP-Complete problems are also NP hard. Also  NP-Hard problems may not be in NP, meaning that they may not have  solutions that can be verified in polynomial time. Eg: Halting problem  (given a program P and input I, will it halt? It is not in NP),  optimization version of TSP (we need to find an actual schedule; harder  than decision version of TSP). NP-Hard problems may not be decision  problem    Embed Quote