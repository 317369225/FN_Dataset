★How is genetic algorithm used to solve the N-Queens problem?I read about genetic algorithm in Artificial Intelligence-A modern approach book I could get an idea of what it does.But i didnt understand how it is implement in N-Queens problem. Can someone help ??
Generate  a population 'P' of strings with 'N' row positions, row position  generated randomly for each column, representing a configuration of  queens on the board. For example for a board of size 9x9, '6 3 1 9 7 4 8 5 2' is a string of size '9' belonging to population 'P'. Create 'P'  such strings. Now, we have an initial population Pi. Pick 2 strings x and y randomly from Pi and apply crossover to them. While randomly picking x and y note that the likely hood of x or y getting picked is directly proportional to the value of it's fitness. Apply crossover to x and y and generate one new string S. With a small probability apply mutation to string S otherwise leave it as it is. Apply steps 2 to 5 until a new population Pn is generated with 'P' strings. Pn acts as Pi for the next iteration through steps 2 to 5. Repeat steps 2 to 6 until a solution string (sting with maximum fitness value) representing a ccorrect board configuration is obtained. For eg. '1 4 6 8 2 5 3 9 7' or '6 3 1 8 5 2 9 7 4'. If a solution has not been found for a long time return a string with maximum fitness value amongst the generated strings. Remember that Genetic algorithms may not just only be unsuccessful in finding a correct solution but they may take a long time under huge values of 'N'. Values above 10 for 'N' may be astronomical for the code given below. Here's the python code:  1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
 import math; import random; from bitarray import bitarray; import sys; mutate_prob = 0.05            # Small probability with which mutation will occur. class Population(object):     population_list = []    # List of individuals: binary strings which represent tentative solutions.     fitness_list = []        # List of the fitness values of each individual in the population.     pop_size = 0            # Population Size.     board_size = 0            # Size of problem. 'N' in N-Queen.     pos_bits_size = 0        # Number of bits required to represent each vertical position.     indv_size = 0            # The total size of an 'induvidual' binary string.     def __init__(self, pop_size, board_size):         self.pop_size = pop_size         self.board_size = board_size         self.population_list = []         self.pos_bits_size = int(math.ceil(math.log(board_size-1))) + 1         self.indv_size = board_size * self.pos_bits_size     def genPopulation(self):         """Generates a population of bitarray strings (individuals) to solve the N-Queen problem, here N = 'board_size'.            'pop_size' parameter decides the number of bitarray strings (individuals) generated by this function.            Creates a list of bitarrray strings (individuals) representing the population for solving the N-Queen problem.            'population_list' parameter holds the list of generated individuals."""         self.population_list = []         for i in xrange(0, self.pop_size):             individual = bitarray(self.indv_size)             # Loop for randomizing the 'individual' string.             for j in xrange(0, self.board_size):                 vert_pos = random.randint(0, self.board_size-1)                 vert_pos_bitnum = toBitArray(vert_pos, self.pos_bits_size)                 # print "\t\t", j, vert_pos_bitnum, vert_pos                 for k in range(0, self.pos_bits_size):                     individual[j * self.pos_bits_size + k] = vert_pos_bitnum[k]             self.population_list.append(individual)             # print "\t", i, individual     def computeFitnessList(self,fitnessFunction):         """Populates the fitness list with fitness function values of co-responding entries in the population list."""         self.fitness_list = []         cmlsum = 0         for individual in self.population_list:             cmlsum = cmlsum + fitnessFunction(individual, self.board_size, self.pos_bits_size)             self.fitness_list.append(cmlsum)... (more)Loading...