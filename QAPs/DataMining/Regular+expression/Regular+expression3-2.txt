★How does 'grep' preprocess a text file for efficient regular expression matching?
GREP: As the name is an abbreviation of Global Regular Expression Parser . Regular expression parsing has established algorithms and as such it does not require to preprocess a text file beforehand(more about this in a short while). Initially it was written by Ken Thompson for unix machines.   Now the algorithm at high level. 1. Take the regular expression 2. Convert it into equivalent NFA (Non deterministic finite automata) 3. Convert the NFA to equivalent DFA (Deterministic Finite Automata) 4.Reduce the number of states in DFA(although this step is optional and is required to reduce the space complexity) 4.Iterate over this DFA consuming the input characters one by one. 5.If the last input character is consumed and the resulting state in DFA is one of the final states, the match is found.   This is it, this is all you need to know to implement a regular expression parser.   Now in detail each step.   1. Take the regular expression: This step is trivial and is self explanatory. However some implementations of RegEX parser , do a preprocessing in this step. Suppose the regular expression is aabb* , which means the regular expression is actually a concatenated to a concatenated to b concatenated to any number of times of b. To make the concatenations operator obvious some implementations insert a character here say ascii 0x5 etc   2. Convert it into equivalent NFA :  An NFA is a non-deterministic finite state machine.   To understand what is and NFA we first will understand what is a DFA (Deterministic finite automata)   Formally DFA is defined by the quintuple D=(Q,A,d,Q0,F). Where     Q is a set of internal states     A is a finite set of input alphabets     d is the transition function defined as Q X A-->Q , it takes an input symbol (say a)and  a state (say q1) and transitions to next state (say q2).    Q0 is the start state and belongs to the set Q    F is a set of final states.   The only difference between DFA and NFA is the non-determinism in the transition function d .   The transition function of NFA  maps the set of internal states to subset of internal states. i.e d : Q X A union (empty string)-->subset (Q). So in a DFA for each input symbol the machine can transition to maximum one and only one state , whereas in an NFA the machine can transition to a set of states (and even empty input is accepted).   Ok now enough with the theory.   Coming back to the real crux of this step , how to convert regular expression into an NFA, we use Thompson’s algorithm  here  For some reason i cannot insert the pictures here, so here is whole algorithm on wiki page Thompson's construction algorithm   An NFA/DFA can be implemented in computer language as by the data structure ,NFA table stored as doubly ended queue of state objects.     3.Convert the NFA to equivalent DFA.  A very nice explanation can be found here , Algorithm: NFA -> DFA   4.Reduce the number of states in DFA. this step is optional and is to remove the redundant states of DFA. And  in the original implementation of grep , Thompson did not do this to save the overhead (can’t find the source now, will update the answer later).   5.Iterate over the DFA and consume each input symbol one by one transitioning from one state to another , if the input symbol makes the machine to transition to a final state, a match is found.     This is how regular expression parsers work in general , and grep also works more or less like this.    Embed Quote