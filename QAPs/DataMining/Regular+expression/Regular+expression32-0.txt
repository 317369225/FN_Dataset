★What is wrong with the listed regular expression for use with an IP address?
Some remarks : Your regular expression will work only with IPv4, with the dot-decimal notation (1) As Lee Byron pointed out, it will allow IP addresses like 999.999.999.999, which is invalid. You should use regular expression litterals, to avoid double-escaping, and this is (I think) simpler to write. Instead of writing this: var r = new RegExp ( "my\\.regex" , "gi" ); you can write this: var r = /my\.regex/gi ; Note that you’ll need to escape slashes, and it doesn’t allow you to create dynamic regular expressions (as in new RegExp ( "foo" + bar , flags )). You don’t need to use the exec method when you only want to check if a regular expression matches a string, it’s more efficient to use the test method, which returns true or false. You seem to want to write a unique function to validate inputs based on a given regular expression. Here is a rewritten version using regular expression litterals, and an object to store regular expressions:  1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
 var regexes = {     // Here we store the regular expressions     // Your regular expression     ip : /[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/gi }; function validInput(userInput, inputType) {     // If there’s no regular expression for this input type, that is, there’s     // no inputType’s value key in the 'regexes' object.     if (!(inputType in regexes)) {         return false;     }     return regexes[inputType].test(userInput); } Then, you’ll call the function like this: 1
2
3
 var badIPIsValid = validInput("999.999.999.999", "ip"); alert(badIPIsValid); // true (for now) Now let’s look at the regular expression: As Evan Priestley pointed out, it’s better to use \ d instead of [ 0 - 9 ]: /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/gi Here, it’s useless to have the "i" flag, since we use numbers, and the "g" flag, since we’re validating one IP address. So we can strip them: /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/ The regular expression also works for strings like "phone number : 1.456.789.0 :)", because we’re just testing if the regular expression can match a part of the string, but not the whole string. So let’s add a caret ( ^) at the beginning, to match the beginning of the string, and a dollar sign ( $) at the end to match the end of the string: /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/ We still have the "999.999.999.999" problem. I think the easiest way to do it is to use Lee Byron’s function, but let’s try to use a regular expression. The first challenge is to make a regular expression which match only positive integers under 256. Here is one: /^(?:(?:0|1)?\d{1,2}|2(?:[0-4]\d|5[0-5]))$/ It matches numbers that begins with a 0 or 1 followed by one or two digits, or numbers with only one or two digits, or numbers that begins with a 2 and followed either by a number between 0 and 4 (included) and a digit, or by a 5 followed by a number between 0 and 5. Now it’s easy, we have to use the regular expression four times: /^(?:(?:0|1)?\d{1,2}|2(?:[0-4]\d|5[0-5]))\.(?:(?:0|1)?\d{1,2}|2(?:[0-4]\d|5[0-5]))\.(?:(?:0|1)?\d{1,2}|2(?:[0-4]\d|5[0-5]))\.(?:(?:0|1)?\d{1,2}|2(?:[0-4]\d|5[0-5]))$/ Optionally, you can shorten the regular expression: /^(?:(?:(?:0|1)?\d{1,2}|2(?:[0-4]\d|5[0-5]))\.){3}(?:(?:0|1)?\d{1,2}|2(?:[0-4]\d|5[0-5]))$/ So here we are, here is the full code:  1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
 var regexes = {     // Here we store the regular expressions     // Your regular expression     ip : /^(?:(?:(?:0|1)?\d{1,2}|2(?:[0-4]\d|5[0-5]))\.){3}(?:(?:0|1)?\d{1,2}|2(?:[0-4]\d|5[0-5]))$/ }; function validInput(userInput, inputType) {     // If there’s no regular expression for this input type, that is, there’s     // no inputType’s value key in the 'regexes' object.     if (!(inputType in regexes)) {         return false;     }     // .test is more efficient than .match when you just     // want to test if a regular expression matches a string.     return regexes[inputType].test(userInput); } You can also shorten the validInput function: 1
2
3
 function validInput(userInput, inputType) {     return ((inputType in regexes) && regexes[inputType].test(userInput)); } Using the valid address tables shown at [1], we can prove our implementation with a series of tests:  1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
 var valid, isValidIPv4; valid = {   yes: [     "0.0.0.0", "10.0.0.0", "100.64.0.0", "127.0.0.0", "169.254.0.0",     "172.16.0.0", "192.0.0.0", "192.0.2.0", "192.88.99.0", "192.168.0.0",     "198.18.0.0", "198.51.100.0", "203.0.113.0", "224.0.0.0", "240.0.0.0",     "255.255.255.255"   ],   no: [     "999.999.999.999", 0, "", null, undefined, NaN, "string", [], {}, true, 1   ] }; isValidIPv4 = function( value ) {   return validInput( value, "ip" ); }; Object.keys(valid).forEach(function( type, k ) {   var expect = type === "yes" ? true : false;   console.log(     valid[ type ].filter(function( value ) {       var result = isValidIPv4(value);       if ( isValidIPv4(value) === expect ) {         // If the test passes, it's filtered from the list         return false;       }       console.log( "TEST FAILED", value );       return true;     }).length === 0 ? "PASS" : "FAIL"   ); }); // The expected output should be: "PASS" "PASS" Notes: [1] : There are others notations, cf: http://en.wikipedia.org/wiki/IPv...    Embed Quote