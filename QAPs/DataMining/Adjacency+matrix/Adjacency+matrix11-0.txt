★What is the fastest algorithm to find whether a string can be converted to desired string in exactly k steps, using adjacency matrix?
Yes, Floyd Warshall can be used to solve this problem. First check if the lengths of the two strings are different. If the lengths are different the answer will "NO" trivially. If they are same, we will use Floyd Warshall to calculate all the letter changes that are possible. Floyd Warshall finds all the paths that exist between any two nodes. So if a vertex k is reachable from i and j is reachable from k, that means j is reachable from i. So the code below will make all adj[i][j] true, if it is possible to reach j from i. This means that if A -> B and B -> C it means A -> C, if adj[A][B] == true and adj[B][C] == true then we will make adj[A][C] = true. 1
2
3
4
 for (int i = 0; i < 26; i++)    for (int j = 0; j < 26; j++)       for (int k = 0; k < 26; k++)          if (adj[i][k] and adj[k][j]) adj[i][j] = true; After we are done, we can just iterate over one string and check if each letter of that string can be converted to the letter in the other string in the same position in O(1) by just checking whether adj[string_one[i]][string_two[i]] == true This will not take care of the case when both letters are same, so you will have to check that case separately. This code will run in where k is the length of the string.    Embed Quote