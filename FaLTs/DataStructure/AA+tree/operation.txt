As in most balanced binary trees, the deletion of an internal node can be turned into the deletion of a leaf node by swapping the internal node with either its closest predecessor or successor, depending on which are in the tree or on the implementor's whims. Retrieving a predecessor is simply a matter of following one left link and then all of the remaining right links. Similarly, the successor can be found by going right once and left until a null pointer is found. Because of the AA property of all nodes of level greater than one having two children, the successor or predecessor node will be in level 1, making their removal trivial.
To re-balance a tree, there are a few approaches. The one described by Andersson in his original paper is the simplest, and it is described here, although actual implementations may opt for a more optimized approach. After a removal, the first step to maintaining tree validity is to lower the level of any nodes whose children are two levels below them, or who are missing children. Then, the entire level must be skewed and split. This approach was favored, because when laid down conceptually, it has three easily understood separate steps:
Decrease the level, if appropriate. Skew the level. Split the level.
However, we have to skew and split the entire level this time instead of just a node, complicating our code.
function delete is
    input: X, the value to delete, and T, the root of the tree from which it should be deleted.
    output: T, balanced, without the value X.
   
    if nil(T) then
        return T
    else if X > value(T) then
        right(T) := delete(X, right(T))
    else if X < value(T) then
        left(T) := delete(X, left(T))
    else
        If we're a leaf, easy, otherwise reduce to leaf case. 
        if leaf(T) then
            return Nil
        else if nil(left(T)) then
            L := successor(T)
            right(T) := delete(L, right(T))
            value(T) := L
        else
            L := predecessor(T)
            left(T) := delete(L, left(T))
            value(T) := L
        end if
    end if

    Rebalance the tree. Decrease the level of all nodes in this level if
    necessary, and then skew and split all nodes in the new level.
    T := decrease_level(T)
    T := skew(T)
    right(T) := skew(right(T))
    right(right(T)) := skew(right(right(T)))
    T := split(T)
    right(T) := split(right(T))
    return T
end function
function decrease_level is
    input: T, a tree for which we want to remove links that skip levels.
    output: T with its level decreased.

    should_be = min(level(left(T)), level(right(T))) + 1
    if should_be < level(T) then
        level(T) := should_be
        if should_be < level(right(T)) then
            level(right(T)) := should_be
        end if
    end if
    return T
end function
A good example of deletion by this algorithm is present in the Andersson paper.
Insertion begins with the normal binary tree search and insertion procedure. Then, as the call stack unwinds (assuming a recursive implementation of the search), it's easy to check the validity of the tree and perform any rotations as necessary. If a horizontal left link arises, a skew will be performed, and if two horizontal right links arise, a split will be performed, possibly incrementing the level of the new root node of the current subtree. Note, in the code as given above, the increment of level(T). This makes it necessary to continue checking the validity of the tree as the modifications bubble up from the leaves.
function insert is
    input: X, the value to be inserted, and T, the root of the tree to insert it into.
    output: A balanced version T including X.

    Do the normal binary tree insertion procedure. Set the result of the
    recursive call to the correct child in case a new node was created or the
    root of the subtree changes.
    if nil(T) then
        Create a new leaf node with X.
        return node(X, 1, Nil, Nil)
    else if X < value(T) then
        left(T) := insert(X, left(T))
    else if X > value(T) then
        right(T) := insert(X, right(T))
    end if
    Note that the case of X == value(T) is unspecified. As given, an insert
    will have no effect. The implementor may desire different behavior.

    Perform skew and then split. The conditionals that determine whether or
    not a rotation will occur or not are inside of the procedures, as given
    above.
    T := skew(T)
    T := split(T)

    return T
end function
As in most balanced binary trees, the deletion of an internal node can be turned into the deletion of a leaf node by swapping the internal node with either its closest predecessor or successor, depending on which are in the tree or on the implementor's whims. Retrieving a predecessor is simply a matter of following one left link and then all of the remaining right links. Similarly, the successor can be found by going right once and left until a null pointer is found. Because of the AA property of all nodes of level greater than one having two children, the successor or predecessor node will be in level 1, making their removal trivial.
To re-balance a tree, there are a few approaches. The one described by Andersson in his original paper is the simplest, and it is described here, although actual implementations may opt for a more optimized approach. After a removal, the first step to maintaining tree validity is to lower the level of any nodes whose children are two levels below them, or who are missing children. Then, the entire level must be skewed and split. This approach was favored, because when laid down conceptually, it has three easily understood separate steps:
Decrease the level, if appropriate. Skew the level. Split the level.
However, we have to skew and split the entire level this time instead of just a node, complicating our code.
function delete is
    input: X, the value to delete, and T, the root of the tree from which it should be deleted.
    output: T, balanced, without the value X.
   
    if nil(T) then
        return T
    else if X > value(T) then
        right(T) := delete(X, right(T))
    else if X < value(T) then
        left(T) := delete(X, left(T))
    else
        If we're a leaf, easy, otherwise reduce to leaf case. 
        if leaf(T) then
            return Nil
        else if nil(left(T)) then
            L := successor(T)
            right(T) := delete(L, right(T))
            value(T) := L
        else
            L := predecessor(T)
            left(T) := delete(L, left(T))
            value(T) := L
        end if
    end if

    Rebalance the tree. Decrease the level of all nodes in this level if
    necessary, and then skew and split all nodes in the new level.
    T := decrease_level(T)
    T := skew(T)
    right(T) := skew(right(T))
    right(right(T)) := skew(right(right(T)))
    T := split(T)
    right(T) := split(right(T))
    return T
end function
function decrease_level is
    input: T, a tree for which we want to remove links that skip levels.
    output: T with its level decreased.

    should_be = min(level(left(T)), level(right(T))) + 1
    if should_be < level(T) then
        level(T) := should_be
        if should_be < level(right(T)) then
            level(right(T)) := should_be
        end if
    end if
    return T
end function
A good example of deletion by this algorithm is present in the Andersson paper.
Insertion begins with the normal binary tree search and insertion procedure. Then, as the call stack unwinds (assuming a recursive implementation of the search), it's easy to check the validity of the tree and perform any rotations as necessary. If a horizontal left link arises, a skew will be performed, and if two horizontal right links arise, a split will be performed, possibly incrementing the level of the new root node of the current subtree. Note, in the code as given above, the increment of level(T). This makes it necessary to continue checking the validity of the tree as the modifications bubble up from the leaves.
function insert is
    input: X, the value to be inserted, and T, the root of the tree to insert it into.
    output: A balanced version T including X.

    Do the normal binary tree insertion procedure. Set the result of the
    recursive call to the correct child in case a new node was created or the
    root of the subtree changes.
    if nil(T) then
        Create a new leaf node with X.
        return node(X, 1, Nil, Nil)
    else if X < value(T) then
        left(T) := insert(X, left(T))
    else if X > value(T) then
        right(T) := insert(X, right(T))
    end if
    Note that the case of X == value(T) is unspecified. As given, an insert
    will have no effect. The implementor may desire different behavior.

    Perform skew and then split. The conditionals that determine whether or
    not a rotation will occur or not are inside of the procedures, as given
    above.
    T := skew(T)
    T := split(T)

    return T
end function
If the node is a leaf or has only one child, remove it. Otherwise, replace it with either the largest in its left sub tree (in order predecessor) or the smallest in its right sub tree (in order successor), and remove that node. The node that was found as a replacement has at most one sub tree. After deletion, retrace the path back up the tree (parent of the replacement) to the root, adjusting the balance factors as needed.
As with all binary trees, a node's in-order successor is the left-most child of its right subtree, and a node's in-order predecessor is the right-most child of its left subtree. In either case, this node will have zero or one children. Delete it according to one of the two simpler cases above.

In addition to the balancing described above for insertions, if the balance factor for the tree is 2 and that of the left subtree is 0, a right rotation must be performed on P. The mirror of this case is also necessary.
The retracing can stop if the balance factor becomes ï¿½? or +1 indicating that the height of that subtree has remained unchanged. If the balance factor becomes 0 then the height of the subtree has decreased by one and the retracing needs to continue. If the balance factor becomes ï¿½? or +2 then the subtree is unbalanced and needs to be rotated to fix it. If the rotation leaves the subtree's balance factor at 0 then the retracing towards the root must continue since the height of this subtree has decreased by one. This is in contrast to an insertion where a rotation resulting in a balance factor of 0 indicated that the subtree's height has remained unchanged.
The time required is O(log n) for lookup, plus a maximum of O(log n) rotations on the way back to the root, so the operation can be completed in O(log n) time.
Pictorial description of how rotations cause rebalancing tree, and then retracing one's steps toward the root updating the balance factor of the nodes. The numbered circles represent the nodes being balanced. The lettered triangles represent subtrees which are themselves balanced BSTs
After inserting a node, it is necessary to check each of the node's ancestors for consistency with the rules of AVL. The balance factor is calculated as follows: balanceFactor = height(left-subtree) - height(right-subtree). For each node checked, if the balance factor remains ï¿½?, 0, or +1 then no rotations are necessary. However, if balance factor becomes less than -1 or greater than +1, the subtree rooted at this node is unbalanced. If insertions are performed serially, after each insertion, at most one of the following cases needs to be resolved to restore the entire tree to the rules of AVL.
There are four cases which need to be considered, of which two are symmetric to the other two. Let P be the root of the unbalanced subtree, with R and L denoting the right and left children of P respectively.
Right-Right case and Right-Left case:
If the balance factor of P is -2 then the right subtree outweighs the left subtree of the given node, and the balance factor of the right child (R) must be checked. The left rotation with P as the root is necessary. If the balance factor of R is -1 (or in case of deletion also 0), a single left rotation (with P as the root) is needed (Right-Right case). If the balance factor of R is +1, two different rotations are needed. The first rotation is a right rotation with R as the root. The second is a left rotation with P as the root (Right-Left case).
Left-Left case and Left-Right case:
If the balance factor of P is 2, then the left subtree outweighs the right subtree of the given node, and the balance factor of the left child (L) must be checked. The right rotation with P as the root is necessary. If the balance factor of L is +1 (or in case of deletion also 0), a single right rotation (with P as the root) is needed (Left-Left case). If the balance factor of L is -1, two different rotations are needed. The first rotation is a left rotation with L as the root. The second is a right rotation with P as the root (Left-Right case).
Tree rotations
Basic operations of an AVL tree involve carrying out the same actions as would be carried out on an unbalanced binary search tree, but modifications are preceded or followed by one or more operations called tree rotations, which help to restore the height balance of the subtrees.
Insertion begins by adding the node as any binary search tree insertion does and by coloring it red. Whereas in the binary search tree, we always add a leaf, in the redâblack tree leaves contain no information, so instead we add a red interior node, with two black leaves, in place of an existing black leaf.
What happens next depends on the color of other nearby nodes. The term uncle node will be used to refer to the sibling of a node's parent, as in human family trees. Note that:
property 3 (all leaves are black) always holds. property 4 (both children of every red node are black) is threatened only by adding a red node, repainting a black node red, or a rotation. property 5 (all paths from any given node to its leaf nodes contain the same number of black nodes) is threatened only by adding a black node, repainting a red node black (or vice versa), or a rotation.
Note: The label N will be used to denote the current node (colored red). At the beginning, this is the new node being inserted, but the entire procedure may also be applied recursively to other nodes (see case 3). P will denote N's parent node, G will denote N's grandparent, and U will denote N's uncle. Note that in between some cases, the roles and labels of the nodes are exchanged, but in each case, every label continues to represent the same node it represented at the beginning of the case. Any color shown in the diagram is either assumed in its case or implied by those assumptions.
Each case will be demonstrated with example C code. The uncle and grandparent nodes can be found by these functions:
struct node *grandparent(struct node *n)
{
        if ((n != NULL) && (n->parent != NULL))
                return n->parent->parent;
        else
                return NULL;
}
 
struct node *uncle(struct node *n)
{
        struct node *g = grandparent(n);
        if (g == NULL)
                return NULL; // No grandparent means no uncle
        if (n->parent == g->left)
                return g->right;
        else
                return g->left;
}
Case 1: The current node N is at the root of the tree. In this case, it is repainted black to satisfy property 2 (the root is black). Since this adds one black node to every path at once, property 5 (all paths from any given node to its leaf nodes contain the same number of black nodes) is not violated.
void insert_case1(struct node *n)
{
        if (n->parent == NULL)
                n->color = BLACK;
        else
                insert_case2(n);
}
Case 2: The current node's parent P is black, so property 4 (both children of every red node are black) is not invalidated. In this case, the tree is still valid. property 5 (all paths from any given node to its leaf nodes contain the same number of black nodes) is not threatened, because the current node N has two black leaf children, but because N is red, the paths through each of its children have the same number of black nodes as the path through the leaf it replaced, which was black, and so this property remains satisfied.
void insert_case2(struct node *n)
{
        if (n->parent->color == BLACK)
                return; /* Tree is still valid */
        else
                insert_case3(n);
}
Note: In the following cases it can be assumed that N has a grandparent node G, because its parent P is red, and if it were the root, it would be black. Thus, N also has an uncle node U, although it may be a leaf in cases 4 and 5.
Case 3: If both the parent P and the uncle U are red, then both of them can be repainted black and the grandparent G becomes red (to maintain property 5 (all paths from any given node to its leaf nodes contain the same number of black nodes)). Now, the current red node N has a black parent. Since any path through the parent or uncle must pass through the grandparent, the number of black nodes on these paths has not changed. However, the grandparent G may now violate properties 2 (The root is black) or 4 (Both children of every red node are black) (property 4 possibly being violated since G may have a red parent). To fix this, the entire procedure is recursively performed on G from case 1. Note that this is a tail-recursive call, so it could be rewritten as a loop; since this is the only loop, and any rotations occur after this loop, this proves that a constant number of rotations occur.
void insert_case3(struct node *n)
{
        struct node *u = uncle(n), *g;
 
        if ((u != NULL) && (u->color == RED)) {
                n->parent->color = BLACK;
                u->color = BLACK;
                g = grandparent(n);
                g->color = RED;
                insert_case1(g);
        } else {
                insert_case4(n);
        }
}
Note: In the remaining cases, it is assumed that the parent node P is the left child of its parent. If it is the right child, left and right should be reversed throughout cases 4 and 5. The code samples take care of this.
Case 4: The parent P is red but the uncle U is black; also, the current node N is the right child of P, and P in turn is the left child of its parent G. In this case, a left rotation that switches the roles of the current node N and its parent P can be performed; then, the former parent node P is dealt with using case 5 (relabeling N and P) because property 4 (both children of every red node are black) is still violated. The rotation causes some paths (those in the sub-tree labelled "1") to pass through the node N where they did not before. It also causes some paths (those in the sub-tree labelled "3") not to pass through the node P where they did before. However, both of these nodes are red, so property 5 (all paths from any given node to its leaf nodes contain the same number of black nodes) is not violated by the rotation. After this case has been completed, property 4 (both children of every red node are black) is still violated, but now we can resolve this by continuing to case 5.
void insert_case4(struct node *n)
{
        struct node *g = grandparent(n);
 
        if ((n == n->parent->right) && (n->parent == g->left)) {
                rotate_left(n->parent);
                n = n->left;
        } else if ((n == n->parent->left) && (n->parent == g->right)) {
                rotate_right(n->parent);
                n = n->right;
        }
        insert_case5(n);
}
Case 5: The parent P is red but the uncle U is black, the current node N is the left child of P, and P is the left child of its parent G. In this case, a right rotation on G is performed; the result is a tree where the former parent P is now the parent of both the current node N and the former grandparent G. G is known to be black, since its former child P could not have been red otherwise (without violating property 4). Then, the colors of P and G are switched, and the resulting tree satisfies property 4 (both children of every red node are black). Property 5 (all paths from any given node to its leaf nodes contain the same number of black nodes) also remains satisfied, since all paths that went through any of these three nodes went through G before, and now they all go through P. In each case, this is the only black node of the three.
void insert_case5(struct node *n)
{
        struct node *g = grandparent(n);
 
        n->parent->color = BLACK;
        g->color = RED;
        if (n == n->parent->left)
                rotate_right(g);
        else
                rotate_left(g);
}
Note that inserting is actually in-place, since all the calls above use tail recursion.
Read-only operations on a redâblack tree require no modification from those used for binary search trees, because every redâblack tree is a special case of a simple binary search tree. However, the immediate result of an insertion or removal may violate the properties of a redâblack tree. Restoring the redâblack properties requires a small number (O(log n) or amortized O(1)) of color changes (which are very quick in practice) and no more than three tree rotations (two for insertion). Although insert and delete operations are complicated, their times remain O(log n).
Suppose the scapegoat tree has elements and has just been rebuilt (in other words, it is a complete binary tree). At most deletions can be performed before the tree must be rebuilt. Each of these deletions take time (the amount of time to search for the element and flag it as deleted). The deletion causes the tree to be rebuilt and takes (or just ) time. Using aggregate analysis it becomes clear that the amortized cost of a deletion is :

Define the Imbalance of a node v to be the absolute value of the difference in size between its left node and right node minus 1, or 0, whichever is greater. In other words:

Immediately after rebuilding a subtree rooted at v, I(v) = 0.
Lemma: Immediately before rebuilding the subtree rooted at v, ( is Big O Notation.)
Proof of lemma:
Let be the root of a subtree immediately after rebuilding. . If there are degenerate insertions (that is, where each inserted node increases the height by 1), then , and .
Since before rebuilding, there were insertions into the subtree rooted at that did not result in rebuilding. Each of these insertions can be performed in time. The final insertion that causes rebuilding costs . Using aggregate analysis it becomes clear that the amortized cost of an insertion is :

To delete a node x, we use the same method as with a binary search tree: if x has two children, we swap its value with that of either the rightmost node of its left sub tree (its in-order predecessor) or the leftmost node of its right subtree (its in-order successor). Then we remove that node instead. In this way, deletion is reduced to the problem of removing a node with 0 or 1 children.
Unlike a binary search tree, in a splay tree after deletion, we splay the parent of the removed node to the top of the tree. OR The node to be deleted is first splayed, i.e. brought to the root of the tree and then deleted. This leaves the tree with two sub trees. The maximum element of the left sub tree (: METHOD 1), or minimum of the right sub tree (: METHOD 2) is then splayed to the root. The right sub tree is made the right child of the resultant left sub tree (for METHOD 1). The root of left sub tree is the root of melded tree.
To insert a node x into a splay tree:
First insert the node as with a normal binary search tree. Then splay the newly inserted node x to the top of the tree.
Here x is the node on which the splay operation is performed and root is the root node of the tree.
#include<stdio.h>
//#include<malloc.h> already in the stdlib library
#include<stdlib.h>
struct node 
{
        int data;
        struct node *parent;
        struct node *left;
        struct node *right;
};
int data_print(struct node *x);
struct node *rightrotation(struct node *p,struct node *root);
struct node *leftrotation(struct node *p,struct node *root);
void splay (struct node *x, struct node *root);
struct node *insert(struct node *p,int value);
struct node *inorder(struct node *p);
struct node *delete(struct node *p,int value);
struct node *successor(struct node *x);
struct node *lookup(struct node *p,int value);
 
void splay (struct node *x, struct node *root)
{
        struct node *p,*g;
        /*check if node x is the root node*/
        if(x==root)
                return;
        /*Performs Zig step*/
        else if(x->parent==root)
        {
                if(x==x->parent->left)
                        root=rightrotation(root,root);
                else
                        root=leftrotation(root,root);
        }
        else
        {
                p=x->parent; /*now points to parent of x*/
                g=p->parent; /*now points to parent of x's parent*/
                /*Performs the Zig-zig step when x is left and x's parent is left*/
                if(x==p->left&&p==g->left)
                {
                        root=rightrotation(g,root);
                        root=rightrotation(p,root);
                }
                /*Performs the Zig-zig step when x is right and x's parent is right*/
                else if(x==p->right&&p==g->right)
                {
                        root=leftrotation(g,root);
                        root=leftrotation(p,root);
                }
                /*Performs the Zig-zag step when x's is right and x's parent is left*/
                else if(x==p->right&&p==g->left)
                {
                        root=leftrotation(p,root);
                        root=rightrotation(g,root);
                }
                /*Performs the Zig-zag step when x's is left and x's parent is right*/
                else if(x==p->left&&p==g->right)
                {
                        root=rightrotation(p,root);
                        root=leftrotation(g,root);
                }
                splay(x, root);
        }
}
struct node *rightrotation(struct node *p,struct node *root)
{
        struct node *x;
        x = p->left;
        p->left = x->right;
        if (x->right!=NULL) x->right->parent = p;
        x->right = p;
        if (p->parent!=NULL)
                if(p==p->parent->right) p->parent->right=x;
                else
                         p->parent->left=x;
        x->parent = p->parent;
        p->parent = x;
        if (p==root)
                return x;
        else 
                return root;
}
struct node *leftrotation(struct node *p,struct node *root)
{
        struct node *x;
        x = p->right;
        p->right = x->left;
        if (x->left!=NULL) x->left->parent = p;
        x->left = p;
        if (p->parent!=NULL)
                if (p==p->parent->left) p->parent->left=x;
                else
                         p->parent->right=x;
        x->parent = p->parent;
        p->parent = x;
        if(p==root) 
                return x;
        else
                return root;
}
struct node *insert(struct node *p,int value)
{
        struct node *temp1,*temp2,*par,*x;
        if(p == NULL)
        {
                p=(struct node *)malloc(sizeof(struct node));
                if(p != NULL)
                {
                        p->data = value;
                        p->parent = NULL;
                        p->left = NULL;
                        p->right = NULL;
                }
                else
                {
                        printf("No memory is allocated\n");
                        exit(0);
                }
                return(p);
        } //the case 2 says that we must splay newly inserted node to root
        else
        {
                        temp2 = p;
                        while(temp2 != NULL)
                        {
                                temp1 = temp2;
                                if(temp2->data > value)
                                        temp2 = temp2->left;
                                else if(temp2->data < value)
                                        temp2 = temp2->right;
                                else
                                        if(temp2->data == value)
                                                return temp2;
                        }
 
                        par = temp1;//temp1 having the parent
                        if(temp1->data > value)
                        {                               
                                temp1->left = (struct node *)malloc(sizeof(struct node));
                                temp1= temp1->left;
                                if(temp1 != NULL)
                                {
                                        temp1->data = value;
                                        temp1->parent = par;//store the parent address.
                                        temp1->left = NULL;
                                        temp1->right = NULL;
                                }
                                else
                                {
                                        printf("No memory is allocated\n");
                                        exit(0);
                                }
                        }
                        else
                        {
                                temp1->right = (struct node *)malloc(sizeof(struct node));
                                temp1 = temp1->right;
                                if(temp1 != NULL)
                                {
                                        temp1->data = value;
                                        temp1->parent = par;//store the parent address
                                        temp1->left = NULL;
                                        temp1->right = NULL;
                                }
                                else
                                {
                                        printf("No memory is allocated\n");
                                        exit(0);
                                }
                        }
        }
        //splay(temp1,p);//temp1 will be new root after splaying // not necessary , already done in the main function
        return (temp1);
}
struct node *inorder(struct node *p)
{
        if(p != NULL)
        {
                inorder(p->left);
                printf("CURRENT %d\t",p->data);
                printf("LEFT %d\t",data_print(p->left));
                printf("PARENT %d\t",data_print(p->parent));
                printf("RIGHT %d\t\n",data_print(p->right));
                inorder(p->right);
        }
}
struct node *delete(struct node *p,int value)
{
        struct node *x,*y,*p1;
        struct node *root;
        struct node *s;
        root = p;
        x = lookup(p,value);
        if(x->data == value)
        {       //if the deleted element is leaf
                if((x->left == NULL) && (x->right == NULL))
                {
                        y = x->parent;
                        if(x ==(x->parent->right)) 
                                y->right = NULL;
                        else 
                                y->left = NULL;
                        free(x);
                }
                //if deleted element having left child only
                else if((x->left != NULL) &&(x->right == NULL))
                {
                        if(x == (x->parent->left))
                        {
                                y = x->parent;
                                x->left->parent = y;
                                y->left = x->left;
                                free(x);
                        }
                        else
                        {
                                y = x->parent;
                                x->left->parent = y;
                                y->right = x->left;
                                free(x);
                        }
                }
                //if deleted element having right child only
                else if((x->left == NULL) && (x->right != NULL))
                {
                        if(x == (x->parent->left))
                        {
                                y = x->parent;
                                x->right->parent = y;
                                y->left = x->right;
                                free(x);
                        }
                        else
                        {
                                y = x->parent;
                                x->right->parent = y;
                                y->right = x->right;
                                free(x);
                        }
                }
                //if the deleted element having two children
                else if((x->left != NULL) && (x->right != NULL))
                {
                        if(x == (x->parent->left))
                        {
                                s = successor(x);
                                if(s != x->right)
                                {
                                        y = s->parent;
                                        if(s->right != NULL)
                                        {
                                                s->right->parent = y;
                                                y->left = s->right;
                                        }
                                        else y->left = NULL;
                                        s->parent = x->parent;
                                        x->right->parent = s;
                                        x->left->parent = s;
                                        s->right = x->right;
                                        s->left = x->left;
                                        x->parent->left = s;
                                }
                                else
                                {
                                        y = s;
                                        s->parent = x->parent;
                                        x->left->parent = s;
                                        s->left = x->left;
                                        x->parent->left = s;
                                }
                                free(x);
                        }
                        else if(x == (x->parent->right))
                        {
                                s = successor(x);
                                if(s != x->right)
                                {
                                        y = s->parent;
                                        if(s->right != NULL)
                                        {
                                                s->right->parent = y;
                                                y->left = s->right;
                                        }
                                        else y->left = NULL;
                                        s->parent = x->parent;
                                        x->right->parent = s;
                                        x->left->parent = s;
                                        s->right = x->right;
                                        s->left = x->left;
                                        x->parent->right = s;
                                }
                                else
                                {
                                        y = s;
                                        s->parent = x->parent;
                                        x->left->parent = s;
                                        s->left = x->left;
                                        x->parent->right = s;
                                }
                                free(x);
                        }
 
                }
                splay(y,root);
        }
        else
        {
                splay(x,root);
        }
}
struct node *successor(struct node *x)
{
        struct node *temp,*temp2;
        temp=temp2=x->right;
        while(temp != NULL)
        {
                temp2 = temp;
                temp = temp->left;
        }
        return temp2;
}
//p is a root element of the tree
struct node *lookup(struct node *p,int value)
{
        struct node *temp1,*temp2;
        if(p != NULL)
        {
                temp1 = p;
                while(temp1 != NULL)
                {
                        temp2 = temp1;
                        if(temp1->data > value)
                                temp1 = temp1->left;
                        else if(temp1->data < value)
                                temp1 = temp1->right;
                        else
                                        return temp1;
                }
                return temp2;
        }
        else
        {
                printf("NO element in the tree\n");
                exit(0);
        }
}
struct node *search(struct node *p,int value)
{
        struct node *x,*root;
        root = p;
        x = lookup(p,value);
        if(x->data == value)
        {
                printf("Inside search if\n");
                splay(x,root);
        }
        else
        {
                printf("Inside search else\n");
                splay(x,root);
        }
}
main()
{
        struct node *root;//the root element
        struct node *x;//x is which element will come to root.
        int i;
        root = NULL;
        int choice = 0;
        int ele;
        while(1)
        {
                printf("\n\n 1.Insert");
                printf("\n\n 2.Delete");
                printf("\n\n 3.Search");
                printf("\n\n 4.Display\n");
                printf("\n\n Enter your choice:");
                scanf("%d",&choice);
                if(choice==5)
                        exit(0);
                switch(choice)
                {
                        case 1:
                                printf("\n\n Enter the element to be inserted:");
                                scanf("%d",&ele);
                                x = insert(root,ele);
                                if(root != NULL)
                                {
                                        splay(x,root);
                                }
                                root = x;
                                break;
                        case 2:
                                if(root == NULL)
                                {
                                        printf("\n Empty tree...");
                                        continue;
                                }
                                printf("\n\n Enter the element to be delete:");
                                scanf("%d",&ele);
                                root = delete(root,ele);
                                break;
                        case 3:
                                printf("Enter the element to be search\n");
                                scanf("%d",&ele);
                                x = lookup(root,ele);
                                        splay(x,root);
                                root = x;
                                break;
                        case 4:
                                printf("The elements are\n");
                                inorder(root);
                                break;
                        default:
                                printf("Wrong choice\n");
                                break;
                }
        }
}
int data_print(struct node *x)
{
        if ( x==NULL )
                return 0;
        else
                return x->data;
}
/*some suggestion this code is not fully functional for example 
if you have inserted some elements then try to delete root then it may not work 
because we are calling right and left child of a null value(parent of root) 
which is not allowed and will give segmentation fault
 
Also for inserting second element because of splaying twice(once in insert and one in main) 
will give error So I have made those changes but mainly in my cpp( c plus plus file) file, 
but I guess wiki will itself look into this and made  these changes */
