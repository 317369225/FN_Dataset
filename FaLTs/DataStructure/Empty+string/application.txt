In most programming languages, strings are a data type. Individual strings are typically stored in consecutive memory locations. This means that the same string (for example the empty string) could be stored in two different places in memory. (Note that even a string of length zero can require memory to store it, depending on the format being used.) In this way there could be multiple empty strings in memory, in contrast with the formal theory definition, for which there is only one possible empty string. However, a string comparison function would indicate that all of these empty strings are equal to each other.
The empty string is distinct from a null reference (or null pointer) because a null reference does not point to any string at all, not even the empty string. A null reference is likely to cause an error if one tries to perform any operation on it, but an empty string is less likely to do so. The empty string is a legitimate string, upon which most string operations should work. Some languages treat some or all of the following in similar ways, which can lessen the danger: empty strings, null references, the integer 0, the floating point number 0, the boolean value false, the ascii character NUL, or other such values.
The empty string is usually represented similarly to other strings. In implementations with string terminating character (null-terminated strings or plain text lines), the empty string is indicated by the immediate use of this terminating character.
λ representation Programming languages "" C, C++, Perl, Python, C#, Go, PHP, Visual Basic .NET, Java, Turing, JavaScript, Haskell, Objective-C (as a C string), OCaml, Standard ML, Scala, Seed7, Tcl '' Perl, PHP, Python, JavaScript, Delphi, Pascal {'\0'} C, C++, Objective-C (as a C string) std::string() C++ @"" Objective-C (as a constant NSString object) [NSString string] Objective-C (as a new NSString object) qw() Perl """""" str() Python string.Empty C# String.Empty Visual Basic .NET String.make 0 '-' OCaml {} Tcl
Arrays are used to implement mathematical vectors and matrices, as well as other kinds of rectangular tables. Many databases, small and large, consist of (or include) one-dimensional arrays whose elements are records.
Arrays are used to implement other data structures, such as heaps, hash tables, deques, queues, stacks, strings, and VLists.
One or more large arrays are sometimes used to emulate in-program dynamic memory allocation, particularly memory pool allocation. Historically, this has sometimes been the only way to allocate "dynamic memory" portably.
Arrays can be used to determine partial or complete control flow in programs, as a compact alternative to (otherwise repetitive), multiple IF statements. They are known in this context as control tables and are used in conjunction with a purpose built interpreter whose control flow is altered according to values contained in the array. The array may contain subroutine pointers (or relative subroutine numbers that can be acted upon by SWITCH statements) - that direct the path of the execution.
In most programming languages, strings are a data type. Individual strings are typically stored in consecutive memory locations. This means that the same string (for example the empty string) could be stored in two different places in memory. (Note that even a string of length zero can require memory to store it, depending on the format being used.) In this way there could be multiple empty strings in memory, in contrast with the formal theory definition, for which there is only one possible empty string. However, a string comparison function would indicate that all of these empty strings are equal to each other.
The empty string is distinct from a null reference (or null pointer) because a null reference does not point to any string at all, not even the empty string. A null reference is likely to cause an error if one tries to perform any operation on it, but an empty string is less likely to do so. The empty string is a legitimate string, upon which most string operations should work. Some languages treat some or all of the following in similar ways, which can lessen the danger: empty strings, null references, the integer 0, the floating point number 0, the boolean value false, the ascii character NUL, or other such values.
The empty string is usually represented similarly to other strings. In implementations with string terminating character (null-terminated strings or plain text lines), the empty string is indicated by the immediate use of this terminating character.
λ representation Programming languages "" C, C++, Perl, Python, C#, Go, PHP, Visual Basic .NET, Java, Turing, JavaScript, Haskell, Objective-C (as a C string), OCaml, Standard ML, Scala, Seed7, Tcl '' Perl, PHP, Python, JavaScript, Delphi, Pascal {'\0'} C, C++, Objective-C (as a C string) std::string() C++ @"" Objective-C (as a constant NSString object) [NSString string] Objective-C (as a new NSString object) qw() Perl """""" str() Python string.Empty C# String.Empty Visual Basic .NET String.make 0 '-' OCaml {} Tcl
Applications of GADTs include generic programming, modelling programming languages (higher-order abstract syntax), maintaining invariants[disambiguation needed] in data structures, expressing constraints in embedded domain-specific languages, and modelling objects.[9]
As the name implies, lists can be used to store a list of records. The items in a list can be sorted for the purpose of fast search (binary search).
Because in computing, lists are easier to realize than sets, a finite set in mathematical sense can be realized as a list with additional restrictions, that is, duplicate elements are disallowed and such that order is irrelevant. If the list is sorted, it speeds up determining if a given item is already in the set but in order to ensure the order, it requires more time to add new entry to the list. In efficient implementations, however, sets are implemented using self-balancing binary search trees or hash tables, rather than a list.
Some languages, such as C, allow the declaration of opaque records (structs), whose size and fields are hidden from the client. The only thing that the client can do with an object of such a type is to take its memory address, to produce an opaque pointer.
If the information provided by the interface is sufficient to determine the type's size, then clients can declare variables, fields, and arrays of that type, assign their values, and possibly compare them for equality. This is usually the case for opaque pointers.
In some languages, such as Java, the only kind of opaque type provided is the opaque pointer. Indeed, in Java (and several other languages) records are always handled through pointers.
Some languages allow partially opaque types, e.g. a record which has some public fields, known and accessible to all clients, and some hidden fields which are not revealed in the interface. Such types play a fundamental role in object-oriented programming.
The information which is missing in the interface may be declared in its implementation, or in another "friends-only" interface. This second option allows the hidden information to be shared by two or more modules.
1) Commercial Computing:[2]
Government organisations, private companies and many web based applications has to deal with huge amount of data. This data is stored by sorting it using different sorting algorithms. This can be used in quick and easy recovery of data.
2) In discrete mathematics: Sorted arrays can be used to implement Dijkstra's algorithm or Prim's algorithm. Also, algorithms like Kruskal's Algorithm for finding minimal spanning trees.
3) In priority scheduling: At the operating system level many processes are pending at a time, but CPU can handle only one process at single instance of time. Therefore, priorities are associated to each process.Then the processes are sent to CPU according to the highest priority by using sorted array of process ID's. Here, processes got sorted depending upon their priorities and then CPU is allocated to them. The process having the highest priority takes first position in sorted array. Hence priority-wise system processes scheduling is done.[3]
4) In Shortest-Job-First Scheduling: This is the special case of priority scheduling. Here, Processes get sorted according to burst time of the processes. The process requiring the shortest time will be allocated CPU first. Hence, Processes are being sent to CPU according to their burst time.

Process Burst time P1 3 P2 4 P3 1 P4 8 P5 6
Stacks have numerous applications. We see stacks in everyday life, from the books in our library, to the sheaf of papers that we keep in our printer tray. All of them follow the Last In First Out (LIFO) logic, that is when we add a book to a pile of books, we add it to the top of the pile, whereas when we remove a book from the pile, we generally remove it from the top of the pile.
Given below are a few applications of stacks in the world of computers:
