A Bidirectional Heuristic Search is a state space search from some state to another state , searching from to and from to simultaneously (or quasi-simultaneously if done on a sequential machine). It returns a valid list of operators that if applied to will give us .
While it may seem as though the operators have to be invertible for the reverse search, it is only necessary to be able to find, given any node , the set of parent nodes of such that there exists some valid operator from each of the parent nodes to . This has often been likened to a one way street in the route-finding domain: it is not necessary to be able to travel down both directions, but it is necessary when standing at the end of the street to determine the beginning of the street as a possible route.
Similarly, for those edges that have inverse arcs (i.e. arcs going in both directions) it is not necessary that each direction be of equal cost. The reverse search will always use the inverse cost (i.e. the cost of the arc in the forward direction). More formally, if is a node with parent , then , defined as being the cost from to .(Auer Kaindl 2004)
In order to facilitate a concrete description, we assume that the goal is to find the minimum value of a function , where ranges over some set of admissible or candidate solutions (the search space or feasible region). Note that one can find the maximum value of by finding the minimum of . (For example, could be the set of all possible trip schedules for a bus fleet, and could be the expected revenue for schedule .)
A branch-and-bound procedure requires two tools. The first one is a splitting procedure that, given a set of candidates, returns two or more smaller sets whose union covers . Note that the minimum of over is , where each is the minimum of within . This step is called branching, since its recursive application defines a tree structure (the search tree) whose nodes are the subsets of .
The second tool is a procedure that computes upper and lower bounds for the minimum value of within a given subset of . This step is called bounding.
The key idea of the BB algorithm is: if the lower bound for some tree node (set of candidates) is greater than the upper bound for some other node , then may be safely discarded from the search. This step is called pruning, and is usually implemented by maintaining a global variable (shared among all nodes of the tree) that records the minimum upper bound seen among all subregions examined so far. Any node whose lower bound is greater than can be discarded.
The recursion stops when the current candidate set is reduced to a single element, or when the upper bound for set matches the lower bound. Either way, any element of will be a minimum of the function within .
The time and space analysis of DFS differs according to its application area. In theoretical computer science, DFS is typically used to traverse an entire graph, and takes time O(|E|), linear in the size of the graph. In these applications it also uses space O(|V|) in the worst case to store the stack of vertices on the current search path as well as the set of already-visited vertices. Thus, in this setting, the time and space bounds are the same as for breadth-first search and the choice of which of these two algorithms to use depends less on their complexity and more on the different properties of the vertex orderings the two algorithms produce.
For applications of DFS to search problems in artificial intelligence, however, the graph to be searched is often either too large to visit in its entirety or even infinite, and DFS may suffer from non-termination when the length of a path in the search tree is infinite. Therefore, the search is only performed to a limited depth, and due to limited memory availability one typically does not use data structures that keep track of the set of all previously visited vertices. In this case, the time is still linear in the number of expanded vertices and edges (although this number is not the same as the size of the entire graph because some vertices may be searched more than once and others not at all) but the space complexity of this variant of DFS is only proportional to the depth limit, much smaller than the space needed for searching to the same depth using breadth-first search. For such applications, DFS also lends itself much better to heuristic methods of choosing a likely-looking branch. When an appropriate depth limit is not known a priori, iterative deepening depth-first search applies DFS repeatedly with a sequence of increasing limits; in the artificial intelligence mode of analysis, with a branching factor greater than one, iterative deepening increases the running time by only a constant factor over the case in which the correct depth limit is known due to the geometric growth of the number of nodes per level.
DFS may be also used to collect a sample of graph nodes. However, incomplete DFS, similarly to incomplete BFS, is biased towards nodes of high degree.
