Knapsack problem. The ants prefer the smaller drop of honey over the more abundant, but less nutritious, sugar.
Ant colony optimization algorithms have been applied to many combinatorial optimization problems, ranging from quadratic assignment to protein folding or routing vehicles and a lot of derived methods have been adapted to dynamic problems in real variables, stochastic problems, multi-targets and parallel implementations. It has also been used to produce near-optimal solutions to the travelling salesman problem. They have an advantage over simulated annealing and genetic algorithm approaches of similar problems when the graph may change dynamically; the ant colony algorithm can be run continuously and adapt to changes in real time. This is of interest in network routing and urban transportation systems.
The first ACO algorithm was called the Ant system [10] and it was aimed to solve the travelling salesman problem, in which the goal is to find the shortest round-trip to link a series of cities. The general algorithm is relatively simple and based on a set of ants, each making one of the possible round-trips along the cities. At each stage, the ant chooses to move from one city to another according to some rules:
It must visit each city exactly once; A distant city has less chance of being chosen (the visibility); The more intense the pheromone trail laid out on an edge between two cities, the greater the probability that that edge will be chosen; Having completed its journey, the ant deposits more pheromones on all edges it traversed, if the journey is short; After each iteration, trails of pheromones evaporate.

The Bees Algorithm has found many applications in engineering, such as:
Training neural networks for pattern recognition.[9][10][11][12][13] Forming manufacturing cells.[2] Scheduling jobs for a production machine.[3] Solving continuous problems and engineering optimization.[14] Finding multiple feasible solutions to a preliminary design problems.[15] Data clustering[16] Optimising the design of mechanical components.[17] Multi-Objective Optimisation.[18] Tuning a fuzzy logic controller for a robot gymnast.[19] Computer Vision and Image Analysis.[20][21][22]
This approach is used for a number of NP-hard problems, such as
Knapsack problem Integer programming Nonlinear programming Traveling salesman problem (TSP) Quadratic assignment problem (QAP) Maximum satisfiability problem (MAX-SAT) Nearest neighbor search (NNS) Cutting stock problem False noise analysis (FNA) Computational phylogenetics
Branch-and-bound may also be a base of various heuristics. For example, one may wish to stop branching when the gap between the upper and lower bounds becomes smaller than a certain threshold. This is used when the solution is "good enough for practical purposes" and can greatly reduce the computations required. This type of solution is particularly applicable when the cost function used is noisy or is the result of statistical estimates and so is not known precisely but rather only known to lie within a range of values with a specific probability. An example of its application here is in biology when performing cladistic analysis to evaluate evolutionary relationships between organisms, where the data sets are often impractically large without heuristics[citation needed].
For this reason, branch-and-bound techniques are often used in game tree search algorithms, most notably through the use of alpha-beta pruning.
Breadth-first search can be used to solve many problems in graph theory, for example:
Finding all nodes within one connected component Copying Collection, Cheney's algorithm Finding the shortest path between two nodes u and v (with path length measured by number of edges) Testing a graph for bipartiteness (Reverse) Cuthill–McKee mesh numbering Ford–Fulkerson method for computing the maximum flow in a flow network Serialization/Deserialization of a binary tree vs serialization in sorted order, allows the tree to be re-constructed in an efficient manner.
The applications of Cuckoo Search into engineering optimization problems have shown its promising efficiency. For example, for both spring design and welded beam design problems, CS obtained better solutions than existing solutions in literature. A promising discrete cuckoo search algorithm is recently proposed to solve nurse scheduling problem.[20] An efficient computation approach based on cuckoo search has been proposed for data fusion in wireless sensor networks.[21][22] A new quantum-inspired cuckoo search was developed to solve Knapsack problems, which shows its effectiveness.[23] Cuckoo search can also be used to efficiently generate independent test paths for structural software testing [24] and test data generation.[25]
A conceptual comparison of the cuckoo search with PSO, DE and ABC suggest that CS and DE algorithms provide more robust results than PSO and ABC.[26] An extensive detailed study of various structural optimization problems suggests that cuckoo search obtains better results than other algorithms.[27] In addition, a new software testing approach has been developed based on cuckoo search.[28] In addition, cuckoo search is particularly suitable for large scale problems, as shown in a recent study.[29] Cuckoo search has been applied to train neural networks with improved performance.[30] Furthermore, CS is successfully applied to train spiking neural models.[31] Cuckoo search has also been used to optimize web service composition process and planning graphs. [32]
Cuckoo search is a reliable approach for embedded system design[33] and design optimization[34] including optimum design of steel frames.[35]
More recent studies suggest that cuckoo search can outperform other algorithms in milling applications,[36]manufacturing scheduling,[37], and others.[38] An interesting application of cuckoo search is to solve boundary value problems.[39]
Sorry, your browser either has JavaScript disabled or does not have any supported player. You can download the clip or download a player to play the clip in your browser. Randomized algorithm similar to depth-first search used in generating a maze.
Algorithms that use depth-first search as a building block include:
Finding connected components. Topological sorting. Finding 2-(edge or vertex)-connected components. Finding 3-(edge or vertex)-connected components. Finding the bridges of a graph. Finding strongly connected components. Planarity testing[4][5] Solving puzzles with only one solution, such as mazes. (DFS can be adapted to find all solutions to a maze by only including nodes on the current path in the visited set.) Maze generation may use a randomized depth-first search. Finding biconnectivity in graphs.
